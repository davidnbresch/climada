<body>
<H1><FONT COLOR="FF0000">Overview of climada routines</FONT></FONT></H1>
<P>
Use <i>Find in page</i> ... from the Edit Menu to search for any text in all help-files.<P>
Use the <i>which</i> command in MATLAB to locate the specific function.<P>
This page has been automatically created by <i>compile_function_header_doc</i>.<P>
Please consult <A HREF="climada_manual.pdf">climada_manual.pdf</A> for more information.<P>
<P>
<P><STRONG>Last modified: </STRONG>09-Jun-2016 17:12:36<P>

<HR>

<A NAME="ROUTINELIST">
<UL>

<P><STRONG>\code:</STRONG><LI><A HREF="#climada">climada</A>
<LI><A HREF="#climada_EDS_calc">climada_EDS_calc</A>
<LI><A HREF="#climada_adaptation_bar_chart">climada_adaptation_bar_chart</A>
<LI><A HREF="#climada_adaptation_cost_curve">climada_adaptation_cost_curve</A>
<LI><A HREF="#climada_adaptation_event_view">climada_adaptation_event_view</A>
<LI><A HREF="#climada_demo">climada_demo</A>
<LI><A HREF="#climada_demo_gui">climada_demo_gui</A>
<LI><A HREF="#climada_demo_step_by_step">climada_demo_step_by_step</A>
<LI><A HREF="#climada_entity_plot">climada_entity_plot</A>
<LI><A HREF="#climada_entity_read">climada_entity_read</A>
<LI><A HREF="#climada_init_vars">climada_init_vars</A>
<LI><A HREF="#climada_measures_impact">climada_measures_impact</A>
<LI><A HREF="#climada_measures_impact_parametric">climada_measures_impact_parametric</A>
<LI><A HREF="#climada_tc_event_damage_ens">climada_tc_event_damage_ens</A>
<LI><A HREF="#climada_tc_event_damage_ens_gui">climada_tc_event_damage_ens_gui</A>
<LI><A HREF="#climada_tc_hazard_set">climada_tc_hazard_set</A>
<LI><A HREF="#climada_tc_hazard_set_exercise">climada_tc_hazard_set_exercise</A>
<LI><A HREF="#climada_tc_random_walk">climada_tc_random_walk</A>
<LI><A HREF="#climada_tc_read_unisys_database">climada_tc_read_unisys_database</A>
<LI><A HREF="#climada_tc_windfield">climada_tc_windfield</A>
<LI><A HREF="#climada_tc_windfield_exercise">climada_tc_windfield_exercise</A>
<LI><A HREF="#climada_viewer">climada_viewer</A>
<LI><A HREF="#climada_waterfall_graph">climada_waterfall_graph</A>
<LI><A HREF="#git_pull">git_pull</A>

<P><STRONG>\code\data_import:</STRONG><LI><A HREF="#RivDIS_read">RivDIS_read</A>
<LI><A HREF="#chirps_read">chirps_read</A>
<LI><A HREF="#climada_tif_read">climada_tif_read</A>
<LI><A HREF="#loadods">loadods</A>
<LI><A HREF="#trmm_get">trmm_get</A>

<P><STRONG>\code\helper_functions:</STRONG><LI><A HREF="#cbfreeze">cbfreeze</A>
<LI><A HREF="#cbhandle">cbhandle</A>
<LI><A HREF="#climada_DFC_compare">climada_DFC_compare</A>
<LI><A HREF="#climada_DFC_read">climada_DFC_read</A>
<LI><A HREF="#climada_EDS2DFC">climada_EDS2DFC</A>
<LI><A HREF="#climada_EDS2YDS">climada_EDS2YDS</A>
<LI><A HREF="#climada_EDS_DFC">climada_EDS_DFC</A>
<LI><A HREF="#climada_EDS_DFC_hist">climada_EDS_DFC_hist</A>
<LI><A HREF="#climada_EDS_DFC_match">climada_EDS_DFC_match</A>
<LI><A HREF="#climada_EDS_DFC_report">climada_EDS_DFC_report</A>
<LI><A HREF="#climada_EDS_ED_at_centroid_report">climada_EDS_ED_at_centroid_report</A>
<LI><A HREF="#climada_EDS_ED_at_centroid_report_xls">climada_EDS_ED_at_centroid_report_xls</A>
<LI><A HREF="#climada_EDS_ED_per_category_report">climada_EDS_ED_per_category_report</A>
<LI><A HREF="#climada_EDS_combine">climada_EDS_combine</A>
<LI><A HREF="#climada_EDS_load">climada_EDS_load</A>
<LI><A HREF="#climada_EDS_save">climada_EDS_save</A>
<LI><A HREF="#climada_EDS_stats">climada_EDS_stats</A>
<LI><A HREF="#climada_ED_plot">climada_ED_plot</A>
<LI><A HREF="#climada_IFC_plot">climada_IFC_plot</A>
<LI><A HREF="#climada_NPV">climada_NPV</A>
<LI><A HREF="#climada_admin1_get_shapes">climada_admin1_get_shapes</A>
<LI><A HREF="#climada_admin1_select_on_map">climada_admin1_select_on_map</A>
<LI><A HREF="#climada_arrow">climada_arrow</A>
<LI><A HREF="#climada_asci2hazard">climada_asci2hazard</A>
<LI><A HREF="#climada_ascii_read">climada_ascii_read</A>
<LI><A HREF="#climada_assets_category_ID">climada_assets_category_ID</A>
<LI><A HREF="#climada_assets_encode">climada_assets_encode</A>
<LI><A HREF="#climada_assets_encode_check">climada_assets_encode_check</A>
<LI><A HREF="#climada_assets_read">climada_assets_read</A>
<LI><A HREF="#climada_assets_select">climada_assets_select</A>
<LI><A HREF="#climada_centroids_cleanup">climada_centroids_cleanup</A>
<LI><A HREF="#climada_centroids_load">climada_centroids_load</A>
<LI><A HREF="#climada_centroids_plot">climada_centroids_plot</A>
<LI><A HREF="#climada_centroids_read">climada_centroids_read</A>
<LI><A HREF="#climada_check_matfile">climada_check_matfile</A>
<LI><A HREF="#climada_circle_plot">climada_circle_plot</A>
<LI><A HREF="#climada_code_copy">climada_code_copy</A>
<LI><A HREF="#climada_code_optimizer">climada_code_optimizer</A>
<LI><A HREF="#climada_code_update">climada_code_update</A>
<LI><A HREF="#climada_collect_measures_impact">climada_collect_measures_impact</A>
<LI><A HREF="#climada_color_plot">climada_color_plot</A>
<LI><A HREF="#climada_colormap">climada_colormap</A>
<LI><A HREF="#climada_concatenate_lon_lat">climada_concatenate_lon_lat</A>
<LI><A HREF="#climada_country_name">climada_country_name</A>
<LI><A HREF="#climada_damage_exceedence">climada_damage_exceedence</A>
<LI><A HREF="#climada_damagefunctions_check">climada_damagefunctions_check</A>
<LI><A HREF="#climada_damagefunctions_generate">climada_damagefunctions_generate</A>
<LI><A HREF="#climada_damagefunctions_map">climada_damagefunctions_map</A>
<LI><A HREF="#climada_damagefunctions_plot">climada_damagefunctions_plot</A>
<LI><A HREF="#climada_damagefunctions_read">climada_damagefunctions_read</A>
<LI><A HREF="#climada_damagefunctions_replace">climada_damagefunctions_replace</A>
<LI><A HREF="#climada_dateline_resolve">climada_dateline_resolve</A>
<LI><A HREF="#climada_demo_adapt_cost_curve">climada_demo_adapt_cost_curve</A>
<LI><A HREF="#climada_demo_parameter_table">climada_demo_parameter_table</A>
<LI><A HREF="#climada_demo_parameter_table_full">climada_demo_parameter_table_full</A>
<LI><A HREF="#climada_demo_waterfall_graph">climada_demo_waterfall_graph</A>
<LI><A HREF="#climada_digit_set">climada_digit_set</A>
<LI><A HREF="#climada_discount_read">climada_discount_read</A>
<LI><A HREF="#climada_distance2coast_km">climada_distance2coast_km</A>
<LI><A HREF="#climada_distance_km">climada_distance_km</A>
<LI><A HREF="#climada_distribution_lon_lat">climada_distribution_lon_lat</A>
<LI><A HREF="#climada_distribution_v0_vi">climada_distribution_v0_vi</A>
<LI><A HREF="#climada_ellipse">climada_ellipse</A>
<LI><A HREF="#climada_entity_check">climada_entity_check</A>
<LI><A HREF="#climada_entity_combine">climada_entity_combine</A>
<LI><A HREF="#climada_entity_load">climada_entity_load</A>
<LI><A HREF="#climada_entity_save">climada_entity_save</A>
<LI><A HREF="#climada_entity_value_GDP_adjust">climada_entity_value_GDP_adjust</A>
<LI><A HREF="#climada_entity_value_GDP_adjust_one">climada_entity_value_GDP_adjust_one</A>
<LI><A HREF="#climada_event_damage_animation">climada_event_damage_animation</A>
<LI><A HREF="#climada_event_damage_data_tc">climada_event_damage_data_tc</A>
<LI><A HREF="#climada_excel_hazard_set">climada_excel_hazard_set</A>
<LI><A HREF="#climada_figure_axis_limits_equal_for_lat_lon">climada_figure_axis_limits_equal_for_lat_lon</A>
<LI><A HREF="#climada_figure_scale_add">climada_figure_scale_add</A>
<LI><A HREF="#climada_figuresize">climada_figuresize</A>
<LI><A HREF="#climada_find_most_severe_event">climada_find_most_severe_event</A>
<LI><A HREF="#climada_geo_distance">climada_geo_distance</A>
<LI><A HREF="#climada_git_pull">climada_git_pull</A>
<LI><A HREF="#climada_git_pull_repositories">climada_git_pull_repositories</A>
<LI><A HREF="#climada_gridded_VALUE">climada_gridded_VALUE</A>
<LI><A HREF="#climada_hazard2IFC">climada_hazard2IFC</A>
<LI><A HREF="#climada_hazard2ge">climada_hazard2ge</A>
<LI><A HREF="#climada_hazard2octave">climada_hazard2octave</A>
<LI><A HREF="#climada_hazard_cleanup">climada_hazard_cleanup</A>
<LI><A HREF="#climada_hazard_clim_scen">climada_hazard_clim_scen</A>
<LI><A HREF="#climada_hazard_load">climada_hazard_load</A>
<LI><A HREF="#climada_hazard_plot">climada_hazard_plot</A>
<LI><A HREF="#climada_hazard_plot_hr">climada_hazard_plot_hr</A>
<LI><A HREF="#climada_hazard_stats">climada_hazard_stats</A>
<LI><A HREF="#climada_hazard_stats_figure">climada_hazard_stats_figure</A>
<LI><A HREF="#climada_init_folders">climada_init_folders</A>
<LI><A HREF="#climada_interp1">climada_interp1</A>
<LI><A HREF="#climada_load">climada_load</A>
<LI><A HREF="#climada_location_sum">climada_location_sum</A>
<LI><A HREF="#climada_lonlat_cleanup">climada_lonlat_cleanup</A>
<LI><A HREF="#climada_map_plot">climada_map_plot</A>
<LI><A HREF="#climada_measure_regional_scope">climada_measure_regional_scope</A>
<LI><A HREF="#climada_measures_assets_change">climada_measures_assets_change</A>
<LI><A HREF="#climada_measures_attach_measures">climada_measures_attach_measures</A>
<LI><A HREF="#climada_measures_check">climada_measures_check</A>
<LI><A HREF="#climada_measures_encode">climada_measures_encode</A>
<LI><A HREF="#climada_measures_impact2EDS_waterfall">climada_measures_impact2EDS_waterfall</A>
<LI><A HREF="#climada_measures_impact_attach_measures_impact">climada_measures_impact_attach_measures_impact</A>
<LI><A HREF="#climada_measures_impact_combine">climada_measures_impact_combine</A>
<LI><A HREF="#climada_measures_impact_combine_scenario">climada_measures_impact_combine_scenario</A>
<LI><A HREF="#climada_measures_impact_discount">climada_measures_impact_discount</A>
<LI><A HREF="#climada_measures_impact_load">climada_measures_impact_load</A>
<LI><A HREF="#climada_measures_impact_read">climada_measures_impact_read</A>
<LI><A HREF="#climada_measures_impact_report">climada_measures_impact_report</A>
<LI><A HREF="#climada_measures_read">climada_measures_read</A>
<LI><A HREF="#climada_nonspheric_distance_m">climada_nonspheric_distance_m</A>
<LI><A HREF="#climada_octave">climada_octave</A>
<LI><A HREF="#climada_odsread">climada_odsread</A>
<LI><A HREF="#climada_plot_ACE">climada_plot_ACE</A>
<LI><A HREF="#climada_plot_IFC_return">climada_plot_IFC_return</A>
<LI><A HREF="#climada_plot_probabilistic_wind_speed_map">climada_plot_probabilistic_wind_speed_map</A>
<LI><A HREF="#climada_plot_tc_track_season">climada_plot_tc_track_season</A>
<LI><A HREF="#climada_plot_tc_track_stormcategory">climada_plot_tc_track_stormcategory</A>
<LI><A HREF="#climada_plot_world_borders">climada_plot_world_borders</A>
<LI><A HREF="#climada_processed2assets">climada_processed2assets</A>
<LI><A HREF="#climada_scenario_name">climada_scenario_name</A>
<LI><A HREF="#climada_scenario_waterfall_identify">climada_scenario_waterfall_identify</A>
<LI><A HREF="#climada_shape_selector">climada_shape_selector</A>
<LI><A HREF="#climada_shapeplotter">climada_shapeplotter</A>
<LI><A HREF="#climada_shaperead">climada_shaperead</A>
<LI><A HREF="#climada_sparse_interp">climada_sparse_interp</A>
<LI><A HREF="#climada_spreadsheet_read">climada_spreadsheet_read</A>
<LI><A HREF="#climada_tc_add_timestep">climada_tc_add_timestep</A>
<LI><A HREF="#climada_tc_equal_timestep">climada_tc_equal_timestep</A>
<LI><A HREF="#climada_tc_get_unisys_databases">climada_tc_get_unisys_databases</A>
<LI><A HREF="#climada_tc_hazard_clim_scen">climada_tc_hazard_clim_scen</A>
<LI><A HREF="#climada_tc_hurdat_read">climada_tc_hurdat_read</A>
<LI><A HREF="#climada_tc_interp">climada_tc_interp</A>
<LI><A HREF="#climada_tc_jtwc_fetch">climada_tc_jtwc_fetch</A>
<LI><A HREF="#climada_tc_overview_table">climada_tc_overview_table</A>
<LI><A HREF="#climada_tc_random_walk_position_windspeed">climada_tc_random_walk_position_windspeed</A>
<LI><A HREF="#climada_tc_read_unisys_track">climada_tc_read_unisys_track</A>
<LI><A HREF="#climada_tc_season">climada_tc_season</A>
<LI><A HREF="#climada_tc_stormcategory">climada_tc_stormcategory</A>
<LI><A HREF="#climada_tc_track_info">climada_tc_track_info</A>
<LI><A HREF="#climada_tc_track_load">climada_tc_track_load</A>
<LI><A HREF="#climada_tc_track_nodes">climada_tc_track_nodes</A>
<LI><A HREF="#climada_tc_windfield_animation">climada_tc_windfield_animation</A>
<LI><A HREF="#climada_tc_windfield_timestep">climada_tc_windfield_timestep</A>
<LI><A HREF="#climada_template">climada_template</A>
<LI><A HREF="#climada_tif2assets">climada_tif2assets</A>
<LI><A HREF="#climada_waterfall_graph_advanced">climada_waterfall_graph_advanced</A>
<LI><A HREF="#climada_waterfall_graph_animation">climada_waterfall_graph_animation</A>
<LI><A HREF="#climada_xlsread">climada_xlsread</A>
<LI><A HREF="#compile_all_function_headers">compile_all_function_headers</A>
<LI><A HREF="#compile_function_header_doc">compile_function_header_doc</A>
<LI><A HREF="#cprintf">cprintf</A>
<LI><A HREF="#freezeColors">freezeColors</A>
<LI><A HREF="#gauss_distribution">gauss_distribution</A>
<LI><A HREF="#git">git</A>
<LI><A HREF="#hist2d">hist2d</A>
<LI><A HREF="#makeColorMap">makeColorMap</A>
<LI><A HREF="#mygaussfit">mygaussfit</A>
<LI><A HREF="#nanmax">nanmax</A>
<LI><A HREF="#nanmean">nanmean</A>
<LI><A HREF="#parseArgs">parseArgs</A>
<LI><A HREF="#plot_normal">plot_normal</A>
<LI><A HREF="#plotclr">plotclr</A>
<LI><A HREF="#subaxis">subaxis</A>
<LI><A HREF="#waitbar_toggle">waitbar_toggle</A>

<P><STRONG>_modules\Louisiana_GIS\code:</STRONG><LI><A HREF="#climada_naturalearthdata_add">climada_naturalearthdata_add</A>
<LI><A HREF="#climada_naturalearthdata_plot">climada_naturalearthdata_plot</A>
<LI><A HREF="#climada_shp_explorer">climada_shp_explorer</A>

<P><STRONG>_modules\advanced\code:</STRONG><LI><A HREF="#climada_assets_crop">climada_assets_crop</A>
<LI><A HREF="#climada_centroids_elevation_add">climada_centroids_elevation_add</A>
<LI><A HREF="#climada_centroids_generate">climada_centroids_generate</A>
<LI><A HREF="#climada_circle_create">climada_circle_create</A>
<LI><A HREF="#climada_entity_crop">climada_entity_crop</A>
<LI><A HREF="#climada_exceedence_freq2freq">climada_exceedence_freq2freq</A>
<LI><A HREF="#climada_hazard2xls">climada_hazard2xls</A>
<LI><A HREF="#climada_hazard_crop">climada_hazard_crop</A>
<LI><A HREF="#climada_hazard_init">climada_hazard_init</A>
<LI><A HREF="#climada_measures_construct">climada_measures_construct</A>
<LI><A HREF="#climada_measures_impact_add">climada_measures_impact_add</A>

<P><STRONG>_modules\advanced\code\ECA_graphics:</STRONG><LI><A HREF="#axescenter">axescenter</A>
<LI><A HREF="#batch_create_ECA_graphics">batch_create_ECA_graphics</A>
<LI><A HREF="#climada_adaptation_graph">climada_adaptation_graph</A>
<LI><A HREF="#climada_adaptation_graph_damage">climada_adaptation_graph_damage</A>
<LI><A HREF="#climada_adaptation_graph_new">climada_adaptation_graph_new</A>
<LI><A HREF="#climada_adaptation_graph_upsidedown">climada_adaptation_graph_upsidedown</A>
<LI><A HREF="#climada_read_risk_analysis">climada_read_risk_analysis</A>
<LI><A HREF="#climada_waterfall_graph_special">climada_waterfall_graph_special</A>
<LI><A HREF="#climada_waterfall_graph_special_NY">climada_waterfall_graph_special_NY</A>
<LI><A HREF="#climada_waterfall_graph_special_tanzania">climada_waterfall_graph_special_tanzania</A>
<LI><A HREF="#font_test">font_test</A>

<P><STRONG>_modules\advanced\code\argument_checks:</STRONG><LI><A HREF="#isassets">isassets</A>
<LI><A HREF="#iscentroids">iscentroids</A>
<LI><A HREF="#isdamagefunctions">isdamagefunctions</A>
<LI><A HREF="#isentity">isentity</A>
<LI><A HREF="#ishazard">ishazard</A>

<P><STRONG>_modules\barisal_demo\code:</STRONG><LI><A HREF="#barisal_ED_find_most_vulnerable">barisal_ED_find_most_vulnerable</A>
<LI><A HREF="#barisal_MI_per_peril">barisal_MI_per_peril</A>
<LI><A HREF="#barisal_adaptation_bar_chart">barisal_adaptation_bar_chart</A>
<LI><A HREF="#barisal_adaptation_cost_curve">barisal_adaptation_cost_curve</A>
<LI><A HREF="#barisal_entity_pre_process">barisal_entity_pre_process</A>
<LI><A HREF="#barisal_entity_pre_process_income">barisal_entity_pre_process_income</A>
<LI><A HREF="#barisal_get_EDS">barisal_get_EDS</A>
<LI><A HREF="#barisal_get_entity">barisal_get_entity</A>
<LI><A HREF="#barisal_get_hazard">barisal_get_hazard</A>
<LI><A HREF="#barisal_measure_zones">barisal_measure_zones</A>
<LI><A HREF="#barisal_plot_adaptation_cost_curve">barisal_plot_adaptation_cost_curve</A>
<LI><A HREF="#barisal_risk_calculations">barisal_risk_calculations</A>
<LI><A HREF="#barisal_tc_hazard_prob">barisal_tc_hazard_prob</A>
<LI><A HREF="#climada_EDS_ED_at_centroid_report_xls">climada_EDS_ED_at_centroid_report_xls</A>
<LI><A HREF="#climada_EDS_multi_calc">climada_EDS_multi_calc</A>
<LI><A HREF="#climada_ED_plot_per_point">climada_ED_plot_per_point</A>
<LI><A HREF="#climada_MI_plot">climada_MI_plot</A>
<LI><A HREF="#climada_measures_impact_advanced">climada_measures_impact_advanced</A>
<LI><A HREF="#climada_waterfall_graph_multi_peril">climada_waterfall_graph_multi_peril</A>

<P><STRONG>_modules\barisal_demo\code\helper_functions:</STRONG><LI><A HREF="#BCC_plot">BCC_plot</A>
<LI><A HREF="#_barisal_entity_prepare">_barisal_entity_prepare</A>
<LI><A HREF="#_barisal_entity_prepare_ward">_barisal_entity_prepare_ward</A>
<LI><A HREF="#_barisal_risk_calculation_excel_old">_barisal_risk_calculation_excel_old</A>
<LI><A HREF="#_barisal_risk_calculations">_barisal_risk_calculations</A>
<LI><A HREF="#barisal_BCC_boundaries_ge">barisal_BCC_boundaries_ge</A>
<LI><A HREF="#barisal_BCC_ward_shp_add_no">barisal_BCC_ward_shp_add_no</A>
<LI><A HREF="#barisal_DFC_graph">barisal_DFC_graph</A>
<LI><A HREF="#barisal_EDS_DFC">barisal_EDS_DFC</A>
<LI><A HREF="#barisal_climate_screw">barisal_climate_screw</A>
<LI><A HREF="#barisal_dmgfun_filter">barisal_dmgfun_filter</A>
<LI><A HREF="#barisal_entity_prepare_100m_cells">barisal_entity_prepare_100m_cells</A>
<LI><A HREF="#barisal_hazard_FL_ge">barisal_hazard_FL_ge</A>
<LI><A HREF="#barisal_hazard_entity_load">barisal_hazard_entity_load</A>
<LI><A HREF="#barisal_hazard_plot_all">barisal_hazard_plot_all</A>
<LI><A HREF="#barisal_hazard_read">barisal_hazard_read</A>
<LI><A HREF="#climada_EDS_plot_3d">climada_EDS_plot_3d</A>
<LI><A HREF="#climada_ED_plot_per_ward">climada_ED_plot_per_ward</A>
<LI><A HREF="#climada_ascii_read">climada_ascii_read</A>
<LI><A HREF="#climada_assets_plot_per_point">climada_assets_plot_per_point</A>
<LI><A HREF="#climada_distributed_measures">climada_distributed_measures</A>
<LI><A HREF="#climada_waterfall_graph_barisal">climada_waterfall_graph_barisal</A>
<LI><A HREF="#climada_waterfall_graph_barisal_combined">climada_waterfall_graph_barisal_combined</A>
<LI><A HREF="#ll2btm">ll2btm</A>
<LI><A HREF="#ll2utm_shift">ll2utm_shift</A>
<LI><A HREF="#subdir">subdir</A>
<LI><A HREF="#tc_surge_plot_3d_Barisal">tc_surge_plot_3d_Barisal</A>
<LI><A HREF="#utm2ll">utm2ll</A>
<LI><A HREF="#utm2ll_shift">utm2ll_shift</A>

<P><STRONG>_modules\barisal_demo\code\old:</STRONG><LI><A HREF="#_climada_measures_impact_report_OLD">_climada_measures_impact_report_OLD</A>
<LI><A HREF="#barisal_risk_calculation_excel">barisal_risk_calculation_excel</A>
<LI><A HREF="#climada_waterfall_graph_2timehorizons">climada_waterfall_graph_2timehorizons</A>
<LI><A HREF="#tc_surge_Barisal">tc_surge_Barisal</A>

<P><STRONG>_modules\country_risk\code:</STRONG><LI><A HREF="#centroids_generate_hazard_sets">centroids_generate_hazard_sets</A>
<LI><A HREF="#climada_create_GDP_entity">climada_create_GDP_entity</A>
<LI><A HREF="#climada_entity_GDP">climada_entity_GDP</A>
<LI><A HREF="#climada_hybrid_entity">climada_hybrid_entity</A>
<LI><A HREF="#climada_night_light_to_country">climada_night_light_to_country</A>
<LI><A HREF="#climada_nightlight_entity">climada_nightlight_entity</A>
<LI><A HREF="#climada_plot_entity_assets">climada_plot_entity_assets</A>
<LI><A HREF="#country_admin1_risk_calc">country_admin1_risk_calc</A>
<LI><A HREF="#country_risk_calc">country_risk_calc</A>
<LI><A HREF="#country_risk_calibrate">country_risk_calibrate</A>
<LI><A HREF="#country_risk_report">country_risk_report</A>
<LI><A HREF="#country_risk_report_raw">country_risk_report_raw</A>
<LI><A HREF="#country_risk_waterfall">country_risk_waterfall</A>
<LI><A HREF="#emdat_read">emdat_read</A>
<LI><A HREF="#selected_countries_all_in_one">selected_countries_all_in_one</A>

<P><STRONG>_modules\country_risk\code\GDP_entity:</STRONG><LI><A HREF="#GDP_docs_test">GDP_docs_test</A>
<LI><A HREF="#climada_GDP_check_countrynames">climada_GDP_check_countrynames</A>
<LI><A HREF="#climada_GDP_read">climada_GDP_read</A>
<LI><A HREF="#climada_ask_country_name">climada_ask_country_name</A>
<LI><A HREF="#climada_create_centroids_entity_base">climada_create_centroids_entity_base</A>
<LI><A HREF="#climada_cut_out_GDP_entity">climada_cut_out_GDP_entity</A>
<LI><A HREF="#climada_define_polygon">climada_define_polygon</A>
<LI><A HREF="#climada_downscale">climada_downscale</A>
<LI><A HREF="#climada_entity_base_assets_add">climada_entity_base_assets_add</A>
<LI><A HREF="#climada_entity_read_wo_assets">climada_entity_read_wo_assets</A>
<LI><A HREF="#climada_entity_save_xls">climada_entity_save_xls</A>
<LI><A HREF="#climada_entity_scaleup_GDP">climada_entity_scaleup_GDP</A>
<LI><A HREF="#climada_entity_scaleup_factor">climada_entity_scaleup_factor</A>
<LI><A HREF="#climada_load_border_mask">climada_load_border_mask</A>
<LI><A HREF="#climada_load_world_borders">climada_load_world_borders</A>
<LI><A HREF="#climada_mask_buffer_hollow">climada_mask_buffer_hollow</A>
<LI><A HREF="#climada_matrix2centroid">climada_matrix2centroid</A>
<LI><A HREF="#climada_night_light_read">climada_night_light_read</A>
<LI><A HREF="#climada_nightlight_nonlinear_transformation">climada_nightlight_nonlinear_transformation</A>
<LI><A HREF="#climada_parameter_string">climada_parameter_string</A>
<LI><A HREF="#climada_plot_centroids">climada_plot_centroids</A>
<LI><A HREF="#climada_polygon2raster">climada_polygon2raster</A>
<LI><A HREF="#climada_resolution_downscale">climada_resolution_downscale</A>
<LI><A HREF="#inpoly">inpoly</A>

<P><STRONG>_modules\country_risk\code\helper_functions:</STRONG><LI><A HREF="#country_risk_EDS2YDS">country_risk_EDS2YDS</A>
<LI><A HREF="#country_risk_EDS_combine">country_risk_EDS_combine</A>
<LI><A HREF="#cr_DFC_plot">cr_DFC_plot</A>
<LI><A HREF="#cr_DFC_plot_aggregate">cr_DFC_plot_aggregate</A>
<LI><A HREF="#cr_EDS_emdat_adjust">cr_EDS_emdat_adjust</A>
<LI><A HREF="#cr_checksum">cr_checksum</A>
<LI><A HREF="#cr_country_DFC_sensitivity">cr_country_DFC_sensitivity</A>
<LI><A HREF="#cr_country_hazard_test">cr_country_hazard_test</A>
<LI><A HREF="#cr_damage_as_percentage_of_GDP">cr_damage_as_percentage_of_GDP</A>
<LI><A HREF="#cr_damagefunction_adjust">cr_damagefunction_adjust</A>
<LI><A HREF="#cr_damagefunction_sensitivity">cr_damagefunction_sensitivity</A>
<LI><A HREF="#cr_economic_loss_calc">cr_economic_loss_calc</A>
<LI><A HREF="#cr_get_damage_weight">cr_get_damage_weight</A>
<LI><A HREF="#cr_hazard_clim_scen">cr_hazard_clim_scen</A>
<LI><A HREF="#cr_hazard_comparison">cr_hazard_comparison</A>
<LI><A HREF="#cr_loss_multiplier_plot">cr_loss_multiplier_plot</A>

<P><STRONG>_modules\disaster_risk_finance_private\code\diana:</STRONG><LI><A HREF="#diana">diana</A>
<LI><A HREF="#diana_params">diana_params</A>
<LI><A HREF="#drf_damage_calc">drf_damage_calc</A>
<LI><A HREF="#drf_evaluation">drf_evaluation</A>
<LI><A HREF="#drf_plot">drf_plot</A>

<P><STRONG>_modules\disaster_risk_finance_private\code\helper_functions:</STRONG><LI><A HREF="#MSP_PLS_read">MSP_PLS_read</A>
<LI><A HREF="#climada_PLS_read">climada_PLS_read</A>

<P><STRONG>_modules\drought_fire\code:</STRONG><LI><A HREF="#bf_TEST">bf_TEST</A>
<LI><A HREF="#bf_generator">bf_generator</A>
<LI><A HREF="#bf_generator2">bf_generator2</A>
<LI><A HREF="#bf_generator_large">bf_generator_large</A>
<LI><A HREF="#climada_bf_hazard_set">climada_bf_hazard_set</A>
<LI><A HREF="#firms_read">firms_read</A>

<P><STRONG>_modules\earthquake_volcano\code:</STRONG><LI><A HREF="#MMI_attenuation_calc">MMI_attenuation_calc</A>
<LI><A HREF="#climada_get_single_event">climada_get_single_event</A>
<LI><A HREF="#eq_centennial_read">eq_centennial_read</A>
<LI><A HREF="#eq_global_attenuation">eq_global_attenuation</A>
<LI><A HREF="#eq_global_attenuation_TEST">eq_global_attenuation_TEST</A>
<LI><A HREF="#eq_global_hazard_set">eq_global_hazard_set</A>
<LI><A HREF="#eq_global_hazard_set_slow">eq_global_hazard_set_slow</A>
<LI><A HREF="#eq_global_probabilistic">eq_global_probabilistic</A>
<LI><A HREF="#eq_isc_gem_read">eq_isc_gem_read</A>
<LI><A HREF="#eq_signigeq_read">eq_signigeq_read</A>
<LI><A HREF="#plot_attenuation_parameters">plot_attenuation_parameters</A>
<LI><A HREF="#plot_gutenberg_richter">plot_gutenberg_richter</A>
<LI><A HREF="#validate_eq_damage">validate_eq_damage</A>
<LI><A HREF="#vq_global_hazard_set">vq_global_hazard_set</A>
<LI><A HREF="#vq_global_probabilistic">vq_global_probabilistic</A>
<LI><A HREF="#vq_tephra_field_cm">vq_tephra_field_cm</A>
<LI><A HREF="#vq_volcano_list_read">vq_volcano_list_read</A>

<P><STRONG>_modules\elevation_models\code:</STRONG><LI><A HREF="#climada_srtm_entity">climada_srtm_entity</A>
<LI><A HREF="#climada_srtm_get">climada_srtm_get</A>
<LI><A HREF="#etopo_elevation_m">etopo_elevation_m</A>
<LI><A HREF="#etopo_get">etopo_get</A>

<P><STRONG>_modules\elevation_models\code\helper_functions:</STRONG><LI><A HREF="#climada_hdr_read">climada_hdr_read</A>
<LI><A HREF="#climada_srtm_info">climada_srtm_info</A>

<P><STRONG>_modules\flood\code:</STRONG><LI><A HREF="#climada_hazard_encode_distance">climada_hazard_encode_distance</A>
<LI><A HREF="#climada_ls_hazard_binary_plot">climada_ls_hazard_binary_plot</A>
<LI><A HREF="#climada_ls_hazard_set">climada_ls_hazard_set</A>
<LI><A HREF="#climada_ls_hazard_set_binary">climada_ls_hazard_set_binary</A>

<P><STRONG>_modules\flood\code\helper_functions:</STRONG><LI><A HREF="#climada_centroids_TWI_calc">climada_centroids_TWI_calc</A>
<LI><A HREF="#climada_flow_find">climada_flow_find</A>
<LI><A HREF="#climada_geo_distance_2">climada_geo_distance_2</A>

<P><STRONG>_modules\flood\code\under_construction:</STRONG><LI><A HREF="#basin_identify">basin_identify</A>
<LI><A HREF="#centroids_BD">centroids_BD</A>
<LI><A HREF="#centroids_ET">centroids_ET</A>
<LI><A HREF="#centroids_LAI">centroids_LAI</A>
<LI><A HREF="#centroids_SD">centroids_SD</A>
<LI><A HREF="#centroids_SWI">centroids_SWI</A>
<LI><A HREF="#centroids_WHC">centroids_WHC</A>
<LI><A HREF="#centroids_basin_ID">centroids_basin_ID</A>
<LI><A HREF="#centroids_river_network">centroids_river_network</A>
<LI><A HREF="#climada_90m_DEM">climada_90m_DEM</A>
<LI><A HREF="#climada_DEM_plot">climada_DEM_plot</A>
<LI><A HREF="#climada_fl_centroids_prepare">climada_fl_centroids_prepare</A>
<LI><A HREF="#climada_fl_hazard_set">climada_fl_hazard_set</A>
<LI><A HREF="#climada_grid2array">climada_grid2array</A>
<LI><A HREF="#climada_ls_cell_failure">climada_ls_cell_failure</A>
<LI><A HREF="#climada_ls_hazard_set_gilles">climada_ls_hazard_set_gilles</A>
<LI><A HREF="#climada_ls_multi_layer_plot">climada_ls_multi_layer_plot</A>
<LI><A HREF="#climada_rf_hazard_set">climada_rf_hazard_set</A>
<LI><A HREF="#dem">dem</A>
<LI><A HREF="#fl_Climada_Aqueduct_compare">fl_Climada_Aqueduct_compare</A>
<LI><A HREF="#fl_hazard_plot_hr">fl_hazard_plot_hr</A>
<LI><A HREF="#flood_countryrisk_generate">flood_countryrisk_generate</A>
<LI><A HREF="#flood_damagefunction_entity_add">flood_damagefunction_entity_add</A>
<LI><A HREF="#landcolor">landcolor</A>
<LI><A HREF="#seacolor">seacolor</A>
<LI><A HREF="#structfind">structfind</A>

<P><STRONG>_modules\flood_module_Anz\code:</STRONG><LI><A HREF="#DEM_rainfall">DEM_rainfall</A>
<LI><A HREF="#climada_90m_DEM">climada_90m_DEM</A>
<LI><A HREF="#climada_fl_encode">climada_fl_encode</A>
<LI><A HREF="#climada_fl_onland">climada_fl_onland</A>
<LI><A HREF="#climada_flood_module">climada_flood_module</A>
<LI><A HREF="#climada_flood_module_ANZ">climada_flood_module_ANZ</A>
<LI><A HREF="#climada_flood_plot">climada_flood_plot</A>
<LI><A HREF="#climada_grid2array">climada_grid2array</A>
<LI><A HREF="#climada_hazard_encode_distance">climada_hazard_encode_distance</A>
<LI><A HREF="#climada_ls_hazard_binary_plot">climada_ls_hazard_binary_plot</A>
<LI><A HREF="#climada_ls_hazard_set">climada_ls_hazard_set</A>
<LI><A HREF="#climada_ls_hazard_set_binary">climada_ls_hazard_set_binary</A>
<LI><A HREF="#climada_read_srtm_DEM">climada_read_srtm_DEM</A>
<LI><A HREF="#discharge_relation">discharge_relation</A>
<LI><A HREF="#flood_calibrate">flood_calibrate</A>
<LI><A HREF="#flood_hazard_create">flood_hazard_create</A>
<LI><A HREF="#flood_hazard_create_single">flood_hazard_create_single</A>
<LI><A HREF="#flood_innund_estim">flood_innund_estim</A>
<LI><A HREF="#flood_remote_centroids_clean">flood_remote_centroids_clean</A>
<LI><A HREF="#flood_shape_write">flood_shape_write</A>
<LI><A HREF="#rain_statistics">rain_statistics</A>
<LI><A HREF="#rating_curve">rating_curve</A>
<LI><A HREF="#stream_elevation_correct">stream_elevation_correct</A>
<LI><A HREF="#streamord">streamord</A>
<LI><A HREF="#streamorder2swathobj">streamorder2swathobj</A>

<P><STRONG>_modules\flood_module_Anz\code\helper_functions:</STRONG><LI><A HREF="#climada_centroids_TWI_calc">climada_centroids_TWI_calc</A>
<LI><A HREF="#climada_flow_find">climada_flow_find</A>
<LI><A HREF="#climada_geo_distance_2">climada_geo_distance_2</A>
<LI><A HREF="#filtfilt">filtfilt</A>
<LI><A HREF="#l_imerode">l_imerode</A>
<LI><A HREF="#lineSegmentIntersect">lineSegmentIntersect</A>
<LI><A HREF="#vec2grid">vec2grid</A>

<P><STRONG>_modules\flood_module_Anz\code\topotoolbox:</STRONG><LI><A HREF="#chiplot">chiplot</A>
<LI><A HREF="#compilemexfiles">compilemexfiles</A>
<LI><A HREF="#coord2ind">coord2ind</A>
<LI><A HREF="#demo_modifystreamnet">demo_modifystreamnet</A>
<LI><A HREF="#flowpathapp">flowpathapp</A>
<LI><A HREF="#preprocessapp">preprocessapp</A>
<LI><A HREF="#showmethods">showmethods</A>
<LI><A HREF="#slopearea">slopearea</A>
<LI><A HREF="#slopeareatool">slopeareatool</A>
<LI><A HREF="#ttbenchmark">ttbenchmark</A>
<LI><A HREF="#usersguide_1_intro">usersguide_1_intro</A>
<LI><A HREF="#usersguide_2_flats">usersguide_2_flats</A>
<LI><A HREF="#usersguide_2_mfd">usersguide_2_mfd</A>
<LI><A HREF="#usersguide_3_ksn">usersguide_3_ksn</A>

<P><STRONG>_modules\meteorite\code:</STRONG><LI><A HREF="#climada_meteorite_hazard_set">climada_meteorite_hazard_set</A>

<P><STRONG>_modules\salvador_demo\code:</STRONG><LI><A HREF="#climada_measure_viewer">climada_measure_viewer</A>
<LI><A HREF="#climada_value_sum">climada_value_sum</A>
<LI><A HREF="#salvador_LS_screw">salvador_LS_screw</A>
<LI><A HREF="#salvador_TC_screw">salvador_TC_screw</A>
<LI><A HREF="#salvador_calc_measures">salvador_calc_measures</A>
<LI><A HREF="#salvador_calc_waterfall">salvador_calc_waterfall</A>
<LI><A HREF="#salvador_entity_files_set">salvador_entity_files_set</A>
<LI><A HREF="#salvador_entity_future_create">salvador_entity_future_create</A>
<LI><A HREF="#salvador_hazard_future_save">salvador_hazard_future_save</A>
<LI><A HREF="#salvador_resolution_test_LS">salvador_resolution_test_LS</A>
<LI><A HREF="#salvador_resolution_test_TC">salvador_resolution_test_TC</A>

<P><STRONG>_modules\salvador_demo\code\helper_functions:</STRONG><LI><A HREF="#Salvador_movie_tc">Salvador_movie_tc</A>
<LI><A HREF="#_ECA_San_Salvador">_ECA_San_Salvador</A>
<LI><A HREF="#_FL_hazard_correction">_FL_hazard_correction</A>
<LI><A HREF="#_salvador_EDS_ED_per_category_report_summary">_salvador_EDS_ED_per_category_report_summary</A>
<LI><A HREF="#_salvador_all_in_one">_salvador_all_in_one</A>
<LI><A HREF="#_salvador_entity_read">_salvador_entity_read</A>
<LI><A HREF="#_salvador_hazard_FL_prepare">_salvador_hazard_FL_prepare</A>
<LI><A HREF="#_salvador_hazard_LS_distance_prepare">_salvador_hazard_LS_distance_prepare</A>
<LI><A HREF="#_salvador_land_use">_salvador_land_use</A>
<LI><A HREF="#_salvador_results_overview">_salvador_results_overview</A>
<LI><A HREF="#_salvador_vegetation">_salvador_vegetation</A>
<LI><A HREF="#climada_map_plot_salvador">climada_map_plot_salvador</A>
<LI><A HREF="#salvador_dem_read">salvador_dem_read</A>
<LI><A HREF="#salvador_hazard_FL_read">salvador_hazard_FL_read</A>
<LI><A HREF="#salvador_hazard_LS_create_acelhuate">salvador_hazard_LS_create_acelhuate</A>
<LI><A HREF="#salvador_hazard_LS_create_las_canas">salvador_hazard_LS_create_las_canas</A>
<LI><A HREF="#salvador_map_plot">salvador_map_plot</A>
<LI><A HREF="#salvador_plot">salvador_plot</A>
<LI><A HREF="#salvador_risk_calculations">salvador_risk_calculations</A>
<LI><A HREF="#salvador_shp_prepare">salvador_shp_prepare</A>
<LI><A HREF="#salvador_tc_hazard_prob">salvador_tc_hazard_prob</A>
<LI><A HREF="#utm2ll_salvador">utm2ll_salvador</A>

<P><STRONG>_modules\storm_europe\code:</STRONG><LI><A HREF="#WS_intensity_correction">WS_intensity_correction</A>
<LI><A HREF="#winterstorm_TEST">winterstorm_TEST</A>
<LI><A HREF="#winterstorm_blend_hazard_event_sets">winterstorm_blend_hazard_event_sets</A>
<LI><A HREF="#winterstorm_compare">winterstorm_compare</A>
<LI><A HREF="#winterstorm_compare_severity">winterstorm_compare_severity</A>
<LI><A HREF="#winterstorm_scenario_hazard">winterstorm_scenario_hazard</A>
<LI><A HREF="#winterstorm_severity">winterstorm_severity</A>

<P><STRONG>_modules\tropical_cyclone\code:</STRONG><LI><A HREF="#_climada_nonspheric_distance_m">_climada_nonspheric_distance_m</A>
<LI><A HREF="#climada_EDS_scaleup_factor">climada_EDS_scaleup_factor</A>
<LI><A HREF="#climada_RCLIPER">climada_RCLIPER</A>
<LI><A HREF="#climada_admin_name">climada_admin_name</A>
<LI><A HREF="#climada_centroids_distance_to_coast">climada_centroids_distance_to_coast</A>
<LI><A HREF="#climada_centroids_hazard_expand">climada_centroids_hazard_expand</A>
<LI><A HREF="#climada_coastline_read">climada_coastline_read</A>
<LI><A HREF="#climada_event_damage_animation_ge">climada_event_damage_animation_ge</A>
<LI><A HREF="#climada_hazard_clim_scen_IPCC">climada_hazard_clim_scen_IPCC</A>
<LI><A HREF="#climada_hazard_clim_scen_advanced">climada_hazard_clim_scen_advanced</A>
<LI><A HREF="#climada_hazard_climate_screw">climada_hazard_climate_screw</A>
<LI><A HREF="#climada_hazard_distance_to_coast">climada_hazard_distance_to_coast</A>
<LI><A HREF="#climada_hazard_distance_to_coast_USA">climada_hazard_distance_to_coast_USA</A>
<LI><A HREF="#climada_hazard_distance_to_coast_australia">climada_hazard_distance_to_coast_australia</A>
<LI><A HREF="#climada_hazard_distance_to_coast_china">climada_hazard_distance_to_coast_china</A>
<LI><A HREF="#climada_hazard_distance_to_coast_japan">climada_hazard_distance_to_coast_japan</A>
<LI><A HREF="#climada_hazard_extract_event">climada_hazard_extract_event</A>
<LI><A HREF="#climada_hazard_footprint_plot">climada_hazard_footprint_plot</A>
<LI><A HREF="#climada_hazard_merge">climada_hazard_merge</A>
<LI><A HREF="#climada_plot_loss_hist">climada_plot_loss_hist</A>
<LI><A HREF="#climada_plot_lossfootprint">climada_plot_lossfootprint</A>
<LI><A HREF="#climada_plot_probabilistic_wind_speed_decay">climada_plot_probabilistic_wind_speed_decay</A>
<LI><A HREF="#climada_plot_probabilistic_wind_speed_map_gui">climada_plot_probabilistic_wind_speed_map_gui</A>
<LI><A HREF="#climada_scale_to_MSP_to_market">climada_scale_to_MSP_to_market</A>
<LI><A HREF="#climada_tc_hazard_set_slow">climada_tc_hazard_set_slow</A>
<LI><A HREF="#climada_tc_on_land">climada_tc_on_land</A>
<LI><A HREF="#climada_tc_track_google_earth">climada_tc_track_google_earth</A>
<LI><A HREF="#climada_tc_track_wind_decay">climada_tc_track_wind_decay</A>
<LI><A HREF="#climada_tc_track_wind_decay_calculate">climada_tc_track_wind_decay_calculate</A>
<LI><A HREF="#climada_tc_track_windfield_google_earth">climada_tc_track_windfield_google_earth</A>
<LI><A HREF="#climada_tc_wind_decay">climada_tc_wind_decay</A>
<LI><A HREF="#climada_tc_windfield_slow">climada_tc_windfield_slow</A>
<LI><A HREF="#climada_tr_hazard_set">climada_tr_hazard_set</A>
<LI><A HREF="#climada_tr_hazard_set_slow">climada_tr_hazard_set_slow</A>
<LI><A HREF="#climada_tr_rainfield">climada_tr_rainfield</A>
<LI><A HREF="#climada_tr_rainfield_slow">climada_tr_rainfield_slow</A>
<LI><A HREF="#climada_tr_rainrate_field_animation">climada_tr_rainrate_field_animation</A>
<LI><A HREF="#climada_tr_rainsum_field_animation">climada_tr_rainsum_field_animation</A>
<LI><A HREF="#climada_track_map">climada_track_map</A>
<LI><A HREF="#climada_ts_hazard_set">climada_ts_hazard_set</A>
<LI><A HREF="#figures_for_hazard_advanced_manual">figures_for_hazard_advanced_manual</A>
<LI><A HREF="#haversine">haversine</A>
<LI><A HREF="#tc_surge_TEST">tc_surge_TEST</A>
<LI><A HREF="#tc_surge_TEST_Netherlands">tc_surge_TEST_Netherlands</A>
<LI><A HREF="#tc_surge_plot_3d">tc_surge_plot_3d</A>
<P>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<PRE>


<A NAME="climada">
<H2>climada</H2></A>
<font color="blue">function measures_impact=climada(entity_today_file,entity_future_file,hazard_today_file,hazard_future_file,check_plots) </font>
 climada all in one adaptaton cost curve climate scenarios economic grwoth projection
 MODULE:
   core
 NAME:
   climada
 PURPOSE:
   Import entity today and entity future, ask for corresponding hazard
   event sets, show a few plots for checks, run all calculations and
   produce the final adaptation cost curve - all in one call.

   Special: on subsequent calls, the routine suggest last inputs - and if
   the first file selection is the same as on previous call, even asks to
   re-run with previous call's inputs without asking for each's
   confirmation.
   It further checks for the entity file to have been edited since last
   call. If not, it does not ask for plotting assets and damagefunctions
   again. If one wants to plot, needs to either save the entity again or
   select another file and then cancel.

   Programmes's note: The present code mainly handles asdmin, i.e.
   checking files, while all calculations are run be the core climada
   functions, i.e. climada_entity_read, climada_measures_impact, 
   climada_adaptation_event_view and - last but not least -
   climada_adaptation_cost_curve. 
 CALLING SEQUENCE:
   measures_impact=climada(entity,entitiy_future,hazard_today_file,hazard_future_file)
 EXAMPLE:
   measures_impact=climada % all prompted for
   measures_impact=climada('TEST_CLIMADA'); % TEST mode
 INPUTS:
   entity_today_file: entity (assets, damagefunctions and measures) today
       a climada entity file, either an Excel (.xls or .xlsx) or Open
       Office (.ods file) or an already encoded .mat file. Note that in
       case a .mat file is provided, the code does not notice if the
       original .xls or .ods got changed - hence preferable select the
       source, i.e. .xls or .ods).   
       &ampgt prompted for if empty
       ='TEST_CLIMADA': special test mode, the code uses the test files
       (as used in climada_demo and climada_demo_step_by_step)
   entity_future_file: future entity (assets, damagefunctions and measures) to
       represent projected economic growth, a climada entity structure
       (see climada_entity_read, same remark as above)
       &ampgt prompted for if empty
   hazard_today_file: a climada hazard event set for today
       &ampgt promted for if not given
   hazard_future_file: a climada hazard event set for future (climate scenario)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   check_plots: whether we show a few check plots (assets,
       damagefunctions)
       =0: no plots (default)
       =1: show plots
       The code also switches to ask for plot if it needs to prompt
       for filenames, i.e. operates in interactive mode.
 OUTPUTS:
   measures_impact: the same output as climada_measures_impact
   and plots: adaptation cost curve, adaptation event view
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150101, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_calc">
<H2>climada_EDS_calc</H2></A>
<font color="blue">function EDS=climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode,sanity_check) </font>
 climada calculate event damage set
 NAME:
   climada_EDS_calc
 PURPOSE:
   given an encoded entity (assets and damage functions) and a hazard
   event set, calculate the event damage set (EDS). The event damage set
   contains the event damage for each hazard event. In case you set
   climada_global.EDS_at_centroid=1, the damage is also stored for each
   event at each centroids (be aware of memory implications). The exepcted
   damage is always stored at each centroid, see EDS.ED_at_centroid.

   Note that the waitbar consumes quite some time, so switch it off by
   setting climada_global.waitbar=0 or by
   using the climada_code_optimizer, which removes all slowing code, i.e.
   all code lines marked by % CLIMADA_OPT - but by now, the code is pretty
   fast, hence climada_code_optimizer does usually not bring huge
   improvements (i.e. less than 4% speedup).

   Search for 'TEST output' in code to show output for VERY SMALL entities

   next (likely): climada_EDS_DFC or climada_EDS2DFC, climada_EDS_DFC_report
   See also climada_EDS_calc_parfor for a parallelized version (beta)
 CALLING SEQUENCE:
   EDS=climada_EDS_calc(entity,hazard,annotation_name)
 EXAMPLE:
   EDS=climada_EDS_calc(climada_assets_encode(climada_assets_read))
   EDS=climada_EDS_calc('demo_today','TCNA_today_small')
 INPUTS:
   entity: an entity structure or an entity .mat file, see climada_assets_encode(climada_assets_read)
       If a file and no path provided, default path ../data/entities is
       used (and name can be without extension .mat)
       &ampgt promted for if not given
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       If a file and no path provided, default path ../data/hazards is
       used (and name can be without extension .mat)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   annotation_name: a free text that will appear e.g. on plots for
       annotation, default is the name of the hazard set
   force_re_encode: if =1, force re-encoding (either to be on the safe
       side, or if the entity has been encoded t a different hazard event
       set). Default=0
   silent_mode: suppress any output to stdout (useful i.e. if called many times)
       defult=0 (output to stdout), =1: no output and no waitbar at all
       But even with silent_mode=1, the one line progress output is shown
 OUTPUTS:
   EDS, the event damage set with:
       ED: the total expected annual damage (=EDS.damage*EDS.frequency')
       reference_year: the year the damages are references to
       event_ID(event_i): the unique ID for each event_i
       damage(event_i): the damage amount for event_i (summed up over all
           assets)
       ED_at_centroid(centroid_i): expected damage at each centroid
       Value: the sum of all Values used in the calculation (to e.g.
           express damages in percentage of total Value)
       frequency(event_i): the per occurrence event frequency for each event_i
       orig_event_flag(event_i): whether an original event (=1) or a
           probabilistic one (=0)
       comment: a free comment, contains time for calculation
       hazard: itself a structure, with:
           filename: the filename of the hazard event set
           comment: a free comment
       assets.lat(asset_i): the latitude of each asset_i
       assets.lon(asset_i): the longitude of each asset_i
       assets.Value(asset_i): the Value of asset_i, i.e. used to show
           ED_at_centroid in percentage of asset value.
       assets.filename: the filename of the assets
       assets.admin0_name: the admin0_name of the assets (optional)
       assets.admin0_ISO3: the admin0_ISO3 code of the assets (optional)
       assets.admin1_name: the admin1_name of the assets (optional)
       assets.admin1_code: the admin1_code of the assets (optional)
       damagefunctions.filename: the filename of the damagefunctions
       annotation_name: a kind of default title (sometimes empty)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091228
 David N. Bresch, david.bresch@gmail.com, 20130316, ELS-&ampgtEDS...
 David N. Bresch, david.bresch@gmail.com, 20130623, re-encoding optional
 David N. Bresch, david.bresch@gmail.com, 20141025, peril_ID added to waitbar title
 David N. Bresch, david.bresch@gmail.com, 20141103, entity.damagefunctions.peril_ID
 David N. Bresch, david.bresch@gmail.com, 20141127, force_re_encode
 David N. Bresch, david.bresch@gmail.com, 20141218, Cover checks added
 David N. Bresch, david.bresch@gmail.com, 20141230, only assets.Value&ampgt0 prcocessed for speedup
 David N. Bresch, david.bresch@gmail.com, 20150101, annotation check for 'MAC' and 'APPLE'
 David N. Bresch, david.bresch@gmail.com, 20150103, check Octave compatibility of (large) hazard event sets
 David N. Bresch, david.bresch@gmail.com, 20150105, filesep conversion (from either PC or MAC) solved
 David N. Bresch, david.bresch@gmail.com, 20150106, add Cover and/or Deductible if missing
 David N. Bresch, david.bresch@gmail.com, 20150106, Octave issue with hazard saved as -v7.3 solved
 David N. Bresch, david.bresch@gmail.com, 20150114, EDS.peril_ID (was EDS.hazard.peril_ID)
 David N. Bresch, david.bresch@gmail.com, 20150320, spfun replaced with explicit call, turns out to be &ampgt50% faster. Further speedup, see loop_mod_step
 Gilles Stassen, gillesstassen@hotmail.com, 20150622, use complete peril_ID in asset_damfun_pos refinement (1:2) -&ampgt (:), MDD, PAA  explicitly capped at max value
 David N. Bresch, david.bresch@gmail.com, 20150804, allow for filename without path for entoity and hazard set name on input
 Lea Mueller, muellele@gmail.com, 20150805, allow centroid_index to be zero, do not integrate such assets in valid_asset_pos, no damage will be calculated
 Lea Mueller, muellele@gmail.com, 20150819, use only unique values in interp_x_table, so that interp1 works (interp_x_table is monotonically increasing)
 Lea Mueller, muellele@gmail.com, 20150819, set minimum damage to min defined in damage function (probably 0)
 Lea Mueller, muellele@gmail.com, 20150831, EDS.ED, EDS.damage, EDS.Value is the sum only of the first Value_unit encountered, all other units are not included
 David N. Bresch, david.bresch@gmail.com, 20150907, ...errant extrapolation leads to WRONG behaviour in case of hazard_intensity_impact_b, commented
 Lea Mueller, muellele@gmail.com, 20150907, add sanity_check variable to call climada_damagefunctions_check
 Lea Mueller, muellele@gmail.com, 20150910, set sanity_check to silent_mode
 Lea Mueller, muellele@gmail.com, 20151117, replace output string to &quotCalculating damage&quot instead of &quotprocessing&quot
 Lea Mueller, muellele@gmail.com, 20151127, add EDS.scenario, EDS.assets.reference_year and EDS.assets.region, add EDS.hazard.refence_year and EDS.hazard.scenario
 Lea Mueller, muellele@gmail.com, 20151127, add EDS.assets.Category
 Lea Mueller, muellele@gmail.com, 20151127, invoke climada_assets_category_ID, add EDS.assets.Category_name and EDS.assets.Category_ID
 David N. Bresch, david.bresch@gmail.com, 20160202, cleanup
 David N. Bresch, david.bresch@gmail.com, 20160210, is_unit removed and substantial speedup (damagefunctions made unique before calc)
 Lea Mueller, muellele@gmail.com, 20160303, bugfix if EDS_at_centroid and state ED in fprintf command line output
 David N. Bresch, david.bresch@gmail.com, 20160306, EDS.ED=EDS.damage*EDS.frequency'
 David N. Bresch, david.bresch@gmail.com, 20160308, no printing of ED to stdout, some silent_mode checks slow down too much, removed
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_EDS_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_adaptation_bar_chart">
<H2>climada_adaptation_bar_chart</H2></A>
<font color="blue">function fig = climada_adaptation_bar_chart(measures_impact,sort_measures,scale_benefit,benefit_str,legend_location,tcr_off,cost_unit,xlim_value) </font>
 climada measures impact climate adaptation bar chart
 NAME:
   climada_adaptation_bar_chart_v2
 PURPOSE:
   plot adaptation bar chart (NPV benefits and costs)
   see also: climada_adaptation_cost_curve

 CALLING SEQUENCE:
   climada_adaptation_bar_chart_v2(measures_impact,sort_measures,cb_text_control,scale_benefit,benefit_str,legend_location,tcr_off)
 EXAMPLE:
   climada_adaptation_bar_chart_v2(climada_measures_impact(climada_entity_read),'',1) % from scratch
 INPUTS:
   measures_impact: a climada measures_impact structure, can hold multiple measures_impacts
       see climada_measures_impact
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   sort_measures: if set to 1, sort measures according to size of benefit
   cb_text_control: control position of cb_ratio 
 OUTPUTS:
   fig: a figure handle
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150921, init
 Lea Mueller, muellele@gmail.com, 20150921, measures_impact can hold multiple measures_impact(impact_i)
 Lea Mueller, muellele@gmail.com, 20150924, add cost_unit and xlim_value, introduce climada_digit_set
 Lea Mueller, muellele@gmail.com, 20151019, set bc ratio to less affected people per 10'000 USD
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_adaptation_bar_chart from climada_adaptation_bar_chart_v2
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_adaptation_bar_chart.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_adaptation_cost_curve">
<H2>climada_adaptation_cost_curve</H2></A>
<font color="blue">function [insurance_benefit,insurance_cost]=climada_adaptation_cost_curve(measures_impact,measures_impact_comparison,x_text_control,y_text_control,scaled_AED,nice_numbers,reverse_cb,plot_arrows) </font>
 climada measures impact climate adaptation cost curve
 NAME:
   climada_adaptation_cost_curve
 PURPOSE:
   plot adaptation cost curve, color measures according to benefit/cost
   ratio (see measures_impact.color_keep to keep colors as defined in
   measures)

   see also: climada_adaptation_event_view

   NOTE: The mode with output arguments insurance_benefit and
   insurance_cost is only used when called from climada_demo (the flag
   called_from_climada_demo), no relevance for standard use .

   Previous call climada_measures_impact
   or read benefits directly from excel file with climada_measures_read
 CALLING SEQUENCE:
   [~,~]=climada_adaptation_cost_curve(measures_impact,measures_impact_comparison,x_text_control,y_text_control,scaled_AED,nice_numbers,reverse_cb,plot_arrows)
 EXAMPLE:
   climada_adaptation_cost_curve(climada_measures_impact(climada_entity_read)) % from scratch
 INPUTS:
   measures_impact: either a struct containing the impacts of measures or
       a measures_impact file (.mat with a struct) see climada_measures_impact
       &ampgt promted for if not given
       If theres is a field measures_impact.y_axis_max, it defines the
       maximum of the vertical axis (to shape plots comparable). There are
       no checks any more, hence if you provide a stange number, you get a
       strange vertical scale ;-)
       If theres is a field measures_impact.x_axis_max, it defines the
       maximum of the horizontal axis (to shape plots comparable).
       If there is a field measures_impact.color_keep, the colors as
       defined in measures are kept, otherwise nice colors are assigned.
 OPTIONAL INPUT PARAMETERS:
   measures_impact_comparison: same as measures_impact, but for comparison
       (will be shown in overlay). Not prompted for, so please specify in
       call, or enter 'ASK' in climada_adaptation_cost_curve('','ASK')
       If theres is a field measures_impact_comparison.label_comparison,
       it defines whether comparison wll be labeld (=1, default) or not (=0)
       If =0, also do not label TCR (total climate risk) for comparison
       These setting are usually good for decluttered plots for presentations
   x_text_control: controls the horizontal distribution of the text labels
       (divider of the length of the x-axis, default=20)
   y_text_control: controls the vertical distribution of the text labels
       (divider of the length of the y-axis, default=50)
   scaled_AED: NOT IMPLEMENTED/IN USE ANY MORE
   nice_numbers: NOT IMPLEMENTED/IN USE ANY MORE
   reverse_cb: (=1, default) show benefit per cost
       Set =0 to show cost/beenfit
   plot_arrows: whether we do (=1) or don't (=0, default) plot arrows
       underneath the x-axis to show cost-effective measures and
       non-cost-effective measures extent.
 OUTPUTS:
   insurance_benefit and insurance_cost: only used when called from
       climada_play_adapt_cost_curve, see there (in essence to write
       insurance cost on the GUI). For illustrative purposes only!
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091228
 David N. Bresch, david.bresch@gmail.com, 20091230 major revision, appreance similar to ECA graphs
 David N. Bresch, david.bresch@gmail.com, 20130316 EDS-&ampgtEDS
 David N. Bresch, david.bresch@gmail.com, 20130316 compatibility for both direct call as well as via climada_demo_gui
 Gilles Stassen gillesstassen@hotmail.com 20141212 fixed the arrow issue; changed labeling of total climate risk to USD x m rounded to 2 s.f.
 David N. Bresch, david.bresch@gmail.com, 20141213 plot_arrows=0 by default and climada_demo option cleaned up
 David N. Bresch, david.bresch@gmail.com, 20141231 subaxis removed (not clean, troubles in Octave)
 Lea Mueller, muellele@gmail.com, 20150617, set to bc_ratio (benefits per cost) instead of cb_ratio
 David N. Bresch, david.bresch@gmail.com, 20150804 reverse_cb fixed for comparison plot
 David N. Bresch, david.bresch@gmail.com, 20150907 decluttered (for presentations), i.e. label_comparison, x_axis_max and y_axis_max introduced
 Lea Mueller, muellele@gmail.com, 20150909, introduce factor for unit 'people', to show cb ratio as people not affected/10'000 USD
 David N. Bresch, david.bresch@gmail.com, 20150909, color_keep introduced
 Lea Mueller, muellele@gmail.com, 20150930, introduce climada_digit_set
 Lea Mueller, muellele@gmail.com, 20160309, bugfix fprintf reverse_cb for insurance
 David N. Bresch, david.bresch@gmail.com, 20160427, total climate risk not plotted for climada_demo, fontsize_ adjusted
 David N. Bresch, david.bresch@gmail.com, 20160429, major review, unit display etc cleaned up
 David N. Bresch, david.bresch@gmail.com, 20160429, insurance_benefit,insurance_cost as output again
 David N. Bresch, david.bresch@gmail.com, 20160429, stdout cleaned up
 Lea Mueller, muellele@gmail.com, 20160531, show x- and y-ticks
 David N. Bresch, david.bresch@gmail.com, 20160606, display units synchronized if same unit_name
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_adaptation_cost_curve.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_adaptation_event_view">
<H2>climada_adaptation_event_view</H2></A>
<font color="blue">function AEV = climada_adaptation_event_view(measures_impact,comparison_return_periods) </font>
 climada measures impact climate adaptation damage frequency effect
 NAME:
   climada_adaptation_event_view
 PURPOSE:
   show the effect of measures for events of different return periods
   see also: climada_adaptation_cost_curve
 CALLING SEQUENCE:
   climada_adaptation_event_view(measures_impact,comparison_return_periods)
 EXAMPLE:
   climada_adaptation_event_view(climada_measures_impact(climada_entity_read)) % from scratch
 INPUTS:
   measures_impact: either a struct containing the impacts of measures or a measures_impact file (.mat with a struct)
       see climada_measures_impact
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   comparison_return_periods: the list of return periods to show the
       comparison for, default is [10 25 100]
 OUTPUTS:
   graph, and AEV, a stucture which holds the data of the graph:
       damage(measure_i,return_period_i): the damage for measure_i at return_period_i
           damage(end,return_period_i) holds the damage with no measures
       return_period(return_period_i): the list of return periods
       frequency(return_period_i): the list of frequencies
       effect(measure_i,return_period_i): the effect of measure_i at return_period_i
       total_effect(return_period_i): the total effect of all measures at return_period_i
       cumulated(return_period_i): for each return period, a struct,with
           effect(measure_i): the cumulated effect up to measure i
           NOTE: measures ordered as in adaptation cost curve
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20100109
 David N. Bresch, david.bresch@gmail.com, 20150402, compatibility with version 8ff (R2014...)
 David N. Bresch, david.bresch@gmail.com, 20151021, checked to work for index insurance, too
 Lea Mueller, muellele@gmail.com, 20151125, correct 'FaceColor' issue for version 8
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_adaptation_event_view.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_demo">
<H2>climada_demo</H2></A>
<font color="blue">function climada_demo </font>
 climada
 NAME:
   climada_demo
 PURPOSE:
   a brief demo of climada by way of an interactive GUI
   
 CALLING SEQUENCE:
   climada_demo
 EXAMPLE:
   climada_demo
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120116
 David N. Bresch, david.bresch@gmail.com, 20141123, waitbar suppressed for speedup (noticeable)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_demo.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_demo_gui">
<H2>climada_demo_gui</H2></A>
<font color="blue">function varargout = climada_demo_gui(varargin) </font>
 CLIMADA_DEMO_GUI M-file for climada_demo_gui.fig
      CLIMADA_DEMO_GUI, by itself, creates a new CLIMADA_DEMO_GUI or raises the existing
      singleton*.

      H = CLIMADA_DEMO_GUI returns the handle to a new CLIMADA_DEMO_GUI or the handle to
      the existing singleton*.

      CLIMADA_DEMO_GUI('CALLBACK',hObject,eventData,handles,...) calls the local
      function named CALLBACK in CLIMADA_DEMO_GUI.M with the given input
      arguments.

      CLIMADA_DEMO_GUI('Property','Value',...) creates a new CLIMADA_DEMO_GUI or raises the
      existing singleton*.  Starting from the left, property value pairs are
      applied to the GUI before climada_demo_gui_OpeningFcn gets called.  An
      unrecognized property name or invalid value makes property application
      stop.  All inputs are passed to climada_demo_gui_OpeningFcn via varargin.

      *See GUI Options on GUIDE's Tools menu.  Choose &quotGUI allows only one
      instance to run (singleton)&quot.

 See also: GUIDE, GUIDATA, GUIHANDLES
 david.bresch@gmail.com, 20140516, reverse_cb added
 muellele@gmail.com, 20160523, take demo_illu1.png from climada_global.root_dir instead of climada_global.data_dir

 Edit the above text to modify the response to help climada_demo_gui

 Last Modified by GUIDE v2.5 05-Aug-2015 17:49:27
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_demo_gui.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_demo_step_by_step">
<H2>climada_demo_step_by_step</H2></A>
 climada_demo_step_by_step
 climada
 NAME:
   climada_demo_step_by_step
 PURPOSE:
   show the core climada key functionality step-by-step. Not a function,
   just a batch-file to allow the user to step trough and inspect all
   individual steps. See climada manual, as this code implements the
   section &quotFrom tropical cyclone hazard generation to the adaptation cost
   curve ? a step-by-step guide&quot provided there.

   running it all takes (first time) about 3 minutes (faster on subsequent
   calls, since the probabilistic hazard event set is loaded rather than
   re-generated)

   Note for Octave users: due to slower processing speed of Octave, the
   demo runs with smaller datasets. Somple plots do not look nice, but all
   calculations and core graphics (adaptation cost curve) work fine.
 CALLING SEQUENCE:
   climada_demo_step_by_step
 EXAMPLE:
   climada_demo_step_by_step
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141217, updated
 David N. Bresch, david.bresch@gmail.com, 20141231, octave-compatible
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_demo_step_by_step.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_plot">
<H2>climada_entity_plot</H2></A>
<font color="blue">function climada_entity_plot(entity,markersize,plot_centroids,max_value,cbar_ylabel) </font>
 plot an entity, no detailed documentation
 NAME:
   climada_entity_plot
 PURPOSE:
   Plot the assets of an entity

   Note that you can overplot, just call hold on before calling
   climada_entity_plot, i.e. to plot assets on top of tracks (see
   climada_tc_track_info)

   See also climada_entity_read
   Possible prior call: climada_tc_track_info;hold on
 CALLING SEQUENCE:
   climada_entity_plot(entity)
 EXAMPLE:
   climada_entity_plot(climada_entity_read)
 INPUTS:
   entity: an entity (see climada_entity_read)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   markersize: the size of the 'tiles', one might need to experiment a
       bit, as the code tries (hard) to set a reasonabls default (based on
       resolution)
   plot_centroids: =1: plot centroids as small red dots
       =0: do not plot centroids (default)
   max_value: the maximum value to color
       default is max(entity.assets.Value)
   cbar_ylabel: label for the color bar, default 'Value'
       if empty, indicate entity value locations by black circles, e.g. for
       climada_hazard_plot(hazard);hold on;climada_entity_plot(entity,1,0,[],'')
 OUTPUTS:
   a figure
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141121, ICE initial
 David N. Bresch, david.bresch@gmail.com, 20160514, max_value,cbar_ylabel added
 David N. Bresch, david.bresch@gmail.com, 20160516, added climada_figure_scale_add
 David N. Bresch, david.bresch@gmail.com, 20160516, added option empty cbar_ylabel plus cleanup
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_entity_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_read">
<H2>climada_entity_read</H2></A>
<font color="blue">function [entity,entity_save_file] = climada_entity_read(entity_filename,hazard) </font>
 climada entity import, read assets, damagefunctions, discount and measures
 NAME:
   climada_entity_read
 PURPOSE:
   read the file with the assets, damagefunctions, measures and discount.
   Calls climada_assets_read, climada_damagefunctions_read,
    climada_measures_read and climada_discount_read.
   climada_assets_encode and climada_measures_encode is automatically invoked

   The code invokes climada_spreadsheet_read to really read the data,
   which implements .xls and .ods files

   For .xls, the sheet names are dynamically checked, for .ods, the sheet
   names are hard-wired (see code), means for .ods, all the sheets
   'assets', 'damagefunctions', 'measures' and 'discount' need to exist.

   NOTE: For backward compatibility, the code does read OLD entity files
   with a tab vulnerability (instead of damagefunctions) and VulnCurveID ...
   It renames respective fields in the resulting entity structure.

   OCTAVE: Please install the io package first, ether directly from source
   forge with: pkg install -forge io -auto
   or, (e.g. in case this fails, get the io package first from Octave
   source forge and then install from the downloaded package:
   pkg install {local_path}/io-2.2.5.tar -auto
   Note that it looks like Octave prefers .xlsx files

   next step: likely climada_ELS_calc
 CALLING SEQUENCE:
   [entity,entity_save_file] = climada_entity_read(entity_filename,hazard)
 EXAMPLE:
   entity = climada_entity_read;
 INPUTS:
   entity_filename: the filename of the Excel (or .ods) file with the assets
       If no path provided, default path ../data/entities is used
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       &ampgt promted for if not given (out of climada_assets_encode)
       ='NOENCODE' or 'noencode': do not encode assets, see climada_assets_encode
 OUTPUTS:
   entity: a structure, with
       assets: a structure, with
           .lat: the latitude of the values
           .lon: the longitude of the values
           .Value: the total insurable value
           .Deductible: the deductible
           .Cover: the cover
           .DamageFunID: the damagefunction curve ID
       damagefunctions: a structure, with
           .DamageFunID: the damagefunction curve ID
           .Intensity: the hazard intensity
           .MDD: the mean damage degree (severity of single asset damage)
           .PAA: the percentage of assets affected
       measures: a structure, with (not all just a list of the most frequent variables)
           .name
           .cost
           .hazard_intensity_impact_a
           .hazard_intensity_impact_b
           .hazard_event_set
           .MDD_impact_a
           .MDD_impact_b
           .PAA_impact_a
           .PAA_impact_b
           .assets_file
           .regional_scope: if assets tab found wich specifies the regional_scope of a measure
       discount: a structure, with
           .yield_ID: yield ID
           .year: year
           .discount_rate: discount_rate per year
   assets tab found wich specifies the regional_scope of a measure
   entity_save_file: the name the encoded entity got saved to
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090920
 Lea Mueller, 20110720
 David N. Bresch, david.bresch@gmail.com, 20130328, vuln_MDD_impact -&ampgt MDD_impact ...
 David N. Bresch, david.bresch@gmail.com, 20141029, entity_save_file added as output
 David N. Bresch, david.bresch@gmail.com, 20141121, hint to climada_damagefunction_read added
 David N. Bresch, david.bresch@gmail.com, 20141221, damagefunctions.MDR removed and NOENCODE added
 David N. Bresch, david.bresch@gmail.com, 20141230, cleanup
 David N. Bresch, david.bresch@gmail.com, 20150101, Octave compatibility (at least for .xlsx)
 David N. Bresch, david.bresch@gmail.com, 20150805, allow for name without path on input
 David N. Bresch, david.bresch@gmail.com, 20150829, check for valid/correct entity.assets.filename
 Lea Mueller, muellele@gmail.com, 20150831, assign assets.Value_unit with climada_global.Value_unit if not given
 Lea Mueller, muellele@gmail.com, 20150907, add damagefunctions check and measures check
 Lea Mueller, muellele@gmail.com, 20150908, add assets even it not encoded
 Lea Mueller, muellele@gmail.com, 20151016, delete nans if there are invalid entries
 Lea Mueller, muellele@gmail.com, 20151119, call climada_assets_read, climada_damagefunctions_read, climada_measures_read, climada_discount_read
 David N. Bresch, david.bresch@gmail.com, 20151229, old commented code deleted (finish 20151119 update)
 Lea Mueller, muellele@gmail.com, 20160523, complete extension, if missing
 David N. Bresch, david.bresch@gmail.com, 20160524, allow for entity without assets (e.g. called from nightlight entity)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_entity_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_init_vars">
<H2>climada_init_vars</H2></A>
<font color="blue">function ok=climada_init_vars(reset_flag) </font>
 init variables global
 NAME:
	climada_init_vars
 PURPOSE:
	initialize path and filenames

 CALLING SEQUENCE:
	ok=climada_init_vars(reset_flag)
 EXAMPLE:
	ok=climada_init_vars;
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   reset_flag: if set to 1, forced re-init
 OUTPUTS:
	ok: =1 if no troubles, 0 else
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120430
 David N. Bresch, david.bresch@gmail.com, 20130316, EDS-&ampgtEDS...
 David N. Bresch, david.bresch@gmail.com, 20130623, re_check_encoding
 Lea Mueller, muellele@gmail.com, 20140211, start year set to 2014
 David N. Bresch, david.bresch@gmail.com, 20141018, switch to modules instead of climada_additional
 David N. Bresch, david.bresch@gmail.com, 20141225, climada_global.coastline_file added
 David N. Bresch, david.bresch@gmail.com, 20141226, update to be in line with manual
 David N. Bresch, david.bresch@gmail.com, 20141231, octave compatibility
 David N. Bresch, david.bresch@gmail.com, 20150126, csv_delimiter depends on computer
 David N. Bresch, david.bresch@gmail.com, 20150203, climada_lonlat_cleanup
 David N. Bresch, david.bresch@gmail.com, 20150211, global_CAGR added
 Lea Mueller, muellele@gmail.com, 20150728, add project directory,i.e. now set to San Salvador
 Lea Mueller, muellele@gmail.com, 20150728, set waitbar to 0
 David N. Bresch, david.bresch@gmail.com, 20150805, project_dir NOT possible to set here, set to default data dir
 David N. Bresch, david.bresch@gmail.com, 20150805, climada_demo_gui parameters set here
 David N. Bresch, david.bresch@gmail.com, 20150807, climada_global.tc.extratropical_transition
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 Lea Mueller, muellele@gmail.com, 20150831, introduce climada_global.Value_unit
 David N. Bresch, david.bresch@gmail.com, 20150906, climada_global.font_scale
 Lea Mueller, muellele@gmail.com, 20150924, introduce climada_global.max_distance_to_hazard
 Lea Mueller, muellele@gmail.com, 20151204, introduce climada_global.markersize, for climada_color_plot and plotclr
 David N. Bresch, david.bresch@gmail.com, 20160222, entities_dir added
 Lea Mueller, muellele@gmail.com, 20160225, introduce climada_global.marker, for climada_color_plot and plotclr
 Lea Mueller, muellele@gmail.com, 20160229, introduce climada_global.admin1_plot, default is 0, do not show admin1 lines, for climada_color_plot
 David N. Bresch, david.bresch@gmail.com, 20160411, climada_global.present_reference_year = 2016
 David N. Bresch, david.bresch@gmail.com, 20160429, Value_* extended and cost_* added
 David N. Bresch, david.bresch@gmail.com, 20160429, climada_lonlat_cleanup and climada_centroids_cleanup switched off
 David N. Bresch, david.bresch@gmail.com, 20160606, max_encoding_distance_m (renamed from max_distance_to_hazard) set to 1e5, not 1e6 any more
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_init_vars.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact">
<H2>climada_measures_impact</H2></A>
<font color="blue">function measures_impact=climada_measures_impact(entity,hazard,measures_impact_reference,measures,map_risk_premium,sanity_check) </font>
 climada
 NAME:
   climada_measures_impact
 PURPOSE:
   calculate the impact of a series of measures on a given set of assets
   under a given hazard, main functions called are climada_EDS_calc and
   climada_measures_impact_discount

   next step: climada_adaptation_cost_curve or
   climada_adaptation_event_view

   Note on display units: consider using climada_digit_set to infer good
   values for measures_impact.Value_display_unit_name
   (measures_impact.Value_display_unit_fact) and
   measures_impact.cost_display_unit_name (measures_impact.cost_display_unit_fact)

   see also: climada_measures_impact_parametric

   Note: the risk premiums show need to be handled with UTMOST care, as
   they are proxies of real risk premiums. First, the total climate risk
   premium is calculated as NPV of total climate risk divided by the sum
   of all assets (that simple), hence it does not really reperesent a
   premium that one would i.e. charge to cover these risks over the course
   of a year (since it's the NPV...). The total climate risk premium
   reduction provides an upper bound of the risk premium reduction due to
   the cost-effective measures, since any further csosts, such as
   distribution, claims handling and capital costs are not considered at
   all. Second, the risk premiums mapped (if map_risk_premium=1) are calculated
   as the expected damage at each centroid divided by the asset value at
   this centroid, hence are again a CRUDE PROXY. Again, the difference of
   the fgu and net values is more telling than the absolute numbers.
 CALLING SEQUENCE:
   measures_impact=climada_measures_impact(entity,hazard,measures_impact_reference,measures)
 EXAMPLE:
   measures_impact=climada_measures_impact % all prompted for
   hazard_set_file='...\climada\data\hazards\TCNA_A_Probabilistic.mat';
   measures_impact=climada_measures_impact(climada_entity_read('',hazard_set_file),hazard_set_file,'no')
   measures_impact=climada_measures_impact('','','','',1) % all interactive, show risk premium map
 INPUTS:
   entity: a read and encoded assets and damagefunctions file, see climada_assets_encode(climada_assets_read)
       &ampgt promted for if not given
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   measures_impact_reference: reference measures (e.g. portfolio today and
       measures today). Used to properly calculate the net present values
       of future impacts
       set to 'no' if you would not like to be asked for a reference
   measures: either a struct containing the measures or a measures set file (.mat with a struct)
       see climada_measures_read.
       A bit complex:
       If measures is empty (not provided), it is taken from entity.measures (in case entity
           contains measures). If entity does not contain measures, user gets prompted for.
       If user provides measures, these measures are used
       If user set measures to 'ASK', he gets prompted for and these are used
   map_risk_premium: whether we show a plot (=1) of risk premium at each
       centroid using a contour plot on a map, with cost-effective
       measures and without any measures(fgu). Default=0 
       Please note that this risk premium is a proxy for a real premium,
       as it just consistes of the expected damage at each centroid.
 OUTPUTS:
   measures_impact: a structure with
       EDS(measure_i): the event damage set for each measure, last one EDS(end) for no measures
       ED(measure_i): the annual expected damage to the assets under measure_i,
           last one ED(end) for no measures
       benefit(measure_i): the benefit of measure_i
       cb_ratio(measure_i): the cost/benefit ratio of measure_i
       measures: just a copy of measures, so we have all we need together
       title_str: a meaningful title, of the format: measures @ assets | hazard
       NOTE: currently measures_impact is also stored (with a lengthy filename)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091228
 David N. Bresch, david.bresch@gmail.com, 20130316, ELS-&ampgtEDS...
 David N. Bresch, david.bresch@gmail.com, 20130328, vuln_MDD_impact -&ampgt MDD_impact...
 David N. Bresch, david.bresch@gmail.com, 20130623, hazard set switch added
 David N. Bresch, david.bresch@gmail.com, 20140509, non-linear damage time dependency implemented
 David N. Bresch, david.bresch@gmail.com, 20140509, risk premium calc added
 David N. Bresch, david.bresch@gmail.com, 20140510, risk premium map added
 David N. Bresch, david.bresch@gmail.com, 20141220, re-encoding check added
 David N. Bresch, david.bresch@gmail.com, 20150101, cleanup
 Gilles Stassen, gillesstassen@hotmail.com, 20150626, if exist(hazard_file,'var') -&ampgt exist('hazard_file','var')
 Lea Mueller, muellele@gmail.com, 20150831, introduce measures_impact.Value_unit
 Lea Mueller, muellele@gmail.com, 20150902, rename to hazard_intensity_impact_b from hazard_intensity_impact
 Lea Mueller, muellele@gmail.com, 20150902, call climada_measures_impact_discount in an separate function
 David N. Bresch, david.bresch@gmail.com, 20150907, hazard_intensity_impact_a and hazard_intensity_impact_b properly implemented
 Lea Mueller, muellele@gmail.com, 20150907, add variable sanity_check to perform a safety check within climada_EDS_calc, add climada_measures_check
 Lea Mueller, muellele@gmail.com, 20150908, switch assets if needed (defined in measures.assets_file)
 Lea Mueller, muellele@gmail.com, 20150915, add regional scope of measures
 Lea Mueller, muellele@gmail.com, 20150921, add measures check to ensure size of regional_scope is aligned with number of assets
 Lea Mueller, muellele@gmail.com, 20150921, save entity as .mat if assets are switched (in entity.assets.filename)
 Lea Mueller, muellele@gmail.com, 20151127, add measures_impact.scenario
 Lea Mueller, muellele@gmail.com, 20151130, invoke climada_hazard_load and climada_entity_load
 David N. Bresch, david.bresch@gmail.com, 20160429, automatic determination of display units
 David N. Bresch, david.bresch@gmail.com, 20160429, title_str without measures name
 David N. Bresch, david.bresch@gmail.com, 20160606, display units synchronized if same unit_name
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_measures_impact.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_parametric">
<H2>climada_measures_impact_parametric</H2></A>
<font color="blue">function measures_impact=climada_measures_impact_parametric(measures_impact,index_def) </font>
 climada template
 MODULE:
   core
 NAME:
   climada_measures_impact_parametric
 PURPOSE:
   Add parametric insurance to measures. Define index payout (attachement,
   cover or exit, tick value) and the centroid_ID at which the hazard is
   being evaluated.

   previous call: climada_measures_impact
   next call: climada_adaptation_cost_curve

   TEST settings:
   climada_demo_step_by_step % run this to get a reasonable measures_impact structure
   index_def.attachement=40;index_def.cover=30;index_def.tick_value=1.0000e+09;
   index_def.centroid_index=50;
   measures_impact=climada_measures_impact_parametric(measures_impact,index_def)
   climada_adaptation_event_view(measures_impact,[10,150,1500])
 CALLING SEQUENCE:
   measures_impact=climada_measures_impact_parametric(measures_impact,index_def)
 EXAMPLE:
   measures_impact=climada_measures_impact_parametric(climada_measures_impact)
 INPUTS:
   measures_impact: the output from climada_measures_impact
   index_def: the parametric index definition, with fields (in the
       metric of the pertinent hazard intensity)
       attachement: the attachement point
       cover: the cover (if missing, calculated from exit)
       exit: the exit (if missing, calculated from cover)
       tick_value: the payout per unit, default=1 (in the monetary unit)
       centroid_ID: the centroid ID (in the hazard set) at which the index
           insurance is evaluated or
       centroid_index: the index (in the hazard set) at which the index
           insurance is evaluated. If both centroid_ID and centroid_index
           are passed, centroid_index is used
       markup: the multiplier to get to cost, default=2
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20151021, intial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_measures_impact_parametric.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_event_damage_ens">
<H2>climada_tc_event_damage_ens</H2></A>
<font color="blue">function [damage,track_filename,err_msg]=climada_tc_event_damage_ens(UNISYS_regi,UNISYS_year,UNISYS_name,n_tracks,call_from_GUI) </font>
 MODULE:
   advanced
 NAME:
   climada_tc_event_damage_ens
 PURPOSE:
   Given a single track file, calculate the damage for all countries
   posibbly hit (i.e. at least one node within country boders)

   Plus generate ensemble 'forecast' damage

   Fetches data from: weather.unisys.com/hurricane, but since the format
   and layout of the webpage changed, it only works back to about 2006...
   earier years will,likely lead to errors. In such cases, retrieve the TC
   track file manually and run the code by passing the track file in the
   first variable (UNISYS_regi)

   See also climada_tc_event_damage_ens_gui
 CALLING SEQUENCE:
   [damage,track_filename]=climada_tc_event_damage_ens(UNISYS_regi,UNISYS_year,UNISYS_name,n_tracks,call_from_GUI)
 EXAMPLE:
   damage=climada_tc_event_damage_ens('w_pacific','2015','KOPPU',5)
   [damage,track_filename]=climada_tc_event_damage_ens('','NONE','NONE',5) % prompt for track file
 INPUTS:
   UNISYS_regi: the UNISYS region, i.e. 'atlantic','e_pacific','w_pacific'
       's_pacific','s_indian' or 'n_indian'
       SPECIAL: if a TC track filename (with path) is passed instead of a region
       and UNISYS_year and UNISYS_name are both set to 'NONE', the track file
       is used. This way, any TC track file can be passed as input.
   UNISYS_year: the year yyyy (as string). Note that years before 2006
       likely do not work properly (since UNISYS changed the layout of
       their webpage and the code reads the html source to figure the
       event names...). If set to 'NONE' together with UNISYS_name, the
       user gets prompted for the TC track file
   UNISYS_name: the name of the event (without Hurricane-1 ..., usually uppercase).
       If set to 'NONE' together with UNISYS_year, the user gets prompted
       for the TC track file.
   &ampgt   if all three parameters above are empty: Select the region and event
       from selection lists, the single TC track file is downloaded from
       UNISYS and processed
   n_tracks: number of tracks (incl original one), default=100
   call_from_GUI: switch to direct to the correct axes
       if empty, not called from GUI, otherwise contains the axes handles
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   damage: the vector with the calculated damages, damage(1) is the one
       for the reported track, all following ones for ensemble members
   track_filename: the TC track filename with path
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20151009, initial
 David N. Bresch, david.bresch@gmail.com, 20151018, automatic country detection
 David N. Bresch, david.bresch@gmail.com, 20151019, converted into a function, see also climada_tc_event_damage_ens_gui
 David N. Bresch, david.bresch@gmail.com, 20151021, special case for no web access added
amage=[];track_filename='';err_msg=''; % init output
 init global variables
lobal climada_global
f ~climada_init_vars,return;end
 poor man's version to check arguments
f ~exist('UNISYS_regi','var'),UNISYS_regi='';end
f ~exist('UNISYS_year','var'),UNISYS_year='';end
f ~exist('UNISYS_name','var'),UNISYS_name='';end
f ~exist('n_tracks','var'),   n_tracks   =100;end % number of tracks (incl original one)
f ~exist('call_from_GUI','var'),call_from_GUI=[];end
 PARAMETERS

 for experimenting, you might set parameters here (otherwise asked at first call)
 track_filename = [climada_global.data_dir filesep 'tc_tracks' filesep '20071116_SIDR_track.dat'];
 country_name='Bangladesh';

ontSize=12; % 18 for plots for e.g. pptx

 UNISYS regions (hard-wired)
NISYS_regis{1}='atlantic';
NISYS_regis{2}='e_pacific';
NISYS_regis{3}='w_pacific';
NISYS_regis{4}='s_pacific';
NISYS_regis{5}='s_indian';
NISYS_regis{6}='n_indian';
f strcmpi(UNISYS_name,'nowebaccess&ampgtpresscalculatebutton')
   % special case to select local file
   UNISYS_name='NONE';
   UNISYS_year='NONE';
nd
f isempty(UNISYS_name)
   
   if isempty(UNISYS_regi)
       % prompt for the region
       [selection,ok] = listdlg('PromptString','Select region:',...
           'ListString',UNISYS_regis,'SelectionMode','SINGLE');
       pause(0.1)
       if ok
           UNISYS_regi=UNISYS_regis{selection};
       end
   end % isempty(UNISYS_regi)
   
   if isempty(UNISYS_year)
       % UNISYS year (usually the actual one)
       UNISYS_year=datestr(today,'yyyy'); % e.g. '2015'
   end
   
   % fetch the index of all events
   url_str=['http://weather.unisys.com/hurricane/' UNISYS_regi '/' UNISYS_year '/index.php'];
   fprintf('fetching %s\n',url_str);
   [index_str,STATUS] = urlread(url_str);
   if STATUS
       % kind of parse index_str to get names
       UNISYS_names={};
       for event_i=100:-1:1
           for black_red=1:2
               if black_red==1
                   check_str=['&amplttr&ampgt&amplttd width=&quot20&quot align=&quotright&quot style=&quotcolor:black;&quot&ampgt' num2str(event_i) '&amplt/td&ampgt&amplttd width=&quot250&quot style=&quotcolor:black;&quot&ampgt'];
               else
                   check_str=['&amplttr&ampgt&amplttd width=&quot20&quot align=&quotright&quot style=&quotcolor:red;&quot&ampgt' num2str(event_i) '&amplt/td&ampgt&amplttd width=&quot250&quot style=&quotcolor:red;&quot&ampgt'];
               end
               
               pos=strfind(index_str,check_str);
               if pos&ampgt0
                   UNISYS_names{end+1}=index_str(pos+length(check_str):pos+length(check_str)+25);
               end
           end % black_red
       end % event_i
       
       [selection,ok] = listdlg('PromptString','Select event:',...
           'ListString',UNISYS_names,'SelectionMode','SINGLE');
       pause(0.1)
       if ok
           UNISYS_name=UNISYS_names{selection};
           % get rid of all clutter
           UNISYS_name=strrep(UNISYS_name,'Super ','');
           UNISYS_name=strrep(UNISYS_name,'Tropical Depression','');
           UNISYS_name=strrep(UNISYS_name,'Tropical Storm','');
           UNISYS_name=strrep(UNISYS_name,'Typhoon-1','');
           UNISYS_name=strrep(UNISYS_name,'Typhoon-2','');
           UNISYS_name=strrep(UNISYS_name,'Typhoon-3','');
           UNISYS_name=strrep(UNISYS_name,'Typhoon-4','');
           UNISYS_name=strrep(UNISYS_name,'Typhoon-5','');
           UNISYS_name=strrep(UNISYS_name,'Hurricane-1','');
           UNISYS_name=strrep(UNISYS_name,'Hurricane-2','');
           UNISYS_name=strrep(UNISYS_name,'Hurricane-3','');
           UNISYS_name=strrep(UNISYS_name,'Hurricane-4','');
           UNISYS_name=strrep(UNISYS_name,'Hurricane-5','');
           UNISYS_name=strrep(UNISYS_name,'Cyclone-1','');
           UNISYS_name=strrep(UNISYS_name,'Cyclone-2','');
           UNISYS_name=strrep(UNISYS_name,'Cyclone-3','');
           UNISYS_name=strrep(UNISYS_name,'Cyclone-4','');
           UNISYS_name=strrep(UNISYS_name,'Cyclone-5','');
           UNISYS_name=strrep(UNISYS_name,' ','');
           UNISYS_name=strrep(UNISYS_name,' ','');
       else
           return
       end
   else
       UNISYS_name='NONE';
   end
nd % isempty(UNISYS_name)
f strcmp(UNISYS_name,'NONE')
   track_filename=''; % force prompting for track file
   if exist(UNISYS_regi,'file'),track_filename=UNISYS_regi;end
lse
   % fetch the tc track data from the internet
   url_str=['http://weather.unisys.com/hurricane/' UNISYS_regi '/' UNISYS_year '/' UNISYS_name '/track.dat'];
   fprintf('fetching %s\n',url_str);
   track_data_str = urlread(url_str);
   track_filename=[climada_global.data_dir filesep 'tc_tracks' filesep  UNISYS_regi '_' UNISYS_year '_' UNISYS_name '.dat'];
   fprintf('saving as %s\n',track_filename);
   fid=fopen(track_filename,'w');
   % write to single track file
   fprintf(fid,'%s\r\n',track_data_str);
   fclose(fid);
nd
 get TC track (prompting for file to be selected)
tc_track,track_filename]=climada_tc_read_unisys_track(track_filename);
 resolve issue with +/-180 at dateline
c_track.lon=climada_dateline_resolve(tc_track.lon);
 automatically detec country/ies
ountry_list={};
hapes=climada_shaperead(climada_global.map_border_file); % get country shapes
or shape_i = 1:length(shapes)
   in = inpolygon(tc_track.lon,tc_track.lat,shapes(shape_i).X,shapes(shape_i).Y);
   if sum(in)&ampgt0
       country_list{end+1}=shapes(shape_i).NAME;
   end
nd % shape_i
f isempty(country_list) % prompt for country, as no direct hit
   country_list{1}=climada_country_name('SINGLE'); % obtain country
nd
or country_i=1:length(country_list)
   %for country_i=1:1
   
   country_name=char(country_list{country_i});
   
   fprintf('*** processing %s:\n',country_name);
   
   if isempty(country_name) % usually not the case any more, but left in, in case one would like to use this
       [country_name,country_ISO3,~]=climada_country_name('SINGLE'); % obtain country
   else
       [country_name,country_ISO3,~]=climada_country_name(country_name); % just get ISO3
   end
   country_name=char(country_name);
   country_ISO3=char(country_ISO3);
   
   tc_tracks=climada_tc_random_walk(tc_track,n_tracks-1,0.1,pi/30); % /15
   
   % get entity and centroids
   entity_filename=[country_ISO3 '_' strrep(country_name,' ','') '_entity'];
   entity_file=[climada_global.entities_dir filesep entity_filename '.mat'];
   centroids_file=[climada_global.centroids_dir filesep country_ISO3 '_' strrep(country_name,' ','') '_centroids.mat'];
   if exist(entity_file,'file')
       entity=climada_entity_load(entity_file);
       if exist(centroids_file,'file')
           centroids=climada_centroids_load(centroids_file);
           %entity=climada_assets_encode(entity,centroids);
       else
           % use geo locations of entity.assets
           centroids.lon=entity.assets.lon;
           centroids.lat=entity.assets.lat;
           centroids.centroid_ID=1:length(centroids.lon);
       end % exist(centroids_file,'file')
   else
       % try to create the entity
       if exist('climada_create_GDP_entity','file')
           % invoke the country_risk module to generate centroids and entity
           fprintf('*** creating %s (takes a moment)\n\n',entity_filename)
           if ~isempty(call_from_GUI)
               cla(call_from_GUI.axes_left)
               axes(call_from_GUI.axes_left);
               text(0.1,0.5,'creating assets (takes a moment) ...','FontSize',FontSize);drawnow
           end
           [centroids,entity] = climada_create_GDP_entity(country_name,[],0,1);
           save(centroids_file,'centroids');
           save(entity_file,'entity');
           climada_entity_value_GDP_adjust(entity_file); % assets based on GDP
           entity=climada_entity_load(entity_file);
           fprintf('%s created\n\n',entity_filename)
       else
           fprintf(['%s not found. Please download ' ...
               '&amplta href=&quothttps://github.com/davidnbresch/climada_module_country_risk&quot&ampgt' ...
               'climada_module_country_risk&amplt/a&ampgt from Github in order to create it.\n'],entity_filename)
           err_msg=sprintf('Please create %s entity first, see command line',country_name);
           return
       end
   end % exist(entity_file,'file')
   
   % resolve issue with +/-180 at dateline
   entity.assets.lon=climada_dateline_resolve(entity.assets.lon);
   centroids.lon=climada_dateline_resolve(centroids.lon);
   
   if isempty(call_from_GUI)
       figure('Name',['TC ensemble ' country_name],'Position',[199 55 1076 618],'Color',[1 1 1]);
       subplot(1,2,1)
   else
       cla(call_from_GUI.axes_left)
       axes(call_from_GUI.axes_left);
   end
   
   climada_entity_plot(entity,4)
   % plot(tc_track.lon,tc_track.lat,'-r');axis equal; hold on
   % climada_plot_world_borders(1,country_name,'',1)
   plot(tc_track.lon,tc_track.lat,'-r')
   plot(tc_track.lon(logical(tc_track.forecast)),tc_track.lat(logical(tc_track.forecast)),'xr')
   
   for track_i=1:length(tc_tracks),plot(tc_tracks(track_i).lon,tc_tracks(track_i).lat,'-b');end
   plot(tc_tracks(1).lon,tc_tracks(1).lat,'-r','LineWidth',2); % orig track
   axis off
   xlabel('red crosses: forecast timesteps, blue:ensemble members','FontSize',8);
   title(country_name,'FontSize',FontSize,'FontWeight','normal');drawnow
   
   if isempty(call_from_GUI)
       subplot(1,2,2)
   else
       cla(call_from_GUI.axes_right)
       axes(call_from_GUI.axes_right);
   end
   damage=zeros(1,length(tc_tracks)); % allocate
   n_tracks=length(tc_tracks);
   for track_i=1:n_tracks
       hazard=climada_tc_hazard_set(tc_tracks(track_i),'NOSAVE',centroids);
       hazard.frequency=1;
       EDS(track_i)=climada_EDS_calc(entity,hazard);
       damage(track_i)=EDS(track_i).damage;
       calc_sec=str2double(strtok(strrep(EDS(track_i).comment,'calculation took ',''),'sec'));
       cla;text(0.1,0.5,sprintf('%i seconds calculation remaining (%i tracks)',...
           ceil((n_tracks-track_i)*calc_sec),n_tracks-track_i),'FontSize',FontSize);drawnow
       %fprintf('%i seconds calculation remaining\n',ceil((length(tc_tracks)-track_i)*calc_sec));
   end % track_i
   
   cla(call_from_GUI.axes_right) % clear
   hist(damage); % plot
   [counts,~]=hist(damage); % get info
   set(gca,'FontSize',FontSize),xlabel('damage [USD]','FontSize',FontSize),ylabel('event count','FontSize',FontSize)
   hold on;plot(damage(1),0,'xr');
   ddamage=(max(damage)-min(damage))/(2*length(counts));
   text(damage(1)+ddamage,1,'damage','Rotation',90,'Color','red','FontSize',FontSize);
   [~,track_i] = max(damage);
   tc_track_name=lower(tc_track.name);
   title([[upper(tc_track_name(1)) tc_track_name(2:end)]  ' @ ' country_name],'FontSize',FontSize,'FontWeight','normal');
   drawnow
   %plot(damage(track_i),0,'xb');
   %text(damage(track_i),0,'max ensemble damage','Rotation',90);
   if isempty(call_from_GUI)
       subplot(1,2,1);hold on;
   else
       axes(call_from_GUI.axes_left);
       hold on
   end
   plot(tc_tracks(track_i).lon,tc_tracks(track_i).lat,'-b','LineWidth',2); % max damage track
   
   call_from_GUI=[]; % second plot in new figure
   
nd % country_i
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_tc_event_damage_ens.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_event_damage_ens_gui">
<H2>climada_tc_event_damage_ens_gui</H2></A>
<font color="blue">function varargout = climada_tc_event_damage_ens_gui(varargin) </font>
 CLIMADA_TC_EVENT_DAMAGE_ENS_GUI MATLAB code for climada_tc_event_damage_ens_gui.fig
      CLIMADA_TC_EVENT_DAMAGE_ENS_GUI, by itself, creates a new CLIMADA_TC_EVENT_DAMAGE_ENS_GUI or raises the existing
      singleton*.

      H = CLIMADA_TC_EVENT_DAMAGE_ENS_GUI returns the handle to a new CLIMADA_TC_EVENT_DAMAGE_ENS_GUI or the handle to
      the existing singleton*.

      CLIMADA_TC_EVENT_DAMAGE_ENS_GUI('CALLBACK',hObject,eventData,handles,...) calls the local
      function named CALLBACK in CLIMADA_TC_EVENT_DAMAGE_ENS_GUI.M with the given input arguments.

      CLIMADA_TC_EVENT_DAMAGE_ENS_GUI('Property','Value',...) creates a new CLIMADA_TC_EVENT_DAMAGE_ENS_GUI or raises the
      existing singleton*.  Starting from the left, property value pairs are
      applied to the GUI before climada_tc_event_damage_ens_gui_OpeningFcn gets called.  An
      unrecognized property name or invalid value makes property application
      stop.  All inputs are passed to climada_tc_event_damage_ens_gui_OpeningFcn via varargin.

      *See GUI Options on GUIDE's Tools menu.  Choose &quotGUI allows only one
      instance to run (singleton)&quot.

 See also: GUIDE, GUIDATA, GUIHANDLES
 Edit the above text to modify the response to help climada_tc_event_damage_ens_gui
 Last Modified by GUIDE v2.5 19-Oct-2015 18:56:29
 Begin initialization code - DO NOT EDIT
ui_Singleton = 1;
ui_State = struct('gui_Name',       mfilename, ...
                  'gui_Singleton',  gui_Singleton, ...
                  'gui_OpeningFcn', @climada_tc_event_damage_ens_gui_OpeningFcn, ...
                  'gui_OutputFcn',  @climada_tc_event_damage_ens_gui_OutputFcn, ...
                  'gui_LayoutFcn',  [] , ...
                  'gui_Callback',   []);
f nargin &amp&amp ischar(varargin{1})
   gui_State.gui_Callback = str2func(varargin{1});
nd
f nargout
   [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
lse
   gui_mainfcn(gui_State, varargin{:});
nd
 End initialization code - DO NOT EDIT
 --- Executes just before climada_tc_event_damage_ens_gui is made visible.
<font color="blue">function climada_tc_event_damage_ens_gui_OpeningFcn(hObject, eventdata, handles, varargin) </font>
 This function has no output args, see OutputFcn.
 hObject    handle to figure
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 varargin   command line arguments to climada_tc_event_damage_ens_gui (see VARARGIN)
 Choose default command line output for climada_tc_event_damage_ens_gui
andles.output = hObject;
 Update handles structure
uidata(hObject, handles);
 UIWAIT makes climada_tc_event_damage_ens_gui wait for user response (see UIRESUME)
 uiwait(handles.figure1);
et_UNISYS_name_list(hObject,eventdata,handles);
 --- Outputs from this function are returned to the command line.
<font color="blue">function varargout = climada_tc_event_damage_ens_gui_OutputFcn(hObject, eventdata, handles)  </font>
 varargout  cell array for returning output args (see VARARGOUT);
 hObject    handle to figure
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Get default command line output from handles structure
arargout{1} = handles.output;
 --- Executes on selection change in popupmenu_region.
<font color="blue">function popupmenu_region_Callback(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_region (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: contents = cellstr(get(hObject,'String')) returns popupmenu_region contents as cell array
        contents{get(hObject,'Value')} returns selected item from popupmenu_region
et_UNISYS_name_list(hObject,eventdata,handles);
et(handles.pushbutton_calculate,'Enable','off');
et(handles.pushbutton_calculate,'BackgroundColor','red'); % make inactive
et(handles.popupmenu_year,'Enable','on'); % first a name region to be selected
 --- Executes during object creation, after setting all properties.
<font color="blue">function popupmenu_region_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_region (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: popupmenu controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 UNISYS regions
lobal climada_tc_event_damage_ens_vars
limada_tc_event_damage_ens_vars.UNISYS_regis{1}='atlantic';
limada_tc_event_damage_ens_vars.UNISYS_regis{2}='e_pacific';
limada_tc_event_damage_ens_vars.UNISYS_regis{3}='w_pacific';
limada_tc_event_damage_ens_vars.UNISYS_regis{4}='s_pacific';
limada_tc_event_damage_ens_vars.UNISYS_regis{5}='s_indian';
limada_tc_event_damage_ens_vars.UNISYS_regis{6}='n_indian';
et(hObject,'String',climada_tc_event_damage_ens_vars.UNISYS_regis);
fprintf('popupmenu_region_CreateFcn\n');
 --- Executes on selection change in popupmenu_year.
<font color="blue">function popupmenu_year_Callback(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_year (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: contents = cellstr(get(hObject,'String')) returns popupmenu_year contents as cell array
        contents{get(hObject,'Value')} returns selected item from popupmenu_year
et_UNISYS_name_list(hObject,eventdata,handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function popupmenu_year_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_year (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: popupmenu controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
lobal climada_tc_event_damage_ens_vars
limada_tc_event_damage_ens_vars.UNISYS_years={}; % reset
limada_tc_event_damage_ens_vars.UNISYS_years{1}=datestr(today,'yyyy');
or year_i=1:10
   climada_tc_event_damage_ens_vars.UNISYS_years{end+1}=...
       sprintf('%i',str2double(climada_tc_event_damage_ens_vars.UNISYS_years{year_i})-1);
nd
et(hObject,'String',climada_tc_event_damage_ens_vars.UNISYS_years);
et(hObject,'Enable','off'); % first a name region to be selected
 --- Executes on selection change in popupmenu_name.
<font color="blue">function popupmenu_name_Callback(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_name (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: contents = cellstr(get(hObject,'String')) returns popupmenu_name contents as cell array
        contents{get(hObject,'Value')} returns selected item from popupmenu_name
et(handles.pushbutton_calculate,'Enable','on');
et(handles.pushbutton_calculate,'BackgroundColor','green'); % make inactive
 --- Executes during object creation, after setting all properties.
<font color="blue">function popupmenu_name_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_name (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: popupmenu controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_ens_n_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_ens_n (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_ens_n as text
        str2double(get(hObject,'String')) returns contents of edit_ens_n as a double
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_ens_n_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_ens_n (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 --- Executes on button press in pushbutton_calculate.
<font color="blue">function pushbutton_calculate_Callback(hObject, eventdata, handles) </font>
 hObject    handle to pushbutton_calculate (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
lobal climada_tc_event_damage_ens_vars
NISYS_regi=climada_tc_event_damage_ens_vars.UNISYS_regis{get(handles.popupmenu_region,'Value')};
NISYS_year=climada_tc_event_damage_ens_vars.UNISYS_years{get(handles.popupmenu_year,'Value')};
NISYS_name=climada_tc_event_damage_ens_vars.UNISYS_names{get(handles.popupmenu_name,'Value')};
 get rid of all clutter
NISYS_name=strrep(UNISYS_name,'Super ','');
NISYS_name=strrep(UNISYS_name,'Tropical Depression','');
NISYS_name=strrep(UNISYS_name,'Tropical Storm','');
NISYS_name=strrep(UNISYS_name,'Typhoon-1','');
NISYS_name=strrep(UNISYS_name,'Typhoon-2','');
NISYS_name=strrep(UNISYS_name,'Typhoon-3','');
NISYS_name=strrep(UNISYS_name,'Typhoon-4','');
NISYS_name=strrep(UNISYS_name,'Typhoon-5','');
NISYS_name=strrep(UNISYS_name,'Hurricane-1','');
NISYS_name=strrep(UNISYS_name,'Hurricane-2','');
NISYS_name=strrep(UNISYS_name,'Hurricane-3','');
NISYS_name=strrep(UNISYS_name,'Hurricane-4','');
NISYS_name=strrep(UNISYS_name,'Hurricane-5','');
NISYS_name=strrep(UNISYS_name,'Cyclone-1','');
NISYS_name=strrep(UNISYS_name,'Cyclone-2','');
NISYS_name=strrep(UNISYS_name,'Cyclone-3','');
NISYS_name=strrep(UNISYS_name,'Cyclone-4','');
NISYS_name=strrep(UNISYS_name,'Cyclone-5','');
NISYS_name=strrep(UNISYS_name,' ','');
NISYS_name=strrep(UNISYS_name,' ','');
ns_n=str2double(get(handles.edit_ens_n,'String'));
printf('%s %s %s - %i\n',UNISYS_regi,UNISYS_year,UNISYS_name,ens_n);
all_from_GUI.axes_left=handles.axes_left;
all_from_GUI.axes_right=handles.axes_right;
damages,~,err_msg]=climada_tc_event_damage_ens(UNISYS_regi,UNISYS_year,UNISYS_name,ens_n,call_from_GUI);
f isempty(err_msg)  &amp&amp ~isempty(damages)
   fprintf('original track: %g [USD], min/max: %g/%g\n',damages(1),min(damages),max(damages));
lse
   fprintf('%s\n',err_msg);
nd % isempty(err_msg)
<font color="blue">function get_UNISYS_name_list(hObject,eventdata,handles) </font>
 get the event names
lobal climada_tc_event_damage_ens_vars
NISYS_REGI=climada_tc_event_damage_ens_vars.UNISYS_regis{get(handles.popupmenu_region,'Value')};
NISYS_YEAR=climada_tc_event_damage_ens_vars.UNISYS_years{get(handles.popupmenu_year,'Value')};
 fetch the index of all events
rl_str=['http://weather.unisys.com/hurricane/' UNISYS_REGI '/' UNISYS_YEAR '/index.php'];
printf('fetching %s\n',url_str);
index_str,STATUS] = urlread(url_str);
f STATUS
   % kind of parse index_str to get names
   UNISYS_names={};
   for event_i=100:-1:1
       for black_red=1:2
           if black_red==1
               check_str=['&amplttr&ampgt&amplttd width=&quot20&quot align=&quotright&quot style=&quotcolor:black;&quot&ampgt' num2str(event_i) '&amplt/td&ampgt&amplttd width=&quot250&quot style=&quotcolor:black;&quot&ampgt'];
           else
               check_str=['&amplttr&ampgt&amplttd width=&quot20&quot align=&quotright&quot style=&quotcolor:red;&quot&ampgt' num2str(event_i) '&amplt/td&ampgt&amplttd width=&quot250&quot style=&quotcolor:red;&quot&ampgt'];
           end
           pos=strfind(index_str,check_str);
           if pos&ampgt0
               UNISYS_names{end+1}=index_str(pos+length(check_str):pos+length(check_str)+25);
           end
       end % black_red
   end % event_i
   set(handles.pushbutton_calculate,'Enable','off'); % first a name needs to be selected
   set(handles.pushbutton_calculate,'BackgroundColor','red'); % make inactive
lse
   UNISYS_names{1}='no web access &ampgt press Calculate button';
   set(handles.pushbutton_calculate,'Enable','on');
   set(handles.pushbutton_calculate,'BackgroundColor','green'); % make inactive
nd
limada_tc_event_damage_ens_vars.UNISYS_names=UNISYS_names;
et(handles.popupmenu_name,'String',climada_tc_event_damage_ens_vars.UNISYS_names);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_tc_event_damage_ens_gui.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hazard_set">
<H2>climada_tc_hazard_set</H2></A>
<font color="blue">function hazard = climada_tc_hazard_set(tc_track,hazard_set_file,centroids) </font>
 climada TC hazard event set generate
 NAME:
   climada_tr_hazard_set
 PURPOSE:
   generate a tc (tropical cyclone) hazard event set

   If centroids.distance2coast_km exists, the hazard intensity is only
   calculated in the coastal_range_km (usually 200km, see PARAMETERS in
   climada_tc_windfield) - this speeds up calculation for large countries
   considerably.

   Special: the hazard event set is stored every 100 tracks in order to
   allow for interruption of the hazard set generation. Just re-start the
   calculation by calling climada_tr_hazard_set with exactly the same
   input parameters (the last track calculated is stored in hazard.track_i
   and the field track_i is removed in the final complete hazard event set).  
   Therefore, if you get errors such as 
       Subscripted assignment dimension mismatch.
       Error in climada_tr_hazard_set (line 270) % ... or nearby
       hazard.intensity(track_i,:)     = res.gust;
   It is VERY likely that you changed something between subsequent calls
   (i.e. different centroids). Just delete the hazard set .mat file and run
   climada_tr_hazard_set again.

   See climada_tc_hazard_set_slow in the tropical cyclone module 
   (https://github.com/davidnbresch/climada_module_tropical_cyclone) 
   for the old slow version (for backward compatibility).

   previous: likely climada_random_walk
   next: diverse
 CALLING SEQUENCE:
   res=climada_tr_hazard_set(tc_track,hazard_set_file,centroids)
 EXAMPLE:
   tc_track=climada_tc_track_load('TEST_tracks.atl_hist');
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   %centroids=climada_entity_load('USA_UnitedStatesFlorida'); % works, too
   hazard=climada_tc_hazard_set(tc_track,'_TC_TEST_PARFOR',centroids);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   tc_track: a TC track structure, or a filename of a saved one
       details: see e.g. climada_tc_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name (and path, optional) of the hazard set file
       If no path provided, default path ../data/hazards is used (and name
       can be without extension .mat). If ='NOSAVE', the hazard set is not
       saved (but returned as output)
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           lon(1,:): the longitudes
           lat(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a .mat-file which contains a centroids struct (saved by
       climada_centroids_read) or the filename of an Excel file (the original
       input to climada_centroids_read) which holds the centroids, in
       which case climada_centroids_read is called.
       OR: an entity, in which case the entity.assets.lat and
       entity.assets.lon are used as centroids.
       &ampgt promted for .mat or .xls filename if not given
       NOTE: if you then select Cancel, a regular default grid is used, see hard-wired definition in code
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       intensity(event_i,centroid_i), sparse: the hazard intensity of 
           event_i at centroid_i
       frequency(event_i): the frequency of each event
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20090729
 david.bresch@gmail.com, 20130506, centroids filename handling improved
 david.bresch@gmail.com, 20140421, waitbar with secs
 david.bresch@gmail.com, 20141226, optional fields in centroids added
 david.bresch@gmail.com, 20150103, equal_timestep (much) improved
 muelleleh@gmail.com, 20150420, include tc category into hazard structure
 david.bresch@gmail.com, 20150804, allow for filename without path for hazard set name on input
 david.bresch@gmail.com, 20150819, climada_global.centroids_dir
 david.bresch@gmail.com, 20150824, removed 'TCNA' from hazard.comment
 david.bresch@gmail.com, 20150906, note on a frequent issue added to header
 david.bresch@gmail.com, 20151008, NOSAVE option added
 muelleleh@gmail.com, 20151127, add hazard.scenario, default is 'no climate change'
 david.bresch@gmail.com, 20160514, -v7.3 in save added
 david.bresch@gmail.com, 20160529, fast parfor version, about twenty times faster
 david.bresch@gmail.com, 20160603, header: comment added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_tc_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hazard_set_exercise">
<H2>climada_tc_hazard_set_exercise</H2></A>
<font color="blue">function hazard = climada_tc_hazard_set_exercise(tc_track, hazard_set_file, centroids) </font>
 climada TC hazard event set generate
 NAME:
   climada_tc_hazard_set_exercise
 PURPOSE:
   generate a tc (tropical cyclone) hazard event set

   previous: likely climada_random_walk
   next: diverse

   NOTE: code for demonstration purposes (e.g. lecture), see 
   climada_tc_windfield for the operational code

 CALLING SEQUENCE:
   res=climada_tc_hazard_set_exercise(tc_track,hazard_set_file)
 EXAMPLE:
   res=climada_tc_hazard_set_exercise(tc_track)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   tc_track: a TC track structure, or a filename of a saved one
       details: see e.g. climada_tc_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes   
           Latitude(1,:): the latitudes   
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a file which contains the struct (saved after climada_centroids_read)
       if you select Cancel, a regular default grid is used, see hard-wired definition in code
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090729
 David N. Bresch, david.bresch@gmail.com, 20120404 copy from climada_tc_hazard_set
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_tc_hazard_set_exercise.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_random_walk">
<H2>climada_tc_random_walk</H2></A>
<font color="blue">function tc_track_out=climada_tc_random_walk(tc_track,ens_size,ens_amp,Maxangle,check_plot) </font>
 TC event set random walk probabilistic
 NAME:
   climada_tc_random_walk
 PURPOSE:
   given a tc_track structure, create ens_size varied derived tracks based on
   directed random walk

   NOTE see PARAMETER section to change parameters
   (e.g. ens_amp0,ens_amp,Maxangle)

   previous step: see climada_tc_read_unisys_database
   next step: see climada_tc_hazard_set
 CALLING SEQUENCE:
   tc_track=climada_tc_random_walk(tc_track,ens_size);
 EXAMPLE:
   tc_track=climada_read_unisys_database;
   tc_track=climada_tc_random_walk(tc_track);
 INPUTS:
   tc_track: a structure with the track information for each cyclone i at
       each node j, see climada_read_unisys_database for a detailed
       description
 OPTIONAL INPUT PARAMETERS:
   ens_size: create ens_size varied derived tracks, default 9 
       (means for each original track, 9 daughter tracks are generated)
   ens_amp: amplitude of random walk wiggles in degree longitude for
       'directed', default 0.35. Be careful when changing, test with one track and plot, e.g.
       climada_tc_random_walk(tc_track(1),9,ens_amp,[],1)
   Maxangle: the angle the track direction can change for one timestep
       default=pi/7. Be careful when changing, test with one track and plot, e.g.
       climada_tc_random_walk(tc_track(1),9,[],Maxangle,1)
   check_plot: whether we show a check plot (=1) or not (=0), default=0
 OUTPUTS:
   same structure now including the ens_size times number of tracks
   all the info from the original tracks is copied, only the lat, lon
   differs
 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090728
 Markus Huber, markus.huber@env.ethz.ch, 20100412
 Omar Bellprat, mar.bellprat@env.ethz.ch, 20100412, Maxangle added as input
 David N. Bresch, david.bresch@gmail.com, 20160423, rand('seed',0) --&ampgt rng(0)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_tc_random_walk.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_read_unisys_database">
<H2>climada_tc_read_unisys_database</H2></A>
<font color="blue">function [tc_track,tc_track_hist_file]=climada_tc_read_unisys_database(unisys_file,check_plot) </font>
 TC event set track database UNISYS
 NAME:
   climada_tc_read_unisys_database
 PURPOSE:
   read UNISYS database file, raw data file to be downloaded from
   http://weather.unisys.com/hurricane/index.html (see
   climada_tc_get_unisys_databases), filter the raw data, namely:
   - a VALID record (=node) is required to have lat, lon and either pressure
     or windspeed (so recrods with only geographical information are skipped)
   - pressure [mb] needs to be in the range 800..1100, otherwise set to
     NaN, windspeeds of zero are also set to NaN
   - longitudes are converted such that east is positive and that the
     coordinates within one region (basin) are uniform, means no jump from
     180 to -180 (done based on median longitude of basin database)
   - latitudes (always North in UNISYS data) are converted for Southern
     Hemipshere datasets, if the unisys_file contains 'she' or 'bsh' in the filename
     (see parameter  convert_latitude, she: southern hemisphere, bsh: best track southern hemisphere)

   NOTE: if the binary file (see tc_track_hist_file) containing tc_track
   exists, the code just returns tc_track. This allows for recurent calls
   to the code and results in substantial speed-up.
   If the binary file (see tc_track_raw_file) exists, reading of raw
   data is skipped. This allows faster iteration iro filtering (as often
   required, since raw data contains missing and errors).
   One needs to delete the binary files to re-read the raw ASCII data.

   Wind = Maximum sustained (1 minute) surface (10m) windspeed in knots
       (in general, these are to the nearest 5 knots). 
   Pressure = Central surface pressure of storm in mb (if available).
       Since 1979, central pressures are given everytime even if a
       satellite estimation is needed.  

   More info: http://weather.unisys.com/hurricane/atlantic/tracks_atl_readme.txt

   previous step: see climada_tc_get_unisys_databases
   next step: see climada_tc_random_walk

   See also: climada_tc_hurdat_read and climada_tc_jtwc_fetch
 CALLING SEQUENCE:
   tc_track=climada_tc_read_unisys_database(unisys_file,check_plot);
 EXAMPLE:
   tc_track=climada_tc_read_unisys_database('tracks.atl.txt');
 INPUTS:
   unisys_file: the filename of the raw databse file (as downloaded from
       UNISYS), prompted for, if not given
       If no path provided, default path ../data/tc_tracks is used
   see also PARAMETERS section, especially for filters
 OPTIONAL INPUT PARAMETERS:
   check_plot: if =1, show plots, =0 not (default)
 OUTPUTS:
   tc_track: a structure with the track information for each cyclone i and
           data for each node j (times are at 00Z, 06Z, 12Z, 18Z):
       tc_track(i).lat(j): latitude at node j of cyclone i
       tc_track(i).lon(j): longitude at node j of cyclone i
       tc_track(i).MaxSustainedWind(j): Maximum sustained (1 minute)
           surface (10m) windspeed in knots (in general, these are to the nearest 5 knots).
       tc_track(i).MaxSustainedWindUnis, almost always 'kn'
           (others allowed: 'mph', 'm/s' or 'km/h')
       tc_track(i).CentralPressure(j): optional
       tc_track(i).CentralPressureUnit: 'mb'
       tc_track(i).yyyy: 4-digit year, optional
       tc_track(i).mm: month, optional
       tc_track(i).dd: day, optional
       tc_track(i).hh: hours
       tc_track(i).datenum:  matlab notation for date and time (see function datestr)
       tc_track(i).TimeStep(j)=time step [h] from this to next node
       tc_track(i).ID_no: unique ID, optional
       tc_track(i).name: name, optional
       tc_track(i).orig_event_flag: whether it is an mother(=1) or daugther(=0) storm

       Please note that a binary file of raw_data is stored (in the
       background). The raw_data is stored to ease (and speedup) re-reading the
       data. To really start from the raw text file again, please delete the
       binary file (*_raw.mat).

   tc_track_hist_file: the filename with path to the binary file
       tc_track is stored in (see NOTE above)

 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090728
 Joeri Rogelj, jr@env.ethz.ch, 20120429 / correct time step computation
 Reto Stockmann, 20120808 / added axes labels and limits
 Lea Mueller, 20120813, added overview of years in plot and codewort 'she'
 for southern hemisphere filename
 David N. Bresch, david.bresch@gmail.com, 20140221, world border plotted on top of tracks
 David N. Bresch, david.bresch@gmail.com, 20140922 (over the Atlantic, LX016), tc_track_hist_file as output added and storing processed as mat
 David N. Bresch, david.bresch@gmail.com, 20150805, allow for unisys_file without path on input
 David N. Bresch, david.bresch@gmail.com, 20150824, made fully consistent with jtwc and hurdat
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_tc_read_unisys_database.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_windfield">
<H2>climada_tc_windfield</H2></A>
<font color="blue">function gust = climada_tc_windfield(tc_track,centroids,~,silent_mode,~) </font>
 TC windfield calculation
 NAME:
   climada_tc_windfield
 PURPOSE:
   given a TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the wind field at locations (=centroids)

   mainly called from: see climada_tc_hazard_set

   Note: this code is optimized for speed, hence assumes that tc_track is
   free of missing data, climada_tc_equal_timestep applied and
   MaxSustainedWind calculated.

   PARFOR: this code does run with parfor, but it seems not to be faster
   at all (sine there seems to be lots of comms overhead to share tc_track
   between parallel processes) - see climada_tc_hazard_set for another
   PARFOR opportunity (we use it there, not here).

   See climada_tc_windfield_slow in the tropical cyclone module 
   (https://github.com/davidnbresch/climada_module_tropical_cyclone) 
   for the old slow version (for backward compatibility).

 CALLING SEQUENCE:
   [gust,res]=climada_tc_windfield(tc_track,centroids,~,silent_mode,~)
 EXAMPLE:
   tc_track=climada_tc_track_load('TEST_tracks.atl_hist');
   tc_track=climada_tc_equal_timestep(tc_track);
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   gust=climada_tc_windfield(tc_track(68),centroids);
   climada_color_plot(gust,centroids.lon,centroids.lat);
 INPUTS:
   tc_track: a structure with the single track information (length(tc_track)!=1)
       see e.g. climada_tc_read_unisys_tc_track
       tc_track.Azimuth and/or tc_track.Celerity calculated, if not existing
       but climada_tc_equal_timestep mist have been run and
       tc_track.MaxSustainedWind must exist on input
   centroids: a structure with the centroids information (see e.g.
       climada_centroids_read):
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
 OPTIONAL INPUT PARAMETERS:
   silent_mode: default=0, if =-1, use step-by-step detailed windfield,
       i.e. reduce wind to zero at center of the eye (not recommended for
       probabilistic, since hit/miss issue with closest node, see variable
       max_wind_at_bullseye in code).  
 OUTPUTS:
   gust: the windfield [m/s] at all centroids, NOT sparse for speedup
       i.e. convert like hazard.intensity()=sparse(res.gust)...
 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090728
 David N. Bresch, david.bresch@gmail.com, 20150103, not faster than climada_tc_windfield any more
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, about 20% faster than climada_tc_windfield_slow
 David N. Bresch, david.bresch@gmail.com, 20160529, only gust returned, even faster
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_tc_windfield.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_windfield_exercise">
<H2>climada_tc_windfield_exercise</H2></A>
<font color="blue">function [res,tc_track] = climada_tc_windfield_exercise(tc_track,centroids,~,silent_mode,~) </font>
 TC windfield calculation
 NAME:
   climada_tc_windfield_exercise
 PURPOSE:
   the EXERCISE version of climada_tc_windfield, used for lecture course,
   see www.iac.ethz.ch/edu/courses/master/modules/climate-risk.html

   given a TC track (lat/lon,MaxSustainedWind), calculate
   the wind field at locations (=centroids)

   mainly called from: see climada_tc_hazard_set

   Note: this code is optimized for speed, hence assumes that tc_track is
   free of missing data, climada_tc_equal_timestep applied and
   MaxSustainedWind calculated.

   PARFOR: this code does run with parfor, but it seems not to be faster
   at all (sine there seems to be lots of comms overhead to share tc_track
   between parallel processes) - see climada_tc_hazard_set for another
   PARFOR opportunity (we use it there, not here).

   See climada_tc_windfield_slow in the tropical cyclone module 
   (https://github.com/davidnbresch/climada_module_tropical_cyclone) 
   for the old slow version (for backward compatibility).

 CALLING SEQUENCE:
   [res,tc_track]=climada_tc_windfield_exercise(tc_track,centroids,~,silent_mode,~)
 EXAMPLE:
   tc_track=climada_tc_track_load('TEST_tracks.atl_hist');
   tc_track=climada_tc_equal_timestep(tc_track);
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   res=climada_tc_windfield_exercise(tc_track(68),centroids);
   climada_color_plot(res.gust,res.lon,res.lat);
 INPUTS:
   tc_track: a structure with the single track information (length(tc_track)!=1)
       see e.g. climada_tc_read_unisys_tc_track
       tc_track.Azimuth and/or tc_track.Celerity calculated, if not existing
       but climada_tc_equal_timestep mist have been run and
       tc_track.MaxSustainedWind must exist on input
   centroids: a structure with the centroids information (see e.g.
       climada_centroids_read):
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
 OPTIONAL INPUT PARAMETERS:
   silent_mode: default=0, if =-1, use step-by-step detailed windfield,
       i.e. reduce wind to zero at center of the eye (not recommended for
       probabilistic, since hit/miss issue with closest node, see variable
       max_wind_at_bullseye in code).  
 OUTPUTS:
   res.gust: the windfield [m/s] at all centroids, NOT sparse for speedup
       i.e. convert like hazard.intensity()=sparse(res.gust)...
   res.lon: the longitude of the centroids (=centroids.lon)
   res.lat: the latitude of the centroids (=centroids.lat)
   res.time: the time (sec) windfield calculation used
   tc_track: provided on output, to validate added fields, such as e.g.
       Azimuth and Celerity
 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090728
 David N. Bresch, david.bresch@gmail.com, 20150103, not faster than climada_tc_windfield any more
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, about 20% faster than climada_tc_windfield_slow
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_tc_windfield_exercise.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_viewer">
<H2>climada_viewer</H2></A>
<font color="blue">function varargout = climada_viewer(varargin) </font>
 climada_viewer MATLAB code for climada_viewer.fig
      climada_viewer, by itself, creates a new climada_viewer or raises the existing
      singleton*.

      H = climada_viewer returns the handle to a new climada_viewer or the handle to
      the existing singleton*.

      climada_viewer('CALLBACK',hObject,eventData,handles,...) calls the local
      function named CALLBACK in climada_viewer.M with the given input arguments.

      climada_viewer('Property','Value',...) creates a new climada_viewer or raises the
      existing singleton*.  Starting from the left, property value pairs are
      applied to the GUI before climada_viewer_OpeningFcn gets called.  An
      unrecognized property name or invalid value makes property application
      stop.  All inputs are passed to climada_viewer_OpeningFcn via varargin.

      *See GUI Options on GUIDE's Tools menu.  Choose &quotGUI allows only one
      instance to run (singleton)&quot.

 See also: GUIDE, GUIDATA, GUIHANDLES
 MODULE:
   viewer
 NAME:
   climada_viewer
 PURPOSE:
   plots entities, assets and damage
 CALLING SEQUENCE:
   climada_viewer
EXAMPLE
   climada_viewer
 INPUT:
   (all inputs are asked for by the GUI)
   entity: an entity structure, see e.g. climada_entity_load and climada_entity_read
   measures_impact: a measures_impact structure, e.g. produced by salvador_calc_measures
   type: must be specified from 'assets','benefits' and 'damage'
   unit: must be specified from 'USD' or 'people'
   timestamp: can be specified from
                  1- current state
                  2- economic growth
                  3- moderate climate change
                  4- extreme climate change
                    (default is 1)
  index_measures:  can be selected from a certain measure (see measure list in the measures_impactfile), default =1;
  categories:      Select a certain category from the list


 OUTPUTS:
   Graphical result
 OPTIONAL OUTPUTS:
   A .mat file with the current selection
   An excel with the curretn selection
   A .kmz file with the current selection
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151206, init based on climada_measure_viewer
 Lea Mueller, muellele@gmail.com, 20151209, add waterfall plot
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_viewer.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_waterfall_graph">
<H2>climada_waterfall_graph</H2></A>
<font color="blue">function  fig = climada_waterfall_graph(EDS_today,EDS_dev,EDS_cc,return_period,check_printplot,legend_on) </font>
 NAME:
   climada_waterfall_graph
 PURPOSE:
   show waterfall plot expected damage for specific return period to
   compare
   - risk today (assets today, hazard today)
   - increase due to economic development (future assets, hazard today)
   - increase due to climate change (future assets, future hazard)

   previous call: climada_EDS_calc
 CALLING SEQUENCE:
   climada_waterfall_graph(EDS_today,EDS_dev,EDS_cc,return_period,check_printplot)
 EXAMPLE:
   climada_waterfall_graph
 INPUTS:
   EDS_today: event damage set for risk today (assets today, hazard today)
       usually generated by climada_EDS_calc
       if EDS_today is a struct with three elements, the code assumes
       EDS_today(1) to be real EDS today, EDS_today(2) to be EDS_dev and
       EDS_today(2) to be EDS_cc
       &ampgt prompted for if not provided (as saved EDS), but this is not
       recommended, as one easily mixes up EDSs.
   EDS_dev: event damage set for risk incl. econ. development (future assets, hazard today)
       &ampgt prompted for if not provided (as saved EDS), but this is not
       recommended, as one easily mixes up EDSs.
   EDS_cc: event damage set for risk incl. econ. dev. and climate change
       (future assets, future hazard)
       &ampgt prompted for if not provided (as saved EDS), but this is not
       recommended, as one easily mixes up EDSs.
 OPTIONAL INPUT PARAMETERS:
   return_period: the return period for which damages are shown, e.g. =100
       default (=9999) is annual expected damage (i.e. EDS.ED)
   check_printplot:if set to 1, figure saved, default 0.
       if =-1, avoid all the additonal labels etc (for e.g. slides)
   legend_on: if =1, show legend with entity and hazard names, default=0
 OUTPUTS:
   waterfall graph
 MODIFICATION HISTORY:
 Lea Mueller, 20110622
 Martin Heynen, 20120329
 David N. Bresch, david.bresch@gmail.com, 20130316 EDS-&ampgtEDS
 David N. Bresch, david.bresch@gmail.com, 20150419 try-catch for arrow plotting
 Lea Mueller, muellele@gmail.com, 20150831, integrate Value_unit from EDS_today.Value_unit
 David N. Bresch, david.bresch@gmail.com, 20150906 ED as default for return_period
 David N. Bresch, david.bresch@gmail.com, 20150906 font scale and label texts shortened
 David N. Bresch, david.bresch@gmail.com, 20150907 font scale and label texts shortened
 Lea Mueller, muellele@gmail.com, 20150930, introduce climada_digit_set
 Lea Mueller, muellele@gmail.com, 20151020, add TIV for future reference year
 Lea Mueller, muellele@gmail.com, 20151030, bugfix in climada_arrow
 Lea Mueller, muellele@gmail.com, 20151209, set no_fig=1, add legend_on=1
 David N. Bresch, david.bresch@gmail.com, 20160524, default legend_on=0, some simplifiactions
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/climada_waterfall_graph.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="git_pull">
<H2>git_pull</H2></A>
 git_pull
 just an alias for climada_git_pull(0)
limada_git_pull
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/git_pull.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="RivDIS_read">
<H2>RivDIS_read</H2></A>
<font color="blue">function data=RivDIS_read(data_file,verbose) </font>
 climada template
 MODULE:
   _LOCAL
 NAME:
   data=RivDIS_read(data_file)
 PURPOSE:
   Read RivDIS data from ftp://daac.ornl.gov/data/rivdis/STATIONS.HTM#I
   http://daac.ornl.gov/RIVDIS/rivdis.shtml
   See ftp://daac.ornl.gov/data/rivdis/README
   Units: cubic meters/sec

   file format as:
     Buretto,44.96 N,10.39 E,E4,Italy,Europe,Po,20,55183
     Monthly average discharge in cubic meters/sec  180 records
     POINTID|YEAR|MONTH|DISCHRG
     750|1965|1|823
     750|1965|2|683
     750|1965|3|901
     750|1965|4|630
     750|1965|5|341
     750|1965|6|803
     750|1965|7|382
     750|1965|8|743
     750|1965|9|2110
     750|1965|10|2000
     ...

 CALLING SEQUENCE:
   data=RivDIS_read(data_file,verbose)
 EXAMPLE:
   data=RivDIS_read

   data01=RivDIS_read('TABLE01.DAT',0);
   data02=RivDIS_read('TABLE02.DAT',0);
   data03=RivDIS_read('TABLE03.DAT',0);
   plot(data01.datenum,data01.DISCHRG,'-r');datetick; hold on
   legend_str{1}=data01.station_name;
   plot(data02.datenum,data02.DISCHRG,'-g');datetick; hold on
   legend_str{2}=data02.station_name;
   plot(data03.datenum,data03.DISCHRG,'-b');datetick; hold on
   legend_str{3}=data03.station_name;
   legend(legend_str);ylabel(data01.units);
   title(['river ' data01.river_name ' monthly maximum discharge']);set(gcf,'Color',[1 1 1])
 INPUTS:
   data_file: the filename of the data (.DAT) file.
       If without path, default path is appended and tried
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   verbose: =1: print some verbose (default),
       =2: show check plot, too, =0: silent
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160121
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/_LOCAL/code/RivDIS_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="chirps_read">
<H2>chirps_read</H2></A>
<font color="blue">function res=chirps_read(nc_files,lonlatrect,check_animation,verbose) </font>
 read CHIRPS netCDF file
 MODULE:
   core
 NAME:
   chirps_read
 PURPOSE:
   read CHIRPS netCDF file, see  http://chg.geog.ucsb.edu/data/chirps/#_Data

   currently reading global daily data, i.e. from files obtained from 
   ftp://ftp.chg.ucsb.edu/pub/org/chg/products/CHIRPS-2.0//global_daily/netcdf/p05/by_month/

   currently VERY innefficient memory use, as we store all (70%) of ocean
   points as zeros

 CALLING SEQUENCE:
   res=chirps_read(nc_files,lonlatrect,check_animation,verbose)
 EXAMPLE:
   res=chirps_read(nc_files)
 INPUTS:
   nc_files: netCDF filename(s) with path. If more than one file, pass as
       struct, i.e. nc_files{i} a single filename with path
 OPTIONAL INPUT PARAMETERS:
   lonlatrect: [minlon maxlon minlat maxlat] to read a rectangular region
       instead of the wholw world, default=[].
   check_animation: =0 (default): no animation, =1: animation to screen
       =2: to screen and saved as MP4 file (CHIRPS_animation.mp4 in pwd)
       =3: only saved to mp4, figure not visible
   verbose: =1 print some info to stdout, =0 not (silent, default)
 OUTPUTS:
   res: a structure with
       lat: [2000x1 single] the latitude
       lon: [7200x1 single] the longitude
       time: [31x1 double] the time (here rather the date),
           as a MATLAB datenum
       time_str: [31x11 char] date string (=datestr(res.time))
   precip: [7200x2000x31 double] the precipitation
   precip_units: the units of res.precip
   &ampgt check output e.g. with
       image(res.lon,res.lat,res.precip(:,end:-1:1,1)');axis equal
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160103, initial
 David N. Bresch, david.bresch@gmail.com, 20160603, pat of core climada
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/_LOCAL/code/chirps_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tif_read">
<H2>climada_tif_read</H2></A>
<font color="blue">function res = climada_tif_read(tif_file,check_plot,verbose) </font>
 climada_tif_read
 MODULE:
   climada code/data_import
 NAME:
   climada_tif_read
 PURPOSE:
   read a tif file (data and coordinates) and put into res.data, res.lon,
   res.lat structure
   tif file can be saved in climada/data/entities or any other folder that
   you select throught he popup-window.
 CALLING SEQUENCE:
   res = climada_tif_read(tif_file,check_plot,verbose)
 EXAMPLE:
   res = climada_tif_read(tif_file,check_plot,verbose)
   res = climada_tif_read
 INPUTS: 
 OPTIONAL INPUT PARAMETERS:
   tif_file: a struct with the following fields, prompted for if not given
   .filename: prompted for if not given. Tif_file is the filename, the file
           contains raster data information.
   .lon_lat_min_max: i.e. [99 100 2 3], define lon min, lon max, lat min, 
           lat max for the gridded data. 
   .lon_lat_min_max_selection: i.e. [99 99.5 2 2.5], define the subset of 
           the data that you want with lon min, lon max, lat min, lat max
   .NODATA_value: i.e. -9999, this data will be overwritten with 0
   check_plot: set to 1 to see a figure, default is 0
   verbose: get fprint information in the command line, default is 0
 OUTPUTS: 
   res: a structure with 
   .data: gridded data from tif-file
   .lon: range of longitude (lon min and lon max)
   .lat: range of latitude (lat min and lat max)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160408, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/data_import/climada_tif_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="loadods">
<H2>loadods</H2></A>
 LOADODS: Loads data from an open document spreadsheet (ods) file into a cell
          array

 SYNTAX: data = loadods(filename,options)

 INPUTS:
   filename:   String representing the path and name of the ods file
   options:    Structural variable containing optional arguments

 OUTPUTS:
   data:       MxN cell array containing data from the spreadsheet

 OPTIONS:
   sheet_name: Name of a specific sheet to load [defaults to the first sheet]
   blank:      Value to store for blank spreadsheet cells [NaN]

 VERSION: 1.0

 Copyright (C) 2007 Alex Marten - alex.marten@gmail.com
 see license at the bottom of this file
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/data_import/loadods.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="trmm_get">
<H2>trmm_get</H2></A>
<font color="blue">function TRMM = trmm_get(yyyy,mm,dd,hh,check_plot,verbose) </font>
 climada TRMM precipitation
 MODULE:
   helper functions
 NAME:
   trmm_get
 PURPOSE:
   Read the TRMM precipitation data, GIS-reformatted version of TRMM 3B42
   files (spatial resolution is 0.25 degrees)
   See ftp://trmmopen.gsfc.nasa.gov/pub/trmmdata/GIS/README.GIS.pdf

   The code tries to automatically get the files from
   ftp://trmmopen.gsfc.nasa.gov/pub/trmmdata/GIS/ (see TRMM_URL in
   PARAMETERS in code). If this fails, the required TRMM file
   is printed to stdout for the user to manually retrieve. Once locally
   stored (to TRMM_data_dir, i.e. ../data/trmm), call trmm_get
   again to process the file.

   calls climada functions climada_plot_world_borders and
   climada_figure_scale_add only if they exists. Hence can easily be run
   stand-alone
 CALLING SEQUENCE:
   TRMM = trmm_get(yyyy,mm,dd,hh,check_plot,verbose)
 EXAMPLE:
   TRMM = trmm_get(2014,10,21,15,1,0);
   trmm_get(2014,10,21,[],1,0) % animate all hours of one day
   trmm_get(2014,10,1:31,[],1,0) % animate a full month
 INPUTS:
   yyyy,mm,dd: year month and day (integers)
   hh: the hour UTC, allowed are every 3 hours, i.e. 0,3,6,9,12,15,18,21
       Special: if empty, we get ALL 3-hourly data and produce an
           animation (to e.g. check data consistenccy)
           In this special case, dd can also be a vector, to loop over
           more than one day, e.g. dd=1:30 
           Note that in this special case TRMM is empty on output
 OPTIONAL INPUT PARAMETERS:
   check_plot: show a check plot, if =1, (default=0)
       if &ampgt1, do not open a new figure
       if &ampgt2, do only show precic &amplt400 mm
   verbose: =1 print info, =0 not (default)
 OUTPUTS:
   TRMM: a structure, with
       yyyy,mm,dd,hh: as on input
       datenum: the MATLAB datenum(yyyy,mm,dd,hh,0,0)
       source_filename: the original (ftp) filename with web path
       filename: the local .mat filename (with path)
       tif_filename: the local .tif filename (with path)
       data(i,j): the data
       lon(i,j): the longitude of the pixels
       lat(i,j): the latitude of the pixels
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20160220, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/data_import/trmm_get.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cbfreeze">
<H2>cbfreeze</H2></A>
<font color="blue">function CBH = cbfreeze(varargin) </font>
CBFREEZE   Freezes the colormap of a colorbar.

   SYNTAX:
           cbfreeze
           cbfreeze('off')
           cbfreeze(H,...)
     CBH = cbfreeze(...);

   INPUT:
     H     - Handles of colorbars to be freezed, or from figures to search
             for them or from peer axes (see COLORBAR).
             DEFAULT: gcf (freezes all colorbars from the current figure)
     'off' - Unfreezes the colorbars, other options are:
               'on'    Freezes
               'un'    same as 'off'
               'del'   Deletes the colormap(s).
             DEFAULT: 'on' (of course)

   OUTPUT (all optional):
     CBH - Color bar handle(s).

   DESCRIPTION:
     MATLAB works with a unique COLORMAP by figure which is a big
     limitation. Function FREEZECOLORS by John Iversen allows to use
     different COLORMAPs in a single figure, but it fails freezing the
     COLORBAR. This program handles this problem.

   NOTE:
     * Optional inputs use its DEFAULT value when not given or [].
     * Optional outputs may or not be called.
     * If no colorbar is found, one is created.
     * The new frozen colorbar is an axes object and does not behaves
       as normally colorbars when resizing the peer axes. Although, some
       time the normal behavior is not that good.
     * Besides, it does not have the 'Location' property anymore.
     * But, it does acts normally: no ZOOM, no PAN, no ROTATE3D and no
       mouse selectable.
     * No need to say that CAXIS and COLORMAP must be defined before using
       this function. Besides, the colorbar location. Anyway, 'off' or
       'del' may help.
     * The 'del' functionality may be used whether or not the colorbar(s)
       is(are) froozen. The peer axes are resized back. Try: 
        &ampgt&ampgt colorbar, cbfreeze del

   EXAMPLE:
     surf(peaks(30))
     colormap jet
     cbfreeze
     colormap gray
     title('What...?')

   SEE ALSO:
     COLORMAP, COLORBAR, CAXIS
     and
     FREEZECOLORS by John Iversen
     at http://www.mathworks.com/matlabcentral/fileexchange


   ---
   MFILE:   cbfreeze.m
   VERSION: 1.1 (Sep 02, 2009) (&amplta href=&quotmatlab:web('http://www.mathworks.com/matlabcentral/fileexchange/authors/11258')&quot&ampgtdownload&amplt/a&ampgt) 
   MATLAB:  7.7.0.471 (R2008b)
   AUTHOR:  Carlos Adrian Vargas Aguilera (MEXICO)
   CONTACT: nubeobscura@hotmail.com
   REVISIONS:
   1.0      Released. (Jun 08, 2009)
   1.1      Fixed BUG with image handle on MATLAB R2009a. Thanks to Sergio
            Muniz. (Sep 02, 2009)
   DISCLAIMER:
   cbfreeze.m is provided &quotas is&quot without warranty of any kind, under the
   revised BSD license.
   Copyright (c) 2009 Carlos Adrian Vargas Aguilera
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/cbfreeze.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cbhandle">
<H2>cbhandle</H2></A>
<font color="blue">function CBH = cbhandle(varargin) </font>
CBHANDLE   Handle of current colorbar axes.

   SYNTAX:
     CBH = cbhandle;
     CBH = cbhandle(H);

   INPUT:
     H - Handles axes, figures or uipanels to look for colorbars.
         DEFAULT: gca (current axes)

   OUTPUT:
     CBH - Color bar handle(s).

   DESCRIPTION:
     By default, color bars are hidden objects. This function searches for
     them by its 'axes' type and 'Colorbar' tag.
    
   SEE ALSO:
     COLORBAR
     and
     CBUNITS, CBLABEL, CBFREEZE by Carlos Vargas
     at http://www.mathworks.com/matlabcentral/fileexchange


   ---
   MFILE:   cbhandle.m
   VERSION: 1.1 (Aug 20, 2009) (&amplta href=&quotmatlab:web('http://www.mathworks.com/matlabcentral/fileexchange/authors/11258')&quot&ampgtdownload&amplt/a&ampgt) 
   MATLAB:  7.7.0.471 (R2008b)
   AUTHOR:  Carlos Adrian Vargas Aguilera (MEXICO)
   CONTACT: nubeobscura@hotmail.com
   REVISIONS:
   1.0      Released. (Jun 08, 2009)
   1.1      Fixed bug with colorbar handle input. (Aug 20, 2009)
   DISCLAIMER:
   cbhandle.m is provided &quotas is&quot without warranty of any kind, under the
   revised BSD license.
   Copyright (c) 2009 Carlos Adrian Vargas Aguilera
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/cbhandle.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_DFC_compare">
<H2>climada_DFC_compare</H2></A>
<font color="blue">function match100fact=climada_DFC_compare(EDS,DFC_file,Percentage_Of_Value_Flag,plot_loglog,scenario_comparison_flag,EDS_multiplier) </font>
 climada
 NAME:
   climada_DFC_compare
 PURPOSE:
   compare climada results (Event damage set, EDS) and the resulting
   damage frequency curve (DFC) with DFC from file, e.g. to compare with
   other models. Purely visual inspection (as the eye of the beholder
   integrates such complex information far better than any code...)

   Instead of a lengthy description of the exact content of the Excel
   file, see the one example (climada_DFC_compare_file.xls) in the
   core climada data results folder. Note that the code (and the format
   of the Excel) is peril-independent. If troubles with .xls, save as
   Excel95.

   See also climada_EDS_calc, climada_EDS_DFC and climada_EDS_DFC_match
 CALLING SEQUENCE:
   climada_DFC_compare(EDS,DFC_file,Percentage_Of_Value_Flag,plot_loglog)
 EXAMPLE:
   DFC_file=[climada_global.data_dir filesep 'results' filesep 'climada_DFC_compare_file.xls']; % the example file
   climada_DFC_compare(EDS,DFC_file)
   climada_DFC_compare(EDS,'',0,0,1,1/5)

   % all in one, e-g frequency_screw on hazard and EDS_multiplier:
   entity_blend=climada_assets_encode(climada_entity_load) % select 'Germany_entity.mat' and WS_Europe.mat from ws_europe module
   module_data_dir=[fileparts(fileparts(which('climada_DFC_compare'))) filesep 'data'];
   DFC_file=[module_data_dir filesep 'climada_DFC_compare_file.xls'];
   frequency_screw=0.25;
   EDS_multiplier=1/3;
   climada_DFC_compare(climada_EDS_calc(entity_blend,...
       winterstorm_blend_hazard_event_sets('WS_Europe_blend.mat',...
       frequency_screw)),'',0,0,1,EDS_multiplier)
 INPUTS:
   EDS: a climada EDS, as produced by climada_EDS_calc
       Only EDS(1) is used for comparison, further EDSs are plotted, but
       not compared.
   DFC_file: an Excel file with a DFC (currently only one single DFC
       supported).If troubles with .xls, save as Excel95 first.
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   Percentage_Of_Value_Flag: if =1, scale vertical axis with Value, such
       that damage as percentage of value is shown, instead of damage amount,
       default=0 (damage amount shown). Very useful to compare DFCs of
       different portfolios to see relative differences in risk
   plot_loglog: if =1, plot logarithmic scale both axes
       =0 plot linear axes (default)
   scenario_comparison_flag: also compare single scenario event losses (if
       in Excel, as tab 'Footprint Report').
   EDS_multiplier: a simple multiplier to multiply the EDS damage with (to
       experiment with a correction factor, highly EXPERIMENTAL
       (default=1, obviously)
 OUTPUTS:
   match100fact: the multiplier to match the 100yr damage
       Note that EDS_multiplier is applied before, hence total suggested
       correction to match 100yr damage = EDS_multiplier*match100fact
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141206, initial 'Samichlaus'
 David N. Bresch, david.bresch@gmail.com, 20141212, minor edits
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_DFC_compare.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_DFC_read">
<H2>climada_DFC_read</H2></A>
<font color="blue">function DFC=climada_DFC_read(DFC_file) </font>
 climada
 NAME:
   climada_DFC_read
 PURPOSE:
   Read a damage frequency curve (DFC) with DFC from file, e.g. to compare with
   other models.

   Instead of a lengthy description of the exact content of the Excel
   file, see the one example (climada_DFC_compare_file.xls) in the
   core climada data results folder. Note that the code (and the format
   of the Excel) is peril-independent. If troubles with .xls (or .xlsx),
   save as Excel95 (or 97).

   See also climada_DFC_compare, climada_EDS_DFC and climada_EDS_DFC_match
 CALLING SEQUENCE:
   DFC=climada_DFC_read(DFC_file)
 EXAMPLE:
   DFC_file=[climada_global.data_dir filesep 'results' filesep 'climada_DFC_compare_file.xls']; % the example file
   DFC=climada_DFC_read(DFC_file)
   % process a full folder, e.g.
   folder=[climada_global.data_dir filesep 'results' filesep 'model_results'];D=dir([folder filesep '*.xlsx']);
   for file_i=1:length(D),if ~D(file_i).isdir,DFC=climada_DFC_read([folder filesep D(file_i).name]);end;end
 INPUTS:
   DFC_file: an Excel file with a DFC (currently only one single DFC
       supported).If troubles with .xls, save as Excel95 first.
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   DFC: a strcture with a damage frequency curve (DFC)
       return_period(i): the return periods
       damage(i): the damage for return_period(i) (sometimes termed loss)
       damage_of_value(i): damage as percentage of total asset value
       peril_ID: the peril_ID
       value: the total asset value (often referred to as TIV, i.e. total
           insurable value)
       ED: the annual expected damage (sometimes referred to as groun up
           loss)
       annotation_name: just a free annotation name
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150120, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_DFC_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS2DFC">
<H2>climada_EDS2DFC</H2></A>
<font color="blue">function DFC=climada_EDS2DFC(EDS,return_period) </font>
 climada
 NAME:
   climada_EDS2DFC
 PURPOSE:
   convert an event damage set (EDS) into a Damage exceedence Frequency Curve (DFC)

   prior call: climada_EDS_calc
   See also: climada_EDS_DFC (which plots the DFC)
 CALLING SEQUENCE:
   DFC=climada_EDS2DFC(EDS,return_period)
 EXAMPLE:
   DFC=climada_EDS2DFC(climada_EDS_calc)
 INPUTS:
   EDS: either an event damage set (or many, i.e. EDS(i), as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       SPECIAL: we also accept a structure which contains an EDS, like
       measures_impact.EDS
       if EDS has the field annotation_name, the legend will show this
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   return_period: the vector of return periods for whoch we'd like to
       obtain the damage. Default are the return periods as defined in
       climada_global.DFC_return_periods
 OUTPUTS:
   DFC: a strcture with a damage frequency curve (DFC)
       return_period(i): the return periods
           if empty, the default return periods as in
           climada_global.DFC_return_periods are used
           if =-1, all points as returned by climada_damage_exceedence are
           used
       damage(i): the damage for return_period(i)
       damage_of_value(i): damage as percentage of total asset value
       peril_ID: the peril_ID
       value: the total asset value
       ED: the annual expected damage
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150120, initial
 David N. Bresch, david.bresch@gmail.com, 20160429, DFC.Value instead of DFC.value
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_EDS2DFC.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS2YDS">
<H2>climada_EDS2YDS</H2></A>
<font color="blue">function [YDS,sampling_vect]=climada_EDS2YDS(EDS,hazard,number_of_years,sampling_vect) </font>
 climada template
 MODULE:
   core
 NAME:
   climada_EDS2YDS
 PURPOSE:
   convert an event (per occurrence) damage set (EDS) into a year damage
   set (YDS), making reference to hazard.orig_yearset (if exists). If
   there is no yearset in hazard, generate an artificial year damage set
   by sampling the EDS into n_years, where n_years is dtermined based on
   EDS.frequency (n_years=1/min(EDS.frequency), such that the yearset
   'spans' the period the damage is 'representative' for).

   The code does perform some consistency checks, but the user is
   ultimately repsonsible for results ;-)

   Note that for TS and TR, the TC hazard event set contains
   hazard.orig_yearset, not each sub-peril hazard event set might contain
   its own yearset. See climada_tc_hazard_set for a good example of how
   such an hazard.orig_yearset is constructed.
 CALLING SEQUENCE:
   YDS=climada_EDS2YDS(EDS,hazard,number_of_years)
 EXAMPLE:
   YDS=climada_EDS2YDS(climada_EDS_calc('',hazard),hazard)
 INPUTS:
   EDS: an event damage set (EDS), as produced by climada_EDS_calc
       (see there)
 OPTIONAL INPUT PARAMETERS:
   hazard: a hazard event set (either a struct or a full filename with
       path) which contains a yearset in hazard.orig_yearset
       Note that for TS and TR, the TC hazard event set contains
       hazard.orig_yearset, not each sub-peril hazard event set
       If empty, the hazard event set is inferred from
       EDS.annotation_name, which often contains the filename (without
       path) of the hazard event set. If this is the case, this hazard is
       used, if not, the function prompts for the hazard event set to use.
       If hazard does neither contain a valid hazard struct, nor an
       existing hazard set name, one event per year is assumed and the EDS
       is just replicated enough times to result in number_of_years (or,
       if number_of_years is not provided, YDS=EDS)
   number_of_years: the target number of years the damage yearset shall
       contain. If shorter than the yearset in the hazard set, just cut,
       otherwise replicate until target length is reached. No advanced
       technique, such as re-sampling, is performed (yet).
   sampling_vect: the sampling vector, techincal, see code (can be used to
       re-create the exact same yearset). Needs to be obtained in a first
       call, i.e. [YDS,sampling_vect]=climada_EDS2YDS(...) and then
       provided in subsequent calls(s) to obtain the exact same sampling
       structure of yearset, i.e YDS=climada_EDS2YDS(...,sampling_vect)
 OUTPUTS:
   YDS: the year damage set (YDS), a struct with same fields as EDS (such
       as Value, ED, ...) plus yyyy and orig_year_flag. All fields same
       content as in EDS, except:
       yyyy(i): the year i
       damage(i): the sum of damage for year(i). Note that for a
           probabilitic hazard event set, there are ens_size+1 same years,
           the first instance being the original year.
       frequency(i): the annual frequency, =1
       orig_year_flag(i): =1 if year i is an original year, =0 else
       Hint: if you want to staore a YDS back into an EDS, note that there
       are two more fields in YDS than EDS: yyyy and orig_year_flag
   sampling_vect: the sampling vector, techincal, see code (can be used to
       re-create the exact same yearset)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141226, initial
 David N. Bresch, david.bresch@gmail.com, 20150116, YDS fields same order as in EDS
 David N. Bresch, david.bresch@gmail.com, 20150204, automatic hazard set detection
 David N. Bresch, david.bresch@gmail.com, 20150721, EDS is proxy for output, i.e. YDS=EDS to start with
 David N. Bresch, david.bresch@gmail.com, 20151231, artifical yearsets and number_of_years implemented
 David N. Bresch, david.bresch@gmail.com, 20160307, sampling_vect as optional output
 David N. Bresch, david.bresch@gmail.com, 20160308, allow for no hazard set
 David N. Bresch, david.bresch@gmail.com, 20160420, orig_year_flag improved
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_EDS2YDS.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_DFC">
<H2>climada_EDS_DFC</H2></A>
<font color="blue">function [DFC,fig,legend_str] = climada_EDS_DFC(EDS,EDS_comparison,Percentage_Of_Value_Flag,plot_loglog) </font>
 climada
 NAME:
   climada_EDS_DFC
 PURPOSE:
   plot occurrence Damage exceedence Frequency Curve (DFC)
   mainly does plotting, uses climada_EDS2DFC to convert EDS to DFC

   See also: climada_EDS_DFC_match and climada_DFC_compare
 CALLING SEQUENCE:
   climada_EDS_DFC(EDS,EDS_comparison,Percentage_Of_Value_Flag,plot_loglog)
 EXAMPLE:
   climada_EDS_DFC(climada_EDS_calc(climada_entity_read))
 INPUTS:
   EDS: either an event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       SPECIAL: we also accept a structure which contains an EDS, like
       measures_impact.EDS
       if EDS has the field annotation_name, the legend will show this
       &ampgt EDS promted for if not given
 OPTIONAL INPUT PARAMETERS:
   EDS_comparison: like EDS see above, plotted (fine lines) for comparison
       not prompted for, if not given,unless set to 'ASK'
   Percentage_Of_Value_Flag: if =1, scale vertical axis with Value, such
       that damage as percentage of value is shown, instead of damage amount,
       default=0 (damage amount shown). Very useful to compare DFCs of
       different portfolios to see relative differences in risk
   plot_loglog: if =1, plot logarithmic scale both axes, =0 plot linear
       axes (default)
 OUTPUTS:
   DFC: a structure with fields
       .return_period
       .sorted_damage
       .ED, .Value, .Value_unit, and .annotation_name
   a figure with the DFC plot
   legend_str: the legend string
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20100108
 david.bresch@gmail.com, 20100109, comparison added
 muellele@gmail.com, 20120816, comparison title of all comparisons, changed markersize
 david.bresch@gmail.com, 20130316, ELS-&ampgtEDS...
 david.bresch@gmail.com, 20130316, slight cleanup
 muellele@gmail.com, 20150421, legend location SouthEast instead of NorthWest
 david.bresch@gmail.com, 20150515, line 212, legend_str{end+1}...
 david.bresch@gmail.com, 20150906, EDS.Value_unit used
 muellele@gmail.com, 20160308, add output DFC structure
 david.bresch@gmail.com, 20160429, calling EDS2DFC, DFC.Value instead of DFC.value
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_EDS_DFC.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_DFC_hist">
<H2>climada_EDS_DFC_hist</H2></A>
<font color="blue">function climada_EDS_DFC_hist(EDS,EDS_comparison,Percentage_Of_Value_Flag) </font>
 climada
 NAME:
   climada_EDS_DFC
 PURPOSE:
   plot occurrence Damage exceedence Frequency Curve (DFC)
 CALLING SEQUENCE:
   climada_EDS_DFC(EDS,EDS_comparison,Percentage_Of_Value_Flag)
 EXAMPLE:
   climada_EDS_DFC(climada_EDS_calc(climada_entity_read))
 INPUTS:
   EDS: either an event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       SPECIAL: we also accept a structure which contains an EDS, like
       measures_impact.EDS
       if EDS has the field annotation_name, the legend will show this
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   EDS_comparison: likeEDS see above), plotted (fine lines) for comparison
       not prompted for, if not given,unless set to 'ASK'
   Percentage_Of_Value_Flag: if =1, scale vertical axis with Value, such
       that damage as percentage of value is shown, instead of damage amount,
       default=0 (damage amount shown). Very useful to compare DFCs of
       different portfolios to see relative differences in risk
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20100108
 David N. Bresch, david.bresch@gmail.com, 20100109, comparison added
 David N. Bresch, david.bresch@gmail.com, 20130316, ELS-&ampgtEDS...
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_EDS_DFC_hist.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_DFC_match">
<H2>climada_EDS_DFC_match</H2></A>
<font color="blue">function EDS=climada_EDS_DFC_match(EDS,DFC_file,match_ED_flag) </font>
 climada EDS DFC
 NAME:
   climada_EDS_DFC_match
 PURPOSE:
   Given a climada event damage set (EDS) and a  damage frequency curve
   (DFC) from file, adjust the EDS, such that the EDS best matches the
   DFC (e.g. to 'reproduce' other model results with climada).

   Instead of a lengthy description of the exact content of the Excel
   file, see the one example (climada_DFC_compare_file.xls) in the
   core climada data results folder. Note that the code (and the format
   of the Excel) is peril-independent. If troubles with .xls, save as
   Excel95.

   There are three steps:
   1) compare and if necessary adjust for EDS to have the same total Value
      as the DFC (i.e. adjust EDS.damage, EDS.Value, EDS.assets.Value)
   2) compare the DFCs of the EDS with the one read from file and adjust
      the single event damages (EDS.damage) such that the adjusted DFC based
      on the EDS matches the one from file
   3) recalculate EDS.ED (expected damage) and compare withe the
      Ground_Up_Loss of the DFC. Adjust EDS.damage once more and finally
      recalculate EDS.ED again.

   See also climada_EDS_calc, climada_EDS_DFC and climada_DFC_compare
 CALLING SEQUENCE:
   EDS=climada_EDS_DFC_match(EDS,DFC_file)
 EXAMPLE:
   DFC_file=[climada_global.data_dir filesep 'results' filesep 'climada_DFC_compare_file.xls']; % the example file
   EDS=climada_EDS_DFC_match(EDS,DFC_file)
 INPUTS:
   EDS: a climada EDS, as produced by climada_EDS_calc
       Only EDS(1) is used for comparison, further EDSs are plotted, but
       not compared.
   DFC_file: an Excel file with a DFC (currently only one single DFC
       supported).If troubles with .xls, save as Excel95 first.
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   match_ED_flag: =1 make sure the expected damage (ED) is matching
       exactly (might lead to small differences on EDS), =0, do not match ED,
       just match the DFC (default, as this leads to perfect match for return
       periods).
       If you set match_ED_flag=-99, the comparison plot of the DFCs is
       omitted
 OUTPUTS:
   EDS: EDS such that it best matches the DFC from file (events adjusted)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150118, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_EDS_DFC_match.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_DFC_report">
<H2>climada_EDS_DFC_report</H2></A>
<font color="blue">function res = climada_EDS_DFC_report(EDS,Percentage_Of_Value_Flag,report_style,report_file) </font>
 climada
 NAME:
   climada_EDS_DFC_report
 PURPOSE:
   Interpolate damage frequency curve (DFC) to standard return periods
   (see climada_global.DFC_return_periods)

   previous call: climada_EDS_calc
 CALLING SEQUENCE:
   res=climada_EDS_DFC_report(EDS,Percentage_Of_Value_Flag,report_style)
 EXAMPLE:
   res=climada_EDS_DFC_report(climada_EDS_calc(climada_entity_read))
 INPUTS:
   EDS: either an event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       SPECIAL: we also accept a structure which contains an EDS, like
       measures_impact.EDS
       if EDS has the field annotation_name, the legend will show this
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   Percentage_Of_Value_Flag: if =1, scale vertical axis with Value, such
       that damage as percentage of value is shown, instead of damage amount,
       default=0 (damage amount shown). Very useful to compare DFCs of
       different portfolios to see relative differences in risk
   report_style: 'lean' for only the damages at predefined return periods
       'std' (default): the damages at return periods.
   report_file: filename (and path) to save the report to (as .csv)
       ='': no saving to file (default)
       ='ASK' to prompt for
 OUTPUTS:
   res: a structure with fields
       return_periods(RP_i): return period RP_i
       damage(EDS_i,RP_i)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20100108
 David N. Bresch, david.bresch@gmail.com, 20100109, comparison added
 David N. Bresch, david.bresch@gmail.com, 20130316, ELS-&ampgtEDS...
 David N. Bresch, david.bresch@gmail.com, 20150101, report_file added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_EDS_DFC_report.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_ED_at_centroid_report">
<H2>climada_EDS_ED_at_centroid_report</H2></A>
<font color="blue">function climada_EDS_ED_at_centroid_report(EDS,Percentage_Of_Value_Flag,report_file) </font>
 climada
 NAME:
   climada_EDS_ED_at_centroid_report
 PURPOSE:
   Write out ED at centroids for one or multiple EDS structures into .csv
   file
   previous call: climada_EDS_calc
 CALLING SEQUENCE:
   climada_EDS_ED_at_centroid_report(EDS,Percentage_Of_Value_Flag,report_file)
 EXAMPLE:
   climada_EDS_ED_at_centroid_report(climada_EDS_calc(climada_entity_read))
 INPUTS:
   EDS: either an event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       SPECIAL: we also accept a structure which contains an EDS, like
       measures_impact.EDS
       if EDS has the field annotation_name, the legend will show this
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   Percentage_Of_Value_Flag: if =1, scale vertical axis with Value, such
       that damage as percentage of value is shown, instead of damage amount,
       default=0 (damage amount shown). Very useful to compare DFCs of
       different portfolios to see relative differences in risk
   report_file: filename (and path) to save the report to (as .csv), if
       empty, prompted for
 OUTPUTS:
   none, report file written as .csv
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150430, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_EDS_ED_at_centroid_report.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_ED_at_centroid_report_xls">
<H2>climada_EDS_ED_at_centroid_report_xls</H2></A>
<font color="blue">function climada_EDS_ED_at_centroid_report_xls(EDS,entity,xls_file) </font>
 climada
 NAME:
   climada_EDS_ED_at_centroid_report
 PURPOSE:
   Write out ED at centroids for one or multiple EDS structures into .csv
   file
   previous call: climada_EDS_calc
 CALLING SEQUENCE:
   climada_EDS_ED_at_centroid_report(EDS,entity,xls_file)
 EXAMPLE:
   climada_EDS_ED_at_centroid_report(climada_EDS_calc(climada_entity_read), climada_entity_read)
 INPUTS:
   EDS: either an event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       SPECIAL: we also accept a structure which contains an EDS, like
       measures_impact.EDS
       if EDS has the field annotation_name, the legend will show this
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   xls_file: filename (and path) to save the report to (as .xls), if
       empty, prompted for
 OUTPUTS:
   none, report file written as .xls
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150430, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/climada_EDS_ED_at_centroid_report_xls.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_ED_per_category_report">
<H2>climada_EDS_ED_per_category_report</H2></A>
<font color="blue">function output_report = climada_EDS_ED_per_category_report(entity,EDS,xls_file,sheet,benefit_flag,percentage_flag,assets_flag,summary) </font>
 climada_EDS_ED_per_category_report
 MODULE:
   climada core
 NAME:
   climada_EDS_ED_per_category_report
 PURPOSE:
   Write out ED per category for one EDS structures into xls file
   previous call: climada_EDS_calc, or climada_EDS_ED_at_centroid_report_xls
 CALLING SEQUENCE:
   output_report = climada_EDS_ED_per_category_report(entity,EDS,xls_file,sheet)
 EXAMPLE:
   output_report = climada_EDS_ED_per_category_report(entity,climada_EDS_calc(entity,hazard))
 INPUTS:
   entity: climada entity structure, with fields entity.assets.Category and entity.assets.Unit
   EDS: either an event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       SPECIAL: we also accept a structure which contains an EDS, like
       measures_impact.EDS
       if EDS has the field annotation_name, the legend will show this
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   xls_file: filename (and path) to save the report to (as .xls), if
       empty, prompted for.Can be set to 'NO_xls_file' to omit creation of
       xls file instead only creates the cell &quotoutput_report&quot
   sheet: sheet name for xls file, if empty, default excel name is &quotSheet1&quot
   summary: Shortens teh code and suppresses some outputs, so it can be used by salvador_results_overview  
 OUTPUTS:
   output_report: cell including header and ED values
   report file written as .xls
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150806, init
 Lea Mueller, muellele@gmail.com, 20150831, introduce benefit_flag to calculate benefit (difference AED with measure and AED without measure)
 Lea Mueller, muellele@gmail.com, 20150831, rename climada_assets_select from salvador_assets_select
 Lea Mueller, muellele@gmail.com, 20150831, enhance to cope with multiple EDS
 Lea Mueller, muellele@gmail.com, 20150910, enhance to cope with Category names (cell) instead of numbers
 Lea Mueller, muellele@gmail.com, 20150915, add assets_flag to write out sum of entity.assets.Value per category, as specified in EDS(EDS_i).assets.filename
 Lea Mueller, muellele@gmail.com, 20150922, add filenames (entity.assets, entity.damagefunctions, entity.discount, entity.measures and EDS.hazard)
 Lea Mueller, muellele@gmail.com, 20150924, set silent_mode for climada_assets_select
 Jacob Anz,   j.anz@gmail.com,    20150929, add summary input so it can be executed with salvador_results_overview   
 Lea Mueller, muellele@gmail.com, 20151106, rename to climada_EDS_ED_per_category_report from salvador_EDS_ED_per_category_report
 Lea Mueller, muellele@gmail.com, 20151106, move to core
 Lea Mueller, muellele@gmail.com, 20151117, add try statement for filenames of assets, damagefunction, etc.
 Lea Mueller, muellele@gmail.com, 20151217, get category_criterium from entity.assets.Category_name
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_EDS_ED_per_category_report.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_combine">
<H2>climada_EDS_combine</H2></A>
<font color="blue">function [EDS,ok]=climada_EDS_combine(EDS,EDS2,force_combination,verbose) </font>
 climada EDS combine
 MODULE:
   core
 NAME:
   climada_EDS_combine
 PURPOSE:
   Combine two event damage sets (EDS), i.e. add damages. You can either
   pass one array of EDSs in EDS, in which case all matching EDSs within are
   combined (even if they are not stored at subsequent positions), or you
   can pass EDS and EDS2, in which case the code first combines any
   matching EDSs in EDS and then adds from EDS2.
   In this latter case, please make sure the 'main' peril(s) are
   in EDS (e.g. TC in EDS, TS in EDS2). Note that ONLY damages are
   added, we do NOT add Value/assets, as most often the sub-peril is on
   the same asset base. Hence edit the resulting EDS yourself in case
   Value should be additive.

   call before: climada_EDS_calc, e.g.
       EDS(1)=climada_EDS_calc, EDS(2)=climada_EDS_calc ...
   see also: country_risk_EDS_combine (climada module country_risk)
 CALLING SEQUENCE:
   [EDS,ok]=climada_EDS_combine(EDS,EDS2,force_combination,verbose)
 EXAMPLE:
   EDS=climada_EDS_combine(EDS)
 INPUTS:
   EDS: a climada EDS (as returned eg by climada_EDS_calc)
       if EDS is in fact an array of EDS(i), the code will combine all
       matching EDSs within (e.g. TC and TS, if damage vector is of same length)
       This way, climada_EDS_combine can be called once to sum up all
       matching EDSs.
 OPTIONAL INPUT PARAMETERS:
   EDS2: a climada EDS (as returned eg by climada_EDS_calc)
       if EDS2 is an array of EDS2(i), the code will recursively treat
       them. Please note that more complex cases need to be treated using
       only EDS (e.g. sub-perils not following each other in sequence in
       the EDS).
   force_combination: also combine if ok=0 upon return when combining
       recursively. Default=1, Set =0 to only combine EDSs that match
       perfectly (i.e. same reference_year and event_ID)
   verbose: =1 print information about combining to stdout, =0 only print
       errors, othwerwise silent
 OUTPUTS:
   EDS: the combined EDS
       Please note that assets are just taken from the first EDS(i) of each
       (sub) hazard. 
   ok: =1 if combination successful, =0 otherwise, also if the basic
       combination worked (same length of damage vector), but some issues
       with either ED_at_centroid, reference_year, frequency or event_ID
       occurred. In some instances, it might still be justified to use the
       combined EDS, even if ok=0 upon return.
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150114, initial
 David N. Bresch, david.bresch@gmail.com, 20150203, array of EDSs and empty EDS2 allowed
 David N. Bresch, david.bresch@gmail.com, 20150215, Value taken from EDS, not added
 David N. Bresch, david.bresch@gmail.com, 20151231, major overhaul, mastering complex cases, like many sub-perils at once
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_EDS_combine.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_load">
<H2>climada_EDS_load</H2></A>
<font color="blue">function EDS = climada_EDS_load(EDS) </font>
 climada
 NAME:
   climada_EDS_load
 PURPOSE:
   load a previously saved EDS (just to avoid typing long paths and
   filenames in the cmd window)
 CALLING SEQUENCE:
   EDS = climada_EDS_load(EDS)
 EXAMPLE:
   EDS = climada_EDS_load(EDS)
 INPUTS:
   EDS: the filename with path of a previously saved EDS, see
       climada_EDS_save. If no path provided, default path ../data/results is used
       (and name can be without extension .mat)  
       &ampgt promted for if not given
       OR: a EDS structure, in which case it is just returned (to allow
       calling climada_EDS_load anytime, see e.g. climada_DFC_fit)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   EDS: a struct, see e.g. climada_EDS_calc for details
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091230
 David N. Bresch, david.bresch@gmail.com, 20130316, ELS-&ampgtEDS...
 Lea Mueller, muellele@gmail.com, 20160307, enhance to work with complete EDS as input, similar to climada_hazard_load
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_EDS_load.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_save">
<H2>climada_EDS_save</H2></A>
<font color="blue">function climada_EDS_save(EDS,EDS_save_file,EDS_default) </font>
 climada
 NAME:
   climada_EDS_save
 PURPOSE:
   save an EDS to a .mat file (just to avoid typing long paths and
   filenames in the cmd window)
 CALLING SEQUENCE:
   climada_EDS_save(EDS,EDS_save_file)
 EXAMPLE:
   climada_EDS_save(EDS,EDS_save_file)
 INPUTS:
   EDS: the event damage set (EDS), see e.g. climada_EDS_calc
   EDS_save_file: the filename to save the EDS in
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   EDS saved to a .mat file
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091230
 David N. Bresch, david.bresch@gmail.com, 20130316, ELS-&ampgtEDS...
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_EDS_save.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_stats">
<H2>climada_EDS_stats</H2></A>
<font color="blue">function EDS = climada_EDS_stats(EDS, EDS_save_file, return_period, check_plot) </font>
 calculating return periods with their corresponding EL
 NAME:
   climada_EDS_stats
 PURPOSE:
   calculating return periods with their corresponding event damage from the EDS
   file
 CALLING SEQUENCE:
   EDS_stats = climada_EDS_stats(EDS, EDS_save_file, return_period)
 EXAMPLE:
   EDS_stat=climada_EDS_stats(EDS,EDS_stat.mat,50)
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   EDS: Event damage set, see climada_EDS_calc(entity, hazard)
       &ampgt promted for if not given
   EDS_save_file: the name of the EDS return periods file
       &ampgt promted for if not given
   return_period: user defined return periods
       &ampgt calculates predefined return periods if not given
   check_plot: whether we show a check plot (=1) or not (=0), default=0
 OUTPUTS:
   EDS, the event damage set with:
       reference_year   : the year the damages are references to
       event_ID(event_i): the unique ID for each event_i
       damage(event_i)    : the damage amount for event_i
       Value            : the sum of allValues used in the calculation (to e.g. express
                          damages in percentage of total Value)
       frequency(event_i)      : the per occurrence event frequency for each event_i
       orig_event_flag(event_i): whether an original event (=1) or a
                                 probabilistic one (=0)
       hazard           : itself a structure, with:
                          .filename: the filename of the hazard event set
                          .comment : a free comment
       comment          : a free comment, contains time for calculation
       assets.filename  : the filename of the assets
       damagefunctions.filename: the filename of the damagefunctions
       annotation_name  : a kind of default title (sometimes empty)
       .AEL             : annual expected damage for the event set 
       .damage_sort       : downward sorted damages
       .damage_ori_sort   : downward sorted damages for original events 
       .R               : corresponding return periods for damage_sort 
       .R_ori           : corresponding return periods for damage_sort_orig
       .R_fit           : specified return periods
       .damage_fit        : damages for specified return periods
       .damage_fit_ori    : damages for specified return periods
 
 MODIFICATION HISTORY:
 Reto Stockmann, 20120813  
 Lea Mueller, 20120816
 David N. Bresch, david.bresch@gmail.com, 20130316, ELS-&ampgtEDS...
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_EDS_stats.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ED_plot">
<H2>climada_ED_plot</H2></A>
<font color="blue">function climada_ED_plot(EDS, percentage_of_value_flag,currency,unit_exp,logscale_check,schematic_check) </font>
 visualize Annual Expected Damage per centroid as a map
 NAME:
   climada_ED_plot
 PURPOSE:
   plot annual expected damage
 CALLING SEQUENCE:
   climada_ED_plot(EDS, percentage_of_value_flag)
 EXAMPLE:
   climada_ED_plot(EDS, percentage_of_value_flag)
 INPUTS:
   EDS, the event damage set with fields:
       reference_year: the year the losses are references to
       event_ID(event_i): the unique ID for each event_i
       damage(event_i): the loss amount for event_i
       Value: the sum of allValues used in the calculation (to e.g. express
           losses in percentage of total Value)
       frequency(event_i): the per occurrence event frequency for each event_i
       orig_event_flag(event_i): whether an original event (=1) or a
           probabilistic one (=0)
       comment: a free comment, contains time for calculation
       hazard: itself a structure, with:
           filename: the filename of the hazard event set
           comment: a free comment
       assets: struct with lon, lat, value and filename of assets
       damagefunctions.filename: the filename of the damage functions
       annotation_name: a kind of default title (sometimes empty)
 OPTIONAL INPUT PARAMETERS:
   percentage_of_value_flag: Set to 1 if you wish to plot damages as
                             percentage of asset values
   currency:   specify the currency unit, can be any string, e.g. 'EUR',
               default is 'USD'
   unit_exp:   specify the unit of the data (i.e. are the values in the 
               EDS struct in 10^3, 10^7 etc. The function automatically
               displays numbers in the best order of magnitude
 OUTPUTS:
   figure
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091228
 Gilles Stassen, gillesstassen@hotmail.com, 20150519 - update and cleanup
 Gilles Stassen, gillesstassen@hotmail.com, 20150528 - currency, unit_exp input args added
 Gilles Stassen, gillesstassen@hotmail.com, 20150528 - logscale_check added
 Gilles Stassen, gillesstassen@hotmail.com, 20150619 - sum damages at non-unique coords, caxis for logscale bug fix
 Gilles Stassen, gillesstassen@hotmail.com, 20150629 - schematic_check added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_ED_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_IFC_plot">
<H2>climada_IFC_plot</H2></A>
<font color="blue">function climada_IFC_plot(IFC,hist_check,check_log,color_index) </font>
 climada
 NAME:
   climada_IFC_plot
 PURPOSE:
   Plots the intensity frequency curve of a given hazard set. See
   climada_hazard2IFC to create the IFC structure to be plotted from a
   climada hazard set.
   Previous call: climada_hazard2IFC
 CALLING SEQUENCE:
   climada_IFC_plot(IFC,hist_check,prob_check,Gumbel_check,check_log,color_index)
 EXAMPLE:
   climada_IFC_plot(IFC,1,1,0,3)
   climada_IFC_plot(climada_hazard2IFC)
 INPUTS:
   IFC:  An intensity frequency curve structure, created using
       climada_hazard2IFC. Either one IFC or an array of structures, i.e. IFC(i)
 OPTIONAL INPUT PARAMETERS:
   hist_check: Whether to plot the historical data points  (default = 1)
   check_log: Whether to use logarithmic x (return period) axis (default = 0)
   color_index: Specify the color pair:
       1:  Red/orange
       2:  Blue/light blue
       3:  Green/light green
       4:  Violet/light violet
       5:  Dark orange/golden
       6:  Black/gray
 OUTPUTS:
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150130
 David N. Bresch, david.bresch@gmail.com, 20150309, bugfixes
 Lea Mueller, muellele@gmail.com, 20150318, changes according to hazard2IFC
 David N. Bresch, david.bresch@gmail.com, 20150405, IFC as struct array, white background
 Lea Mueller, muellele@gmail.com, 20160308, bugfix if no historical data
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_IFC_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_NPV">
<H2>climada_NPV</H2></A>
<font color="blue">function NPV=climada_NPV(values,discount_rates) </font>
 climada NPV
 NAME:
   climada_NPV
 PURPOSE:
   calculate net present value (NPV) of a temporal (yearly) series of
   values (e.g. costs)
 CALLING SEQUENCE:
   NPV=climada_NPV(values,discount_rates)
 EXAMPLE:
   NPV=climada_NPV([10 10 10],[0.02 0.02 0.02])
 INPUTS:
   values: the vector with values (any currency)
       value(1) corresponds to todays's value, value(end) to the
       futuremost value.
   discount_rates: the vector with discount rates (decimal)
       if not give, a zero discount rate is used
       if only a single number is given, this is used as the discount rate
       for all years
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   NPV: the net present value of values after application of the discount rates
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20100221
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_NPV.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_admin1_get_shapes">
<H2>climada_admin1_get_shapes</H2></A>
<font color="blue">function admin1_shape_selection = climada_admin1_get_shapes(admin0_name,admin1_name) </font>
 climada select shapes that belong to one or more admin1_name
 MODULE:
   climada/code/helper_functions
 NAME:
   climada_admin1_get_shapes
 PURPOSE:
   Get a selection of admin1_shapes based on admin1_name or select on a
   map. If you select the admin1 on the map, press &quotEnter&quot in the command
   line to complete the selection on the map. Invokes
   climada_admin1_select_on_map. Hint: If admin1_name is 'all', the entire
   admin1_shape is returned.
 CALLING SEQUENCE:
   admin1_shape_selection = climada_admin1_get_shapes(admin0_name,admin1_name)
 EXAMPLE:
   admin1_shape_selection = climada_admin1_get_shapes;
   admin1_shape_selection = climada_admin1_get_shapes('Vietnam');
   admin1_shape_selection = climada_admin1_get_shapes('Vietnam','Y??n B??i');
   admin1_shape_selection = climada_admin1_get_shapes('Vietnam',{'VNM-5483' 'VNM-458'});
   admin1_shape_selection = climada_admin1_get_shapes('','all'); % get all admin1_shapes
   admin1_shape_selection = climada_admin1_get_shapes('Vietnam','all'); % get all admin1_shapes in Vietnam
 INPUTS:
   admin0_name: the country name, either full or ISO3
       &ampgt If empty, a list dialog lets the user select (default)
   admin1_name: or admin1_code, if passed on, do not prompt for admin1 name
       &ampgt If empty, a list dialog lets the user select (default), if is set
       to 'all', the admin1_shape is returned. 
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   admin1_shape_selection: shape file (admin1_shapes) with selected admin1 only
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160224, init
 Lea Mueller, muellele@gmail.com, 20160229, add functionality 'all' to return the entire admin1_shape set
 Lea Mueller, muellele@gmail.com, 20160229, move to climada/helper_functions, rename to climada_admin1_get_shapes
 Lea Mueller, muellele@gmail.com, 20160316, make sure admin1_name is a cell
 Lea Mueller, muellele@gmail.com, 20160429, bugfix in input
 Lea Mueller, muellele@gmail.com, 20160429, add functionality 'all' to return the all admin1 for a given country
 Lea Mueller, muellele@gmail.com, 20160509, use case-insensitive ismember to compare admin1_names
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_admin1_get_shapes.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_admin1_select_on_map">
<H2>climada_admin1_select_on_map</H2></A>
<font color="blue">function listbox = climada_admin1_select_on_map(admin0_name,admin0_shapes,admin1_shapes) </font>
 climada select admin1 on a map
 MODULE:
   climada/code/helper_functions
 NAME:
   climada_admin1_select_on_map
 PURPOSE:
   Select admin1 or a multiple admin1 on a map for a given admin0_name
 CALLING SEQUENCE:
   listbox = climada_admin1_select_on_map(admin0_name)
 EXAMPLE:
   listbox = climada_admin1_select_on_map;
   listbox = climada_admin1_select_on_map('Vietnam');
   admin1_name = get(listbox,'UserData'); % use to identify the selected admin1_name
 INPUTS:
   admin0_name: admin0_name, e.g. 'Switzerland', 'Vietnam', prompted for
       if empty
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   listbox: a listbox handle, from where we can identify the selected
   admin1_name using
   admin1_name = get(listbox,'UserData')
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160224, init
 Lea Mueller, muellele@gmail.com, 20160229, move to climada/helper_functions, rename to climada_admin1_select_on_map
 Lea Mueller, muellele@gmail.com, 20160426, loop over single segments of polygons divided by nan
 Lea Mueller, muellele@gmail.com, 20160601, horizontal alignment of text in center
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_admin1_select_on_map.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_arrow">
<H2>climada_arrow</H2></A>
<font color="blue">function [h,yy,zz] = climada_arrow(varargin) </font>
 ARROW  Draw a line with an arrowhead.

  ARROW(Start,Stop) draws a line with an arrow from Start to Stop (points
        should be vectors of length 2 or 3, or matrices with 2 or 3
        columns), and returns the graphics handle of the arrow(s).

        A copy of arrow, just to fix the following 'bug':
        Undefined function 'arrow' for input arguments of type 'double'
        The present version does read double...

  ARROW uses the mouse (click-drag) to create an arrow.

  ARROW DEMO &amp ARROW DEMO2 show 3-D &amp 2-D demos of the capabilities of ARROW.

  ARROW may be called with a normal argument list or a property-based list.
        ARROW(Start,Stop,Length,BaseAngle,TipAngle,Width,Page,CrossDir) is
        the full normal argument list, where all but the Start and Stop
        points are optional.  If you need to specify a later argument (e.g.,
        Page) but want default values of earlier ones (e.g., TipAngle),
        pass an empty matrix for the earlier ones (e.g., TipAngle=[]).

  ARROW('Property1',PropVal1,'Property2',PropVal2,...) creates arrows with the
        given properties, using default values for any unspecified or given as
        'default' or NaN.  Some properties used for line and patch objects are
        used in a modified fashion, others are passed directly to LINE, PATCH,
        or SET.  For a detailed properties explanation, call ARROW PROPERTIES.

        Start         The starting points.                     B
        Stop          The end points.                         /|\           ^
        Length        Length of the arrowhead in pixels.     /|||\          |
        BaseAngle     Base angle in degrees (ADE).          //|||\\        L|
        TipAngle      Tip angle in degrees (ABC).          ///|||\\\       e|
        Width         Width of the base in pixels.        ////|||\\\\      n|
        Page          Use hardcopy proportions.          /////|D|\\\\\     g|
        CrossDir      Vector || to arrowhead plane.     ////  |||  \\\\    t|
        NormalDir     Vector out of arrowhead plane.   ///    |||    \\\   h|
        Ends          Which end has an arrowhead.     //&amplt-----&ampgt||      \\   |
        ObjectHandles Vector of handles to update.   /   base |||        \  V
                                                    E    angle||&amplt--------&ampgtC
  ARROW(H,'Prop1',PropVal1,...), where H is a                 |||tipangle
        vector of handles to previously-created arrows        |||
        and/or line objects, will update the previously-      |||
        created arrows according to the current view       --&ampgt|A|&amplt-- width
        and any specified properties, and will convert
        two-point line objects to corresponding arrows.  ARROW(H) will update
        the arrows if the current view has changed.  Root, figure, or axes
        handles included in H are replaced by all descendant Arrow objects.

  A property list can follow any specified normal argument list, e.g.,
  ARROW([1 2 3],[0 0 0],36,'BaseAngle',60) creates an arrow from (1,2,3) to
  the origin, with an arrowhead of length 36 pixels and 60-degree base angle.

  The basic arguments or properties can generally be vectorized to create
  multiple arrows with the same call.  This is done by passing a property
  with one row per arrow, or, if all arrows are to have the same property
  value, just one row may be specified.

  You may want to execute AXIS(AXIS) before calling ARROW so it doesn't change
  the axes on you; ARROW determines the sizes of arrow components BEFORE the
  arrow is plotted, so if ARROW changes axis limits, arrows may be malformed.

  This version of ARROW uses features of MATLAB 6.x and is incompatible with
  earlier MATLAB versions (ARROW for MATLAB 4.2c is available separately);
  some problems with perspective plots still exist.
 Copyright (c)1995-2009, Dr. Erik A. Johnson &ampltJohnsonE@usc.edu&ampgt, 5/20/2009
 http://www.usc.edu/civil_eng/johnsone/
 Lea Mueller, muellele@gmail.com, 20160428, update to version 2015
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_arrow.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_asci2hazard">
<H2>climada_asci2hazard</H2></A>
<font color="blue">function hazard = climada_asci2hazard(asci_file, row_count, utm_transformation) </font>
 climada_asci2hazard
 MODULE:
   climada core
 NAME:
   climada_asci2hazard
 PURPOSE:
   read hazard event asci files and transform to climada hazard structure, 
   asci files can be saved in climada/data/hazard/external_model_output or 
   climada/data/hazard/myfolder and named asci_filename1.asc, asci_filename2.asc,...
   Please manually add the following fields: .peril_ID, .units, .comment, 
   .orig_years, .frequency, .yyyy and .datenum. Default: Every event is set to one year, starting
   with 1-Jan-0001, 1-Jan-0002,...
 CALLING SEQUENCE:
   hazard=climada_asci2hazard(asci_file)
 EXAMPLE:
   hazard=climada_asci2hazard
 INPUTS: 
 OPTIONAL INPUT PARAMETERS:
   asci_file: prompted for if not given. Asci file is delimited by tabs
   (\t) and has 6 rows of information (ncols, nrows, xllcorner, yllcorner,
   cellsize, NODATA_value).
   utm_transformation: special case 'barisal' and 'salvador' to enable
   local coordinate system transformation to utm lat lon coordinates.
 OUTPUTS: hazard
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150313, init
 Lea Mueller, muellele@gmail.com, 20150326, changes for generalisation
 Lea Mueller, muellele@gmail.com, 20150511, row_count input added, 10 if empty
 Lea Mueller, muellele@gmail.com, 20150617, utm_tranformation added, to
              specific for barisal coordinate transformation and salvador
 Lea Mueller, muellele@gmail.com, 20150623, bugfix if not tranfomration needed
 Lea Mueller, muellele@gmail.com, 20150815, special case for San Salvador, where we get lon/lat min/max 
                                            directly from Maxime/GFA, thus ignoring xllorner and yllcorner
 Lea Mueller, muellele@gmail.com, 20150815, replace .asc with ext, so that txt-files can be processed as well
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_asci2hazard.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ascii_read">
<H2>climada_ascii_read</H2></A>
<font color="blue">function output = climada_ascii_read(asci_file,save_file,check_plot,delim) </font>
 climada_ascii_read
 MODULE:
   climada core
 NAME:
   climada_ascii_read
 PURPOSE:
   read asci file and store as struct with the following fields: .lon,
   .lat, .value, .comment
 CALLING SEQUENCE:
   output = climada_ascii_read(asci_file,save_file,check_plot,delim)
 EXAMPLE:
   output = climada_ascii_read(asci_file)
 INPUTS: 
 OPTIONAL INPUT PARAMETERS:
   asci_file: prompted for if not given. Asci file is delimited by tabs
   (\t) and has 6 rows of information (ncols, nrows, xllcorner, yllcorner,
   cellsize, NODATA_value).
 OUTPUTS: output structure with fields .lon, .lat, .value, .comment
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150511, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/climada_ascii_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_assets_category_ID">
<H2>climada_assets_category_ID</H2></A>
<font color="blue">function assets = climada_assets_category_ID(assets) </font>
 climada_assets_category_ID
 MODULE:
   core/helper_functions
 NAME:
   climada_assets_category_ID
 PURPOSE:
   Create category IDs (assets.Category_name, assets.Category_ID) and
   overwrite assets.Category with IDs. This is saves memory space.
 CALLING SEQUENCE:
   assets = climada_assets_category_ID(assets)
 EXAMPLE:
   assets = climada_assets_category_ID
   assets = climada_assets_category_ID('entity_template.xlsx')
   assets = climada_assets_category_ID(assets)
 INPUTS:
   assets: a climada assets structure (included in entity), contains
   fields .lon, .lat, .Value, .Category. If .Category is not given, this
   function does nothing. 
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151207, init
 Lea Mueller, muellele@gmail.com, 20151208, add Category_name and Category_ID also if field Category does not exist (.Category_name = 'All categories'; .Category_ID = ''; .Category = '';)
 Lea Mueller, muellele@gmail.com, 20151217, make sure assets.Category_name is a cell
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_assets_category_ID.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_assets_encode">
<H2>climada_assets_encode</H2></A>
<font color="blue">function entityORassets = climada_assets_encode(entityORassets,hazard,max_encoding_distance_m) </font>
 climada assets encode
 NAME:
   climada_assets_encode
 PURPOSE:
   encode an entity (an already read assets file)
   eoncoding means: map read data points to calculation centroids of
   hazard event set
   
   Accepts both entity or assets as well as hazard or centroids as input,
   output i therefore either entity (if entity on input) or assets (if
   assets on input)

   normally called from: climada_entity_read
   see also: climada_assets_encode_check
 CALLING SEQUENCE:
   entityORassets=climada_assets_encode(entityORassets,hazard,max_encoding_distance_m)
 EXAMPLE:
   assets=climada_assets_encode(climada_entity_load)
 INPUTS:
   entityORassets: an assets structure (such as entity.assets), see
       climada_entity_read. Or just the full entity (with assets in entity.assets)
       &ampgt prompted for if empty (promting for an entity, the assets within
       are then taken - in this case, instead of assets, the entity is
       returned in 'assets')
   hazard: either a hazard set (struct) or a hazard set file (.mat with a
       struct) or a centroid struct (as returned by climada_centroids_load or
       climada_centroids_read). hazard needs to have fields hazard.lon and
       hazard.lat, centroids fields centroids.lon and centroids.lat  
       &ampgt promted for if not given (select either a hazard event set or a
       centroids .mat file)
       if set to 'SKIP', do not encode, return original assets (used for
       special cases, where this way no need for if statements prior to
       calling climada_assets_encode)
       SPECIAL: centroids with centroid_ID&amplt0 (in either hazard.centroid_ID
       or centroids.centroid_ID) are not used in encoding.
       (this way the user can e.g. temporarily 'disable' centroids prior
       to passing them to climada_assets_encode by simply setting their
       centroid_ID=-1)
       NOTE: if isfield(centroids,'peril_ID') and FL some special rules apply
 OPTIONAL INPUT PARAMETERS:
   max_encoding_distance_m: the maximum distance to encode an asset
       location to a centroid (in meters, e.g. 1e5 for 100km). Default
       is climada_global.max_encoding_distance_m, or, if there is a field
       hazard.max_encoding_distance_m.
 OUTPUTS:
   the encoded assets, means locations mapped to calculation centroids
       new field assets.centroid_index added
       NOTE: in case an entity instead of assets was passed on input, the
       output is also the entity
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091227
 David N. Bresch, david.bresch@gmail.com, 20100107, revised, changed from entity.assets to assets
 David N. Bresch, david.bresch@gmail.com, 20141127, allows for assets OR entity as input
 David N. Bresch, david.bresch@gmail.com, 20141127, allows for hazard OR centroids as input
 Lea Mueller, muellele@gmail.com, 20150511, only for unique lon/lat values, essential speedup
 David N. Bresch, david.bresch@gmail.com, 20150610, Lea's speedup fixed
 Lea Mueller, muellele@gmail.com, 20150617, speedup works for both dimensions of entity.lats and .lons (1xn and nx1)
 David N. Bresch, david.bresch@gmail.com, 20150618, Lea's speedup fixed 2nd time (line 134)
 Lea Mueller, muellele@gmail.com, 20150805, define a maximum distance to hazard, otherwise centroid_index is set to 0 and no damage wil be calculated (see climada_EDS_calc)             
 David N. Bresch, david.bresch@gmail.com, 20150825, bug-fix to use centroids instead of hazard
 Lea Mueller, muellele@gmail.com, 20150915, set max_encoding_distance_m as input variable
 Lea Mueller, muellele@gmail.com, 20150916, add max_distance in waitbar text
 David N. Bresch, david.bresch@gmail.com, 20160606, max_distance_to_hazard renamed to max_encoding_distance_m and speedup
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_assets_encode.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_assets_encode_check">
<H2>climada_assets_encode_check</H2></A>
<font color="blue">function climada_assets_encode_check(assets,hazard) </font>
 climada assets encode
 NAME:
   climada_assets_encode_check
 PURPOSE:
   check an encoded assets or entity structure, i.e. whether the
   coordinates in the structure map well to the hazard centroids

   eoncoding means: map read data points to calculation centroids of
   hazard event set, see climada_assets_encode
 CALLING SEQUENCE:
   assets=climada_assets_encode_check(assets)
 EXAMPLE:
   climada_assets_encode_check(climada_entity_load)
 INPUTS:
   assets: a read assets OR an entity structure, see climada_entity_read
       &ampgt prompted for if empty (promting for an entity, the assets within
       are then taken)
 OPTIONAL INPUT PARAMETERS:
   hazard: a hazard to check against (optional, since the code tries to
       use the hazard as specified in assets.hazard.filename). If hazard
       is passed, assets.hazard.filename is ignored
       Default is no hazard on input, using assets.hazard.filename
 OUTPUTS:
   a plot, showing the encoding
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141219, initial
 David N. Bresch, david.bresch@gmail.com, 20141230, hazard as input option added
 David N. Bresch, david.bresch@gmail.com, 20150716, logical (line 72) fixed
 David N. Bresch, david.bresch@gmail.com, 20160606, small error in plot fixed
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_assets_encode_check.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_assets_read">
<H2>climada_assets_read</H2></A>
<font color="blue">function [assets,assets_save_file] = climada_assets_read(assets_filename,hazard) </font>
 climada assets read import
 NAME:
   climada_assets_read
 PURPOSE:
   read assets with .lon, .lat, .Values. climada_assets_encode is 
   automatically invoked.
   usually called from climada_entity_read, see climada_entity_read for
   more information. The field &quotValue&quot is
   mandatory otherwise assets are not read.

   The code invokes climada_spreadsheet_read to really read the data,
   which implements .xls and .ods files
   For .xls, the sheet names are dynamically checked, for .ods, the sheet
   names are hard-wired (see code), means for .ods, the sheet
   'assets' needs to exist.
 CALLING SEQUENCE:
   [assets,assets_save_file] = climada_assets_read(assets_filename,hazard)
 EXAMPLE:
   assets = climada_assets_read;
 INPUTS:
   assets_filename: the filename of the Excel (or .ods) file with the assets
       If no path provided, default path ../data/entities is used
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       &ampgt promted for if not given (out of climada_assets_encode)
       ='NOENCODE' or 'noencode': do not encode assets, see climada_assets_encode
 OUTPUTS:
    assets: a structure, with
           Latitude: the latitude of the values
           Longitude: the longitude of the values
           Value: the total insurable value
           Deductible: the deductible
           Cover: the cover
           DamageFunID: the damagefunction curve ID
   assets_save_file: the name the encoded assets got saved to
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151117, init from climada_entity_read to read only assets
 David Bresch, david.bresch@gmail.com, 20151119, bugfix for Octave to try/catch xlsinfo
 Lea Mueller, muellele@gmail.com, 20151127, add assets.region and assets.refence_year
 Lea Mueller, muellele@gmail.com, 20151207, return if already a complete assets structure as input
 Lea Mueller, muellele@gmail.com, 20151207, invoke climada_assets_category_ID
 david.bresch@gmail.com, 20160603, make sure we have 1xN arrays
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_assets_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_assets_select">
<H2>climada_assets_select</H2></A>
<font color="blue">function [is_selected,peril_criterum,unit_criterium,category_criterium] = climada_assets_select(entity,peril_criterum,unit_criterium,category_criterium,silent_mode) </font>
  Create a selection array to select a subset of asset locations
 MODULE:
   climada core
 NAME:
   climada_assets_select
 PURPOSE:
   Create a selection array to select a subset of asset locations, that
   match a peril, a unit and a category (e.g. FL, USD, Category 7). Selected assets must fullfil ALL
   criterias. However empty criterium will select all assets.
 CALLING SEQUENCE:
   is_selected = climada_assets_select(entity,peril_criterum,unit_criterium, category_criterium)
 EXAMPLE:
   is_selected = climada_assets_select(entity,'FL','USD',6)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   entity:  climada entity structure, with fields entity.assets.Value_unit
            and entity.damagefunctions.peril_ID
   peril_criterum: a string, e.g. 'FL' or 'TC'
   unit_criterium: a string, e.g. 'USD' or 'people'
   category_criterium: a string or a number, e.g. 7
   silent_mode: set to 1 if no fprintf output
 OUTPUTS:
   is_selected   : a logical array that points to the selected asset locations
   peril_criterum: a string or a cell, e.g. 'FL' or 'TC'
   unit_criterium: a string or a cell, e.g. 'USD' or 'people'
   category_criterium: a string, cell or a number, e.g. 7
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150730, init
 Lea Mueller, muellele@gmail.com, 20150731, add outputs for criteria, e.g. if select only
                'TC', unit_criterium will return all corresponding units, e.g. USD and people
 Lea Mueller, muellele@gmail.com, 20150831, rename to climada_assets_select
 Lea Mueller, muellele@gmail.com, 20150910, reshape selection vectors so that dimensions match
 Lea Mueller, muellele@gmail.com, 20150910, enhance to cope with Category names (cell) instead of numbers
 Lea Mueller, muellele@gmail.com, 20150924, add silent_mode option
 Lea Mueller, muellele@gmail.com, 20151106, move to core
 Lea Mueller, muellele@gmail.com, 20151120, make sure that category_criterium is a cell and not a char
 Lea Mueller, muellele@gmail.com, 20151202, replace strcmp with ismember for multiple category_criterium as a cell
 Lea Mueller, muellele@gmail.com, 20151203, set print_cat to 0 if category-criterium is a cell (and not numeric)
 Lea Mueller, muellele@gmail.com, 20151207, invoke climada_assets_category_ID (use assets.Category_name and assets.Category_ID)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_assets_select.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_cleanup">
<H2>climada_centroids_cleanup</H2></A>
<font color="blue">function ok=climada_centroids_cleanup </font>
 climada cleanup centroids
 MODULE:
   core
 NAME:
   climada_centroids_cleanup
 PURPOSE:
   moves all centroid files into centroid folder
   (in the past, they were stored in system folder)

   Note: this code is currently invoked ONCE by climada_init_vars. There,
   a small file ../system/climada_centroids_cleanup_done.txt is written to
   indicate successful execution. We will remove this cleanup in winter
   2015 latest.
 CALLING SEQUENCE:
   ok=climada_centroids_cleanup
 EXAMPLE:
   ok=climada_centroids_cleanup
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   ok: =1 if all done, see error messages else
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150819
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_centroids_cleanup.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_load">
<H2>climada_centroids_load</H2></A>
<font color="blue">function centroids=climada_centroids_load(centroids) </font>
 climada
 NAME:
   climada_centroids_load
 PURPOSE:
   load previously saved centroids (just to avoid typing long paths and
   filenames in the cmd window)
   Works also if the file contains an entity.

   Previous call: climada_centroids_read
 CALLING SEQUENCE:
   centroids_out=climada_centroids_load(centroids_file)
 EXAMPLE:
   centroids_out=climada_centroids_load(centroids_file)
 INPUTS:
   entity: the filename (and path, optional) of a previously saved centroids
       structure. If no path provided, default path ../data/centroids is used
       (and name can be without extension .mat or even without _entity.mat)
       &ampgt promted for if empty
       OR: a centroids structure, in which cas it is just returned (to allow
       calling climada_centroids_load anytime, see e.g. climada_EDS_calc)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   centroids_out: a struct, see e.g. climada_centroids_read for details
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20130719
 david.bresch@gmail.com, 20150804, allow for name without path on input
 david.bresch@gmail.com, 20150817, climada_global.centroids_dir
 david.bresch@gmail.com, 20160516, allow for filename without _centroids
 david.bresch@gmail.com, 20160528, fix for .mat extension
 david.bresch@gmail.com, 20160703, same full flexibility as climada_entity_load
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_centroids_load.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_plot">
<H2>climada_centroids_plot</H2></A>
<font color="blue">function climada_centroids_plot(centroids,country_name,plot_all) </font>
 plot centroids on a map, differentiate for coastal land areas,
 bufferzone, and further away (more inland and on sea)
 NAME:
   climada_centroids_plot
 PURPOSE:
   plot centroids on a map, differentiate for coastal land areas,
   bufferzone, and further away (more inland and on sea)
   next: diverse
 CALLING SEQUENCE:
   climada_centroids_plot(centroids,country_name)
 EXAMPLE:
   climada_centroids_plot(climada_centroids_load)
 INPUTS:
   centroids: centroids structure
       &ampgt prompts for already read centroids if empty
   country_name: name of the country (cell or string)
       Only used to label the plot
 OPTIONAL INPUT PARAMETERS:
   plot_all: if =1, plot all centroids (also grid) (default=0)
 OUTPUTS:
   plot
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20140205
 David N. Bresch, david.bresch@gmail.com, 20150203, renamed from climada_plot_centroids to climada_centroids_plot
 David N. Bresch, david.bresch@gmail.com, 20160514, plot_all added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_centroids_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_read">
<H2>climada_centroids_read</H2></A>
<font color="blue">function centroids = climada_centroids_read(centroids_filename, centroids_save_file, visualize, add_regular_grid) </font>
 climada measures read import
 NAME:
   climada_centroids_read
 PURPOSE:
   read the Excel file with the list of measures
 CALLING SEQUENCE:
   centroids = climada_centroids_read(centroids_filename)
 EXAMPLE:
   centroids = climada_centroids_read
   centroids = climada_centroids_read('','',1) % to plot
 INPUTS:
   centroids_filename: the filename of the Excel file with the centroids
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   centroids_save_file: filename for saving of centroids in
       ...\climada\system\... (default is Excel filename with ext .mat)
       'NO_SAVE' to suppress saving centroids
       'PROMPT' to prompt for via file dialog
   visualize: whether we plot the centroids on a map (=1) or not (=0, default)
   add_regular_grid: add a regular grid for plotting purposes (default=1)
 OUTPUTS:
   centroids: a structure, with (at least)
       lon  (1,:): the longitudes   
       lat   (1,:): the latitudes   
       centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091229
 Lea Mueller, 20110718
 David N. Bresch, david.bresch@gmail.com, 20120505, cleanup
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir and add_regular_grid as input parameter
 David N. Bresch, david.bresch@gmail.com, 20160514, lon/lat in header description updated
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_centroids_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_check_matfile">
<H2>climada_check_matfile</H2></A>
<font color="blue">function ok=climada_check_matfile(source_filename,mat_filename) </font>
 climada
 NAME:
   climada_check_matfile
 PURPOSE:
   check for existence of the .mat file (binary) version of the source
   file (source_filename, usually a .xls) and check for the .mat file
   being more recent than the source

   The code does NOT re-read the source_file, as this is context specific
   and the .mat file might contain more than the raw content of the source
   file
 CALLING SEQUENCE:
   ok=climada_check_matfile(source_filename,mat_filename)
 EXAMPLE:
   ok=climada_check_matfile
 INPUTS:
   source_filename: the source filename, most likely a .xls file that gets
       imported into climada and saved as .mat (binary)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   mat_filename: check for the given filename of the binary file
       if empty, use the source_filename with its extension replaced by
       .mat to check against
 OUTPUTS:
   ok: =1 if .mat file exists and is more recent than source file
       =0 if .mat file does not exist or if source file is more recent
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141104
 David N. Bresch, david.bresch@gmail.com, 20141208, datenum_mat-datenum_source&ampgt=0
 Lea Mueller, muellele@gmail.com, 20150305, datenum taken automatically
 from file (for source and mat_file), due to problems with German version
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_check_matfile.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_circle_plot">
<H2>climada_circle_plot</H2></A>
<font color="blue">function climada_circle_plot(values,lon,lat,title_str,circle_diam,circle_format,marker_size,marker_format,overlay_plot,axis_range,max_value) </font>
 climada catos event damage hazard probabilistic stochastic
 NAME:
   climada_circle_plot
 PURPOSE:
   plot circles with diameters scaled by values
   in the range min(values)..max(values)
   the routine does not open a new figure if one exists

   see climada_circle_plot_legend for a legend to this plot

   %% precedes a switched off option, not a comment

 CALLING SEQUENCE:
   climada_circle_plot(values,lon,lat,title_str,circle_diam,circle_format,marker_size,marker_format,overlay_plot,axis_range,max_value);
 EXAMPLE:
   climada_circle_plot('Test',lon,lat,values,10)
 INPUTS:
   values(i): the values to display
   lon(i),lat(i): the coordinates of the values (same length as values)
   title_str: plot title
 OPTIONAL INPUT PARAMETERS:
   circle_diam: max diameter of the circles, default=10
   circle_format: format as in plot, like 'or' for red circles, default='or'
   marker_size: size of markers denoting centers, default=2
   marker_format: format as in plot, default='+b'
   overlay_plot: if set to 1, only do an overlay, no country borders...,
       default=0
   axis_range: if set [min(lon) max(lon) min(lat) max(lat)], otherwise
       determined in the function
   max_value: if set, use this value to scale circle diameters, otherwise
       max(values) is used
 OUTPUTS:
   figure
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120430
 David N. Bresch, david.bresch@gmail.com, 20141213, plot zooms to relevant area
 David N. Bresch, david.bresch@gmail.com, 20150206, cleanup
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_circle_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_code_copy">
<H2>climada_code_copy</H2></A>
<font color="blue">function climada_code_copy(verbose) </font>
 climada code copy
 NAME:
   climada_code_copy
 PURPOSE:
   Copy all climada code and code of all active modules into a new folder
   structure for easy exchange (e.g. to be zipped and sent by email).
   Overwrites any existing climada_code_bucket folder (in order to have a
   clean code version, delete any possibly existing climada_code_bucket
   folder before calling)

   It's mainly intended to be used to support users unable to get git
   installed. That's why there is no 'code extract' or the like, as the
   local names of the user's repositories might differ etc.

   see also climada_git_pull_repositories (recommended for all with local
   git installed, since much more comprehensive, user-friendly etc.)
   
   and climada_code_update, which updated local code based on the
   climada_code_bucket created by climada_code_copy
 CALLING SEQUENCE:
   climada_code_copy(verbose)
 EXAMPLE:
   climada_code_copy
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   verbose: if =1, lost copied files to stdout
       if =2, only list filenames, without folder
       if =0, silent, only notify errors (default)
 OUTPUTS:
   writes a folder [climada_global.root_dir]\climada_code_bucket with code
       for core climada and modules as sub-folders
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141105
 David N. Bresch, david.bresch@gmail.com, 20141107, cleanup (on flight to Dubai)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_code_copy.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_code_optimizer">
<H2>climada_code_optimizer</H2></A>
<font color="blue">function climada_code_optimizer(code_file) </font>
 climada
 NAME:
   climada_code_optimizer
 PURPOSE:
   optimize climada code by removing waitbars etc. Very simple mechanisms,
   just any line which comprises the tag % CLIMADA_OPT is removed
   so the optimization is fully controlled by the programmer
 CALLING SEQUENCE:
   climada_code_optimizer(code_file)
 EXAMPLE:
   climada_code_optimizer
 INPUTS:
   code_file: the code file to be optimized
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   the optimized, code, _OPT added at the end (prior to the suffix)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091228
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_code_optimizer.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_code_update">
<H2>climada_code_update</H2></A>
<font color="blue">function climada_code_update(code_bucket_folder) </font>
 Import the latest climada code update
 NAME:
	climada_code_update
 PURPOSE:
   Automate the import of updated climada code files.

   NOTE: For this routine to work, it is assumed that the existing
   climada module directories are of the form climada_module_x_x. The code
   in these directories should be stored in a subfolder named 'code'.
   Finally, this function relies on the fact that the name of the climada
   module dirs, i.e. climada_module_x_x, is contained within the name of
   the respective folder in climada_code_bucket.

   See climada_code_copy, which copies all climada code and code of all
   active modules into a new folder structure for easy exchange (e.g. to
   be zipped and sent by email).
 CALLING SEQUENCE:
   climada_code_update(code_bucket_folder)
 EXAMPLE:
   climada_code_update(code_bucket_folder)
   climada_code_update
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   code_bucket_folder: Specify the path of the unzipped climada code
       bucket, containing the code files to be extracted and copied into
       the climada code folders.
 OUTPUTS:
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com 20141124
 David N. Bresch, david.bresch@gmail.com, 20141125, reference to climada_code_copy added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_code_update.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_collect_measures_impact">
<H2>climada_collect_measures_impact</H2></A>
<font color="blue">function impact_collected=climada_collect_measures_impact(impact1,impact2) </font>
climada
 NAME:
   climada_collect_measures_impact
 PURPOSE:
   collect impact files for two hazards created by climada_measures_impact
   next step: climada_adaptation_cost_curve

   1. sum up benefit (loss averted) for shared measures
   2. cost of shared measures - take higher costs if costs not the same --&ampgt WARNING
   3. It is assumed that the two hazards are insured separately, therefore
       make sure to not use the same name for both hazards e.g. risk_transfer_rain
       and risk_transfer_wind. If one insurance covers both hazards sum up the losses
       of both hazards, apply the risk transfer and calculate the NPV of
       the benefits and the premium

 CALLING SEQUENCE:
   impact_collected=climada_collect_measures_impact(impact1,impact2))
 INPUTS:
   impact: 2 struct files with impact on ELS of differnet adaptation measures
   see climada_measures_impact
       &ampgt promted for if not given
 OUTPUTS:
   impact_collected: struct file which includes the impact of both shared
   and unique measures.

   -   new cost benefit ratios: for shared measures the benefits
       were summed up and the costs taken only once (if costs are not the
       same the higher ones are taken -&ampgtwarning)

   -   Risk transfer was not changed asuming that the two hazards are
       insured separately.

   EL(measure_i): the annual expected loss to the assets under measure_i
   benefit(measure_i):NPV of the benefit of measure_i
   cb_ratio(measure_i):initial cost or NPV of insurance premium (for risk transfer only)
                       divided by NPV of benefit (averted loss) of measure_i
   measures: just a copy of measures, so we have all we need together
   risk_transfer: NPV of insurance rate (risk transfer costs)
   NPV_total_climate_risk: NPV of loss without measures
   EL: annual unmitigated loss (no measures)
   title_str: a meaningful title stating the two collected impacts

 MODIFICATION HISTORY:
 Martin Heynen, 20120313
 david.bresch@gmail.com, 20140804, GIT update
 david.bresch@gmail.com, 20141020, moved from tc_rain to core climada
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_collect_measures_impact.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_color_plot">
<H2>climada_color_plot</H2></A>
<font color="blue">function fig = climada_color_plot(values,lon,lat,figure_name,title_str,plot_method,interp_method,npoints,plot_centroids,caxis_range,cmap,stencil_ext) </font>
 color plot
 NAME:
   climada_color_plot
 PURPOSE:
   helper function to make nice color plot
   does only show values in the vicinity of the hazard zone centroids

   for speed up, if one gives the npoints negative, the mask is stored

   %% precedes a switched off option, not a comment

 CALLING SEQUENCE:
   climada_color_plot(values,lon,lat,figure_name,title_str,plot_method,interp_method,npoints)
 EXAMPLE:
   climada_color_plot(mean(hazard.intensity,2),hazard.lon,hazard.lat)
 INPUTS:
   values(i): values
   lon(i),lat(i): coordinates of values, same length as values
   interactive_mode: 'interactive' allows for GUIs
 OPTIONAL INPUT PARAMETERS:
   figure_name: name of the figure window, if set to 'none', no figure is opened
   title_str:plot title
   plot_method: 'pcolor', 'contour', 'plotclr', default is matrix
   interp_method: method in griddata, like 'linear', 'cubic',...
   npoints: the number of points used
   plot_centroids: if set to 0, do not plot dentroids as red dots
       (default=1)
   caxis_range: [min max] data values for constant color bars
   stencil_ext: to extend the stencil range (in units of the target grid,
       default=0
 OUTPUTS:
   makes new figure
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120430
 Lea Mueller, muellele@gmail.com, 20151124, add fig output
 Lea Mueller, muellele@gmail.com, 20151130, add plotclr option
 Lea Mueller, muellele@gmail.com, 20151130, set marker to '' so it is taken from climada_global.marker
 Lea Mueller, muellele@gmail.com, 20150226, correct type (contourF instead of contour)
 Lea Mueller, muellele@gmail.com, 20160229, introduce climada_global.admin1_plot, if 1, show all admin1 lines
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
 Lea Mueller, muellele@gmail.com, 20160314, add figure scale (climada_figure_scale_add)
 Lea Mueller, muellele@gmail.com, 20160314, add caxis_range (also for contourf)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_color_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_colormap">
<H2>climada_colormap</H2></A>
<font color="blue">function [cmap, c_ax] = climada_colormap(peril_ID, steps10) </font>
 climada color map
 NAME:
   climada_colormap
 PURPOSE:
   a helper function, returns a color map for specified perils, if empty
   peril ID cmap jet is returned
 CALLING SEQUENCE:
   cmap = climada_colormap(peril_ID)
 EXAMPLE:
   cmap = climada_colormap('TC')
 INPUTS:
   peril_ID: a peril ID, currently implemented are TC, TS, TR, FL, LS, FS (factor of safety), 
   can also be assets, damage, schematic or benefit (averted damage).
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141121, raw documentation
 Lea Mueller, muellele@gmail.com, 20140429, add colormaps for damage and schematic
 Lea Mueller, muellele@gmail.com, 20140429, add waterfall colormap
 Lea Mueller, muellele@gmail.com, 20150522, add mudslides (MS) colormap
 Lea Mueller, muellele@gmail.com, 20150607, add benefit colormap (grey-green) for averted damage in climada_MI_plot
 Lea Mueller, muellele@gmail.com, 20150713, add LS colormap
 Lea Mueller, muellele@gmail.com, 20150720, add FS (factor of safety) colormap
 Lea Mueller, muellele@gmail.com, 20150729, add assets colormap
 Lea Mueller, muellele@gmail.com, 20150729, add measures colormap
 Lea Mueller, muellele@gmail.com, 20150922, add benefit for adaptation bar chart colormap
 Lea Mueller, muellele@gmail.com, 20150924, special case if only one colour is required
 Lea Mueller, muellele@gmail.com, 20151201, update benefit colors (grey, yellow, green, turqoise)
 Lea Mueller, muellele@gmail.com, 20160201, add excess or rain (XR), lack of rain (LR) and lack of greenness (LG)
 Lea Mueller, muellele@gmail.com, 20160314, for TS and XR use only 8 colors (3 green, 5 blue)
 Lea Mueller, muellele@gmail.com, 20160316, add separate lack of greenness (LG) colormap (brown - yellow - green)
 Lea Mueller, muellele@gmail.com, 20160426, finetune lack of greenness colors
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_colormap.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_concatenate_lon_lat">
<H2>climada_concatenate_lon_lat</H2></A>
<font color="blue">function lonlat = climada_concatenate_lon_lat(lon, lat) </font>
 climada_concatenate_lon_lat
 MODULE:
   climada core
 NAME:
   climada_concatenate_lon_lat
 PURPOSE:
   Concatenate two vectors lon and lat into one matrice with lonlat 
 CALLING SEQUENCE:
   lonlat = climada_concatenate_lon_lat(lon, lat)
 EXAMPLE:
   lonlat = climada_concatenate_lon_lat(lon, lat)
 INPUTS: 
   lon            : a vector, either 1xn or nx1
   lat            : a vector, either 1xn or nx1, must be same numel as lon
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:      
   lonlat         : a matrix containing lonlat information, where
                    lonlat(:,1) = lon and lonlat(:,2) = lat
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150724, init
 Lea Mueller, muellele@gmail.com, 20151106, move to core
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_concatenate_lon_lat.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_country_name">
<H2>climada_country_name</H2></A>
<font color="blue">function [country_name,country_ISO3,shape_index] = climada_country_name(input_name) </font>
 check country name ISO3
 MODULE:
   core climada
 NAME:
   climada_country_name
 PURPOSE:
   check for valid country name or valid ISO3 country code and return both
   (hence it can also be used to get the respective code or full name)
 CALLING SEQUENCE:
   [country_name,country_ISO3,shape_index] = climada_country_name(input_name)
 EXAMPLE:
 	[country_name,country_ISO3,shape_index] = climada_country_name('Switzerland')
   climada_country_name % to return a list of all valid country names (and their ISO3 codes)
 INPUTS:
   input_name: name of country (string) or an ISO3 code (needs to be uppercase, like 'CHE')
       if ='ALL' or empty, write all country names and the corresponding
       ISO3 codes to stdout and return the full name, ISO and index list
       if ='all', as 'ALL', but do not write the list to stdout
       if ='Single' or 'Multiple', select single country or multiple
       countries from a list dialog
 OUTPUTS:
   country_name: country name(s), empty string if no match
   country_ISO3: country ISO3 code(s) (like 'CHE'), empty if no match
   shape_index: index(s) of the corresponding shapes (of the file as in climada_global.map_border_file
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20141016
 David N. Bresch, david.bresch@gmail.com, 20141209, ISO3 country code added
 David N. Bresch, david.bresch@gmail.com, 20141211, switched to admin0 instead of world*.gen
 Lea Mueller, muellele@gmail.com, 20141016, compare with strcmpi to find valid country names
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_country_name.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_damage_exceedence">
<H2>climada_damage_exceedence</H2></A>
<font color="blue">function [sorted_damage,exceedence_freq,cumulative_probability,sorted_freq,event_index_out]=climada_damage_exceedence(event_damage,event_freq,event_index) </font>
 climada event damage hazard probabilistic stochastic
 NAME:
   climada_damage_exceedence
 PURPOSE:
   sort the damages descendingly
   calculate the exceedence frequency
   calculate the cumulative probability

 CALLING SEQUENCE:
   [damage,exceedence_freq,cumulative_probability]=climada_damage_exceedence(event_damage,event_freq);
 EXAMPLE:
   [damage,exceedence_freq,cumulative_probability]=climada_damage_exceedence([10 1000 100],[0.1 0.001 0.01]);
 INPUTS:
   event_damage: event damages (array)
   event_freq: occurrence frequency of each event damage (array)
 OPTIONAL INPUT PARAMETERS:
   event_index: the event_ID for each event_damage
 OUTPUTS:
   sorted_damage:   sorted damages (descendingly)
   exceedence_freq: exceedence frequency for each damage
   cumulative_probability: cumulative probability of each damage
   sorted_freq: frequency sorted as event damages
   event_index_out: event_index sorted as damages (only if provided input)
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120430
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_damage_exceedence.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_damagefunctions_check">
<H2>climada_damagefunctions_check</H2></A>
<font color="blue">function entity_out = climada_damagefunctions_check(entity,hazard,silent_mode) </font>
 climada_damagefunctions_check
 NAME:
   climada_damagefunctions_check
 PURPOSE:
   Given an entity.damagefunctions structure we check that we have defined 
   MDD and PAA values for occurring hazard intensities. If MDD and PAA are
   only defined for smaller intensity values, entity.damagefunction fields
   are enlarged by an additional line (for .Intentiy, .MDD, .PAA, etc.)

   can be called from: climada_EDS_calc if set to sanity_check
 CALLING SEQUENCE:
   entity = climada_damagefunctions_check(entity,hazard)
 EXAMPLE:
   entity = climada_damagefunctions_check(entity,hazard)
 INPUTS:
   entity: an entity structure or an entity .mat file, see climada_assets_encode(climada_assets_read)
       If a file and no path provided, default path ../data/entities is
       used (and name can be without extension .mat)
       &ampgt promted for if not given
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       If a file and no path provided, default path ../data/hazards is
       used (and name can be without extension .mat)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   entity with enlarged entity.damagefunctions fields (.Intentiy, .MDD, .PAA, etc.)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150907, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_damagefunctions_check.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_damagefunctions_generate">
<H2>climada_damagefunctions_generate</H2></A>
<font color="blue">function [damagefunctions,dmf_info_str]=climada_damagefunctions_generate(intensity,dmf_min_intens,dmf_exp,dmf_max,dmf_shape,peril_ID,check_plot) </font>
 climada_damagefunctions_generate
 MODULE:
   core
 NAME:
   climada_damagefunctions_generate
 PURPOSE:
   Generate damagefunctions

   See also: climada_damagefunctions_map and _plot ...
 CALLING SEQUENCE:
   damagefunction=climada_damagefunctions_generate(intensity,dmf_min_intens,dmf_exp,dmf_max,dmf_shape,peril_ID,check_plot)
 EXAMPLE:
   damagefunction=climada_damagefunctions_generate(0:10:120,20,3,1,'exp','TC')
   damagefunction=climada_damagefunctions_generate([],20,1,0.5,'s-shape','TC',1)
 INPUTS:
   intensity: the hazard intensity scale, i.e. the horizontal axis of the
       damage function. Any vector of intensities, ascending in value,
       such as 1:10:100
   dmf_min_intens: minimum intensity for MDD and PPA &ampgt0, default=0
   dmf_exp: the exponent of the damage function, see also shape
   dmf_max: the maximum value of MDD (and PAA), default=1
   dmf_shape: the shape of the damage function, implemented are (the
   damagefunction are always normalized such that MDD(max intensity=1):
       'exp' for expoential shape, i.e.
       MDD=(intensity-dmf_min_intens)^dmf_exp
       's-shape' for an S-shaped damage function, satrting a
       dmf_min_intens and 'skewed by dmf_exp
   peril_ID: the 2-digit peril_ID, such as 'TC','EQ',...
 OPTIONAL INPUT PARAMETERS:
   check_plot: =1 to show a check plot (using
       climada_damagefunction_plot) or not (=0, default)
       plots on the same plot on sunsequent calls to allow for easy
       comparison of say two options
 OUTPUTS:
   damagefunction: a structure with
       filename: just for information, here 'climada_damagefunctions_generate'
       Intensity(i): the hazard intensity (a vector)
       DamageFunID(i): =ones(1,length(Intensity)
       peril_ID{i}: a cell array with peril_ID
       MDD(i): the mean damage degree value for Intensity(i)
       PAA(i): the percentage of affected assets for Intensity(i)
   dmf_info_str: the parameters returned as a string (e.g. for annotation),
       in the form 'shape dmf_max*(i-dmf_min_intens)^dmf_exp'
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150211, initial
 Lea Mueller, muellele@gmail.com, 20160212, rename to climada_damagefunctionS_generate instead of without s
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_damagefunctions_generate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_damagefunctions_map">
<H2>climada_damagefunctions_map</H2></A>
<font color="blue">function entity=climada_damagefunctions_map(entity,damagefunctions,damagefunctions_map) </font>
 climada
 NAME:
   climada_damagefunctions_map
 PURPOSE:
   Given an encoded entity, map damagefunctions, e.g. after reading
   alternative damagefunctions with climada_damagefunction_read

   If only entity is entered, the current DamageFunIDs in entity.assets
   and entity.damagefunctions are shown.

   If both entity and damagefunctions are passed, but no map,
   the DamageFunIDs in both entity and damagefunctions are shown.

   Only if a valid damage function map is passed, the mapping effectively
   happens. After mapping, the consistency is checked (a damagefunction
   definition for each DamageFunID). Please note that the mapping occurs
   independent of peril_ID (this is correct, since this alows to analyze
   the same assets with different perils).

   See also climada_damagefunctions_read and climada_damagefunctions_plot
   and climada_damagefunctions_replace
 CALLING SEQUENCE:
   entity=climada_damagefunctions_map(entity,damagefunctions,damagefunctions_map)
 EXAMPLE:
   entity=climada_damagefunctions_map(entity,damagefunctions,'1to3;2to4');
   entity=climada_damagefunctions_map(entity,'1to3;2to4');
 INPUTS:
   entity: an entity, see climada_entity_read
       &ampgt promted for if not given (calling climada_entity_load, not
       climada_entity_read)
 OPTIONAL INPUT PARAMETERS:
   damagefunctions: see climada_damagefunctions_read, a struct with damage
       functions. If one does not need to pass on new damage functions,
       one can also pass the damagefunctions_map in this variable (see 2nd
       EXAMPLE above). This option comes handy, if one stores several
       damagefunctions in entity.damagefunctions and uses this code to
       switch between.
   damagefunctions_map: the damagefunction map, either
       - a string with the mappings, e.g.
       '1to3;2to4', as in the entity.measures.damagefunctions_map
       - or a structure as in entity.measures.damagefunctions_mapping with
       fields map_from and map_to, such that we map map_from(i) to map_to(i)
       If empty, the DamageFunIDs in both entity and damagefunctions are
       shown, but no mapping actually occurs.
 OUTPUTS:
   entity: the entity with damagefunctions mapped (and damagefunction
       definitions taken from damagefunctions, if passed)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141121, ICE
 David N. Bresch, david.bresch@gmail.com, 20141212, ID format switched to 3.3i
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_damagefunctions_map.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_damagefunctions_plot">
<H2>climada_damagefunctions_plot</H2></A>
<font color="blue">function res=climada_damagefunctions_plot(entity,unique_ID_sel) </font>
 climada
 NAME:
   climada_damagefunctions_plot
 PURPOSE:
   Plot the damage functions within entity (if a damagefunctions struct is
   passed, it works, too).

   See also climada_damagefunctions_read and climada_damagefunctions_generate
 CALLING SEQUENCE:
   climada_damagefunctions_plot(entity,unique_ID_sel)
   climada_damagefunctions_plot(climada_damagefunctions_read)
 EXAMPLE:
   climada_damagefunctions_plot
 INPUTS:
   entity: an entity, see climada_entity_read
       &ampgt promted for if not given (calling climada_entity_load, not
       climada_entity_read)
       Works also, if just a damagefunctions structure is passed (i.e. the
       same as in entity.damagefunctions, as returned by
       climada_damagefunctions_read)
 OPTIONAL INPUT PARAMETERS:
   unique_ID_sel: a single unique ID or the first n characters of an ID to
       plot only selected damage function(s), as in the case of an entity
       containing many functions, the single panes of the plot might get
       too small). It is recommended to run climada_damagefunctions_plot 
       first without specifying a unique_ID_sel and inspect the single 
       sub-plot headers. Examples are:
       unique_ID_sel='TC 001' % print only the one curve
       unique_ID_sel='TC'     % print all TC curves
 OUTPUTS:
   a figure
   res: a structure with the last (and only the last) damagefunction, with
       fields Intensity, MDD, PAA, MDR for further use. Hence res only
       make sense when called with one unique ID.
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141121, ICE
 David N. Bresch, david.bresch@gmail.com, 20141214, unique_ID_sel added
 David N. Bresch, david.bresch@gmail.com, 20141221, MDR calculated locally and unique_ID_sel improved
 David N. Bresch, david.bresch@gmail.com, 20150206, res returned
 David N. Bresch, david.bresch@gmail.com, 20150225, datenum added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_damagefunctions_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_damagefunctions_read">
<H2>climada_damagefunctions_read</H2></A>
<font color="blue">function [damagefunctions,entity] = climada_damagefunctions_read(damagefunction_filename,entity) </font>
 climada damage function vulnerability read import
 NAME:
   climada_damagefunctions_read
 PURPOSE:
   read a file with damage functions (vulnerabilities), usually called in
   climada_entity_read, which reads a full entity file, i.e. assets, 
   damagefunctions, discount and measures. The field &quotIntensity&quot is
   mandatory otherwise damagefunctions are not read.

   The code invokes climada_spreadsheet_read to really read the data,
   which implements .xls and .ods files

   For .xls, the sheet names are dynamically checked, for .ods, the sheet
   names are hard-wired (see code), means for .ods, all the sheets
   'assets','damagefunctions','measures' and 'discount' need to exist.

   NOTE: For backward compatibility, the code does read OLD files
   with a tab vulnerability (instead of damagefunctions) and VulnCurveID ...
   It renames respective fields in the resulting structure.

   See also climada_damagefunction_map and climada_damagefunctions_plot
 CALLING SEQUENCE:
   damagefunctions = climada_damagefunctions_read(damagefunction_filename)
 EXAMPLE:
   damagefunctions = climada_damagefunctions_read
 INPUTS:
   damagefunction_filename: the filename of the Excel file with the assets
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   entity: if an entity is passed, it's entity.damagefunctions is replaced
       by the newly imported damagefunctions (EXPERT use, as the
       DamageFunID have to be consistent, the code warns at least). 
       See also climada_damagefunctions_map
 OUTPUTS:
   damagefunctions: a structure, with
           DamageFunID: the damagefunction curve ID
           Intensity: the hazard intensity
           MDD: the mean damage degree
   entity: the entity (as on input, with exchanged damagefuncions)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141121, ICE initial
 David N. Bresch, david.bresch@gmail.com, 20141221, damagefunctions.MDR removed
 Lea Mueller, muellele@gmail.com, 20151016, delete nans if there are invalid entries
 Lea Mueller, muellele@gmail.com, 20151119, read first sheet if sheet &quotdamagefunctions&quot is not found
 David Bresch, david.bresch@gmail.com, 20151119, bugfix for Octave to try/catch xlsinfo
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_damagefunctions_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_damagefunctions_replace">
<H2>climada_damagefunctions_replace</H2></A>
<font color="blue">function entity=climada_damagefunctions_replace(entity,damagefunctions) </font>
 climada
 NAME:
   climada_damagefunctions_replace
 PURPOSE:
   Given an encoded entity, replace select damagefunctions with the ones
   provided. The code does in fact NOT delete any damage function, but set
   the DamageFunID of the one replaced to a new number.

   If entity contains a damage function with peril_ID 'TC' and
   DamageFunID=1 and damagefunctions also contains a damage function with
   peril_ID 'TC' and DamageFunID=1, the damage function in damagefunctions
   is added to entity damagefunctions and the previous damagefunction
   TC_001 is moved to TC_nnn, where nnn is a not yet used DamageFunID. But
   in case all MDD and PAA values of the existing damagefunction are
   exactly the same, the curve is NOT replaced (ensures we do not
   endlessly increase the number of damagefunctions on subsequent calls
   unnecessarily).

   See also climada_damagefunctions_read, climada_damagefunctions_generate
   and climada_damagefunctions_plot
 CALLING SEQUENCE:
   entity=climada_damagefunctions_replace(entity,damagefunctions)
 EXAMPLE:
   entity=climada_damagefunctions_replace(entity,damagefunctions);
 INPUTS:
   entity: an entity, see climada_entity_read
       &ampgt promted for if not given (calling climada_entity_load, not
       climada_entity_read)
   damagefunctions: see climada_damagefunctions_read, a struct with damage
       functions. If one does not need to pass on new damage functions,
       one can also pass the damagefunctions_map in this variable (see 2nd
       EXAMPLE above). This option comes handy, if one stores several
       damagefunctions in entity.damagefunctions and uses this code to
       switch between.
       No way to prompt for, hence aborted if not provided
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   entity: the entity with damagefunctions added (and DamageFunID of
       previous - replaced - damage functions set to a new number)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150212, initial
 David N. Bresch, david.bresch@gmail.com, 20150225, datenum added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_damagefunctions_replace.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_dateline_resolve">
<H2>climada_dateline_resolve</H2></A>
<font color="blue">function lon=climada_dateline_resolve(lon,hemisphere,margin) </font>
 climada template
 MODULE:
   module name
 NAME:
   climada_dateline_resolve
 PURPOSE:
   Resolves dateline issue in Longitude coordinates, re-coding them either
   all W (hence values &amplt-180 possible) or all East (values &ampgt180 possible,
   default). By default, a margin of 20 degrees is used, such that if
   hemisphere='E', a value of -161 gets converted to +199, 
   while -160 remains.

   For Fiji for example, after creating the entity and/or centroids (e.g.
   using climada_GDP_entity, see module country_risk), run:
       entity.assets.lon=climada_dateline_resolve(entity.assets.lon);
       centroids.lon=climada_dateline_resolve(centroids.lon);
   and save these 'clean' structures for further use.

   For tropical cyclone tracks in the datelone region, similarly (after
   e.g. using tc_track=climada_tc_read_unisys_track)
       tc_track.lon=climada_dateline_resolve(tc_track.lon);
 CALLING SEQUENCE:
   lon=climada_dateline_resolve(lon,hemisphere,margin)
 EXAMPLE:
   tc_track.lon=climada_dateline_resolve(tc_track.lon)
 INPUTS:
   lon: a (vector of) longitude values (in degrees) to be resolved
 OPTIONAL INPUT PARAMETERS:
   hemisphere: whether we convert all to 'E' for Eastern or 'W' for
       Western hemisphere. Default ='E'
   margin: the margin for wich values are converted, i.e. for what range
       around the dateline the correction applied. Default =20, such that
       if hemisphere='E', a value of -161 gets converted to +199, while
       -160 remains.  
 OUTPUTS:
   lon: same as on input, with values 'mapped' as described
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160221
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_dateline_resolve.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_demo_adapt_cost_curve">
<H2>climada_demo_adapt_cost_curve</H2></A>
<font color="blue">function [impact_present, impact_future, insurance_benefit, insurance_cost] = climada_demo_adapt_cost_curve(climada_demo_params,omit_plot, scaled_AED, nice_numbers, reverse_cb) </font>
 climada
 NAME:
   climada_demo_adapt_cost_curve
 PURPOSE:
   update the demo entity etc. to reflect parameter changes
   (first time, it reads the demo entity from the Excel file demo_present.xls)
   run the calculations and call climada_adaptation_cost_curve for the
   visualization (all in one, hence easy to call from the GUI)
   
   see also: climada_demo_gui, normally called therefrom
 CALLING SEQUENCE:
   [impact_present,impact_future]=climada_demo_adapt_cost_curve(climada_demo_params,omit_plot);
 EXAMPLE:
   climada_demo_params.growth=0.02;climada_demo_params.scenario=1;climada_demo_params.measures.beachnourish=1;
   climada_demo_params.measures.mangroves=1;climada_demo_params.measures.seawall=1;
   climada_demo_params.measures.quality=1;climada_demo_params.measures.insurance_deductible=0;
   [impact_present,impact_future]=climada_demo_adapt_cost_curve(climada_demo_params);
 INPUTS:
   climada_demo_params: a structure with the climada parameters the demo GUI allows to edit:
       growth: the percentage, decimal (0.02 means 2% CAGR until 2030)
       scenario: 0, 1 or 2 for no, moderate and high climate change
       discount_rate: the discount rate used to discount damages
       measures, a sub-structure with
          beachnourish: the level of investment 0..1
          mangroves: 0..1
          seawall: 0..1, costs non-linear (power 4)
          quality: 0..1, costs non-linear (power 4)
          insurance_deductible: 0..1, costs dealt with also in EDS
      &ampgt ususally set in GUI, hard-coded for testing (if nothing handed over or empty)
 OPTIONAL INPUT PARAMETERS:
   omit_plot: if =1, omit plotting (faster), degfault=0 (do plot)
 OUTPUTS:
   impact_present: impact structure, see climada_measures_impact
   impact_future: impact structure, see climada_measures_impact
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20110623, Ashdown Park
 David N. Bresch, david.bresch@gmail.com, 20130328, vuln_MDD_impact -&ampgt MDD_impact...
 David N. Bresch, david.bresch@gmail.com, 20140516, reverse_cb added
 David N. Bresch, david.bresch@gmail.com, 20140816, automatic update if entity changed
 Lea Mueller, muellele@gmail.com, 20150902, rename to hazard_intensity_impact_b from hazard_intensity_impact
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_demo_adapt_cost_curve.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_demo_parameter_table">
<H2>climada_demo_parameter_table</H2></A>
<font color="blue">function climada_demo_parameter_table(csv_filename) </font>
 climada
 NAME:
   climada_demo_parameter_table
 PURPOSE:
   based on climada_demo_gui, create a (extensive) parameter table
   for use by applications which cannot truly simulate the risk
   such applications will have to interpolate (linearly) between
   lookup points.

   NOTE: This code takes more than 10 hours to run:
   for each line of output, it simulates 15*13'000 events (takes a few sec)
   number of lines in the output file: 3*11*11*n_measures*parameter_resolution

   measure names etc. are currently hard-wired, could be made dynamic
 CALLING SEQUENCE:
   climada_demo_parameter_table(csv_filename)
 EXAMPLE:
   climada_demo_parameter_table
 INPUTS:
   csv_filename:
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
	parameters written to file csv_filename
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20110628, sur TGV Paris-Mulhouse
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_demo_parameter_table.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_demo_parameter_table_full">
<H2>climada_demo_parameter_table_full</H2></A>
<font color="blue">function climada_demo_parameter_table(csv_filename) </font>
 climada
 NAME:
   climada_demo_parameter_table
 PURPOSE:
   based on climada_demo_gui, create a (extensive) parameter table
   for use by applications which cannot truly simulate the risk
   such applications will have to interpolate (linearly) between
   lookup points.

   This code might need several hours to run:
   for each line of output, it simulates 15*13'000 events (takes a few sec)
   number of lines in the output file: 3*6*6*(parameter_resolution^n_measures)

   measure names etc. are currently hard-wired, could be made dynamic
 CALLING SEQUENCE:
   climada_demo_parameter_table(csv_filename)
 EXAMPLE:
   climada_demo_parameter_table
 INPUTS:
   csv_filename: 
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
	parameters written to file csv_filename
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20110628, sur TGV Paris-Mulhouse
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_demo_parameter_table_full.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_demo_waterfall_graph">
<H2>climada_demo_waterfall_graph</H2></A>
<font color="blue">function [risk_today,risk_econ_growth,risk_climate_change]=climada_demo_waterfall_graph(climada_demo_params,omit_plot,nice_numbers) </font>
 climada
 NAME:
   climada_demo_waterfall_graph
 PURPOSE:
   produce the waterfall graph for the climada GUI
   (first time, it reads the demo entity from the Excel file demo_today.xls)
   run the calculations and show the waterfall graph

   see also: climada_demo_gui, normally called therefrom
 CALLING SEQUENCE:
   climada_demo_waterfall_graph(climada_demo_params,omit_plot);
 EXAMPLE:
   climada_demo_params.growth=0.02;climada_demo_params.scenario=1;
   climada_demo_waterfall_graph(climada_demo_params);
 INPUTS:
   climada_demo_params: a structure with the climada parameters the demo GUI allows to edit:
       growth: the percentage, decimal (0.02 means 2% CAGR until 2030)
       scenario: 0, 1 or 2 for no, moderate and high climate change
      &ampgt ususally set in GUI, hard-coded for testing (if nothing handed over or empty)
 OPTIONAL INPUT PARAMETERS:
   omit_plot: if =1, omit plotting (faster), degfault=0 (do plot)
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20110625
 David N. Bresch, david.bresch@gmail.com, 20130316, ELS-&ampgtEDS...
 David N. Bresch, david.bresch@gmail.com, 20150402, area compatibility with version 8 (R2014...)
 David N. Bresch, david.bresch@gmail.com, 20150805, entity re-read from Excel if Excel edited (to allow for experimentation)
 David N. Bresch, david.bresch@gmail.com, 20150805, entity and hazard set files defined in climada_init_vars
 David N. Bresch, david.bresch@gmail.com, 20140816, automatic update if entity changed
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_demo_waterfall_graph.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_digit_set">
<H2>climada_digit_set</H2></A>
<font color="blue">function [digit, digit_str, result_str] = climada_digit_set(data,data2) </font>
 set digit and digit string for a given data set
 NAME:
   climada_digit_set
 PURPOSE:
   Set digit (10 to the power of digit) and digit string for a given data 
   set, e.g. for an input of 1'000'000, digit = 6 and digit_str =
   'million', result_str = '1.00 million'
 CALLING SEQUENCE:
   [digit, digit_str, result_str] = climada_digit_set(data,data2)
 EXAMPLE:
   [digit, digit_str, result_str] = climada_digit_set(1000000,20)
 INPUTS:
   data: an array or matrix of data
   data2: an array or matrix of data
 OPTIONAL INPUT PARAMETERS:
   data2: a second array or matrix of data
 OUTPUTS:
   digit: an array defining 10 to the power of digit, e.g. 6 for million,
   9 for billion
   digit_str: a char, e.g 'million', 'billion'
   result_str: a char, containing the maximum of the data, e.g '4.21 million' 
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20150924, init
 Lea Mueller, 20150928, delete s in million, billion, etc
 Lea Mueller, 20151202, add result_str
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_digit_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_discount_read">
<H2>climada_discount_read</H2></A>
<font color="blue">function discount = climada_discount_read(discount_filename) </font>
 climada discount read import
 NAME:
   climada_discount_read
 PURPOSE:
   read discount sheet with .yield_ID, .year, .discount_rate. 
   usually called from climada_entity_read, see climada_entity_read for
   more information. The field &quotdiscount_rate&quot is
   mandatory otherwise discount is not read.

   The code invokes climada_spreadsheet_read to really read the data,
   which implements .xls and .ods files
   For .xls, the sheet names are dynamically checked, for .ods, the sheet
   names are hard-wired (see code), means for .ods, the sheet 'discount' 
   needs to exist.
 CALLING SEQUENCE:
   [discount,discount_save_file] = climada_discount_read(discount_filename)
 EXAMPLE:
   discount = climada_discount_read;
 INPUTS:
   discount_filename: the filename of the Excel (or .ods) file with the
   discount information
       If no path provided, default path ../data/entities is used
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
    discount: a structure, with
           .yield_ID: yield ID
           .year: year
           .discount_rate: discount_rate per year
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151117, init from climada_entity_read to read only discount
 David Bresch, david.bresch@gmail.com, 20151119, bugfix for Octave to try/catch xlsinfo
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_discount_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_distance2coast_km">
<H2>climada_distance2coast_km</H2></A>
<font color="blue">function [distance_km,lon,lat]=climada_distance2coast_km(lon,lat,check_plot,force_beyond_1000km,check_inpolygon) </font>
 climada distance km coast
 NAME:
   climada_distance2coast
 PURPOSE:
   calculate distance to coast in km (approx.)

   NOTE: for speedup, max distance is 1'000km, i.e. distances larger than
   approx 1'000km are set to 1'000km (speeds up by st least factor ten). See the
   try/catch statement to switch to calculation of all distances (even
   beyond 1'000 km)

   Run climada_shaperead('SYSTEM_COASTLINE') in case the coastline does
   not exist (requires the climada module country_risk from
   https://github.com/davidnbresch/climada_module_country_risk
 CALLING SEQUENCE:
   distance_km=climada_distance2coast_km(lon,lat,check_plot)
 EXAMPLE:
   distance_km=climada_distance2coast_km(lon,lat)
 INPUTS:
   lon: vector of longitues
   lat: vector of latitudes
 OPTIONAL INPUT PARAMETERS:
   check_plot: =1: show circle plot for check (default=0)
   force_beyond_1000km: =1 to claculate all distances precisely, even for
       points &ampgt1000km from coast (default=0)
   check_inpolygon: if=1, set distance negative if inside the polygon (i.e. on land)
       if check_inpolygon&amplt0, only the points closer than
       abs(check_inpolygon) [km] are checked and returned (see oputput
       arguments lon lat in this case. This options speeds up the
       inpolygon search substantially
 OUTPUTS:
   distance_km: distance to coast in km for each lat/lon
   lon and lat: same as on input, except for check_inpolygon&amplt0, whre only
       the points closer than abs(check_inpolygon) [km] are returned
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141225, initial
 David N. Bresch, david.bresch@gmail.com, 20150514, progress indication for more than 1000 points added
 David N. Bresch, david.bresch@gmail.com, 20150514, speedup factor ten or more implemented
 David N. Bresch, david.bresch@gmail.com, 20150515, check_inpolygon implemented
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_distance2coast_km.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_distance_km">
<H2>climada_distance_km</H2></A>
<font color="blue">function dist_km=climada_distance_km(lon1,lat1,lon2,lat2) </font>
 climada
 NAME:
   climada_distance_km
 PURPOSE:
   calculate distance between two points or a point and a series of points
 CALLING SEQUENCE:
   climada_distance_km(lon1,lat1,lon2,lat2);
 EXAMPLE:
   climada_distance_km(0.0,45.0,1.0,45.0); % two points
   climada_distance_km(0.0,45.0,[1.0 2.0 2.0],[45.0 45.0 46.0]); % point and a series of points
 INPUTS:
   lon1,lat1: longitude and latitude of first point
   lon2,lat2: longitude and latitude of second point
       or, if vectors of the same length, series of points
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   dist_km: distance(s) between points in km
 MODIFICATION HISTORY:
 David N. Bresch, david_bresch@gmail.com, 20130328
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_distance_km.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_distribution_lon_lat">
<H2>climada_distribution_lon_lat</H2></A>
<font color="blue">function climada_distribution_lon_lat(tc_track, check_printplot, check_printplot_2) </font>
 distribution of start point longitude and latitude and difference in
 longitude and latitude
 NAME:
   climada_distribution_lon_lat
 PURPOSE:
   plot to visually control distribution of probabilistic to historical
   track data
 CALLING SEQUENCE:
   climada_distribution_lon_lat(tc_track_prob, check_printplot, check_printplot_2)
 EXAMPLE:
   climada_distribution_lon_lat
   climada_distribution_lon_lat([],1,1)
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   tc_track_prob  :  probabilistic track set, if not given prompted for
   check_printplot:  if set to 1 will print (save) figure, default 0
 OUTPUTS:
   plot
 MODIFICATION HISTORY:
 Lea Mueller, 20110715
 david.bresch@gmail.com, 20120407, load(colormap) fixed, but still some Q.
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_distribution_lon_lat.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_distribution_v0_vi">
<H2>climada_distribution_v0_vi</H2></A>
<font color="blue">function [mu, sigma, A] = climada_distribution_v0_vi(tc_track, output_unit, check_visible, check_printplot) </font>
 distribution of initial wind speed v0 and change in in wind speed vi
 tc_track has to be recorded at 6h intervals with wind speed in kn
 NAME:
   climada_distribution_v0_vi
 PURPOSE:
   fit normal distribution to inital wind speed from tc tracks and 
   fit normal distribution to 
   previous:   .....
   next:       ....
 CALLING SEQUENCE:
   [mu, sigma] = climada_distribution_v0_vi(tc_name, check_printplot)
 EXAMPLE:
   [mu, sigma] = climada_distribution_v0_vi('all', 1);
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   tc_track:     historical tc tracks, prompted for if not given
   output_unit:      output unit of mu and sigma, e.g. 'kn' for knots or
   'm/s' for m/s, default m/s
   check_visible:    if set to 1 will show figure, default 1
   check_printplot:  if set to 1 will print (save) figure, default 0
 OUTPUTS:
   mu and sigma, mean and standard deviation of fitted normal distribution
   mu:     mean for initial wind speed v0 mu(1) and difference in wind
   speed vi mu(2)
   sigma:  standard deviation for initial wind speed v0 sigma(1) and difference in wind
   speed vi sigma(2)
 MODIFICATION HISTORY:
 Lea Mueller, 20110616
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_distribution_v0_vi.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ellipse">
<H2>climada_ellipse</H2></A>
<font color="blue">function h=climada_ellipse(ra,rb,ang,x0,y0,C,Nb) </font>
 Ellipse adds ellipses to the current plot

 ELLIPSE(ra,rb,ang,x0,y0) adds an ellipse with semimajor axis of ra,
 a semimajor axis of radius rb, a semimajor axis of ang, centered at
 the point x0,y0.

  A copy of ellipse, just to fix the following 'bug':
  Undefined function 'ellipse' for input arguments of type 'double'
  The present version does read double...

 The length of ra, rb, and ang should be the same. 
 If ra is a vector of length L and x0,y0 scalars, L ellipses
 are added at point x0,y0.1
 If ra is a scalar and x0,y0 vectors of length M, M ellipse are with the same 
 radii are added at the points x0,y0.
 If ra, x0, y0 are vectors of the same length L=M, M ellipses are added.
 If ra is a vector of length L and x0, y0 are  vectors of length
 M~=L, L*M ellipses are added, at each point x0,y0, L ellipses of radius ra.

 ELLIPSE(ra,rb,ang,x0,y0,C)
 adds ellipses of color C. C may be a string ('r','b',...) or the RGB value. 
 If no color is specified, it makes automatic use of the colors specified by 
 the axes ColorOrder property. For several circles C may be a vector.

 ELLIPSE(ra,rb,ang,x0,y0,C,Nb), Nb specifies the number of points
 used to draw the ellipse. The default value is 300. Nb may be used
 for each ellipse individually.

 h=ELLIPSE(...) returns the handles to the ellipses.

 as a sample of how ellipse works, the following produces a red ellipse
 tipped up at a 45 deg axis from the x axis
 ellipse(1,2,pi/8,1,1,'r')

 note that if ra=rb, ELLIPSE plots a circle


 written by D.G. Long, Brigham Young University, based on the
 CIRCLES.m original 
 written by Peter Blattner, Institute of Microtechnology, University of 
 Neuchatel, Switzerland, blattner@imt.unine.ch
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_ellipse.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_check">
<H2>climada_entity_check</H2></A>
<font color="blue">function entity = climada_entity_check(entity,fieldname,silent_mode) </font>
 climada_entity_check
 NAME:
   climada_entity_check
 PURPOSE:
   Given an assets, damagefunction or measures structure delete nan lines
 
   can be called from: climada_entity_read, climada_damagefunction_read,
   climada_measures_read
 CALLING SEQUENCE:
   entity_out = climada_entity_check(entity,fieldname)
 EXAMPLE:
   entity_out = climada_entity_check(entity,fieldname)
 INPUTS:
   entity: an entity structure or an entity .mat file, see climada_assets_encode(climada_assets_read)
       If a file and no path provided, default path ../data/entities is
       used (and name can be without extension .mat)
       &ampgt promted for if not given
   fieldname: fieldname to specify where to look for nans, e.g. 'lon' for
   assets, 'DamageFunID' for damagefunctions, 'name' for measures
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   entity cleaned up, deleted rows with nans
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151016, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_entity_check.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_combine">
<H2>climada_entity_combine</H2></A>
<font color="blue">function [entity,entity_save_file] = climada_entity_combine(entity,entity2,entity_save_file,purge_flag) </font>
 climada entity import, read assets, damagefunctions, discount and measures
 NAME:
   climada_entity_combine
 PURPOSE:
   Combine two climada entities, just appends assets, keeps everything
   else the same.

   previous steps: climada_entity_read, climada_entity_load
   next step: likely climada_ELS_calc
 CALLING SEQUENCE:
   [entity,entity_save_file] = climada_entity_combine(entity,entity2,entity_save_file)
 EXAMPLE:
   entity = climada_entity_combine(entity,entity2)
 INPUTS:
   entity: a climada entity structure, as returned by climada_entity_read
   entity2: a climada entity structure, as returned by climada_entity_read
 OPTIONAL INPUT PARAMETERS:
   entity_filename: the filename to save the combined entity to
       NOT asked if not provided, as in this case, the combined entity is
       NOT saves back to disk
   purge_flag: =1 delete array entries where entity.assets.Value=0 in
       combinded assets, =0 keep all (default) 
 OUTPUTS:
   entity: an entity structure, see climada_entity_read
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160120, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_entity_combine.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_load">
<H2>climada_entity_load</H2></A>
<font color="blue">function [entity,entity_file]=climada_entity_load(entity) </font>
 climada
 NAME:
   climada_entity_load
 PURPOSE:
   load a previously saved entity (just to avoid typing long paths and
   filenames in the command window)
 CALLING SEQUENCE:
   entity_out=climada_entity_load(entity)
 EXAMPLE:
   entity=climada_entity_load('demo_today')
 INPUTS:
   entity: the filename (and path, optional) of a previously saved entity
       structure. If no path provided, default path ../data/entities is used
       (and name can be without extension .mat or even without _entity.mat)
       &ampgt promted for if empty
       OR: an entity structure, in which case it is just returned (to allow
       calling climada_entity_load anytime, see e.g. climada_EDS_calc)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   entity: a struct, see climada_entity_read for details
   entity_file: the full filename the entity was loaded from
       useful in subsequent call climada_entity_save(entity,entity_file)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091230
 David N. Bresch, david.bresch@gmail.com, 20150804, allow for name without path on input
 David N. Bresch, david.bresch@gmail.com, 20150820, memory use optimized, filename checked
 Lea Mueller, muellele@gmail.com, 20151124, check that field .assets exist
 Lea Mueller, muellele@gmail.com, 20151127, enhance to work with complete entity as input
 Lea Mueller, muellele@gmail.com, 20151127, set entity_file to empty if a struct without .assets
 David N. Bresch, david.bresch@gmail.com, 20160202, speedup if entity structure passed
 David N. Bresch, david.bresch@gmail.com, 20160516, _entity added if needed, too. entity_file as output added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_entity_load.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_save">
<H2>climada_entity_save</H2></A>
<font color="blue">function climada_entity_save(entity,entity_file) </font>
 climada
 NAME:
   climada_entity_save
 PURPOSE:
   save an entity to a .mat file (just to avoid typing long paths and
   filenames in the cmd window)
 CALLING SEQUENCE:
   climada_entity_save(entity,entity_file)
 EXAMPLE:
   climada_entity_save(climada_assets_encode(climada_assets_read))
 INPUTS:
   entity: the entity struct to be saved, see e.g. climate_assets_encode
   entity_file: the filename (with path, optional) to save the entity in
       If no path provided, default path ../data/entities is used
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   entity saved to a .mat file
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091230
 David N. Bresch, david.bresch@gmail.com, 20150804, allow for name without path on input
 David N. Bresch, david.bresch@gmail.com, 20150820, filename checked
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_entity_save.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_value_GDP_adjust">
<H2>climada_entity_value_GDP_adjust</H2></A>
<font color="blue">function entity_adjusted=climada_entity_value_GDP_adjust(entity_file_regexp,mode_selector) </font>
 scale up asset values
 MODULE:
   country_risk
 NAME:
   climada_entity_value_GDP_adjust
 PURPOSE:
   Scale up asset values based on a country's estimated total asset value.
   The total asset value is derived as follows:
       - normalize the asset values
       - multiply with the country's GDP
       - multiply with a factor that depends on a country's income
         group, i.e., its GDP per capita. This last factor is the KEY
         ASSUMPTION here, see income_group_factors in PARAMETERS in code

   If an entity has a field entity.assets.Value_today, the code calculates
   the factor to entity.assets.Value and applies this factor after GDP
   adjustment (this way, the code does not scale _future entities back to
   today).

   The entities' asset values are first normalized and then
   multiplied by a factor that depends on a country's income group (low,
   lower middle, upper middle, or high). The choice of this factor is
   based on a comparison of climada entities to estimates for total asset
   values in countries where such data are available. This comparison
   showed that in general, adjusting the Climada asset values requires a
   higher multiplication factor the wealthier a country is. Thus, as a
   rule of thumb, the value of all assets in a country can be estimated by
       Total_asset_value = GDP * (1+income_group_factor)
   where GDP is the country's gross domestic product, and
   income_group_factor ranges from 2 for low income countries to 5 for
   high income countries.

   Caution: as soon as the entity has a field entity.assets.admin0_ISO3 or
   entity.assets.admin0_name, it is adjusted, unless there are non-empty
   fields entity.assets.admin1_name or entity.assets.admin1_code, in which
   case it skips adjustment.

   Note: to avoid any troubles, Cover is set equal to Value.

   Calls climada_entity_value_GDP_adjust_one

   Prior calls: e.g. climada_nightlight_entity, country_risk_calc
   Next calls: e.g. country_risk_calc
 CALLING SEQUENCE:
   entity_adjusted=climada_entity_value_GDP_adjust(entity_file_regexp,mode_selector)
 EXAMPLE:
   entity_adjusted=climada_entity_value_GDP_adjust('../data/*.mat') % put .. in
   entity_adjusted=climada_entity_value_GDP_adjust('BEL_Belgium_entity.mat')
 INPUT:
   entity_file_regexp: the full filename of the entity to be scaled up
       or a regexp expression, e.g. for all entities:
       entity_file_regexp=[climada_global.data_dir filesep 'entities' filesep '*.mat']
 OPTIONAL INPUT PARAMETERS:
   mode_selector: =1, print step-by-step to stdout, =0, not (default)
       If =2, do not care for Value_today, just adjust to GDP*income_group_factors
       If =3, use GDP_future instead of GDP_today (if this column is in
       the economic_indicators_mastertable.xls, otherwise throw an error).
       In this case, ignore Value_today, just scale with GDP_future.
 OUTPUTS:
   entity_adjusted: entity with adjusted asset values, also stored as .mat
       file (only last entity if entity_file_regexp covers more than one)
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150121, initial
 David N. Bresch, david.bresch@gmail.com, 20150121, cleanup
 David N. Bresch, david.bresch@gmail.com, 20150122, mode_selector added
 David N. Bresch, david.bresch@gmail.com, 20150122, mode_selector=3 added
 David N. Bresch, david.bresch@gmail.com, 20150204, processing moved to climada_entity_value_GDP_adjust_one
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_entity_value_GDP_adjust.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_value_GDP_adjust_one">
<H2>climada_entity_value_GDP_adjust_one</H2></A>
<font color="blue">function entity=climada_entity_value_GDP_adjust_one(entity,mode_selector) </font>
 scale up asset values GDP
 MODULE:
   country_risk
 NAME:
   climada_entity_value_GDP_adjust_one
 PURPOSE:
   Scale up asset values based on a country's estimated total asset value.
   The total asset value is derived as follows:
       - normalize the asset values
       - multiply with the country's GDP
       - multiply with a factor that depends on a country's income
         group, i.e., its GDP per capita. This last factor is the KEY
         ASSUMPTION here, see income_group_factors in PARAMETERS in code

   See also climada_entity_value_GDP_adjust, which allows to process a
   series of entity .mat files

   If an entity has a field entity.assets.Value_today, the code calculates
   the factor to entity.assets.Value and applies this factor after GDP
   adjustment (this way, the code does not scale _future entities back to
   today).

   The entities' asset values are first normalized and then
   multiplied by a factor that depends on a country's income group (low,
   lower middle, upper middle, or high). The choice of this factor is
   based on a comparison of climada entities to estimates for total asset
   values in countries where such data are available. This comparison
   showed that in general, adjusting the Climada asset values requires a
   higher multiplication factor the wealthier a country is. Thus, as a
   rule of thumb, the value of all assets in a country can be estimated by
       Total_asset_value = GDP * (1+income_group_factor)
   where GDP is the country's gross domestic product, and
   income_group_factor ranges from 2 for low income countries to 5 for
   high income countries.

   Caution: as soon as the entity has a field entity.assets.admin0_ISO3 or
   entity.assets.admin0_name, it is adjusted, unless there are non-empty
   fields entity.assets.admin1_name or entity.assets.admin1_code, in which
   case it skips adjustment.

   Note: to avoid any troubles, Cover is set equal to Value.

   Prior calls: e.g. climada_nightlight_entity, country_risk_calc
   Next calls: e.g. country_risk_calc
 CALLING SEQUENCE:
   entity_adjusted=climada_entity_value_GDP_adjust_one(entity,mode_selector)
 EXAMPLE:
   entity_adjusted=climada_entity_value_GDP_adjust_one(climada_entity_load)
 INPUT:
   entity: an entity structure, see e.g. climada_entity_load and
       climada_entity_read
 OPTIONAL INPUT PARAMETERS:
   mode_selector: =1, print step-by-step to stdout, =0, not (default)
       If =2, do not care for Value_today, just adjust to GDP*income_group_factors
       If =3, use GDP_future instead of GDP_today (if this column is in
       the economic_indicators_mastertable.xls, otherwise throw an error).
       In this case, ignore Value_today, just scale with GDP_future.
 OUTPUTS:
   entity_adjusted: entity with adjusted asset values, also stored as .mat
       file (only last entity if entity_file_regexp covers more than one)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150204, switched to one entity, see also climada_entity_value_GDP_adjust
 David N. Bresch, david.bresch@gmail.com, 20150927, economic_indicators_mastertable from climada_global.system_dir
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_entity_value_GDP_adjust_one.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_event_damage_animation">
<H2>climada_event_damage_animation</H2></A>
<font color="blue">function climada_event_damage_animation(animation_data_file,animation_mp4_file,schematic_tag,show_plots,focus_region,FontSize) </font>
 climada event animation movie
 MODULE:
   module name
 NAME:
   climada_event_damage_animation
 PURPOSE:
   Animation of event damage - as an .mp4 movie

   An animation of the tropical cylclon track hitting the assets as
   defined in entity

   This code does the visualization (rendering), see e.g.
   climada_event_damage_data_tc to calculate all the data. As one often
   needs to play with visualization parameters, the process is split.

   The code determines the plot area based on entity (but since there can be
   more than one ocean basin's tracks hitting the centroids, the user has
   to select the track file).

   Note that this code does not (yet) run in Octave, as video support is
   limited (see &amplthttp://octave.sf.net/video/&ampgt) and the present code uses
   latest MATLAB videowriter (better performance than avifile...).

   prior calls: climada_event_damage_data_tc or similar to prepare the
   event damage information

   NOTE: please consider to rename and edit/tune your local version
 CALLING SEQUENCE:
   climada_event_damage_animation(animation_data_file,animation_mp4_file,schematic_tag,show_plots,focus_region,FontSize)
 EXAMPLE:
   climada_event_damage_animation; % prompt for
 INPUTS:
   animation_data_file: the data file (.mat) with hazard set which
       includes event damage information, see e.g. climada_event_damage_data_tc
       If specified without path, searched for in ../results and extension .mat
       &ampgt promted for if not given
   animation_mp4_file: the filename of the resulting .mp4 movie
       If specified without path, stored in ../results with extension .mp4
       &ampgt promted for if not given (if cancel pressed, the movie frames are
       not written to file - useful for test)
 OPTIONAL INPUT PARAMETERS:
   schematic_tag: whether we plot schematic or with colorbar)
       =0: show colorbar and values, e.g. tc wind color scale is yellow
       (20-30 m/s), orange (30-40 m/s), dark orange (40-50 m/s), etc...
       =1: use (old) circle-style appearance for assets and damages
       =2 (default): use climada_entity_plot style for assets and mark
       damaged ones with dark red.
       &amplt0: use option 2 and abs(schematic_tag) defines markersize (as in
       climada_entity_plot), often needed to keep squares of markers in
       good size.
   focus_region: the region we're going to show [minlon maxlon minlat maxlat]
       if empty, automatically determined by area of entity lat/lon, i.e.
       hazard.assets.lat/lon
       Default: use the region as stored in hazard.focus_region
   FontSize: the size for legend and title, default=18 (good readability
       on animation)
 OUTPUTS:
   and .mp4 animation file
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150118, initial
 David N. Bresch, david.bresch@gmail.com, 20150119, hazard translucent, entity blue, damage red
 Lea Mueller, muellele@gmail.com, 20150202, schematic tag, exponential circle size for assets
 David N. Bresch, david.bresch@gmail.com, 20150220, show_plots added
 David N. Bresch, david.bresch@gmail.com, 20150220, focus_region added
 David N. Bresch, david.bresch@gmail.com, 20150318, save as text debugged
 David N. Bresch, david.bresch@gmail.com, 20150804, switched from 'Uncompressed AVI' to 'MPEG-4' (no AVI coded on Mac)
 David N. Bresch, david.bresch@gmail.com, 20150915, schematic_tag=2 implemented, i.e. asset distribution shown as in climada_entity_plot
 David N. Bresch, david.bresch@gmail.com, 20150916, speedup plotting map borders directly (avoid climada_plot_world_borders)
 David N. Bresch, david.bresch@gmail.com, 20160516, filenames without path allowed
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_event_damage_animation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_event_damage_data_tc">
<H2>climada_event_damage_data_tc</H2></A>
<font color="blue">function [hazard,hazard_TS]=climada_event_damage_data_tc(tc_track,entity,animation_data_file,add_surge,check_mode,focus_region) </font>
 climada tc ts animation
 MODULE:
   core
 NAME:
   climada_event_damage_data_tc
 PURPOSE:
   Animation of climada cyclone impact for illustration - this code
   calculates all the data and produces simple circle plots for checks. As
   one often needs to play with visualization parameters, the process is
   split. See climada_event_damage_animation for nice plots and movie
   generation.

   Usual steps:
   0: load your tc_track and entity with 
   &ampgt&ampgt tc_track=climada_tc_track_load
   &ampgt&ampgt entity=climada_entity_load
   1. run once with default parameters to check, i.e. for track 777
   &ampgt&ampgt climada_event_damage_data_tc(tc_track(777),entity);
   1b. define a rectangular area (zoom in on the last plot and read off
   &ampgt&ampgt rect=[minlon maxlon minlat maxlat]
   2. run again, now to silently generate data on higher resolution, e.g.
   &ampgt&ampgt climada_event_damage_data_tc(tc_track(777),entity,'',0,-0.5,rect); % omit rect, if no need to zoom in
   3. generate the maovi, use
   &ampgt&ampgt climada_event_damage_animation % select the animation_data.mat file

   Instead of using a track from any of the ../data/tc_tracks databases,
   you might also just download a single track from
   weather.unisys.com/hurricane (click trough to a single track, then
   save the 'tracking information' as .dat file, i.e. right click and save
   as...) and then load with tc_track=climada_tc_read_unisys_track (in
   contrast to climada_tc_read_unisys_database, this reads one single
   track from a single track .dat file).

   The code asks for a tc track and an entity and produces all the
   step-by-step data to produce a damage animation. Instead of single
   events, the resulting hazard event set contains single time steps of
   the one event and the corresponding damage is also stored as a field
   into hazard (hazard.damage). For ease of use, the tc_track and the
   assets are also stored to hazard.

   The code determines the plot area based on entity (but since there can be
   more than one ocean basin's tracks hitting the centroids, the user has
   to select the track file). See variable focus_region in case you'd like
   to hard-wire the region (see PARAMETERS in code).

   prior calls: none necessarily, consider climada_tc_track_info to obtain
   information about all tracks in an ocean basin
   next call: climada_event_damage_animation
 CALLING SEQUENCE:
   [hazard,hazard_TS]=climada_event_damage_data_tc(tc_track,entity,animation_data_file,add_surge,check_mode)
 EXAMPLE:
   % save a single track file from weather.unisys.com/hurricane as .dat
   tc_track=climada_tc_read_unisys_track % read the single track file
   hazard=climada_event_damage_data_tc(tc_track,[],'',0,1); % prompts for entity, check
   hazard=climada_event_damage_data_tc(tc_track,[],'',0,0); % prompts for entity, high-res
   climada_event_damage_data_tc([],[],'',1); % TC and TS, check mode

   [hazard,hazard_TS]=climada_event_damage_data_tc([],[],'',1); % TC and TS, check mode
   [hazard,hazard_TS]=climada_event_damage_data_tc([],[],'',0,0); % no TS, no plots
 INPUTS:
   tc_track: a tc_track structure, as returned by
       climada_tc_read_unisys_database or climada_tc_read_unisys_tc_track
       &ampgt promted for if not given
       Note: if a tc_track struct is passed, the user is prompted for the
       specific single track (a plot shows all tracks to select from)
   entity: a climada entity, see climada_entity_read (skip hazard set
       selection to encode to) or climada_entity_load
       &ampgt promted for if not given
       Note: for speedup, consider creating an entity covering only the
       region you'd like to focus on, e.g. avoid full contiguous US if
       you'd like to animate a TC hitting Floriday, i.e consider
       entity=climada_nightlight_entity('USA','Florida')
   animation_data_file: the file where animation data is stored (not the
       animation itself). If not provided, set to ../results/animation_data.mat
 OPTIONAL INPUT PARAMETERS:
   add_surge: whether we also treat surge (TS) =1) or not (=0, default)
   check_mode: =1: show plots, use 1h timestep
       =0: no plots, 6 min timestep (the best option to generate the data
       pretty fast)
       =2: (default) show plots, use 2h timestep (fast check)
       &amplt0: set timestep=check_mode (in hours or fractions thereof, i.e. 
       0.5 for 30 min) and omit any plots (expert use)
   focus_region: the region we're going to show [minlon maxlon minlat maxlat]
       default=[], automatically determined by area of entity lat/lon
       SPECIAL: if =1, use the region around the tc_track, NOT around the entity
       E.g. for Salvador (Lea, 20150220) focus_region = [-91.5 -86 12 15.5];
 OUTPUTS:
   hazard_plus: a hazard structure (as usual) with additional fields:
       tc_track_node(i): the node i (tc_track.lon(i)...) for which the other
       fields (like hazard.intensity(i,:)..) are valid
       tc_track: the TC track (see climada_tc_read_unisys_database for
           description of fields)
       damage: the same dimension as intensity, the damage at each
           centroid for each timestep of the tc track
       max_damage: the maximum damage at each centroid (useful to scale or
           normalize, can also be calculated as =full(max(hazard.damage,[],1));
   hazard_TS: in case add_surge=1, otherwise empty. Does contain the same
       additional fields tc_track, tc_track_node, damage and max_damage.
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150117, intial
 David N. Bresch, david.bresch@gmail.com, 20150118, TS added
 David N. Bresch, david.bresch@gmail.com, 20150120, check_mode added
 David N. Bresch, david.bresch@gmail.com, 20150128, climada_tc_track_nodes
 David N. Bresch, david.bresch@gmail.com, 20150220, focus_region added
 David N. Bresch, david.bresch@gmail.com, 20150318, low wind to NaN removed
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_event_damage_data_tc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_excel_hazard_set">
<H2>climada_excel_hazard_set</H2></A>
<font color="blue">function hazard=climada_excel_hazard_set(excel_file,hazard_set_file,visualize) </font>
 climada excel hazard event set generate
 NAME:
   climada_excel_hazard_set
 PURPOSE:
   generate a hazard event set based on Excel input. The Excel sheet
   contains all the event footprints. 

   An easy method to use climada with a finite (small) number of
   predefined events (more hazard event scenarios then a full
   probabilistic set). 

   NOTE: no consistency checks performed, user to ensure that number of
   events equals number of frequencies, events defined at all centroids...
   
   see also: e.g. climada_tc_hazard_set
   next: diverse
 CALLING SEQUENCE:
   hazard=climada_excel_hazard_set(excel_file,hazard_set_file,visualize)
 EXAMPLE:
   hazard=climada_excel_hazard_set('','',1)
 INPUTS:
   excel_file: an Excel file with the centroid and hazard information
       required tabs: centroids, hazard_intensity and hazard_frequency
       centroids, required columns: centroid_ID, Longitude, Latitude
       hazard_intensity, required columns: centroid_ID, event001, event002, ...
       hazard_frequency, required columns: event_ID, frequency, orig_event_flag
       &ampgt promted for if not given
       See file ../data/hazards/Excel_hazard.xls which contains a small
       example (for Mozambique).
 OPTIONAL INPUT PARAMETERS:
   hazard_set_file: the name of the hazard set file
       &ampgt promted for if not given
   visualize: whether we plot the centroids on a map (=1) or not (=0,default)
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       intensity(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20110328
 David N. Bresch, david.bresch@gmail.com, 20141217, climada_hazard_cleanup added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_excel_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_figure_axis_limits_equal_for_lat_lon">
<H2>climada_figure_axis_limits_equal_for_lat_lon</H2></A>
<font color="blue">function climada_figure_axis_limits_equal_for_lat_lon(ax_limits) </font>
 set axis limits and set equal aspect ratio for maps (based on distance in km)
 MODULE:
   core/helper_functions
 NAME:
   climada_figure_axis_limits_equal_for_lat_lon
 PURPOSE:
   set axis limits and set equal aspect ratio for maps (based on distance in km)
   so that distance in x- and y-direction correspond to the same distance
   in km. This is necessary for coordinates in lat/lon as 1 degree in lat
   and lon are not the same distance in km. E.g. in Switzerland (47N,
   8E) 1 lon are 75km, and 1lat are 111km.
 CALLING SEQUENCE:
   climada_figure_axis_limits_equal_for_lat_lon(ax_limits)
 EXAMPLE:
   climada_figure_axis_limits_equal_for_lat_lon([-89 -90 14 15])
 INPUTS: 
   ax_limits: an array with 4 elements, specifying x_min, x_max, y_min,
              y_max
 OUTPUTS:      
   figure axis limits are set and data aspect ratio set to equal
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150730, init
 Lea Mueller, muellele@gmail.com, 20151106, move to advanced
 Lea Mueller, muellele@gmail.com, 20151106, move to core/helper_functions
 Lea Mueller, muellele@gmail.com, 20160310, workaround if ax_limits is only one lat/lon
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_figure_axis_limits_equal_for_lat_lon.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_figure_scale_add">
<H2>climada_figure_scale_add</H2></A>
<font color="blue">function climada_figure_scale_add(fig_axes,left_corner,bottom_corner) </font>
 add figure scale to a figure 
 MODULE:
   climada core
 NAME:
   climada_figure_scale_add
 PURPOSE:
   Add figure scale to a figure, in km
 CALLING SEQUENCE:
   climada_figure_scale_add(fig_axes,left_corner,bottom_corner)
 EXAMPLE:
   climada_figure_scale_add
   climada_figure_scale_add('',1,1) % to position first from left and bottom
   climada_figure_scale_add('',-1,-1) % to position first from right and top
 INPUTS: 
 OPTIONAL INPUT PARAMETERS:
   fig_axes: axes of figures 
   left_corner: position of scale in the figure, default is 1, scale is 
       positioned on first x-grid from the left, set to -1 to start from the right
   bottom_corner: position of scale in the figure, default is 1, scale is 
       positioned on first y-grid from the bottom, set to -1 to start from the top
 OUTPUTS:      
   scale with km information appears on the current axis
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150724, init
 Lea Mueller, muellele@gmail.com, 20150729, return if x_tick is empty
 Lea Mueller, muellele@gmail.com, 20150729, add option for utm (no conversion to lat/lon)
 Lea Mueller, muellele@gmail.com, 20150729, limit top_corner and right_corner to maximum number of tick elements
 Lea Mueller, muellele@gmail.com, 20151106, move to core
 Lea Mueller, muellele@gmail.com, 20160311, start from the left and bottom
 Lea Mueller, muellele@gmail.com, 20160404, only half of the x-tick length
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_figure_scale_add.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_figuresize">
<H2>climada_figuresize</H2></A>
<font color="blue">function fig = climada_figuresize(height, width) </font>
 figure size for printing/saving pdf figures
 NAME:
   climada_figuresize
 PURPOSE:
   create figure so that pdf not A4 but customed to matlab figure
   and set default axes font size, line width, marker line width and text
   font size bigger, so that approriate for export
 CALLING SEQUENCE:
   fig = climada_figuresize(height, width)
 EXAMPLE:
   fig = climada_figuresize(0.4, 0.5)
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   height: percentage of height of screen
   width:  percentage of height of screen
 %   width:  percentage of width of screen
 OUTPUTS:
   figure with handle fig with requested height and width
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110616
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_figuresize.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_find_most_severe_event">
<H2>climada_find_most_severe_event</H2></A>
<font color="blue">function event_ii = climada_find_most_severe_event(hazard,event_i) </font>
 climada find most severe hazard event
 MODULE:
   climada/helper_functions
 NAME:
   climada_find_most_severe_event
 PURPOSE:
   find most severe hazard event (or second most or third most severe)
   among others to be used in climada_map_plot
 CALLING SEQUENCE:
   event_ii = climada_find_most_severe_event(hazard,event_i)
 EXAMPLE:
   event_ii = climada_find_most_severe_event(hazard,-1) % identify most severe event
 INPUTS:
   hazard: hazard structure
       &ampgt prompted for if empty
   event_i: the i-th event in the hazard event set to be displayed
       if event_i=0, the maximum intensity at each centroid is shown
       if event_i=-i, the i-th 'largest' event (sum of intensities) is shown
           e.g. for event_i=-2, the second largest event is shown
       default=-1 (just to get something on the screen ;-)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   event_ii, an index that points to the identified event
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160129, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_find_most_severe_event.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_geo_distance">
<H2>climada_geo_distance</H2></A>
<font color="blue">function dist_m = climada_geo_distance(lon1,lat1,lon2,lat2) </font>
 calculate distance between to points in meters
 NAME:
   climada_geo_distance
 PURPOSE:
   calculate distance between two points or a point and a series of points
 CALLING SEQUENCE:
   dist_m=climada_geo_distance(lon1,lat1,lon2,lat2);
 EXAMPLE:
   dist_m=climada_geo_distance(0.0,45.0,1.0,45.0); % two points
   dist_m=climada_geo_distance(0.0,45.0,[1.0 2.0 2.0],[45.0 45.0 46.0]); % point and a series of points
 INPUTS:
   lon1,lat1: longitude and latitude of first point
   lon2,lat2: longitude and latitude of second point
       or, if vectors of the same length, series of points
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   dist_m: distance(s) between points in [m]
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091227
 David N. Bresch, david.bresch@gmail.com, 20160606, degree2km used
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_geo_distance.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_git_pull">
<H2>climada_git_pull</H2></A>
<font color="blue">function climada_git_pull(TEST_mode) </font>
 climada git pull
 MODULE:
   core
 NAME:
   climada_git_pull
 PURPOSE:
   git pull for climada, first the core module, then all installed modules

   avoids all modules where name starts with '_' or which contain 'TEST',
   like _local_module, _local_TEST or local_TEST

   Note: climada_git_push is nt implemented yet, as this might cause
   trouble, i.e. as it might automatically check in (large) .mat files or
   other stuff one did nort check. For the time, use a git tool or operate
   git add, git commit and gut push on the command line yourself.

   OLD VERSION: there is still climada_git_pull_repositories, which used a
   c-shell (csh) to issue the git commands (hence needed a local git
   installation). Please do NOT use climada_git_pull_repositories any
   more.

   previous call: startup (usually already executed)
   next call: See Note above
 CALLING SEQUENCE:
   climada_git_pull
 EXAMPLE:
   climada_git_pull(1)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   TEST_mode: =1 only show which paths will be processed, do not pull
       default=0, i.e. run git pull
 OUTPUTS:
   all messaging to stdout
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20160606, initial
 david.bresch@gmail.com, 20160609, added remark about old climada_git_pull_repositories
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_git_pull.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_git_pull_repositories">
<H2>climada_git_pull_repositories</H2></A>
<font color="blue">function climada_git_pull_repositories(TEST_mode,git_pull_command) </font>
 climada
 NAME:
   climada_git_pull_repositories
 PURPOSE:
   Execute a git pull on core climada and all repositories

   NEW version: see climada_git_pull. The code here just calls
   climada_git_pull, the rest of it kep for backward compatiblility (old
   MATLAB version)

   OLD VERSION: this is the OLD approach, using a c-shell (csh) to issue
   the git commands (hence needed a local git installation). Please do NOT
   use climada_git_pull_repositories any more.  

   Automatically updates all local repositories' code, including core
   climada. Only prerequisite: git installed locally (such that the system
   command 'git pull' is valied, see OPTIONAL INPUT git_pull_command)

   On some machines, the MATLAB system command seems not to execute
   properly. In this case, the code writes a csh (C-Shell) script and
   tries to execute it. If that fails again, it leaves the script there
   and informs the user to execute it himself.

   see also climada_code_copy
 CALLING SEQUENCE:
   climada_git_pull_repositories(TEST_mode,git_pull_command)
 EXAMPLE:
   climada_git_pull_repositories
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   TEST_mode: idf =1, do not execute any system command, just lost them to
       stdout, =0, execute (default)
   git_pull_command: the local operating system's &ampltgit pull&ampgt command
       default ='git pull'
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141102, initial
 David N. Bresch, david.bresch@gmail.com, 20141107, TEST_mode added
 David N. Bresch, david.bresch@gmail.com, 20150305, csh script option added
 David N. Bresch, david.bresch@gmail.com, 20160609, switch to climada_git_pull
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_git_pull_repositories.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_gridded_VALUE">
<H2>climada_gridded_VALUE</H2></A>
<font color="blue">function [X, Y, gridded_VALUE] = climada_gridded_VALUE(values,centroids,interp_method,npoints,stencil_ext) </font>
 NAME:
   climada_gridded_VALUE
 PURPOSE:
   gridded data of wind speed in hazard.intensity 
   for creating color plot
 CALLING SEQUENCE:
   climada_gridded_VALUE(values,centroids,interp_method,npoints,stencil_ext)
 EXAMPLE:
   climada_gridded_VALUE(values,centroids)
 INPUTS:
   values
   centroids
 OPTIONAL INPUT PARAMETERS:
   interp_method: method in griddata, like 'linear', 'cubic',...
   npoints: the number of points used
   stencil_ext: to extend the stencil range (in units of the target grid,
       default=0
 OUTPUTS:
   X, Y, gridded Value
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120430
 Lea Mueller, muellele@gmail.com, 20110517
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_gridded_VALUE.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard2IFC">
<H2>climada_hazard2IFC</H2></A>
<font color="blue">function [IFC,geo_locations] = climada_hazard2IFC(hazard,geo_locations,return_period,check_plot) </font>
 climada
 MODULE:
   climada/helper_functions
 NAME:
   climada_hazard2IFC
 PURPOSE:
   Obtains the intensity frequency curve (IFC) of a given hazard set.
   See climada_IFC_plot to plot the IFC structure.

   Subsequent call: climada_IFC_plot
 CALLING SEQUENCE:
   climada_hazard2IFC(hazard,geo_locations)
 EXAMPLE:
   climada_hazard2IFC(hazard,[23 94 51]) % pass centroid_IDs
   geo_locations.lon=14.426;geo_locations.lat=40.821; % pass lat/lon
   climada_hazard2IFC('',geo_locations)
 INPUTS:
   hazard: A climada hazard set.
 OPTIONAL INPUT PARAMETERS:
   geo_location: if not given, centroid ID is set to 1.
       Can be either: a 1xN vector of centroid_IDs;  Or a structure with
       fields .lon and .lat to specificy coordinates of interest, i.e.
       geo_locations.lon=14.426;geo_locations.lat=40.821;
   return_period: a list of return period at which we calculate the intensities
   check_plot: set to 1 to show plot, default is 1
 OUTPUTS:
   IFC(i): A structure (array of) to be used as input to climada_IFC_plot,
       containing information about the intensity-frequency
       properties of a given hazard. Fields are:
       .hazard_comment: string
       .peril_ID: the peril ID, string
       .centroid_ID: the (integer) centroid ID
       .intensity(n): hazard intensty for all n events
       .return_periods(n): hazard return period for each of the n events
       .fit_return_periods(m): the m return periods for the fit (m&amplt&ampltn)
       .intensity_fit(m): the m intensities for the fit
       .polyfit(2): the polyfit parameters, see code
       .hist_intensity(N): the N historic intensities (if orig_event_flag...)
       .hist_return_periods: hazard return period for each of the N historic events
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150130
 David N. Bresch, david.bresch@gmail.com, 20150309, bugfixes
 Lea Mueller, muellele@gmail.com, 20150318, fit parameters only for positive intensity values
 David N. Bresch, david.bresch@gmail.com, 20150405, IFC as struct array
 Lea Mueller, muellele@gmail.com, 20150504, variable intensity threshold depending on peril_ID
 Gilles Stassen, gillesstassen@hotmail.com, 20150615, check_plot and 'SELECT' option added, bug fix order of isstruct/isvector(geo_loc)
 Lea Mueller, muellele@gmail.com, 20160308, introduce return_period as input
 Lea Mueller, muellele@gmail.com, 20160314, bugfix if hazard has only one lat/lon
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_hazard2IFC.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard2ge">
<H2>climada_hazard2ge</H2></A>
<font color="blue">function climada_hazard2ge(hazard,google_earth_save,schematic_tag) </font>
 climada
 MODULE:
   core cliamda
 NAME:
   climada_hazard2ge
 PURPOSE:
   hazard footprints visualisation in google earth
 CALLING SEQUENCE:
   climada_hazard2ge(hazard,google_earth_save,schematic_tag)
 EXAMPLE:
   climada_hazard2ge
 INPUTS:
   hazard: structure
       &ampgt promted for if not given
   google_earth_save: the filename of the resulting .kmz google earth file
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   schematic_tag: set to 1 if schematic plot (no colorbar, indicative
   colorscale). if set to 0, e.g. tc wind color scale is yellow
   (20-30 m/s), orange (30-40 m/s), dark orange (40-50 m/s), etc...
 OUTPUTS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150313, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_hazard2ge.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard2octave">
<H2>climada_hazard2octave</H2></A>
<font color="blue">function hazard=climada_hazard2octave(hazard) </font>
 climada template
 MODULE:
   core
 NAME:
   climada_hazard2octave
 PURPOSE:
   In case the .mat file whch contains hazard has been saved with option
   -v7.3, in Octave, hazard.intensity contains sub-fields jc, ir and data
   There might be a more elegant way, but the present one is an explicit
   conversion back into a sparse matrix in Octave.

   Call this code whenever you access to hazard.intensity and would like
   to make sure the code works in Octave for large(r) hazard event sets,
   too.

   Calling the code in MATLAB has most likely (almost certainly) no effect
   and does take a few femptoseconds ;-)

   called from e.g. climada_EDS_calc
 CALLING SEQUENCE:
   hazard=climada_hazard2octave(hazard)
 EXAMPLE:
   hazard=climada_hazard2octave(hazard)
 INPUTS:
   hazard: a climada hazard event set structure, see e.g.
       climada_tc_hazard_set
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   hazard: a climada hazard event set structure, with hazard.intensity a
       sparse array
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150112, initial
 David N. Bresch, david.bresch@gmail.com, 20150114, speedup
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_hazard2octave.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_cleanup">
<H2>climada_hazard_cleanup</H2></A>
<font color="blue">function hazard=climada_hazard_cleanup(hazard_file) </font>
 climada
 NAME:
   climada_hazard_cleanup
 PURPOSE:
   Check a hazard event set for full climada compatibility, i.e.
   - switch from hazard.arr to hazard.intensity
   - check for orientation of vectors and matrices (speedup)
   - check consistency (e.g. hazard.event_count)

   We decided 20141017 to switch from hazard.arr to hazard.intensity,
   since this fieldname is more telling.

 CALLING SEQUENCE:
   hazard=climada_hazard_cleanup(hazard_file)
 EXAMPLE:
   hazard=climada_hazard_cleanup % prompts for
 INPUTS:
   hazard_file: the filename with path of an existing hazard event set
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   hazard: a struct, see e.g. climada_tc_hazard_set
       the cleaned hazard is saved back to the original .mat file
   file
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141017
 David N. Bresch, david.bresch@gmail.com, 20141121, hazard.lon check added
 David N. Bresch, david.bresch@gmail.com, 20141123, converted to full check
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_hazard_cleanup.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_clim_scen">
<H2>climada_hazard_clim_scen</H2></A>
<font color="blue">function hazard = climada_hazard_clim_scen(hazard,hazard_clim_file,frequency_screw,intensity_screw,intensity_shift) </font>
 climada
 NAME:
   climada_template
 PURPOSE:
   starting from a given hazard event set (hazard), construct the
   climate scenario hazard event set (hazard_clim_file)

   Modifications done in code, so please visit/edit the code prior to use,
   please check the PARAMETERS section below, e.g. for
       frequency_screw, intensity_screw
       hazard_reference_year: the reference year for the hazard set
 CALLING SEQUENCE:
   hazard=climada_tc_hazard_clim_scen(hazard,hazard_clim_file)
 EXAMPLE:
   hazard=climada_tc_hazard_clim_scen
 INPUTS:
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   hazard_clim_file: the filename of the new climate scenario hazard event set
       &ampgt promted for if not given
 OUTPUTS:
   hazard: the hazard event set for the climate scenario, also stored to hazard_clim_file
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090920
 Lea Mueller, 20110720
 Reto Stockmann 20120719
 David N. Bresch, david.bresch@gmail.com, 20150906, allow for name without path on input
 Lea Mueller, muellele@gmail.com, 20151021, add intensity shift
 Lea Mueller, muellele@gmail.com, 20151022, bugfix in fprintf
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_hazard_clim_scen.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_load">
<H2>climada_hazard_load</H2></A>
<font color="blue">function hazard=climada_hazard_load(hazard) </font>
 climada
 NAME:
   climada_hazard_load
 PURPOSE:
   load a hazard event set (just to avoid typing long paths and
   filenames in the command window)
 CALLING SEQUENCE:
   hazard=climada_hazard_load(hazard)
 EXAMPLE:
   hazard=climada_hazard_load(hazard)
 INPUTS:
   hazard: the filename (and path, optional) of a previously saved hazard
       event set. If no path provided, default path ../data/hazards is used
       (and name can be without extension .mat)  
       &ampgt promted for if empty
       OR: a hazard structure, in which cas it is just returned (to allow
       calling climada_hazard_load anytime, see e.g. climada_EDS_calc)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   hazard: a struct, see e.g. climada_tc_hazard_set
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140302
 David N. Bresch, david.bresch@gmail.com, 20150804, allow for name without path on input
 David N. Bresch, david.bresch@gmail.com, 20150820, check for correct filename
 Lea Mueller, muellele@gmail.com, 20151127, enhance to work with complete hazard as input
 Lea Mueller, muellele@gmail.com, 20151127, set hazard_file to empty if a struct without .lon
 David N. Bresch, david.bresch@gmail.com, 20160202, speedup if hazard structure passed
 David N. Bresch, david.bresch@gmail.com, 20160527, climada_hazard2octave added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_hazard_load.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_plot">
<H2>climada_hazard_plot</H2></A>
<font color="blue">function res=climada_hazard_plot(hazard,event_i,label,caxis_range,plot_centroids) </font>
 climada plot single hazard event footprint
 NAME:
   climada_hazard_plot
 PURPOSE:
   plot hazard event as contour on a map, works for all perils

   see also climada_plot_tc_footprint (works for TC only)
   and the high-resolution version climada_hazard_plot_hr
 CALLING SEQUENCE:
   climada_hazard_plot(hazard,event_i,label)
 EXAMPLE:
   climada_hazard_plot(climada_hazard_load,1); % plot first event
   climada_hazard_plot; % prompt for hazard event set, plot largest event
 INPUTS:
   hazard: hazard structure
       &ampgt prompted for if empty
   event_i: the i-th event in the hazard event set to be displayed
       if event_i=0, the maximum intensity at each centroid is shown
       if event_i=-i, the i-th 'largest' event (sum of intensities) is shown
           e.g. for event_i=-2, the second largest event is shown
       default=-1 (just to get something on the screen ;-)
 OPTIONAL INPUT PARAMETERS:
   label: a struct with a label to add on the plot (i.e. a place)
       longitude: the longitude (decimal)
       latitude: the latitude (decimal)
       name: the label itself, like 'gaga'
   caxis_range: [minval maxval], the range of the color axis, e.g. [20 40]
       to show colors for values brtween 20 and 40
   plot_centroids: =1, plot centroids, =0 no (default)
 OUTPUTS:
   creates a figure
   res, a structure with the core data, i.e. X,Y and VALUE as shown
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140302
 David N. Bresch, david.bresch@gmail.com, 20150114, Octave compatibility for -v7.3 mat-files
 David N. Bresch, david.bresch@gmail.com, 20150225, res instead of [X,Y,gridded_VALUE]
 Lea Mueller, muellele@gmail.com, 20150424, colormap according to peril_ID
 Lea Mueller, muellele@gmail.com, 20150427, higher resolution, npoints set to 2000 (instead of 199)
 Lea Mueller, muellele@gmail.com, 20150512, switched to griddata instead of climada_gridded_Value
 David N. Bresch, david.bresch@gmail.com, cleanup
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_hazard_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_plot_hr">
<H2>climada_hazard_plot_hr</H2></A>
<font color="blue">function fig = climada_hazard_plot_hr(hazard,event_i,label,caxis_range,plot_centroids,hist_check) </font>
 climada plot single hazard event footprint
 NAME:
   climada_hazard_plot_hr
 PURPOSE:
   plot hazard event as high resolution contour on a map, works for all perils

   See also the low-resolution version climada_hazard_plot
 CALLING SEQUENCE:
   climada_hazard_plot_hr(hazard,event_i,label,caxis_range,plot_centroids,hist_check)
 EXAMPLE:
   climada_hazard_plot_hr(hazard,1); % plot first event
   climada_hazard_plot_hr; % prompt for hazard event set, plot largest event
 INPUTS:
   hazard: hazard structure
       &ampgt prompted for if empty
   event_i: the i-th event in the hazard event set to be displayed
       if event_i=0, the maximum intensity at each centroid is shown
       if event_i=-i, the i-th 'largest' event (sum of intensities) is shown
           e.g. for event_i=-2, the second largest event is shown
       default=-1 (just to get something on the screen ;-)
 OPTIONAL INPUT PARAMETERS:
   label: a struct with a label to add on the plot (i.e. a place)
       longitude: the longitude (decimal)
       latitude: the latitude (decimal)
       name: the label itself, like 'gaga'
   caxis_range: [minval maxval], the range of the color axis, e.g. [20 40]
       to show colors for values brtween 20 and 40
   plot_centroids: =1, plot centroids, =0 no (default)
   hist_check: if =1, plot historic events only, =0 all (default)
 OUTPUTS:
   creates a figure and returns figure handle
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150206
 David N. Bresch, david.bresch@gmail.com, 20150313, synchronized with climada_hazard_plot
 Gilles Stassen, 20150428, special plotting routine for MS hazard added
 Gilles Stassen, 20150703, &quot**1st&quot, &quot**2nd&quot &quot**3rd&quot etc. added in title
 Lea Mueller, muellele@gmail.com, 20150713, add LS special case (intensity = 1-1/cutoff*distance_m)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_hazard_plot_hr.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_stats">
<H2>climada_hazard_stats</H2></A>
<font color="blue">function hazard = climada_hazard_stats(hazard,return_periods,check_plot) </font>
 NAME:
   climada_hazard_stats
 PURPOSE:
   plot hazard intensity maps for different return periods, based on the
   probabilistic (and historic) data set. On output, the statistics are available.

   If called with the output hazard on subsequent calls, only the plotting
   needs to be done (e.g. to further improve plots)

   previous call: e.g. climada_tc_hazard_set
 CALLING SEQUENCE:
   climada_hazard_stats(hazard,return_periods,check_plot)
 EXAMPLE:
   hazard=climada_hazard_stats
   climada_hazard_stats(hazard,[],-1) % show historic events only
 INPUTS:
   hazard: hazard structure, as generated by e.g. climada_tc_hazard_set
       &ampgt prompted for if not given
 OPTIONAL INPUT PARAMETERS:
   return_periods: vector containing the requested return periods
       (default=[1 5 10 25 50 100 500 1000])
   check_plot: default=1, draw the intensity maps for various return
       periods for the full hazard set. Set=0 to omit plot
       =-1: plot the return period maps based on historic events only
 OUTPUTS:
   the field hazard.map is added to the hazard structure, with
   map.return_period(rp_i): return period rp_i
   map.intensity(rp_i,c_i): intensity for return period rp_i at centroid c_i
   map.intensity_orig: same as map.intensity, only based on historic events
       if the hazard set contains historic events (some orig_event_flag=1)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20110623
 David N. Bresch, david.bresch@gmail.com, 20130317 cleanup
 David N. Bresch, david.bresch@gmail.com, 20140411 fixed some non-TC issues
 David N. Bresch, david.bresch@gmail.com, 20150114, Octave compatibility for -v7.3 mat-files
 Lea Mueller, muellele@gmail.com, 20150607, change tc max int. value to 80 instead of 100m/s
 Lea Mueller, muellele@gmail.com, 20150607, add cross for San Salvador in plot, for San Salvador only
 Lea Mueller, muellele@gmail.com, 20150716, add landslides option (LS) with specific colormap, intensities from 0 to 1
 David N. Bresch, david.bresch@gmail.com, 20160527, complete overhaul, new field hazard.map
 David N. Bresch, david.bresch@gmail.com, 20160529, otherwise in colorscale selection fixed
 David N. Bresch, david.bresch@gmail.com, 20160529, new default return periods (6)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_hazard_stats.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_stats_figure">
<H2>climada_hazard_stats_figure</H2></A>
<font color="blue">function fig = climada_hazard_stats_figure(hazard,return_periods,intensity_xtick,plot_method) </font>
 NAME:
   climada_hazard_stats_figure
 PURPOSE:
   plot hazard intensity maps for different return periods
   based on statistics 
     .intensity_fit_ori
     .intensity_fit
     .R_fit (requested return periods)
   previous withing climada_hazard_stats
 PREVIOUS STEP:
   climada_hazard_stats
 CALLING SEQUENCE:
   fig = climada_hazard_stats_figure(hazard,return_periods)
 EXAMPLE:
   climada_hazard_stats_figure
   climada_hazard_stats_figure(climada_hazard_stats(hazard),[10 50],[0:20:100],'contourf')
 INPUTS:
   hazard with hazard stats (.intensity_fit, .R)
 OPTIONAL INPUT PARAMETERS:
   hazard: hazard structure, if not given, prompted for
       generated by e.g. climada_tc_hazard_set
   return_periods: vector containing the requested return periods
       (e.g. [1 5 10 25 50 100 500 1000])
       if empty, taken from default as defined in climada_init_vars
   intensity_xtick: set xtick of intensity values
   plot_method: 'contourf', 'pcolor', 'plotclr', default is contourf
 OUTPUTS:
   a figure with the intensity per return period
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150914, separate from climada_hazard_stats
 Lea Mueller, muellele@gmail.com, 20160226, add intensity_xtick and plot_method
 Lea Mueller, muellele@gmail.com, 20160314, add climada_global.admin1_plot, bugfix
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_hazard_stats_figure.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_init_folders">
<H2>climada_init_folders</H2></A>
<font color="blue">function ok=climada_init_folders(root_folder) </font>
 init variables global
 NAME:
	climada_init_folders
 PURPOSE:
	initialize basic folder structure (eg in modules)

 CALLING SEQUENCE:
	ok=climada_init_folders(root_folder)
 EXAMPLE:
	ok=climada_init_folders
 INPUTS:
 OPTIONAL INPUT PARAMETERS:

 OUTPUTS:
	ok: =1 if no troubles, 0 else
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140825, initial release
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_init_folders.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_interp1">
<H2>climada_interp1</H2></A>
<font color="blue">function varargout = climada_interp1(varargin) </font>
INTERP1 1-D interpolation (table lookup)

   SPECIAL: copy of original interp1 with some checks removed for speedup,
   since called thousands of times from climada_EDS_calc
   In case you encounter troubles, just replace calls of climada_interp1
   with interp1 in climada_EDS_calc. 
   20150320, david.bresch@gmail.com

   Some features of INTERP1 will be removed in a future release.
   See the R2012a release notes for details.

   Vq = INTERP1(X,V,Xq) interpolates to find Vq, the values of the
   underlying function V=F(X) at the query points Xq. X must
   be a vector of length N.
   If V is a vector, then it must also have length N, and Vq is the
   same size as Xq.  If V is an array of size [N,D1,D2,...,Dk], then
   the interpolation is performed for each D1-by-D2-by-...-Dk value
   in V(i,:,:,...,:).
   If Xq is a vector of length M, then Vq has size [M,D1,D2,...,Dk].
   If Xq is an array of size [M1,M2,...,Mj], then Vq is of size
   [M1,M2,...,Mj,D1,D2,...,Dk].

   Vq = INTERP1(V,Xq) assumes X = 1:N, where N is LENGTH(V)
   for vector V or SIZE(V,1) for array V.

   Interpolation is the same operation as &quottable lookup&quot.  Described in
   &quottable lookup&quot terms, the &quottable&quot is [X,V] and INTERP1 &quotlooks-up&quot
   the elements of Xq in X, and, based upon their location, returns
   values Vq interpolated within the elements of V.

   Vq = INTERP1(X,V,Xq,METHOD) specifies alternate methods.
   The default is linear interpolation. Use an empty matrix [] to specify
   the default. Available methods are:

     'nearest'  - nearest neighbor interpolation
     'linear'   - linear interpolation
     'spline'   - piecewise cubic spline interpolation (SPLINE)
     'pchip'    - shape-preserving piecewise cubic interpolation
     'cubic'    - same as 'pchip'
     'v5cubic'  - the cubic interpolation from MATLAB 5, which does not
                  extrapolate and uses 'spline' if X is not equally
                  spaced.

   Vq = INTERP1(X,V,Xq,METHOD,'extrap') uses the interpolation algorithm
   specified by METHOD to perform extrapolation for elements of Xq outside
   the interval spanned by X.

   Vq = INTERP1(X,V,Xq,METHOD,EXTRAPVAL) replaces the values outside of the
   interval spanned by X with EXTRAPVAL.  NaN and 0 are often used for
   EXTRAPVAL.  The default extrapolation behavior with four input arguments
   is 'extrap' for 'spline' and 'pchip' and EXTRAPVAL = NaN (NaN +NaNi for 
   complex values) for the other methods.

   PP = INTERP1(X,V,METHOD,'pp') will use the interpolation algorithm specified
   by METHOD to generate the ppform (piecewise polynomial form) of V. The
   method may be any of the above METHOD except for 'v5cubic'. PP may then
   be evaluated via PPVAL. PPVAL(PP,Xq) is the same as
   INTERP1(X,V,Xq,METHOD,'extrap').

   For example, generate a coarse sine curve and interpolate over a
   finer abscissa:
       X = 0:10; V = sin(X); Xq = 0:.25:10;
       Vq = climada_interp1(X,V,Xq); plot(X,V,'o',Xq,Vq)

   For a multi-dimensional example, we construct a table of functional
   values:
       X = [1:10]'; V = [ X.^2, X.^3, X.^4 ];
       Xq = [ 1.5, 1.75; 7.5, 7.75]; Vq = climada_interp1(X,V,Xq);

   creates 2-by-2 matrices of interpolated function values, one matrix for
   each of the 3 functions. Vq will be of size 2-by-2-by-3.

   Class support for inputs X, V, Xq, EXTRAPVAL:
      float: double, single

   See also INTERP1Q, INTERPFT, SPLINE, PCHIP, INTERP2, INTERP3, INTERPN, PPVAL.
   Copyright 1984-2012 The MathWorks, Inc.
   $Revision: 5.41.4.25 $  $Date: 2012/10/29 19:19:25 $
   david.bresch@gmail.com, 20150301, copied as climada_interp1 for speedup (but limited functionality compared to interp1)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_interp1.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_load">
<H2>climada_load</H2></A>
<font color="blue">function [struct_data, struct_name] = climada_load(struct_file,struct_type,silent_mode) </font>
 climada
 MODULE:
   core/helper_functions
 NAME:
   climada_load
 PURPOSE:
   Load any climada struct (entity, EDS, hazard, centroids) and set
   variable_name yourself with struct_data. Identify variable type.
 CALLING SEQUENCE:
   [struct_data, struct_name] = climada_load(struct_file,struct_type)
 EXAMPLE:
   [struct_data, struct_name] = climada_load(struct_file,struct_type)
   entity = climada_load('demo_today')
   measures_impact = climada_load('','measures_impact')
   hazard = climada_load('TCNA_today_small')
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   struct_file: the filename (with path, optional) of a previously saved
       climada structure
       If no path provided, default path ../data/... is used (and
       name can be without extension .mat)
       &ampgt promted for if not given
   struct_type: a string to define the type of a climada struct, i.e 
       'entity', 'hazard', 'measures_impact'. If no struct_file given, the
       prompt will reflect the appropiate folder (data/entities, or
       data/results, ...)
   silent_mode: suppress any output, default=0 (output to command window), =1: no output
 OUTPUTS:
   struct_data: a struct, i.e. hazard, entity, EDS, centroids, etc.
   struct_name: a char that contains the name of the struct, i.e.
   'hazard', 'entity', etc.
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151124, init from climada_entity_load
 Lea Mueller, muellele@gmail.com, 20151130, move to climada/code/helper_functions
 Lea Mueller, muellele@gmail.com, 20151202, enhance to work with multiple variables within one matfile
 Lea Mueller, muellele@gmail.com, 20151207, identify any given struct_file as input, identify entity with .ED field
 Lea Mueller, muellele@gmail.com, 20160203, identify centroids with .centroid_ID
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_load.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_location_sum">
<H2>climada_location_sum</H2></A>
<font color="blue">function [lon_unique, lat_unique, values_sum]= climada_location_sum(lon, lat, values) </font>
 MODULE:
   core/helper_functions
 NAME:
   climada_location_sum
 PURPOSE:
   Sum of values per unique locations
 CALLING SEQUENCE:
   [lon_unique, lat_unique, values_sum]= climada_location_sum(lon, lat, values)
EXAMPLE
   [lon_unique, lat_unique, values_sum]= climada_location_sum([1 1], [2 2], [5 5])
 INPUT:
   lon: a list of longitude coordinates
   lat: a list of latitude coordinates
   value: a list of the same lenght as lon and lat with values                
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   lon_unique: unique longitude coordinates
   lat_unique: unique longitude coordinates
   values_sum: summed values per unique location
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150212, init based on climada_assets_sum
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_location_sum.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_lonlat_cleanup">
<H2>climada_lonlat_cleanup</H2></A>
<font color="blue">function ok=climada_lonlat_cleanup </font>
 climada template
 MODULE:
   core
 NAME:
   climada_lonlat_cleanup
 PURPOSE:
   cleans up old entities and centroids in renaming fields
   .Latitude to .lat and .Longitude to .lon, i.e.:
   entity.assets.Longitude/Latitude -&ampgt entity.assets.lon/lat
   centroids.Longitude/Latitude -&ampgt centroids.lon/lat

   Note: this code is currently invoked ONCE by climada_init_vars. There,
   a small file ../system/climada_lonlat_cleanup_done.txt is written to
   indicate successful execution. We will remove this cleanup in summer
   2015 latest.
 CALLING SEQUENCE:
   ok=climada_lonlat_cleanup
 EXAMPLE:
   ok=climada_lonlat_cleanup
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   ok: =1 if all done, see error messages else
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150203
 David N. Bresch, david.bresch@gmail.com, 20150819, centroids folder added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_lonlat_cleanup.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_map_plot">
<H2>climada_map_plot</H2></A>
<font color="blue">function [input_structure, fig] = climada_map_plot(input_structure,fieldname_to_plot,plot_method,event_no,category_criterium) </font>
 Generate a map plot
 MODULE:
   core/helper_functions
 NAME:
   climada_map_plot
 PURPOSE:
   create a map, for a selected input structure and a fieldname, i.e.
   'elevation_m' of centroids, 'Value' of entity.assets, 'intensity' of
   hazard
 PREVIOUS STEP:
   multiple
 CALLING SEQUENCE:
   [input_structure, fig] = climada_map_plot(input_structure,fieldname_to_plot,plot_method,event_no,category_criterium)
 EXAMPLE:
   [input_structure, fig] = climada_map_plot
   hazard = climada_map_plot('TCNA_today_small','','contourf',7121);
   climada_map_plot(entity,'Value')
   climada_map_plot(centroids,{'elevation_m' 'slope_deg'})
   climada_map_plot(EDS(3),'ED_at_centroid','',1,'Residential') % plot AED at residential houses from EDS(3)
   climada_map_plot('m_demotoday_TCNA2030highsmall',{'ED_at_centroid' 'benefit'},'',2) % plot AED and benefit for measure no 2
 INPUTS:
   input_structure:  a climada stucture, i.e. centroids, entity,
        entity.assets, hazard, EDS, can also be the filename of a saved
        struct, i.e. TCNA_today_small
   fieldname_to_plot: string or cell, i.e. 'Value', or {'elevation_m' 'slope_deg'}
 OPTIONAL INPUT PARAMETERS:
   plot_method: a string, default is 'plotclr', can also be 'contourf'
   event_no: an array, only important to select a specific event for
   'intensity', or number of measure for measures_impact
   category_criterium: a string or cell, e.g. {'Agriculture' 'Residential'}
   to select a subset of assets that will be shown
 OUTPUTS:
   input_structure:  a climada stucture, i.e. centroids, entity,
        entity.assets, hazard, EDS
   fig: handle on the figure with a map displaying the selected field 
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151124, init
 Lea Mueller, muellele@gmail.com, 20151130, enhance to work with measures_impact and plot benefit
 Lea Mueller, muellele@gmail.com, 20151202, enhance to select only one or multiple categories (.assets.Category)
 Lea Mueller, muellele@gmail.com, 20151203, delete struct_no
 Lea Mueller, muellele@gmail.com, 20151207, invoke climada_load to identify input structure
 Lea Mueller, muellele@gmail.com, 20151207, invoke climada_assets_category_ID to identify input structure
 Lea Mueller, muellele@gmail.com, 20151207, do not create a new figure, so we can use it in climada_viewer (gui)
 Lea Mueller, muellele@gmail.com, 20151217, return if ED_at_centroid control and measure do not have same dimension
 Lea Mueller, muellele@gmail.com, 20160107, add workaround to avoid prctile that uses statistics toolbox
 Lea Mueller, muellele@gmail.com, 20160129, invoke climada_find_most_severe_event
 Lea Mueller, muellele@gmail.com, 20160219, bugfix for hazard
 Lea Mueller, muellele@gmail.com, 20160226, start title_str with uppercase
 Lea Mueller, muellele@gmail.com, 20160303, plot damagemap if strfind(damage) somewhere in the fieldname_to_plot
 Lea Mueller, muellele@gmail.com, 20160303, add date of event in title for hazard
 Lea Mueller, muellele@gmail.com, 20160314, add climada_global.caxis_range
 Lea Mueller, muellele@gmail.com, 20160316, set nans to 0
 Lea Mueller, muellele@gmail.com, 20160330, add fprintf if no field to show found
 -
ig = []; % init
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('input_structure', 'var'), input_structure = ''; end
f ~exist('fieldname_to_plot', 'var'), fieldname_to_plot = []; end
f ~exist('plot_method', 'var'), plot_method = []; end
f ~exist('event_no', 'var'), event_no = []; end
f ~exist('struct_no', 'var'), struct_no = []; end
f ~exist('category_criterium','var'), category_criterium = []; end
f isempty(plot_method), plot_method = 'plotclr'; end 
 if isempty(event_no), event_no = 1; end 
f isempty(category_criterium), category_criterium = ''; end 
init
on = []; lat = []; Category = []; ED_at_centroid_control = []; 
ategory_ID = []; Category_name = [];
o_fig = 1;
 identify input structure as a climada structure
input_structure, struct_name] = climada_load(input_structure); 
printf('You have loaded a %s\n',struct_name);
f isempty(input_structure), fprintf('No structure (centroids, hazard, entity) selected to plot on a map\n'); return, end
 take only first structure if it contains more than one (e.g. EDS)
f numel(input_structure)&ampgt1, input_structure = input_structure(1); fprintf('Only first structure extracted\n'); end
 make sure fieldname_to_plot is a cell
f ischar(fieldname_to_plot) &amp&amp ~isempty(fieldname_to_plot), fieldname_to_plot = {fieldname_to_plot}; end
 get all fieldnames
ames = fieldnames(input_structure);
 find fields that require benefit to plot and replace with ED_at_centroid
 and save benefit information in is_benefit
s_benefit = strcmp(fieldname_to_plot,'benefit');
f any(is_benefit)
   fieldname_to_plot{is_benefit} = 'ED_at_centroid';
nd
 special cases for special climada structs
limada_struct_names = {'measures_impact' 'EDS' 'entity' 'hazard' 'centroids'};
f ~any(strcmp(struct_name,climada_struct_names))
   struct_name = 'unknown struct';
nd
itle_str_2 = ''; %init
cenario_name = ''; peril_ID = ''; region = ''; assets_year = ''; hazard_units = ''; event_name = ''; date_str = '';
witch struct_name
   case 'measures_impact'
       % extract measures_impact.EDS
       if isempty(event_no), event_no = 1; end 
       if isfield(input_structure,'EDS')
           if isfield(input_structure,'scenario'),scenario_name = input_structure.scenario.name_simple;end
           input_structure = input_structure.EDS;
           names = fieldnames(input_structure);
           struct_name = 'measures_impact';
           
           % we have more than one EDS, as we have at least one measure
           if numel(input_structure)&ampgt1 
               % get control ED_at_centroid for benefit of a measure
               try, ED_at_centroid_control = input_structure(end).ED_at_centroid; end
               if event_no&ampgtnumel(input_structure), event_no = numel(input_structure); end
               % extract EDS for select measure
               input_structure = input_structure(event_no);
               fprintf('You selected measure %d: %s\n',event_no, input_structure.annotation_name)
           end
           % extract longitudes, latitudes, Category
           if isfield(input_structure,'assets')
               lon = input_structure.assets.lon; lat = input_structure.assets.lat;
               %if isfield(input_structure.assets,'Category'), Category = input_structure.assets.Category;end
               if isfield(input_structure.assets,'Category')
                   Category = getfield(input_structure.assets,'Category');
                   if isfield (input_structure.assets,'Category_name')
                       Category_name = getfield(input_structure.assets,'Category_name');
                       Category_ID = getfield(input_structure.assets,'Category_ID');
                   end
               end
       
           else
               fprintf('No assets found, although you seemed to load a measures_impact.\n')
               return
           end             
       else
           fprintf('No EDS found, although you seemed to load a measures_impact.\n')
           return
       end
       if isfield(input_structure,'peril_ID'),peril_ID = input_structure.peril_ID; end
       title_str_2 = sprintf('\nMeasure %d: %s \n Scenario %s, %s', event_no, input_structure.annotation_name,scenario_name,peril_ID);
       
   case 'EDS'
       % extract longitudes, latitudes
       if isempty(event_no), event_no = 1; end 
       if isfield(input_structure,'assets')
           lon = input_structure.assets.lon; lat = input_structure.assets.lat;
           %if isfield(input_structure.assets,'Category'), Category = input_structure.assets.Category;end
           if isfield(input_structure.assets,'Category')
               Category = getfield(input_structure.assets,'Category');
               if isfield (input_structure.assets,'Category_name')
                   Category_name = getfield(input_structure.assets,'Category_name');
                   Category_ID = getfield(input_structure.assets,'Category_ID');
               end
           end
       
       else
           fprintf('No assets found, although you seemed to load an EDS.\n')
           return
       end
       if isfield(input_structure,'peril_ID'),peril_ID = input_structure.peril_ID; end
       if isfield(input_structure,'scenario'),scenario_name = input_structure.scenario.name_simple;end
       title_str_2 = sprintf('\nScenario %s, %s', scenario_name, peril_ID);   
       
   case 'entity'
       % extract entity.assets
       if isempty(event_no), event_no = 1; end 
       required_fieldname_to_plot = {'Value'};
       if isempty(fieldname_to_plot),fieldname_to_plot = required_fieldname_to_plot; end
       if isfield(input_structure,'assets')
           input_structure = input_structure.assets;
           %struct_name = 'assets';
       else
           fprintf('No assets found, although you seemed to load an entity.\n')
           return
       end    
       %if isfield(input_structure,'Category'), Category = getfield(input_structure,'Category');end
       if isfield(input_structure,'Category')
           Category = getfield(input_structure,'Category');
           if isfield (input_structure,'Category_name')
               Category_name = getfield(input_structure,'Category_name');
               Category_ID = getfield(input_structure,'Category_ID');
           end
       end
       if isfield(input_structure,'region'),region = input_structure.region;end
       if isfield(input_structure,'reference_year'),assets_year = input_structure.reference_year;end
       title_str_2 = sprintf('\nAssets %s %d', region,assets_year); 
       
   case 'hazard'
       % nothing special to extract
       % just set title_str
       if isfield(input_structure,'units'),hazard_units = input_structure.units;end 
       if isfield(input_structure,'peril_ID'),peril_ID = input_structure.peril_ID;end
       if isempty(event_no), event_no = climada_find_most_severe_event(input_structure,-1); end % find most severe event 
       if event_no&amplt0, event_no = climada_find_most_severe_event(input_structure,event_no); end        
       if isfield(input_structure,'name')
           if event_no&ampgtnumel(input_structure.name), event_no = numel(input_structure.name); end
           event_name = strrep(input_structure.name{event_no},'_',' ');
       end
       if isfield(input_structure,'datenum')
           if event_no&ampgtnumel(input_structure.datenum), event_no = numel(input_structure.datenum); end
           date_str = datestr(input_structure.datenum(event_no));
       end
       title_str_2 = sprintf('\nEvent %d: %s, %s', event_no,event_name,date_str);
       %title_str_1 = sprintf('%s (%s %s)',fieldname_to_plot_str, peril_ID, hazard_units);
       
   case 'centroids'
       % nothing special
       if isempty(event_no), event_no = 1; end 
nd
 make sure that we have .lon and .lat information
f isempty(lon)
   if ~isfield(input_structure,'lon') || ~isfield(input_structure,'lat')
       fprintf('This struct does not have .lon and .lat fields\n')
       return   
   else
       lon = input_structure.lon;lat = input_structure.lat;
   end
nd
f isfield(input_structure,'Category')
   Category = getfield(input_structure,'Category');
   if isfield (input_structure,'Category_name')
       Category_name = getfield(input_structure,'Category_name');
       Category_ID = getfield(input_structure,'Category_ID');
   end
nd
 find possible fieldname_to_plot if not given    
f isempty(fieldname_to_plot)
   names = fieldnames(input_structure);
   fieldname_to_plot = {'elevation_m' 'slope_deg' 'TWI' 'intensity' 'Value' 'ED_at_centroid'};
   has_fieldname = ismember(fieldname_to_plot,names);
   if any(has_fieldname)
       % we have found one or more fieldnames to plot
       fieldname_to_plot = fieldname_to_plot(has_fieldname);       
   end
nd     
f isempty(fieldname_to_plot), fprintf('No field to show found.\n'), return, end 

 select specific locations (based on categories, or units)
ilent_mode = 0;
f ~isempty(Category) 
   % create entity for input to climada_assets_select
   entity.assets.lon = lon;
   entity.assets.lat = lat;
   entity.assets.Category = Category;
   if ~isempty(Category_name) 
       entity.assets.Category_name = Category_name;
       entity.assets.Category_ID = Category_ID;
   end
   is_selected = climada_assets_select(entity,[],[],category_criterium,silent_mode);
lse
   is_selected = true(size(lon));
nd
 plot input_structure characteristics
 -----------
points = 2000; plot_centroids = 0;
nterp_method = []; stencil_ext = [];
 create figures
ounter = 0;
or f_i = 1:numel(fieldname_to_plot)
   if isfield(input_structure,fieldname_to_plot{f_i})
       
       % get values
       values = full(getfield(input_structure,fieldname_to_plot{f_i}));
       
       % special case where values are in a matrix, and we want to
       % extract only one event
       [values_i, values_j] = size(values);
       if values_j == numel(lon) &amp&amp values_i&ampgt1 % &amp&amp values_j&ampgt1
           %if values_i&ampgtnumel(lon) 
           if event_no &ampgt values_i; event_no = values_i;end % limit to maximum amount of events
           values = values(event_no,:);
       elseif values_i == numel(lon) &amp&amp values_j&ampgt1 
           if event_no &ampgt values_j; event_no = values_j;end % limit to maximum amount of events
           values = values(:,event_no);
           %end
       end
       
       % special case for benefit, difference of AED control and AED measure
       if is_benefit(f_i)
           if ~isempty(ED_at_centroid_control)
               if numel(ED_at_centroid_control) ~= numel(values), fprintf('Dimensions ED measure and ED control do not agree.\n'); return, end
               values = ED_at_centroid_control - values;
               fieldname_to_plot{f_i} = 'benefit';
           else
               values = '';
           end
       end
           
       if any(values) || ~isempty(values)            
           % select a subset of locations, based on categories
           values(~is_selected) = 0;
           values(isnan(values)) = 0; % overwrite nans
           
           if sum(values)&ampgt0
               counter = counter+1;
           
               % sum up values at every unique location
               [lon_unique, lat_unique, values_sum] = climada_location_sum(lon, lat, values);
               % create title string as combination of title_str_1 and title_str_2
               [~, ~, result_str] = climada_digit_set(sum(values_sum));
               result_str = sprintf('%s %s',climada_global.Value_unit,result_str);
               fieldname_to_plot_str = strrep(fieldname_to_plot{f_i},'_',' ');
               title_str_1 = sprintf('%s (%s)',fieldname_to_plot_str,result_str);
               
               % special colormap for hazard intensities, benefit, asset Value, damage
               if strcmp(fieldname_to_plot{f_i},'intensity') &amp&amp isfield(input_structure,'peril_ID'),
                   cmap = climada_colormap(input_structure.peril_ID);
                   title_str_1 = sprintf('%s (%s %s)',fieldname_to_plot_str, peril_ID, hazard_units);
               elseif strcmp(fieldname_to_plot{f_i},'benefit'), cmap = climada_colormap('benefit');
               elseif strcmp(fieldname_to_plot{f_i},'Value'), cmap = climada_colormap('assets');
               elseif strcmp(fieldname_to_plot{f_i},'ED_at_centroid'), cmap = climada_colormap('damage');
               elseif any(strfind(fieldname_to_plot{f_i},'damage')), cmap = climada_colormap('damage');
               else cmap = jet(64); 
                   try cmap = climada_colormap(input_structure.peril_ID);end
               end
               title_str_1(1) = upper(title_str_1(1));
               caxis_range = [];
               if isfield(climada_global,'caxis_range'), caxis_range = climada_global.caxis_range; end
               if isempty(caxis_range)
                   try %uses statistics toolbox
                      caxis_max = prctile(values_sum,99.5);
                   catch 
                       requested_rank = round(numel(values_sum)*(1-0.995))+1;
                       values_ordered = sort(values_sum,'descend');
                       caxis_max = values_ordered(requested_rank);
                   end
                   caxis_range = [0 caxis_max]; 
               end
               title_str = sprintf('%s %s',title_str_1,title_str_2);
               if no_fig
                   climada_color_plot(values_sum,lon_unique,lat_unique,'none',...
                                       title_str,plot_method,interp_method,npoints,plot_centroids,caxis_range,cmap,stencil_ext);
               else
                   fig(counter) = climada_color_plot(values_sum,lon_unique,lat_unique,fieldname_to_plot{f_i},...
                                       title_str,plot_method,interp_method,npoints,plot_centroids,caxis_range,cmap,stencil_ext);
               end
               values = []; values_sum = []; % reset      
           end
       end
   else
       fprintf('No field to show found.\n'),
   end
nd
 %title_str = sprintf('%s (%s), event %d',fieldname_to_plot_str,result_str,event_no);
 event_no_name = []; struct_no_name = [];
 if isfield(input_structure,'annotation_name'),event_no_name = strrep(input_structure.annotation_name,'_',' ');end
 %if isfield(input_structure,'scenario'),struct_no_name = input_structure.scenario.name_simple;end
 if isfield(input_structure,'peril_ID'),struct_no_name = sprintf('%s, %s',scenario_name,input_structure.peril_ID);end
 title_str_2 = ''; %init
 switch struct_name
     case 'measures_impact'
         title_str_2 = sprintf('\nMeasure %d: %s \n Scenario %d: %s', event_no,event_no_name,struct_no,struct_no_name);
     case 'EDS'
         title_str_2 = sprintf('\nEvent %d: %s', event_no,event_no_name);    
     case 'assets'
         region = ''; assets_year = '';
         if isfield(input_structure,'region'),region = input_structure.region;end
         if isfield(input_structure,'reference_year'),assets_year = input_structure.reference_year;end
         title_str_2 = sprintf('\nAssets %s %d', region,assets_year);    
     case 'hazard'
         units = ''; peril_ID = '';
         if isfield(input_structure,'units'),units = input_structure.units;end
         if isfield(input_structure,'peril_ID'),peril_ID = input_structure.peril_ID;end
         title_str_1 = sprintf('%s (%s %s)',fieldname_to_plot_str, peril_ID, units);
         if isfield(input_structure,'name'),event_no_name = strrep(input_structure.name{event_no},'_',' ');end
         title_str_2 = sprintf('\nEvent %d: %s', event_no,event_no_name);   
     case 'centroids'
 end
 if any(strcmp(fieldname_to_plot,'intensity')), struct_name = 'hazard'; end
 if any(strcmp(fieldname_to_plot,'elevation_m')), struct_name = 'centroids'; end
 % special case if it is a measures_impact
 required_names = {'EDS' 'benefit' 'cb_ratio' 'NPV_total_climate_risk'};
 if sum(ismember(required_names,names))&ampgt=2 
     % extract measures_impact.EDS
     if isfield(input_structure,'EDS')
         if isfield(input_structure,'scenario'),scenario_name = input_structure.scenario.name_simple;end
         input_structure = getfield(input_structure,'EDS');
         names = fieldnames(input_structure);
         struct_name = 'measures_impact';
     else
         fprintf('No EDS found, although you seemed to load a measures_impact.\n')
         return
     end
 end  
 % special case if it is an EDS
 required_names = {'ED' 'annotation_name'};
 required_fieldname_to_plot = {'ED_at_centroid'};
 if sum(ismember(required_names,names))&ampgt=2 
     if isempty(fieldname_to_plot),fieldname_to_plot = required_fieldname_to_plot; end
     % extract longitudes, latitudes
     if isfield(input_structure,'assets')
         if event_no&ampgtnumel(input_structure), event_no = numel(input_structure); end
         lon = getfield(input_structure(event_no).assets,'lon');
         lat = getfield(input_structure(event_no).assets,'lat');
         if isfield(input_structure(event_no).assets,'Category'), Category = getfield(input_structure(event_no).assets,'Category');end
     else
         fprintf('No assets found, although you seemed to load an EDS.\n')
         return
     end
     if numel(input_structure)&ampgt1 % we have more than one EDS
         % get control ED_at_centroid for benefit of a measure
         try, ED_at_centroid_control = input_structure(end).ED_at_centroid; end
         input_structure = input_structure(event_no);
         fprintf('You selected EDS event no %d (%s).\n',event_no, input_structure.annotation_name)
     end
     if ~strcmp(struct_name,'measures_impact'), struct_name = 'EDS'; end
 else
     % special case, if it is an entity
     required_names = {'assets' 'damagefunctions' 'measures' 'discount'};
     required_fieldname_to_plot = {'Value'};
     if sum(ismember(required_names,names))&ampgt=2 
         % extract entity.assets
         if isempty(fieldname_to_plot),fieldname_to_plot = required_fieldname_to_plot; end
         %if ~strcmp(fieldname_to_plot,required_fieldname_to_plot),fieldname_to_plot = {'assets'};end
         if isfield(input_structure,'assets')
             input_structure = input_structure.assets;
             struct_name = 'assets';
         else
             fprintf('No assets found, although you seemed to load an entity.\n')
             return
         end      
     end
 end
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_map_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measure_regional_scope">
<H2>climada_measure_regional_scope</H2></A>
<font color="blue">function EDS = climada_measure_regional_scope(EDS_in,within_scope,EDS_control) </font>
 climada
 NAME:
   climada_measure_regional_scope
 PURPOSE:
   Limit impact of measure to a given regional scope, correct
   EDS.ED_at_centroid and EDS.ED.
   Note: EDS.damage now holds an incorrect value, and should not be used anyore
   to be called in climada_measures_impact
 CALLING SEQUENCE:
   EDS = climada_measure_regional_scope(EDS_in,regional_scope,EDS_control)
 EXAMPLE:
   EDS = climada_measure_regional_scope(EDS_in,regional_scope,EDS_control)
 INPUTS:
   EDS_in: a climada EDS structure with .ED_at_centroid
   within_scope: an logical array defining the regional scope
   EDS_control: a climada EDS structure with .ED_at_centroid with original damage values without measure
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   EDS: a climada EDS structure with corrected damages depening on regional impact of measure
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150908, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measure_regional_scope.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_assets_change">
<H2>climada_measures_assets_change</H2></A>
<font color="blue">function assets = climada_measures_assets_change(measures,measure_i) </font>
 climada
 NAME:
   climada_measures_assets_change
 PURPOSE:
   Read new assets from excel if defined so in measures.assets_file
   If measures.assets_file{measure_i} is 'nil', assets remains empty
   Note: assets are not yet encoded
   to be called in climada_measures_impact
 CALLING SEQUENCE:
   assets = climada_measures_assets_change(measures,measure_i)
 EXAMPLE:
   assets = climada_measures_assets_change(measures,measure_i)
 INPUTS:
   measures: a measures structure
   measire_i: an array between 1 and n_measures
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   assets: an asset structure with
       .lon, .lat, .Value, etc. not encoded
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150908, init
 Lea Mueller, muellele@gmail.com, 20150930, save assets.filename with .mat as extension
 Lea Mueller, muellele@gmail.com, 20151117, call climada_assets_read instead of climada_entity_read
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_assets_change.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_attach_measures">
<H2>climada_measures_attach_measures</H2></A>
<font color="blue">function measures = climada_measures_attach_measures(measures1,measures2,silent_mode) </font>
 climada measures attach another measures
 MODULE:
   core/helper_functions
 NAME:
   climada_measures_impact_attach_measures_impact
 PURPOSE:
   Attach/enlarge measures with another measures, so that the new measures
   structure contains all measures (.name, .cost.,
   .hazard_intensity_impact_a, ...)

 CALLING SEQUENCE:
   measures = climada_measures_attach_measures(measures1,measures2,silent_mode)
 EXAMPLE:
   measures = climada_measures_attach_measures((measures1,measures2,silent_mode)
 INPUTS:
   measures1: a climada measures, as read from climada_measures_read;
   measures2: a climada measures, as read from climada_measures_read;
 OPTIONAL INPUT PARAMETERS:
   silent_mode: default is 0, set to 1, if you do not want command line output
 OUTPUTS:
   measures: the measures containing all information
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151217, init 
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_attach_measures.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_check">
<H2>climada_measures_check</H2></A>
<font color="blue">function measures = climada_measures_check(measures, assets) </font>
 climada_measures_check
 NAME:
   climada_measures_check
 PURPOSE:
   Check measures (just a check, but no changes/improvements) to be aware
   if the measures decrease or (accidentally) increase the damage
   can be called from: climada_measures_read
   climada_measures_check(measures)
 EXAMPLE:
   climada_measures_check(measures)
 INPUTS:
   measures: a measures structure 
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   none, just stdout information
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150907, init
 Lea Mueller, muellele@gmail.com, 20150909, check if a measure implies to use a differerent assets file
 Lea Mueller, muellele@gmail.com, 20150915, check that regional_scope matrix has the correct dimension 
 Lea Mueller, muellele@gmail.com, 20150916, shorten or enlarge regional_scope if needed 
 Lea Mueller, muellele@gmail.com, 20150921, hand back corrected measures
 Lea Mueller, muellele@gmail.com, 20151117, correct fprintf
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_check.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_encode">
<H2>climada_measures_encode</H2></A>
<font color="blue">function measures=climada_measures_encode(measures) </font>
 climada
 NAME:
   climada_measures_encode
 PURPOSE:
   encode measures, i.e. process the damagefunctions_map to convert it
   into a damagefunctions_mapping, which allows climada_measures_impact to
   switch damagefunctions for specific measures. Also convert color
   triples as string into RGB color triplets. Plus some sanity checks.

   Previous call: climada_entity_read (usually called in there,
       climada_measures_encode is a low-level function)

   See also climada_damagefunctions_read and climada_damagefunctions_map
 CALLING SEQUENCE:
   measures=climada_measures_encode(measures);
 EXAMPLE:
   measures=climada_measures_encode(climada_measures_read);
 INPUTS:
   measures: a structure, with the measures as read in climada_entity_read
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   measures: a structure, with the measures as input, plus the fields
       color_RGB: the RGB triples (each element range 0..1), default all
       yellow, if troubles arise converting measures.color (the
       triple, but as text, often troubles if read in Octave)
   damagefunctions_mapping: the damagefunctions_map converted into a
       direct index, i.e. from damagefunctions_map(i)='1to3;4to7' to a mapping
       damagefunctions_mapping(i).map_from(i)=[1 4]
       damagefunctions_mapping(i).map_to(i)=[3 7] etc.
   hazard_intensity_impact_b: older entities
       might still have hazard_intensity_impact and hence we rename it to
       hazard_intensity_impact_b. See excel_template.xls and the comment
       for column 'hazard intensity impact' in tab 'measures'.
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20100107
 David N. Bresch, david.bresch@gmail.com, 20141121, using only damagefunctions_map information
 David N. Bresch, david.bresch@gmail.com, 20150103, some checks for .ods imported entities
 David N. Bresch, david.bresch@gmail.com, 20150518, safety checkin
 Lea Mueller, muellele@gmail.com, 20150902, rename to hazard_intensity_impact_b from hazard_intensity_impact
 David N. Bresch, david.bresch@gmail.com, 20150907, keep color_RGB if provided on input
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_encode.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact2EDS_waterfall">
<H2>climada_measures_impact2EDS_waterfall</H2></A>
<font color="blue">function [EDS1, EDS2, EDS3, is_today, is_eco, is_cc] = climada_measures_impact2EDS_waterfall(measures_impact,measure_no,category_selected,silent_mode) </font>
 climada measures impact combine scenario
 MODULE:
   core/helper_functions
 NAME:
   climada_measures_impact2EDS_waterfall
 PURPOSE:
   Extract 3 EDS from measures_impact that contains 3 or more
   structs/scenarios to plot waterfall (in the next step)
   
   invokes: climada_scenario_identify if more than 3 structs given
 NEXT: climada_waterfall_graph
 CALLING SEQUENCE:
   [EDS1, EDS2, EDS3, is_today, is_eco, is_cc] = climada_measures_impact2EDS_waterfall(measures_impact,measure_no,category_selected,silent_mode)
 EXAMPLE:
   [EDS1, EDS2, EDS3] = climada_measures_impact2EDS_waterfall(measures_impact)
 INPUTS:
   measures_impact: a climada measures_impact structure (as returned eg 
       by climada_measures_impact). Holds at least three structs (one for
       today, one for econ. development, one for climate change).
 OPTIONAL INPUT PARAMETERS:
   measure_no: default is end/control scenario, but can also be a specific measure
   category_selected: a string or a cell, e.g. 'Houses', or {'Houses' 'Public'},  if empty all assets will be selected
   silent_mode: default =0
 OUTPUTS:
   EDS1: a climada EDS struct for scenario today, with EDS.ED summed for a
      specific category
   EDS2: same as above but for scenario economic development
   EDS3: same as above but for scenario climate change
   is_today: a number pointing to the order in which the original EDS was
      located within measurse_impact
   is_eco: a number pointing to the order in which the original EDS was
      located within measurse_impact
   is_cc: a number pointing to the order in which the original EDS was
      located within measurse_impact
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151202, init
 Lea Mueller, muellele@gmail.com, 20151202, add option silent_mode
 Lea Mueller, muellele@gmail.com, 20151217, bugfix if no scenarios identified
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_impact2EDS_waterfall.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_attach_measures_impact">
<H2>climada_measures_impact_attach_measures_impact</H2></A>
<font color="blue">function measures_impact = climada_measures_impact_attach_measures_impact(measures_impact1,measures_impact2,silent_mode) </font>
 climada measures attach another measures_impact
 MODULE:
   core/helper_functions
 NAME:
   climada_measures_impact_attach_measures_impact
 PURPOSE:
   Attach/enlarge a measure impact structure with another one. I.e.
   if you have calculated two measures_impact based on two different
   entity.measures, add both into one structure (does not add up benefits
   or damages, but enlarges the structure).

 CALLING SEQUENCE:
   measures_impact = climada_measures_impact_attach_measures_impact(measures_impact1,measures_impact2,silent_mode)
 EXAMPLE:
   measures_impact = climada_measures_impact_attach_measures_impact(measures_impact1,measures_impact2,silent_mode)
 INPUTS:
   measures_impact1: a climada measures_impact structure (as returned eg 
       by climada_measures_impact).
   measures_impact2: a climada measures_impact structure (as returned eg 
       by climada_measures_impact) if measures_impact2 is an array of 
       measures_impact2(i), the code will find the matching scenario
 OPTIONAL INPUT PARAMETERS:
   silent_mode: default is 1, set to 0, if you want command line output
 OUTPUTS:
   measures_impact: the combined measures_impact
       Please note that assets are likely not meaningful, since just taken
       from measures_impact1 (in order to allow to store resulting measures_impact back into an
       array of measures_impacts if needed)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151217, init 
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_impact_attach_measures_impact.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_combine">
<H2>climada_measures_impact_combine</H2></A>
<font color="blue">function measures_impact=climada_measures_impact_combine(measures_impact1,measures_impact2,combine_modus,silent_mode) </font>
 climada measures impact combine
 MODULE:
   core/helper_functions
 NAME:
   climada_measures_impact_combine
 PURPOSE:
   Combine two measure impact structures, i.e. add averted damages. The 
   codes in essence takes measures_impact=measures_impact1 and then adds 
   relevant fields (benfit, ED_benefit) from measures_impact2. Hence 
   please make sure the 'main' peril is in measures_impact1 (e.g. TC in 
   measures_impact1, TS in measures_impact2). Note that ONLY averted 
   damages/benefits are added, we do NOT add costs, as most often the cost 
   of the measures include the total costs. Hence edit the resulting 
   measures_impact yourself in case costs should be additive.

   call before: climada_adaptation_cost_curve
 CALLING SEQUENCE:
   measures_impact=climada_measures_impact_combine(measures_impact1,measures_impact2,combine_modus,silent_mode)
 EXAMPLE:
   measures_impact=climada_measures_impact_combine(measures_impact1,measures_impact2,combine_modus,silent_mode)
 INPUTS:
   measures_impact1: a climada measures_impact structure (as returned eg 
       by climada_measures_impact).
   measures_impact2: a climada measures_impact structure (as returned eg 
       by climada_measures_impact) if measures_impact2 is an array of 
       measures_impact2(i), the code will recursively treat them
 OPTIONAL INPUT PARAMETERS:
   combine_modus: a string, either 'add_measures' or 'delete_measures' to
   add impacts from measures that only exist in measures_impact1 or
       measures_impact2, or to delete measures that do not exist in both
       measures_impacts
 OUTPUTS:
   measures_impact: the combined measures_impact
       Please note that assets are likely not meaningful, since just taken
       from measures_impact1 (in order to allow to store resulting measures_impact back into an
       array of measures_impacts if needed)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150617, init based on climada_EDS_combine
 Lea Mueller, muellele@gmail.com, 20151202, combine also EDS, add 'delete_measures' option
 Lea Mueller, muellele@gmail.com, 20151202, add option silent_mode
 Lea Mueller, muellele@gmail.com, 20151217, attach/enlarge ED_at_centroid, assets.lon, .lat, .Category... if different locations
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_impact_combine.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_combine_scenario">
<H2>climada_measures_impact_combine_scenario</H2></A>
<font color="blue">function measures_impact = climada_measures_impact_combine_scenario(measures_impact1,measures_impact2,measures_impact3,peril_list,silent_mode) </font>
 climada measures impact combine scenario
 MODULE:
   core/helper_functions
 NAME:
   climada_measures_impact_combine
 PURPOSE:
   Combine measure impact structures for a given scenario, i.e. add
   damages and averted damages for a list of selected perils, so that we have an
   overall impact of averted damage per scenario. Needs
   measures_impact.scenario field.

   invokes: climada_measures_impact_combine
 CALLING SEQUENCE:
   measures_impact=climada_measures_impact_combine_scenario(measures_impact1,measures_impact2,measures_impact3,peril_list,silent_mode)
 EXAMPLE:
   measures_impact=climada_measures_impact_combine_scenario(measures_impact1,'','',{'TC' 'FL'})
 INPUTS:
   measures_impact1: a climada measures_impact structure (as returned eg 
       by climada_measures_impact).
   measures_impact2: a climada measures_impact structure (as returned eg 
       by climada_measures_impact) if measures_impact2 is an array of 
       measures_impact2(i), the code will recursively treat them
    measures_impact3: a climada measures_impact structure (as returned eg 
       by climada_measures_impact) if measures_impact3 is an array of 
       measures_impact3(i), the code will recursively treat them
    peril_list: a cell with list of peril IDs, i.e. {'TC' 'FL'}
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   measures_impact: the combined measures_impact, summed up all perils per
       scenario
       Please note that assets are likely not meaningful, since just taken
       from measures_impact1 (in order to allow to store resulting measures_impact back into an
       array of measures_impacts if needed)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151202, init
 Lea Mueller, muellele@gmail.com, 20151202, add option silent_mode
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_impact_combine_scenario.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_discount">
<H2>climada_measures_impact_discount</H2></A>
<font color="blue">function measures_impact = climada_measures_impact_discount(entity,measures_impact,measures_impact_reference,unit_or_cat_flag,criterium) </font>
 climada
 NAME:
   climada_measures_impact_discount
 PURPOSE:
   calculate the benefit-cost ratio based on discounted benefits and costs
   for series of measures on a given set measures_impact.EDS
   called from climada_measures_impact
   can also be called separately in order to calculate benefit-cost ratio
   only for a selection of assets (e.g. only for USD, or category 7)
   previous step: climada_measures_impact
 CALLING SEQUENCE:
   measures_impact = climada_measures_impact_discount(entity,measures_impact,measures_impact_reference,unit_or_cat_flag,criterium)
 EXAMPLE:
   measures_impact = climada_measures_impact_discount(entity,measures_impact,'no')
   measures_impact = climada_measures_impact_discount(entity,measures_impact,'no','unit','USD')
   measures_impact = climada_measures_impact_discount(entity,measures_impact,'no','category',2)
 INPUTS:
   entity: a read and encoded assets and damagefunctions file, see climada_assets_encode(climada_assets_read)
       &ampgt promted for if not given
   measures_impact: measures impact structure (e.g. portfolio future and measures future)
       with only the following fields .EDS, .measures and .risk_transfer
 OPTIONAL INPUT PARAMETERS:
   measures_impact_reference: reference measures (e.g. portfolio today and
       measures today). Used to properly calculate the net present values
       of future impacts
       set to 'no' if you would not like to be asked for a reference
   unit_or_cat_flag: a string, either 'unit' or 'category'
   criterium: a string or an array to define the unit or category for the 
       subselection of asset values, e.g. 'USD', 'people', 2
 OUTPUTS:
   measures_impact: a structure with
       ED(measure_i): the annual expected damage to the assets under measure_i,
           last one ED(end) for no measures
       benefit(measure_i): the benefit of measure_i
       cb_ratio(measure_i): the cost/benefit ratio of measure_i
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150902, separate function to be called in climada_measures_impact
 Lea Mueller, muellele@gmail.com, 20150924, set to silent mode in climada_assets_select
 Lea Mueller, muellele@gmail.com, 20150925, correct discounting if reference scenario is provided
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_impact_discount.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_load">
<H2>climada_measures_impact_load</H2></A>
<font color="blue">function measures_impact=climada_measures_impact_load(measures_impact_file,time_estimate) </font>
 climada
 MODULE:
   climada core
 NAME:
   climada_measures_impact_load
 PURPOSE:
   load a previously saved measures_impact (just to avoid typing long paths and
   filenames in the command window)
 CALLING SEQUENCE:
   measures_impact_out=climada_measures_impact_load(measures_impact_file)
 EXAMPLE:
   measures_impact_out=climada_measures_impact_load(measures_impact_file)
 INPUTS:
   measures_impact_file: the filename (with path, optional) of a previously saved
       measures_impact, see salvador_calc_measures
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   measures_impact_out: a struct, see e.g. salvador_calc_measures for details
 MODIFICATION HISTORY:
 Jacob Anz, j.anz@gmx.net, 20151106, init
 Lea Mueller, muellele@gmail.com, 20151127, enhance to work with complete measures_impact as input
 Jacob Anz, j.anz@gmx.net, 20151202, enable the loading of variables which are internally not exactly named measures_impact
 and add loading time estimate
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_impact_load.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_read">
<H2>climada_measures_impact_read</H2></A>
<font color="blue">function measures_impact = climada_measures_impact_read(measures) </font>
 climada measures impact read (from measures-xls file)
 NAME:
   climada_measures_impact_read
 PURPOSE:
   Create measures_impact struct from measures.cost and
   measures.benefit, read from the excel file. Works only if field
   &quotbenefit&quot is given in the measures-xls file.
   
   Plot adaptation cost curve directy with measures-xls field instead of
   calculation benefits with climada_measures_impact
 CALLING SEQUENCE:
  measures_impact = climada_measures_impact_read(measures)
 EXAMPLE:
    measures_impact = climada_measures_impact_read
    measures_impact = climada_measures_impact_read('measures_impact_xls.xls')
 INPUTS:
   measures: the measures as read from climada_measures_read or the 
       filename of the Excel file with the measures
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   measures_impact: a structure that can be plotted with climada_adaptation_cost_curve,
       i.e. with fields .benefit, .cb_ratio, .measures, etc.
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160523, init
 Lea Mueller, muellele@gmail.com, 20160531, NVP_total_climate_risk is an array instead of a vector
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_impact_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_report">
<H2>climada_measures_impact_report</H2></A>
<font color="blue">function output_report = climada_measures_impact_report(measures_impact,xls_file,sheet) </font>
 MODULE:
   climada core
 NAME:
   climada_measures_impact_report
 PURPOSE:
   Write out measures_impact report (discounted benefits over time horizon, costs, benefit/cost ratio)
 CALLING SEQUENCE:
   output_report = climada_measures_impact_report(measures_impact,xls_file,sheet)
 EXAMPLE:
   output_report = climada_measures_impact_report
 INPUTS:
   measures_impact: climada measures_impact structure, with fields 
       .benefit, .cb_ratio, measures.cost, .measures.name 
       can hold multiple measures_impact files
 OPTIONAL INPUT PARAMETERS:
   xls_file: filename (and path) to save the report to (as .xls), if
       empty, prompted for.Can be set to 'NO_xls_file' to omit creation of
       xls file instead only creates the cell &quotoutput_report&quot
   sheet: sheet name for xls file, if empty, default excel name is &quotSheet1&quot
 OUTPUTS:
   output_report: cell including header and ED values
   report file written as .xls
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150907, init
 Lea Mueller, muellele@gmail.com, 20150909, add NPV total climate risk
 Lea Mueller, muellele@gmail.com, 20150924, enhance to cope with multiple measures_impact's
 Lea Mueller, muellele@gmail.com, 20151106, move to core
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_impact_report.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_read">
<H2>climada_measures_read</H2></A>
<font color="blue">function [measures, measures_impact] = climada_measures_read(measures_filename) </font>
 climada measures read import
 NAME:
   climada_measures_read
 PURPOSE:
   read the Excel file with the list of measures, usually called from
   climada_entity_read. The field &quotcost&quot is
   mandatory otherwise measures are not read.

   This code allows single Excel files with measures
   (and, if a tab damagefunctions exists, damage functions, and if a tab 
   assets exists, regional_scope of measures) to be read
   The user will then have to 'switch' measures in an already read and
   encoded entity with the measures read here.
 CALLING SEQUENCE:
   measures = climada_measures_read(measures_filename)
 EXAMPLE:
   measures = climada_measures_read;
 INPUTS:
   measures_filename: the filename of the Excel file with the measures
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   measures: a structure, with the measures, including .regional_scope if
   assets tab found wich specifies the regional_scope of a measure
 MODIFICATION HISTORY:
 David N. Bresch,  david.bresch@gmail.com, 20091228
 David N. Bresch,  david.bresch@gmail.com, 20130316, vulnerability-&ampgtdamagefunctions...
 Jacob Anz, j.anz@gmx.net, 20150819, use try statement to check for damagefunctions in excel sheet
 Lea Mueller, muellele@gmail.com, 20150907, add measures sanity check
 Lea Mueller, muellele@gmail.com, 20150915, add read the &quotassets&quot tab which defines the regional scope of one or more measures
 Lea Mueller, muellele@gmail.com, 20150916, omit nans in regional_scope 
 Lea Mueller, muellele@gmail.com, 20151016, delete nans in measures.name if there are invalid entries
 Lea Mueller, muellele@gmail.com, 20151119, use climada_assets_read, use spreadsheet_read instead of xls_read
 David Bresch, david.bresch@gmail.com, 20151119, bugfix for Octave to try/catch xlsinfo
 Jacob Anz, j.anz@gmx.net, 20151204, remove measures.damagefunctions if empty
 Lea Mueller, muellele@gmail.com, 20160523, complete extension, if missing
 Lea Mueller, muellele@gmail.com, 20160523, add measures_impact, invoke climada_measures_impact_read
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_measures_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_nonspheric_distance_m">
<H2>climada_nonspheric_distance_m</H2></A>
<font color="blue">function [fDistance_km,GridVect] = climada_nonspheric_distance_m(fLon1,fLat1,fLon2,fLat2,CUID, inreach) </font>
 This function calculates the distance for each individual gridpoint from
 the TC center. Distance differences in x direction, depending on
 latitude, are normalized in the whole inreach-box with the value at the
 TC-Center

View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_nonspheric_distance_m.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_octave">
<H2>climada_octave</H2></A>
<font color="blue">function ok=climada_octave </font>
 climada octave
 MODULE:
   core
 NAME:
   climada_octave
 PURPOSE:
   Sourced at the end of climada_init_vars if the system we're running on
   is Octave instead of MATLAB

   This way, we can handle any specifics at startup

   Currently, Octave specifc are:
   - admin0.mat contains non-ASCII characters, remedied for Octave
   - climada_global.map_border_file is set to
     climada_global.coastline_file, since Octave takes about 6 sec to plot
     borders based on admin0.mat, compared to only 0.1 sec if based on
     coastline.mat. WARNING: it could be somebody uses map_border_file in
     a specific sense, in which case this shortcut might trigger problems.

 CALLING SEQUENCE:
   ok=climada_octave
 EXAMPLE:
   ok=climada_octave
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   ok: =1, if running on Octave
       =0, if MATLAB (the default)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141231, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_octave.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_odsread">
<H2>climada_odsread</H2></A>
<font color="blue">function res=climada_odsread(interactive_mode,ods_file,ods_sheet,silent_mode) </font>
 climada ods (open data spreadsheet) data import read
 NAME:
   climada_odsread
 PURPOSE:
   read one ods sheet from an ods file and return the content in a
   structure. Mainly a wrapper to invoke loadods and then sort into a 
   struct as uased in climada. 
   Limited functionality compared to climada_xlsread
   
   The sheet might contain as  many columns as you like, the first row (1)
   is interpreted as header and converted into field names, the data in.
   Empty columns are skipped

   HINT: Sometimes, not all columns of an .ods sheet are read, just
   copy/paste as values in ods, it often helps. It looks as if columns
   with results of functions are skiped... therefore, copy/paste as values

 CALLING SEQUENCE:
   res=climada_odsread(interactive_mode,ods_file,ods_sheet);
 EXAMPLE:
   res=climada_odsread(interactive_mode,ods_file,ods_sheet);
 INPUTS:
   interactive_mode: 'interactive' or 'no'. If interactive, the user gets
       prompted for the sheet in the Excel file
       (Currently hard-wired to interactive)
   ods_file: the Excel file to read, prompted for if not given
   ods_sheet: the ods sheet to read in the ods_file
       given the simplicity of the ods implementation, the sheet name is
       needed, the oce fails if not given (does not even read the first
       sheet, sorry)
 OPTIONAL INPUT PARAMETERS:
   silent_mode: if =1, do not write messages to stdout, default=0, means writing
 OUTPUTS:
   res: a structure holding the data from the selected Excel sheet
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20130401
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_odsread.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_ACE">
<H2>climada_plot_ACE</H2></A>
<font color="blue">function tc_track = climada_plot_ACE(tc_track, name_tag, check_printplot) </font>
 ---------------------------------------------
% ACCUMULATED CYCLONE ENERGY ACE
 % The ACE of a season is calculated by 
 % summing the squares of the estimated maximum sustained velocity of
 % - every active tropical storm (wind speed 35 knots (65 km/h) or higher),
 % - at six-hour intervals. 
 ---------------------------------------------

 plot histograms of Accumulated Cyclone Energy ACE, No. of storms per
 seasons, No. of hurricanes and No. of major hurricanes per season of
 probabilistic tracks, with historical tracks indicated with dotted black
 lines
 NAME:
   climada_plot_ACE
 PURPOSE:
   given a probabilistic tc_track structure, histograms of ACE, No. storms,
   hurricanes and major hurricanes per season and compare with historical
   histograms (black dotted lines), check distributions
   ACE of a season is calculated by summing the squares of the estimated 
   maximum sustained velocity of
   - every active tropical storm (wind speed 35 knots (65 km/h) or higher),
   - at six-hour intervals. 
 
   previous step:  generation of probabilistic tracks, 
   tc_track_prob = climada_tc_random_walk_position_windspeed;
   next step:      
 CALLING SEQUENCE:
   climada_plot_ACE(tc_track, name_tag, check_printplot)
 EXAMPLE:
   climada_plot_ACE(tc_track_prob, '4480', 1)
 INPUTS:
   tc_track: probabilistic tc track set (random walk of wind speed, 
   longitude and latitude), wind speed in knots, nodes every six hours
 OPTIONAL INPUT PARAMETERS:
   name_tag:        string that will be used for name of printed pdf
   check_printplot: if set to 1 will print (save) figure
 OUTPUTS:
   figure, printout of figure if requested
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110621
 davids.bresch@gmail.com, 20120407
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_plot_ACE.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_IFC_return">
<H2>climada_plot_IFC_return</H2></A>
<font color="blue">function climada_plot_IFC_return(hazard,centroids,important_centroid,check_printplot) </font>
 climada intensity vs return period for multiple centroids
 based on probabistic hazard set
 NAME:
   climada_plot_IFC_return
 PURPOSE:
   find all wind speed greater zero that hit important centroid
   (historical and probabilistic storms)
   calculate the exceedence frequency and return period
   fit a gumbel distribution for requested return period and extrapolate
   according wind speed values
   plot wind speed vs return period
 CALLING SEQUENCE:
   climada_plot_IFC_return(hazard,centroids,important_centroid,check_printplot);
 EXAMPLE:
   climada_plot_IFC_return
 INPUTS:
   hazard: probabilistic hazard set (structure)
   centroids
   important_centroid: index number of one or multiple centroids (scalar or array)
 OPTIONAL INPUT PARAMETERS:
   check_printplot: if set to 1 will print (save) figure
 OUTPUTS:
   none
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 Lea Mueller, 19.05.2011
 David N. Bresch, david.bresch@gmail.com, 20141222, bugfix to make it work again
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_plot_IFC_return.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_probabilistic_wind_speed_map">
<H2>climada_plot_probabilistic_wind_speed_map</H2></A>
<font color="blue">function climada_plot_probabilistic_wind_speed_map(tc_track, track_req) </font>
 plot historical tc track (Longitude, Latitude) in world map according to
 saffir-simpson hurrican scale. Add plot of probabilistic generated sister
 storms. Historical tracks has black lines around markers to identify as
 original track.
 NAME:
   climada_plot_probabilistic_wind_speed_map
 PURPOSE:
   analyse visually historical tc track and its generated probabilistic
   sister storms. Check Longitude, Latitude and wind speed category
   (saffir-simpson hurricane scale) 
 CALLING SEQUENCE:
   climada_plot_probabilistic_wind_speed_map(tc_track)
 EXAMPLE:
   climada_plot_probabilistic_wind_speed_map
 INPUTS:
   tc_track: probabilistic tc track set (random walk of wind speed, 
   longitude and latitude), wind speed in knots, nodes every six hours, if
   not given, prompted for
 OPTIONAL INPUT PARAMETERS:
   track_req:  number of specific historical track to be displayed with
   its probabilistic sister storms, prompts for input 
   p:          to print figure
   x:          to exit
   41:         or any other track number. will be rounded to the nearest 
               historical track.
   enter:      to continue.
 OUTPUTS:
   figure, printout of figure if requested
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20110628
 Lea Mueller, muellele@gmail.com, 20150319, only every 6h a node
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_plot_probabilistic_wind_speed_map.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_tc_track_season">
<H2>climada_plot_tc_track_season</H2></A>
<font color="blue">function climada_plot_tc_track_season(tc_track, season, markersize, check_printplot, invisible) </font>
 plot historical tc tracks for one specific season (year) in colors 
 according to saffir-simpson hurricane scale
 NAME:
   climada_plot_tc_track_season
 PURPOSE:
   plot tc tracks for one specific season in colors according to saffir-simpson
   hurricane scale
   provide handle of tc_track
 CALLING SEQUENCE:
   [h] = climada_plot_tc_track_season(tc_track,season,markersize,check_printplot,invisible)
 EXAMPLE:
   [h] = climada_plot_tc_track_season(tc_track,1980,10,1,1)
 INPUTS:
	tc_track:       one or more tc_tracks (structure)
   season:         specific season (scalar or vector) for tc tracks to be plotted,
                   e.g. 2012, or 2000:2012
 OPTIONAL INPUT PARAMETERS:
   markersize:     markersize of tc_track nodes, default 7   
   check_printplot:if set to 1 figure is saved in folder
                   \results\mozambique\tc_tracks\tracks_1978.pdf
   invisible:      if set to 1 figure is not visible on screen
 OUTPUTS:
   h:               handle of tc_track nodes
 Lea Mueller, 20110606
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_plot_tc_track_season.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_tc_track_stormcategory">
<H2>climada_plot_tc_track_stormcategory</H2></A>
<font color="blue">function  [h] = climada_plot_tc_track_stormcategory(tc_track, markersize, check_legend, linewidth) </font>
 plot tc track in colors according to saffir-simpson hurricane scale
 NAME:
   climada_plot_tc_track_stormcategory
 PURPOSE:
   plot tc track in colors according to saffir-simpson hurricane scale
   provide handle of tc_track
 CALLING SEQUENCE:
   [h] =
   climada_plot_tc_track_stormcategory(tc_track,markersize,check_legend)
 EXAMPLE:
   [h] =
   climada_plot_tc_track_stormcategory(tc_track(1),10,1)
 INPUTS:
	tc_track:        one or more tc_tracks (structure)
 OPTIONAL INPUT PARAMETERS:
   markersize:      markersize of tc_track nodes, default 7   
   check_legend:    if set to 1 legend of saffir-simpson hurricane scale
   in upper left corner
 OUTPUTS:
   h:               handle of tc_track nodes
 Lea Mueller, 20110603
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_plot_tc_track_stormcategory.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_world_borders">
<H2>climada_plot_world_borders</H2></A>
<font color="blue">function climada_plot_world_borders(linewidth,check_country,map_shape_file,keep_boundary,country_color,border_color) </font>
 world border map country political
 NAME:
	climada_plot_world_borders
 PURPOSE:
   plot (world) borders for map in lat/lon

   Reads the file with border information (.mat or the original .shp) and
   plots it (line plot) in existing figure (do not forget hold on before)
   or create new one. Allows to color (a set of) countries

   The first time the shape file is read, all shapes are read into a
   second structure for fast plotting, see climada_shaperead(*,1,1).
   It uses the .mat file written by climada_shaperead with the borders
   info in subsequent calls for speedup.

   Called from many plot functions, e.g. climada_entity_plot
   See also: climada_shaperead

   Programmers hint:
   In case you only need the borders (quick&ampdirty, order of 10 times faster),
   you might consider the following code bit instead of
   climada_plot_world_borders (especially in subsequent calls, as
   climada_plot_world_borders does also set up the .mat file if missing etc.)

       shapes=climada_shaperead(climada_global.map_border_file,1,1); % reads .mat
       border.X=[];for i=1:length(shapes),border.X=[border.X shapes(i).X];end
       border.Y=[];for i=1:length(shapes),border.Y=[border.Y shapes(i).Y];end
       plot(border.X,border.Y,'-k')

 CALLING SEQUENCE:
   climada_plot_world_borders(linewidth,check_country,map_shape_file,keep_boundary,country_color,border_color);
 EXAMPLE:
   climada_plot_world_borders
   climada_plot_world_borders(1,'','',1) % most often used that way
   climada_plot_world_borders(0.8,'United States (USA)')
   climada_plot_world_borders(0.8,{'Canada' 'Germany'})
   climada_plot_world_borders(1,'','ASK') % prompt for shape file
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   linewidth: line width of borders, default is 1
       if negative, fill land with border_color
   check_country: name (field in shapes named 'NAME') of one or multiple
       countries, e.g. 'Germany' or {'Germany' 'Ghana'},that will be gray
       shaded in the world plot, default is no shading of countries.
       Note that 'United States (USA)' is used, hence both 'United States' and 'USA' work.
       ='LABEL': label all countries, but do NOT use for coloring
   map_shape_file: filename and path to a *.shp shapes file
       if set to 'ASK', prompt for the .shp file. If empty, set to the
       file as defined in climada_global.map_border_file (default).
   keep_boundary: to keep the map area (as it looks on input)
   country_color: a [R G B] triple, see PARAMETERS in code, default is
       [255 236 139]/255 (yellow).
       Currently, it does not color the shape, only draws the boundary.
   border_color: a [R G B] triple, see PARAMETERS in code, default is
       [ 81  81  81]/255 for dark gray
 OUTPUTS:
   plot borders as line plot
 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141211, initial, supersedes old version (which read a .gen file)
 David N. Bresch, david.bresch@gmail.com, 20141223, fill debugged
 David N. Bresch, david.bresch@gmail.com, 20150916, hint for speedup in header added
 David N. Bresch, david.bresch@gmail.com, 20151230, links in ERROR prompts referenced
 David N. Bresch, david.bresch@gmail.com, 20160514, border_color and fill land (linewidth negative) added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_plot_world_borders.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_processed2assets">
<H2>climada_processed2assets</H2></A>
<font color="blue">function assets=climada_processed2assets(processed_file) </font>
 climada
 NAME:
   climada_processed2assets
 PURPOSE:
   converts a processed (encoded) file into the essential information as
   needed by climada
 CALLING SEQUENCE:
   assets=climada_processed2assets(processed_file)
 EXAMPLE:
   assets=climada_processed2assets(processed_file)
 INPUTS:
   processed_file: filename of a processed (encoded) file
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   assets: a climada asset structure, but more important, a .csv file (to
   be converted into xls) with the same information is generated
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091229
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_processed2assets.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_scenario_name">
<H2>climada_scenario_name</H2></A>
<font color="blue">function scenario = climada_scenario_name(entity,hazard) </font>
 climada set scenario name
 NAME:
   climada_scenario_name
 PURPOSE:
   given an entity and a hazard, define a scenario name, based on
   assets.reference_year, assets.region, hazard.reference_year,
   hazard.scenario
 
 CALLING SEQUENCE:
   scenario = climada_scenario_name(entity,hazard)
 EXAMPLE:
   scenario = climada_scenario_name(entity,hazard)
   scenario = climada_scenario_name;
 INPUTS:
   entity: an entity structure or an entity .mat file, see climada_assets_encode(climada_assets_read)
       If a file and no path provided, default path ../data/entities is
       used (and name can be without extension .mat)
       &ampgt promted for if not given
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       If a file and no path provided, default path ../data/hazards is
       used (and name can be without extension .mat)
       &ampgt promted for if not given
 OUTPUTS:
   scenario, a structure with fields
       .name: a string, e.g. Assets 2014, Hazard 2014 no climate change, Florida 
              or Assets 2014, Hazard 2030 moderate climate change, Florida
       .name_simple: a string with a simplified version of the scenario name, 
              e.g., 2014, no climate change, Florida, or 2030 moderate
              climate change, Florida
       .assets_year: 2014, 2030, 2040, 2050, etc.
       .region: a string, read from assets in excel, e.g. Florida, San Salvador, etc.
       .hazard_year: 2014, 2030, 2040, 2050, taken from hazard.refence_year
       .hazard_scenario: a string, taken from hazard.scenario, e.g. no climate change, 
              moderate climate change, extreme climate change
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151127, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_scenario_name.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_scenario_waterfall_identify">
<H2>climada_scenario_waterfall_identify</H2></A>
<font color="blue">function [is_today, is_eco, is_cc] = climada_scenario_waterfall_identify(measures_impact) </font>
 climada identify scenarios today, eco and climate change
 NAME:
   climada_scenario_waterfall_identify
 PURPOSE:
   Given a measures_impact with multiple scenarios, identify scenario
   today, economic development and climate change.
 
 CALLING SEQUENCE:
   [is_today, is_eco, is_cc] = climada_scenario_waterfall_identify(measures_impact)
 EXAMPLE:
   [is_today, is_eco, is_cc] = climada_scenario_waterfall_identify(measures_impact)
 INPUTS:
   measures_impact: a climate measures_impact structure with field
    .scenario. 
       &ampgt promted for if not given
 OUTPUTS:
   is_today: a number pointing to the order in which the today's scenario
       is located within measurse_impact 
   is_eco: a number pointing to the order in which the economic scenario
       is located within measurse_impact
   is_cc: a number pointing to the order in which the climate change scenario
       is located within measurse_impact
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151127, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_scenario_waterfall_identify.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_shape_selector">
<H2>climada_shape_selector</H2></A>
<font color="blue">function shapes = climada_shape_selector(fig,n_shapes,smooth_factor,hold_shapes,min_dist_frac,shape_file,disco_mode) </font>
 select shapes
 MODULE:
   climada core
 NAME:
   climada_shape_selector
 PURPOSE:
   select shapes in plot
 CALLING SEQUENCE:
   shapes = climada_shape_selector(fig,N,hold_shapes,min_dist_frac)
 EXAMPLE:
   shapes = climada_shape_selector(2,5,1,0.01)
   shapes = climada_shape_selector
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   fig:    figure handle of figure in which you want to select shapes.
           if not given, existing figure with largest handle number is
           chosen. If no figures exist, climada_plot_world_borders is
           called
   n_shapes:       number of shapes you wish to draw
   hold_shapes:    whether to keep plot of shapes on figure or remove
                   them. Remove by default (=0)
   min_dist_frac:  radius of circle within which a click would close the
                   polygon (default = 2% of axis lims)
 OUTPUTS:
   shapes:     structure array with fields X and Y defining the coordinates
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150729 init
 Gilles Stassen, gillesstassen@hotmail.com, 20150827, V2.0 :-)
 Lea Mueller, muellele@gmail.com, 20150915, set disco_mode to 0
 Lea Mueller, muellele@gmail.com, 20151106, move to core
 Lea Mueller, muellele@gmail.com, 20160314, rename to n_shapes from N, change input order
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_shape_selector.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_shapeplotter">
<H2>climada_shapeplotter</H2></A>
<font color="blue">function climada_shapeplotter(shapes,label_att,lon_fieldname,lat_fieldname,varargin) </font>
 climada_shapeplotter
 MODULE:
   climada/code/helper_functions
 NAME:
   climada_shapeplotter
 PURPOSE:
   easily plot shape structs containing multiple shapes
 CALLING SEQUENCE:
   climada_shapeplotter(shapes,label_att,varargin)
 EXAMPLE:
   climada_shapeplotter(shapes,'attribute name','X','Y','linewidth',2,'color','r')
   climada_shapeplotter(shapes,'attribute name','x','y','linewidth',2,'color','r','plot3_level',500)
 INPUTS: 
   shapes         : struct with shape file info must have fields X and Y
 OPTIONAL INPUT PARAMETERS:
   label_att      : the fieldname containing the string with which you wish to
                    label each shape
   lon_fieldname  : specify fieldname where to take lon information, default &quot.X&quot
   lat_fieldname  : specify fieldname where to take lat information, default &quot.Y&quot
   varargin       : any property value pair compatible with Matlab's plot func
 OUTPUTS:
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 18052015, init
 Lea Mueller, muellele@gmail.com, 20150607, add lon_fieldname and lat_fieldname to specify fieldnames of lon/lat coordinates
 Lea Mueller, muellele@gmail.com, 20160229, use plot instead of plot3
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter and move to climada/core/helper_functions
 Lea Mueller, muellele@gmail.com, 20160314, try both, .X and .Y as well as .lon and .lat
 Lea Mueller, muellele@gmail.com, 20160314, add &quotplot3_level&quot to plot lines as plot3 on a certain plot3_level
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_shapeplotter.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_shaperead">
<H2>climada_shaperead</H2></A>
<font color="blue">function [shapes,whole_world_borders]=climada_shaperead(shape_filename,mat_save_flag,create_world_borders,force_reread,silent_mode) </font>
 climada
 NAME:
   climada_shaperead
 PURPOSE:
   read a shape file and return shapes structure. See shaperead (likely in
   mapping toolbox)

   See climada module country_risk for e.g. a global admin0 (country) and
   admin1 (state/prvince) shape file.

   Note that this code requires the mapping toolbox, that's why the binary
   version of the admin0 shapes is stored as ../data/system/admin0.mat

   Stores a .mat binary file with shapes for subsequent fast access
 CALLING SEQUENCE:
   shapes=climada_shaperead(shape_filename,mat_save_flag,create_world_borders,force_reread,silent_mode);
 EXAMPLE:
   shapes=climada_shaperead(shape_filename);
   shapes=climada_shaperead('SYSTEM_ADMIN0');    % re-create ../data/system/admin0.mat
   shapes=climada_shaperead('SYSTEM_COASTLINE'); % re-create ../data/system/coastline.mat
 INPUTS:
   shape_filename: filename (with path) of a shapefile
       &ampgt promted for if not given

       Special case: if set to 'SYSTEM_ADMIN0', the core climada
       admin0.mat file is re-created (requires country_risk module).
       Note that in this case, country names are unified, see
       reference_ISO3_country_name in PARAMETERS in code)
       Note that in this case, some shapes are reduced to the comestic
       part of the countries, namely for France, Netherlands, Norway, New
       Zealand, Portugal, Russia and United States (see special_shape in
       PARAMETERS in code and also see SYSTEM_ADMIN0 flag in code)

       Special case: if set to 'SYSTEM_COASTLINE', the core climada
       coastline.mat file is re-created (requires country_risk module).
       The coastline is saved as one large 'Point' structure, in order to
       speed up calculations in climada_distance2coast_km
       That's currently the key use of the coastline. Since segments are
       still separated by NaN, one can use plot(shapes.X,shapes.Y,'-r') to
       show the coastline as line. In order to get the original shapes,
       one needs to read the source .shp file again (see PARAMETERS in
       code and also see SYSTEM_ADMIN0 flag in code, since the source file
       is defined relative to the country_risk module and hence done only
       if requested).
 OPTIONAL INPUT PARAMETERS:
   mat_save_flag: =1: do save as .mat file (default)
       =0: do not save as .mat file
   create_world_borders: =1: create whole_world_borders which contains all
       shapes in one structure for fast (global) plotting (no loop needed)
       =0: do not do so (default)
       See code, currently DISABLED, since it doubles the size of the .mat
       file but plotting world borders only takes 0.35 sec compared to 0.25
       sec. But kept in code (commented, as this might matter for even
       higher border shape resolution)
   force_reread: =1 force re-reading the original shape file
       =0: use the .mat file if existing
   silent_mode: =1, do not print anything,
       =0: print shape filename (default)
 OUTPUTS:
   shapes: a shapes structure, containing one element for each non-null
       geographic feature in the shapefile. shapes is a &quotmapstruct&quot geographic
       data structure array and combines coordinates/geometry, expressed in
       terms of map X and Y, with non-spatial feature attributes.
   whole_world_borders: a simpler structure with all shapes in one for
       fast plotting, see e.g. climada_plot_world_borders (only genersted
       if create_world_borders=1). DISABLED, see above.
       In case you need whole_world_borders, add the following lines to
       your code:
           load(climada_global.map_border_file);
           whole_world_borders.lon = [];
           whole_world_borders.lat = [];
           for i=1:length(shapes)
               whole_world_borders.lon = [whole_world_borders.lon; shapes(i).X'];
               whole_world_borders.lat = [whole_world_borders.lat; shapes(i).Y'];
           end
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141211, initial
 David N. Bresch, david.bresch@gmail.com, 20141212, SYSTEM_ADMIN0 added
 David N. Bresch, david.bresch@gmail.com, 20141221, restriction to domestic for SYSTEM_ADMIN0
 David N. Bresch, david.bresch@gmail.com, 20141225, SYSTEM_COASTLINE added
 Lea Mueller, muellele@gmail.com, 20160229, add semicolon
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_shaperead.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_sparse_interp">
<H2>climada_sparse_interp</H2></A>
<font color="blue">function res = climada_sparse_interp(matrix) </font>
 climada event damage hazard probabilistic stochastic damagefunctions
 NAME:
   climada_sparse_interp
 PURPOSE:

   SOON TO BE DECOMMISSIONED, only used in climada_EDS_calc_OLD

   helper-function to allow for very efficient execution of the
   mapping from the hazard-array to the MDD-matrix
   since the hazard-array is sparse, we cannot directly apply interp1
   but do this only on the non-zero elements by use of a function handle
   to the present routine climada_sparse_interp, but before, we pass the other
   two arguments of interp1 as global variables:

   global interp_x_table
   global interp_y_table
   MDD=spfun(@climada_sparse_interp,hazard_arr);

   see climada_EDS_calc about further details (in the code)

 CALLING SEQUENCE:
   res=climada_sparse_interp(matrix)
 EXAMPLE:
   res=climada_sparse_interp(matrix)
   see climada_EDS_calc
 INPUTS:
   matrix: any matrix to be interpolated based upon the relation
       defined by (interp_x_table,interp_y_table), passed as global variables
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   the interpolated matrix res of same dimensions as matrix
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091228
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_sparse_interp.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_spreadsheet_read">
<H2>climada_spreadsheet_read</H2></A>
<font color="blue">function res=climada_spreadsheet_read(interactive_mode,spreadsheet_file,spreadsheet_sheet,silent_mode) </font>
 climada spreadhseet data import read
 NAME:
   climada_spreadsheet_read
 PURPOSE:
   a wrapper that reads spreadsheet data

   currently implemented are climada_xlsread and climada_odsread

   see all further details in mentioned implementations, the wrapper just
   passes all variables over to them
 CALLING SEQUENCE:
   res=climada_spreadsheet_read(interactive_mode,spreadsheet_file,spreadsheet_sheet,silent_mode);
 EXAMPLE:
   res=climada_spreadsheet_read
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   interactive_mode: 'interactive' or 'no'. If interactive, the user gets
       prompted for the sheet in the Excel file
       (Currently hard-wired to interactive)
   spreadsheet_file: the spreadsheet file to read
   spreadsheet_sheet: the sheet to read in the spreadsheet file
   silent_mode: if =1, do not write messages to stdout, default=0, means writing
 OUTPUTS:
   res: a structure holding the data from the selected Excel sheet
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20130330
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_spreadsheet_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_add_timestep">
<H2>climada_tc_add_timestep</H2></A>
<font color="blue">function tc_track=climada_tc_add_timestep(tc_track) </font>
 climada tc track timestep
 NAME:
   climada_tc_add_timestep
 PURPOSE:
   add TimeStep [hours] to a TC track, which contains only date (yyyymmdd and time
   in hours) of each node. TimeStep is defined between nodes (thus one
   element shorter than nodes)

 CALLING SEQUENCE:
   tc_track=climada_tc_add_timestep(tc_track)
 EXAMPLE:
   tc_track=climada_tc_add_timestep(tc_track)
 INPUTS:
   tc_track: a TC structure, e.g. as returned by climada_read_unisys_database
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   tc_track: a TC structure, with added TimeStep
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120430
 David N. Bresch, david.bresch@gmail.com, 20150103, datenum added, too
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_add_timestep.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_equal_timestep">
<H2>climada_tc_equal_timestep</H2></A>
<font color="blue">function tc_track=climada_tc_equal_timestep(tc_track,default_min_TimeStep) </font>
 tropical cyclone track timstep datenum
 NAME:
   climada_tc_equal_timestep
 PURPOSE:
   Interpolate tc_track to equal timestep, usually 1h

   Uses linear interpolation for all fields (for speedup) and removes the
   (anyway unused) field 'extratrop' (of the form '****..EEE')

   Works to interpolate on any timestep between first and last node,
   timestep measured in hours. Note that time step shall 'fit' within
   start and end, e.g. 0:6:24 -&ampgt [0 6 12 18 24], but 0:5:24 -&ampgt [0 5 10 15 20]

 CALLING SEQUENCE:
   tc_track=climada_tc_equal_timestep(tc_track,default_min_TimeStep)
 EXAMPLE:
   tc_track=climada_tc_equal_timestep(tc_track)
 INPUTS:
   tc_track: a tc_track structure (a single track or many), eg as returned
       by climada_tc_read_unisys_database or climada_tc_read_unisys_track 
 OPTIONAL INPUT PARAMETERS:
   default_min_TimeStep: the default minimum TimeStep in hours
       (default=1 hour as defined in climada_global.tc.default_min_TimeStep)
 OUTPUTS:
   tc_track: a tc_track structure, with equal timesteps and copy of
       time-independent fields
 MODIFICATION HISTORY:
 David N. Bresch, david_bresch@gmail.com, 20040911, 20081006
 Mathias Hauser, 20120507
 Lea Mueller, 20121203
 David N. Bresch, david_bresch@gmail.com, 20040911, new version of MATLAB does not like adding empty stuff
 David N. Bresch, david_bresch@gmail.com, 20141231, datevecmx replaced
 David N. Bresch, david_bresch@gmail.com, 20150103, simplified (a lot) and about five times faster
 David N. Bresch, david_bresch@gmail.com, 20150119, lat/lon interpolation switched to spline
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_equal_timestep.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_get_unisys_databases">
<H2>climada_tc_get_unisys_databases</H2></A>
<font color="blue">function climada_tc_get_unisys_databases(tc_tracks_folder) </font>
 climada
 NAME:
   climada_tc_get_unisys_databases
 PURPOSE:
   get UNISYS databases from www, i.e. all the ocean basin files from 
   http://weather.unisys.com/hurricane/index.html

   next step: see climada_tc_read_unisys_database
 CALLING SEQUENCE:
   climada_tc_get_unisys_databases
 EXAMPLE:
   climada_tc_get_unisys_databases
 INPUTS:
   param1: 
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   param2: as an example
   tc_tracks_folder: the place to store the data files to
       default the climada core /data/tc_tracks folder
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140715
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_get_unisys_databases.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hazard_clim_scen">
<H2>climada_tc_hazard_clim_scen</H2></A>
<font color="blue">function hazard = climada_tc_hazard_clim_scen(hazard,hazard_clim_file,frequency_screw,intensity_screw) </font>
 climada
 NAME:
   climada_template
 PURPOSE:
   starting from a given hazard event set (hazard), construct the
   climate scenario hazard event set (hazard_clim_file)

   Modifications done in code, so please visit/edit the code prior to use,
   please check the PARAMETERS section below, e.g. for
       frequency_screw, intensity_screw
       hazard_reference_year: the reference year for the hazard set
 CALLING SEQUENCE:
   hazard=climada_tc_hazard_clim_scen(hazard,hazard_clim_file)
 EXAMPLE:
   hazard=climada_tc_hazard_clim_scen
 INPUTS:
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   hazard_clim_file: the filename of the new climate scenario hazard event set
       &ampgt promted for if not given
 OUTPUTS:
   hazard: the hazard event set for the climate scenario, also stored to hazard_clim_file
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090920
 Lea Mueller, 20110720
 Reto Stockmann 20120719
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_hazard_clim_scen.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hurdat_read">
<H2>climada_tc_hurdat_read</H2></A>
<font color="blue">function [tc_track,tc_track_hist_file]=climada_tc_hurdat_read(hurdat_filename,check_plot) </font>
 climada template
 MODULE:
   core
 NAME:
   climada_tc_hurdat_read
 PURPOSE:
   Read HURDAT database, www.nhc.noaa.gov/data

   The code does check for at least 3 nodes (see parameter min_nodes) and
   sets missing CentralPressure and negative MaxWInd to NaN.

   Atlantic hurricane database (HURDAT2) 1851-2014:
   www.nhc.noaa.gov/data/hurdat/hurdat2-1851-2014-060415.txt

   Northeast and North Central Pacific hurricane database (HURDAT2)
   1949-2013: www.nhc.noaa.gov/data/hurdat/hurdat2-nencpac-1949-2013-070714.txt

   for format and details, see www.nhc.noaa.gov/data/hurdat/hurdat2-format-atlantic.pdf

   For debugging, there is a simple try/catch which stops and shows the
   line number and its content in case of trouble.

   next step: see climada_tc_random_walk and climada_tc_hazard_set

   See also climada_tc_read_unisys_database and climada_tc_jtwc_fetch
 CALLING SEQUENCE:
   tc_track=climada_tc_hurdat_read(hurdat_filename)
 EXAMPLE:
   tc_track=climada_tc_hurdat_read;
 INPUTS:
   hurdat_filename: name (and path) of the HURDAT2 text file
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   check_plot: =1, plot for check, =0, no plot (default)
 OUTPUTS:
   tc_track: a structure with the track information for each cyclone i and
           data for each node j (times are at 00Z, 06Z, 12Z, 18Z):
       tc_track(i).lat(j): latitude at node j of cyclone i
       tc_track(i).lon(j): longitude at node j of cyclone i
       tc_track(i).MaxSustainedWind(j): Maximum sustained (1 minute)
           surface (10m) windspeed in knots (in general, these are to the nearest 5 knots).
       tc_track(i).MaxSustainedWindUnit, almost always 'kn'
           (others allowed: 'mph', 'm/s' or 'km/h')
       tc_track(i).CentralPressure(j): optional
       tc_track(i).CentralPressureUnit: 'mb'
       tc_track(i).yyyy: 4-digit year, optional
       tc_track(i).mm: month, optional
       tc_track(i).dd: day, optional
       tc_track(i).hh: hours
       tc_track(i).datenum:  matlab notation for date and time (see function datestr)
       tc_track(i).TimeStep(j)=time step [h] from this to next node
           Nearly all HURDAT2 records correspond to the synoptic times of 0000, 0600, 1200, and 1800.
           Recording best track data to the nearest minute became available within the b-decks
           beginning in 1991 and some tropical cyclones since that year have the landfall best track to the nearest minute.
       tc_track(i).ID_no: unique ID, optional
       tc_track(i).name: name, optional
       tc_track(i).orig_event_flag: whether it is an mother(=1) or daugther(=0) storm

       PLUS: optional field (only in HURDAT)
       tc_track(i).WindRadii(j,1:12): wind radii maximum extent (in
           nautical miles) for quadrants:
           tc_track(i).WindRadii(j,1): northeastern quadrant
                    2): southeastern quadrant
                    3): southwestern quadrant
                    4): northwestern quadrant
                    5): northeastern quadrant
                    6): southeastern quadrant
                    7): southwestern quadrant
                    8): northwestern quadrant
                    9): northeastern quadrant
                   10): southeastern quadrant
                   11): southwestern quadrant
                   12): northwestern quadrant

       To really start from the raw text file again, please delete the
       binary file (*_hist.mat).

   tc_track_hist_file: the filename with path to the binary file
       tc_track is stored in (see NOTE above)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150730, intial
 David N. Bresch, david.bresch@gmail.com, 20150824, made fully consistent with unisys and jtwc
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_hurdat_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_interp">
<H2>climada_tc_interp</H2></A>
<font color="blue">function y = climada_tc_interp(x,sample_rate) </font>
 TC new event set windfield calculation
 NAME:
   climada_tc_interp
 PURPOSE:
   increase resolution of any data by linear interpolation between nodes
 CALLING SEQUENCE:
   y = climada_tc_interp(x,sample_rate)
 EXAMPLE:
   y = climada_tc_interp([1 2 3],1); y = [1 1.5 2 2.5 3];
 INPUTS:
   x: one-dimensional vector to be interpolated between nodes
   sample_rate: number of interpolation points between nodes
       =0 returns x unchanged
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   y: the resampled vector x
 RESTRICTIONS:
 MODIFICATION HISTORY:
 srzdnb, 29.4.2003
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_interp.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_jtwc_fetch">
<H2>climada_tc_jtwc_fetch</H2></A>
<font color="blue">function [tc_track,tc_track_hist_file]=climada_tc_jtwc_fetch(check_plot) </font>
 climada_tc_jtwc_fetch
 MODULE:
   core
 NAME:
   climada_tc_jtwc_fetch
 PURPOSE:
   fetch TC track files from web, as (very) cumbersome for TC Southern
   Hemisphere, and convert into tc_track structure. See
   www.usno.navy.mil/NOOC/nmfc-ph/RSS/jtwc/best_tracks/shindex.php

   See parameter Pacific_centric in code, with sets longitudes such that
   event set generation works for South Psacific ocean (most likely use,
   as there is no UNISYS data for this region). Set Pacific_centric=0 in
   case you'd like to use jtwc data for South Indian ocean.

   Note: we do NOT store empty (no wind nor pressure) or too short (less
   than 3 nodes) tracks in tc_track, as any subsequent climada code would
   struggle to use it anyway.

   next step: see climada_tc_random_walk and climada_tc_hazard_set

   See also climada_tc_read_unisys_database and climada_tc_hurdat_read
 CALLING SEQUENCE:
   [tc_track,tc_track_hist_file]=climada_tc_jtwc_fetch(check_plot)
 EXAMPLE:
   tc_track=climada_tc_jtwc_fetch(1)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   check_plot: =1, plot for check, =0, no plot (default)
 OUTPUTS:
   tc_track: a structure with the track information for each cyclone i and
           data for each node j (times are at 00Z, 06Z, 12Z, 18Z):
       tc_track(i).lat(j): latitude at node j of cyclone i
       tc_track(i).lon(j): longitude at node j of cyclone i
       tc_track(i).MaxSustainedWind(j): Maximum sustained (1 minute)
           surface (10m) windspeed in knots (in general, these are to the nearest 5 knots).
       tc_track(i).MaxSustainedWindUnit, almost always 'kn'
           (others allowed: 'mph', 'm/s' or 'km/h')
       tc_track(i).CentralPressure(j): optional
       tc_track(i).CentralPressureUnit: 'mb'
       tc_track(i).yyyy: 4-digit year, optional
       tc_track(i).mm: month, optional
       tc_track(i).dd: day, optional
       tc_track(i).hh: hours
       tc_track(i).datenum:  matlab notation for date and time (see function datestr)
       tc_track(i).TimeStep(j)=time step [h] from this to next node
           Nearly all HURDAT2 records correspond to the synoptic times of 0000, 0600, 1200, and 1800.
           Recording best track data to the nearest minute became available within the b-decks
           beginning in 1991 and some tropical cyclones since that year have the landfall best track to the nearest minute.
       tc_track(i).ID_no: unique ID, optional
       tc_track(i).name: name, optional
       tc_track(i).orig_event_flag: whether it is an mother(=1) or daugther(=0) storm
   tc_track_hist_file: the filename with path to the binary file
       tc_track is stored in (see NOTE above)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150823
 David N. Bresch, david.bresch@gmail.com, 20150824, made fully consistent with unisys and hurdat
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_jtwc_fetch.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_overview_table">
<H2>climada_tc_overview_table</H2></A>
<font color="blue">function climada_tc_overview_table(tc_track,csv_filename) </font>
 climada
 NAME:
   climada_tc_overview_table
 PURPOSE:
   write key information of tracks into .csv file
 CALLING SEQUENCE:
   climada_tc_overview_table(tc_track)
 EXAMPLE:
   climada_tc_overview_table
 INPUTS:
   tc_track: a tc_track structure, as returned eg by climada_tc_read_unisys_database
       &ampgt promted for if not given
   csv_filename: the name of the file to write to
       &ampgt promted for if not given (well, prompted for a binary file that
       contains a tc_track structure)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20110307
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_overview_table.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_random_walk_position_windspeed">
<H2>climada_tc_random_walk_position_windspeed</H2></A>
<font color="blue">function tc_track_prob = climada_tc_random_walk_position_windspeed(tc_track , tc_track_save, ens_size, ens_amp, Maxangle,... </font>
   check_plot, check_printplot)
 TC event set with probabilistic longitude, latitude and wind speed based
 on random walk
 NAME:
   climada_tc_random_walk_position_windspeed
 PURPOSE:
   given a tc_track structure, create ens_size WIND SPEED varied derived tracks based on
   directed random walk
   and generates ens_size LONGITUDE, LATITUDE varied based on directed
   random walk
   PARAMETERS for wind speed: distribution of initial wind speed v0 and
   distribution of change in wind speed vi (mu and sigma) obtained by
   function: [mu, sigma, A]   = climada_distribution_v0_vi('all');
   PARAMETERS for longitude, latitude:
   ens_amp0, ens_amp, Maxangle, etc.
   previous step:  see climada_tc_read_unisys_database
   next step:      see climada_tc_hazard_set
 CALLING SEQUENCE:
   tc_track_prob = climada_tc_random_walk_position_windspeed(tc_track,
   'tc_track_prob',
   ens_size, ens_amp, Maxangle, check_plot, check_printplot);
 EXAMPLE:
   tc_track_prob = climada_tc_random_walk_position_windspeed;
 INPUTS:
   none, if tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   tc_track: a structure with the track information for each cyclone i at
       each node j, see climada_read_unisys_database for a detailed
       description, wind speed in knots, nodes every six hours
   ens_size: create ens_size varied derived tracks, default 9
 OUTPUTS:
   same structure now including the ens_size times number of tracks
   all the info from the original tracks is copied, only the WIND SPEED
   differs
   field category and season is added
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110616
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_random_walk_position_windspeed.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_read_unisys_track">
<H2>climada_tc_read_unisys_track</H2></A>
<font color="blue">function [tc_track,track_filename] = climada_tc_read_unisys_track(track_filename,check_plot) </font>
 climada unisys TC track
 NAME:
   climada_tc_read_unisys_track
 PURPOSE:
   read a single track data file as downloaded from
   http://www.weather.unisys.com/hurricane/
   can be used to add to existing tc_track structure like:
   tc_track(end+1)=climada_tc_read_unisys_track

   Note that identical (double entry) and backward timesteps are removed.
   In such cases, you better inspect the tc_track file (source) and remove
   using an editor. 

   See also e.g. climada_event_damage_data_tc
 CALLING SEQUENCE:
   tc_track=climada_tc_read_unisys_track(filename,check_plot)
 EXAMPLE:
   tc_track=climada_tc_read_unisys_track
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   track_filename: the filename with path of a UNISYS *.dat file
       &ampgt user gets prompted for if not specified
   check_plot: =1 show track on map, =0 not (default)
 OUTPUTS:
   tc_track: a TC track structure, see climada_tc_read_unisys_database
   track_filename: the track_filename (usefeul if prompted for)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20110429
 Lea Mueller, 20110718
 David N. Bresch, david.bresch@gmail.com, 20150220, init_vars reset removed
 David N. Bresch, david.bresch@gmail.com, 20151018, forecast file added to output and automatic removal of backward timesteps
 David N. Bresch, david.bresch@gmail.com, 20151102, allow for name without path on input
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_read_unisys_track.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_season">
<H2>climada_tc_season</H2></A>
<font color="blue">function  [tc_track, seasons] = climada_tc_season(tc_track) </font>
 add season for every tc track (former climada_add_tc_track_season)
 NAME:
   climada_tc_season
 PURPOSE:
   add season for every tc track 
 CALLING SEQUENCE:
   [tc_track, seasons] = climada_tc_season(tc_track)
 EXAMPLE:
   [tc_track, seasons] = climada_tc_season(tc_track)
 INPUTS:
	tc_track:    one or more tc_tracks (structure)
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   tc_track:    tc_track with tc_track.season (array)
 Lea Mueller, 20110620
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_season.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_stormcategory">
<H2>climada_tc_stormcategory</H2></A>
<font color="blue">function  tc_track = climada_tc_stormcategory(tc_track) </font>
 add  Saffir Simpson category for every tc track (former
 climada_add_tc_track_stormcategory)
 NAME:
   climada_tc_stormcategory
 PURPOSE:
   add storm category for every tc track according to saffir-simpson
   hurricane scale
   -1 tropical depression
    0 tropical storm
    1 Hurrican category 1
    2 Hurrican category 2
    3 Hurrican category 3
    4 Hurrican category 4
    5 Hurrican category 5
 CALLING SEQUENCE:
   [tc_track] = climada_tc_stormcategory(tc_track)
 EXAMPLE:
   [tc_track] = climada_tc_stormcategory(tc_track)
 INPUTS:
	tc_track:    one or more tc_tracks (structure)
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   tc_track:    tc_track with tc_track.category (array)
 Lea Mueller, 20110614
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_stormcategory.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_track_info">
<H2>climada_tc_track_info</H2></A>
<font color="blue">function info=climada_tc_track_info(tc_track,check_plot,boundary_rect,centroids,manual_select) </font>
 climada tc track info
 MODULE:
   core
 NAME:
   climada_tc_track_info
 PURPOSE:
   Prints information of tracks to stdout (name, date....) and shows
   (nice) plots of historic (and probabilistic) tracks

   Prior call: climada_tc_read_unisys_tc_track
   Possible subsequent call: hold on;climada_entity_plot
 CALLING SEQUENCE:
   info=climada_tc_track_info(tc_track)
 EXAMPLE:
   info=climada_tc_track_info('tracks.she_hist.mat',-2,[140 180 -40 -10]); % historic
   info=climada_tc_track_info('tracks.she_prob.mat',-1,[140 180 -40 -10]); % also probabilistic
 INPUTS:
   tc_track: a tc_track structure, as returned by
       climada_tc_read_unisys_database or climada_tc_read_unisys_tc_track
       &ampgt promted for (.mat) if not given
       If a .mat filename is passed, the content is loaded
 OPTIONAL INPUT PARAMETERS:
   check_plot: if =1, show checkplot, =0 not (default)
       =-1; ONLY check plot, do not print info to stdout
       =-2; only check plot and only historic events (to create the e.g.
       the slide to show hist/prob, see boundary_rect also)
   boundary_rect: the boundary to plot [minlon maxlon minlat maxlat]
       default is whole globe
   centroids: a structure with centroids.lon, centroids.lat
       if provided, only show tracks intersecting centroids
   manual_select: if =1, alow for user to define point(s) on the map to
       select tracks in vicinity (press enter after clicking on the map)
       Best use is to define a 'gate', i.e. two points on the left and
       right of the track to select.
 OUTPUTS:
   info contains some information, but to stdout is main purpose of this
       routine
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150118, initial
 David N. Bresch, david.bresch@gmail.com, 20160515, check_plot and boundary_rect added
 David N. Bresch, david.bresch@gmail.com, 20160528, centroids and manual_select added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_track_info.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_track_load">
<H2>climada_tc_track_load</H2></A>
<font color="blue">function tc_track=climada_tc_track_load(tc_track_filename,check_plot) </font>
 climada tc track load
 MODULE:
   core
 NAME:
   climada_tc_track_load
 PURPOSE:
   Load a previously generated tc_track strcuture

   Prior call: climada_tc_read_unisys_tc_track
   Possible subsequent call: climada_tc_track_info
 CALLING SEQUENCE:
   tc_track=climada_tc_track_load(tc_track_filename,check_plot)
 EXAMPLE:
   tc_track=climada_tc_track_load(tc_track_filename)
 INPUTS:
   tc_track_filename: a filename of a .mat file containign a tc_track
       structure, as returned by climada_tc_read_unisys_database or
       climada_tc_read_unisys_tc_track
       If only a filename is given, the default path (../tc_tracks) is
       presumed, and if only a basin is given (e.g. atl_hist), the
       filename is completed (to tracks.atl_hist.mat)
       &ampgt promted for (.mat) if not given
 OPTIONAL INPUT PARAMETERS:
   check_plot: if =1, show checkplot, =0 not (default)
       =-1; ONLY check plot, do not print info to stdout
       =-2; only check plot and only historic events (to create the e.g.
       the slide to show hist/prob, see boundary_rect also)
       Info: this just calls climada_tc_track_info(tc_track,check_plot)
 OUTPUTS:
   tc_track: a tc_track structure, as returned by
       climada_tc_read_unisys_database or climada_tc_read_unisys_tc_track
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160516, initial
 David N. Bresch, david.bresch@gmail.com, 20160528, more filename completion options
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_track_load.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_track_nodes">
<H2>climada_tc_track_nodes</H2></A>
<font color="blue">function [tc_track_nodes,tc_track_nodes_file]=climada_tc_track_nodes(tc_track_mat_file) </font>
 climada tc track nodes
 MODULE:
   core
 NAME:
   climada_tc_track_nodes
 PURPOSE:
   Given a .mat file with tc_track(i), usually named *_hist.mat 
   (for historic, see climada_tc_read_unisys_database), 
   construct the nodes file, usually named *_nodes.mat, i.e. the
   file containing tc_track_nodes.lon(j) and tc_track_nodes.lat(j)

   previous call: 
   called from: centroids_generate_hazard_sets and climada_event_damage_data_tc
 CALLING SEQUENCE:
   [tc_track_nodes,tc_track_nodes_file]=climada_tc_track_nodes(tc_track_mat_file)
 EXAMPLE:
   [tc_track_nodes,tc_track_nodes_file]=climada_tc_track_nodes(tc_track_mat_file)
 INPUTS:
   tc_track_mat_file: the mat file containing tc_track(i), most likely a
       file *_hist.mat (but one can also use _prob.mat, in wich case the
       output is named *_prob_nodes.mat instead of *_nodes.mat)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   tc_track_nodes: a structure with all nodes of TC tracks, i.e.
       lon(j): the node j
       lat(j): the node j
       track_no(j): the track number, tc_track(tc_track_nodes.track_no(j))
           is the track node j comes from
   tc_track_nodes_file: the name of the .mat file (*_nodes.mat) containing
       tc_track_nodes
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150128, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_track_nodes.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_windfield_animation">
<H2>climada_tc_windfield_animation</H2></A>
<font color="blue">function climada_tc_windfield_animation(tc_track,centroids,aggregation,check_avi)                                 </font>
 plot animation of windfield for a specific historical or
 probabilistic storm
 to find a specific windstorm use
 climada_plot_probabilistic_wind_speed_map
 NAME:
   climada_tc_windfield_animation
 PURPOSE:
   plot animation of windfield for a specific historical or
   probabilistic storm, plot is produced every aggregation time step
   (minimum 1 hour or more)
 CALLING SEQUENCE:
   climada_tc_windfield_animation(tc_track       ,...
                                  centroids      ,...
                                  aggregation    ,...
                                  check_printplot)
 EXAMPLE:
   climada_tc_windfield_animation(tc_track_prob(1226), centroids, 1, 6)
 INPUTS:
	tc_track:           just one tc_track, tc_track_prob(1)
   centroids:          centroid mat file
 OPTIONAL INPUT PARAMETERS:
   aggregation:        desired timestep for plots (minimum one plot per
   hour, can be one plot for 6 hours or more)
   check_avi:         if set to 1 will save animation as avi-file
 OUTPUTS:
   plot of windfield (footprint) for every aggreagation step
   (minimum 1 hour) for one specific storm track
 MODIFICATION HISTORY:
 Lea Mueller, 20110603
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_windfield_animation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_windfield_timestep">
<H2>climada_tc_windfield_timestep</H2></A>
<font color="blue">function res = climada_tc_windfield_timestep(tc_track, centroids, equal_timestep) </font>
 TC windfield calculation for every timestep
 NAME:
   climada_tc_windfield_timestep
 PURPOSE:
   given a TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the wind field at locations (=centroids) for every timestep and display
   it in a loop
 CALLING SEQUENCE:
   climada_tc_windfield_timestep(tc_track, centroids, equal_timestep)
 EXAMPLE:
   climada_tc_windfield_timestep
 INPUTS:
   tc_track: a structure with the track information:
       tc_track.lat
       tc_track.lon
       tc_track.MaxSustainedWind: maximum sustained wind speed (one-minute)
       tc_track.MaxSustainedWindUnit as 'kn', 'mph', 'm/s' or 'km/h'
       tc_track.CentralPressure: optional
       tc_track.Celerity: translational (forward speed) of the hurricane.
           optional, calculated from lat/lon if missing
       tc_track.TimeStep: optional, only needed if Celerity needs to be
           calculated, 6h assumed as default
       tc_track.Azimuth: the forward moving angle, calculated if not given
           to ensure consistency, it is even suggested not to pass Azimuth
       tc_track.yyyy: 4-digit year, optional
       tc_track.mm: month, optional
       tc_track.dd: day, optional
       tc_track.ID_no: unique ID, optional
       tc_track.name: name, optional
       tc_track.SaffSimp: Saffir-Simpson intensity, optional
   centroids: a structure with the centroids information
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
 OPTIONAL INPUT PARAMETERS:
   equal_timestep: if set=1 (default), first interpolate the track to a common
       timestep, if set=0, no equalization of TC track data (not
       recommended)
 OUTPUTS:
   res.gust: the windfield [m/s] at all centroids
       the single-character variables refer to the Pioneer offering circular
       that's why we kept these short names (so one can copy the OC for
       documentation)
   res.lat: the latitude of the centroids
   res.lon: the longitude of the centroids
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110721
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tc_windfield_timestep.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_template">
<H2>climada_template</H2></A>
<font color="blue">function res=climada_template(param1,param2) </font>
 climada template
 MODULE:
   module name
 NAME:
   climada_template
 PURPOSE:
   &ampltdescribe purpose and use here&ampgt

   previous call: &ampltnote the most usual previous call here&ampgt
   next call: &ampltnote the most usual next function call here&ampgt
 CALLING SEQUENCE:
   res=climada_template(param1,param2);
 EXAMPLE:
   climada_template(param1,param2);
 INPUTS:
   param1:
       &ampgt promted for if not given
   OPTION param1: a structure with the fields...
       this way, parameters can be passed on a fields, see below
 OPTIONAL INPUT PARAMETERS:
   param2: as an example
 OUTPUTS:
   res: the output, empty if not successful
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160603
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_template.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tif2assets">
<H2>climada_tif2assets</H2></A>
<font color="blue">function assets = climada_tif2assets(tif_file,check_plot,verbose) </font>
 climada_tif2assets
 MODULE:
   climada code/helperfunctions
 NAME:
   climada_tif2assets
 PURPOSE:
   create climada assets structure from a tif-file, create .lon, .lat,
   .Values as given in tif-file, transform transform tif-units to Values
   with weights given in tif_file.tif_value and tif_file.asset_weights
 CALLING SEQUENCE:
   assets = climada_tif2assets(tif_file,check_plot,verbose)
 EXAMPLE:
   assets = climada_tif2assets
 INPUTS: 
 OPTIONAL INPUT PARAMETERS:
   tif_file: a struct with the following fields, prompted for if not given
   .filename: prompted for if not given. Tif_file is the filename, the file
           contains raster data information.
   .lon_lat_min_max: i.e. [99 100 2 3], define lon min, lon max, lat min, 
           lat max for the gridded data. 
   .lon_lat_min_max_selection: i.e. [99 99.5 2 2.5], define the subset of 
           the data that you want with lon min, lon max, lat min, lat max
   .NODATA_value: i.e. -9999, this data will be overwritten with 0
   .tif_value: i.e. [0 1 2 3], values as given in tif-file
   .asset_weights: i.e. [0 5 80 15]/100, these are the weights assigned to
           the tif-file values, i.e. 5% for 1, 80% for 2 and 15 for 3.
   check_plot: set to 1 to see a figure, default is 0
   verbose: get fprint information in the command line, default is 0
 OUTPUTS: 
   a climada assets structure, with fields .lon, .lat, .Value,
       .Deductible, etc
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160408, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_tif2assets.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_waterfall_graph_advanced">
<H2>climada_waterfall_graph_advanced</H2></A>
<font color="blue">function climada_waterfall_graph_advanced(return_period, check_printplot, EDS1, EDS2, EDS3, EDS4, EDS5, EDS6) </font>
 climada water fall plot adapatation cost
 NAME:
   climada_waterfall_graph
 PURPOSE:
   waterfall figure, expected loss for specified return period for
   - today,
   - increase from economic growth,
   - increase from high climate change, total expected loss 2030
   for the n EDS passed on
 CALLING SEQUENCE:
   climada_waterfall_graph(return_period,check_printplot,EDS1, EDS2, EDS3,...)
 EXAMPLES:
   climada_waterfall_graph_advanced('AEL',0,EDS_2014,EDS_2030)
 INPUTS:
   return_period:  requested return period for according expected loss (e.g. =100),or
                   annual expted loss (='AEL'), prompted if not given
   check_printplot:if set to 1, figure saved, default 0.
 OPTIONAL INPUT PARAMETERS:
   EDSn: Event damage set, see e.g. climada_EDS_calc
 OUTPUTS:
   waterfall graph
 MODIFICATION HISTORY:
 Lea Mueller, 20110622
 Martin Heynen, 20120307
 david.bresch@gmail.com, 20140804, GIT update
 david.bresch@gmail.com, 20141020, moved from tc_rain to core climada
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_waterfall_graph_advanced.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_waterfall_graph_animation">
<H2>climada_waterfall_graph_animation</H2></A>
<font color="blue">function climada_waterfall_graph_animation(EDS1, EDS2, EDS3) </font>
 waterfall figure, expected damage for specified return period for 
 - today,
 - increase from economic growth, 
 - increase from high climate change, total expected damage 2030
 for the three EDS quoted above
 NAME:
   climada_waterfall_graph_animation
 PURPOSE:
   plot expected damage for specific return period
 CALLING SEQUENCE:
   climada_waterfall_graph_animation(EDS1, EDS2, EDS3)
 EXAMPLE:
   climada_waterfall_graph_animation
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   EDS:            three event damage sets 
                   - today
                   - economic growth
                   - cc combined with economic growth, future       
 OUTPUTS:
   waterfall graph animation
 MODIFICATION HISTORY:
 Lea Mueller, 20110622
 David N. Bresch, david.bresch@gmail.com, 20130316, ELS-&ampgtEDS...
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_waterfall_graph_animation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_xlsread">
<H2>climada_xlsread</H2></A>
<font color="blue">function res=climada_xlsread(interactive_mode,excel_file,in_excel_sheet,silent_mode,misdat_value,misdat_out_value) </font>
 climada excel data import read
 NAME:
   climada_xlsread
 PURPOSE:
   read one Excel sheet from an Excel file and return the content in a
   structure.

   Usually, just read each column of the Excel tab into one variable.

   NOTE: for older MATLAB versions, only the array-type input works, not
   the single variables (header) etc.

   OCTAVE: Please install the io package first, ether directly from source
   forge with: pkg install -forge io -auto
   or, (e.g. in case this fails, get the io package first from Octave
   source forge and then install from the downloaded package:
   pkg install {local_path}/io-2.2.5.tar -auto
   Note that it looks like Octave prefers .xlsx files

   The sheet might contain as many single variables (a header)
   and in the second part (data) as many columns as you like.
   % preceedes rows used for comment
   * denotes single variables (scalars) all read as text, the string after
       the asterix is used as variable name and the next right cell as value.
       Any further cells to the right are not processed (eg used for comments,
       as shown below)
   the last row before the data section is used to label the data columns

   an Excel sheet of eg the following form will be processed:

 %climada post event TC trackdata sheet, fill in at least the bold data, either MaxSustainedWind or Pressure?
 *event_date	20030906	the date as yyyymmdd
 *event_name	Isabel	    the name
 *MaxSustainedWindUnit	kn	either kn (also use kn for kt), mph, km/h or m/s
 *CentralPressureUnit	mb	mb or hPa
 *CelerityUnit	kn	        either kn, mph, km/h or m/s
 *track_timestep	6	    in hours, used in Celerity calculation if Celerity and/or time not given below
 *unique_ID	0	        default=0
 *MaxSaffSimp	4	        maximum Safir Simson scale reached
 *record_date	20030919	date of this record
 *comment	test	        free comment
 %follows the track data (next line are headers, fill in as much as you know, do NOT change headers!)
 lat	lon	                MaxSustainedWind	CentralPressure	Celerity	SaffSimp	time	yyyy	mm	dd
 14	-34	61.775			0	                                                            13	2003	9	6
 13.6	-34.5	61.775	    0	                                                            15	2003	9	6
   ...
 13.4	-35.4	79.425		0	                                                            21	2003	9	6

   and returned in a structure like:

   res.event_date='20030906'
   res.event_name='Isabel'
   ...
   res.comment='test'
   res.lat the vector hold all latitudes
   res.lon the vector holding all longitides
   res.MaxSustainedWind the windspeed vector
   ...
   res.dd the day number vector

   note that empty columns (like CentralPressure) are skipped
 CALLING SEQUENCE:
   res=climada_xlsread(interactive_mode,excel_file,in_excel_sheet,silent_mode,misdat_value,misdat_out_value)
 EXAMPLE:
   res=climada_xlsread(interactive_mode,excel_file,in_excel_sheet);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   interactive_mode: 'interactive' or 'no'. If interactive, the user gets
       prompted for the sheet in the Excel file
       (Currently hard-wired to interactive)
   excel_file: the Excel file to read
   in_excel_sheet: the Excel sheet to read in the excel_file
   silent_mode: if =1, do not write messages to stdout, default=0, means writing
   misdat_value: a missing date value, all numeric data of exatly this
       value are ste to NaN, default is no missing data treatment, i.e.
       misdat_value=[].
   misdat_out_value: the value missing data is set to on output,
       default=NaN. Only active if misdat_value is set
 OUTPUTS:
   res: a structure holding the data from the selected Excel sheet. Note
       that colunm headers that contain a number (xxx) are named VALxxx 
       in the structure
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20020901, 20080924
 Lea Mueller, muellele@gmail.com, 20120730, if ~isempty(NUMERIC) also possible
 David N. Bresch, david.bresch@gmail.com, 20141230, misdat_value added
 David N. Bresch, david.bresch@gmail.com, 20150101, simplified if file and sheet provided (no check for sheet to exist)
 David N. Bresch, david.bresch@gmail.com, 20150227, finally, column headers with numbers are named VALxxxx
 Lea Mueller, muellele@gmail.com, 20150505, bugfix for difficult header name
 David N. Bresch, david.bresch@gmail.com, 20160527, misdat_out_value introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/climada_xlsread.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="compile_all_function_headers">
<H2>compile_all_function_headers</H2></A>
<font color="blue">function compile_all_function_headers(output_file) </font>
 climada
 NAME:
   compile_all_function_headers
 PURPOSE:
   Crawl through all active climada code and modules and compile a file
   with ALL function headers (comes very handy as a raw documentation).
   Omits modules starting with _

   This code calls compile_function_header_doc recursively for core
   climada and all modules

   RESTRICTION: the present code does NOT process code sub-folders

   see also compile_function_header_doc
 CALLING SEQUENCE:
   compile_all_function_headers(output_file)
 EXAMPLE:
   compile_all_function_headers
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   output_file: file to write (.txt or .html)
       set to ../climada/docs/code_overview.html by default
 OUTPUTS:
   writes the file ../climada/docs/code_overview.html
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141107, initial (on flight to Dubai)
 David N. Bresch, david.bresch@gmail.com, 20160609, standardized, one sub-code level
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/compile_all_function_headers.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="compile_function_header_doc">
<H2>compile_function_header_doc</H2></A>
<font color="blue">function compile_function_header_doc(folder,recursive_flag,output_file,req_output_mode,out_fid) </font>
 wk02 sounding
 MODULE:
   core
 NAME:
	compile_function_header_doc
 PURPOSE:
   crawl through all .m files in a given folder and compile the headers
   into one single text (.txt) or html (.html) document. The html document
   starts with a header listing all routine names, followed by the full
   header listings, each with a link to the full source code.

 CALLING SEQUENCE:
	compile_function_header_doc(folder,recursive_flag,output_file);
 EXAMPLE:
   compile_function_header_doc;
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   folder: folder with m-files
       &ampgt asked for if not provided
   recursive_flag: if =1, also crawl subfolder recursively
       Does not seem to work properly, please re-check if using
   output_file: file to write (.txt or .html)
       &ampgt asked for if not provided
   req_output_mode: for internal use only (in recursive_flag case)
   out_fid: for internal use only (in recursive_flag case)
 OUTPUTS:
   a file with all headers. Note that the output is appended to the file,
   thus delete the file manually prior to running this code for a new
   version.
 MODIFICATION HISTORY:
 david.n.bresch@alumni.ethz.ch, 20030930, during WK (military repetition course at IAC, ETH)
 Lea Mueller, 20111025
 David N. Bresch, david.bresch@gmail.com, 20141107, cleanup (on flight to Dubai)
 David N. Bresch, david.bresch@gmail.com, 20160608, new e-mail
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/compile_function_header_doc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cprintf">
<H2>cprintf</H2></A>
<font color="blue">function count = cprintf(style,format,varargin) </font>
 CPRINTF displays styled formatted text in the Command Window

 Syntax:
    count = cprintf(style,format,...)

 Description:
    CPRINTF processes the specified text using the exact same FORMAT
    arguments accepted by the built-in SPRINTF and FPRINTF functions.

    CPRINTF then displays the text in the Command Window using the
    specified STYLE argument. The accepted styles are those used for
    Matlab's syntax highlighting (see: File / Preferences / Colors /
    M-file Syntax Highlighting Colors), and also user-defined colors.

    The possible pre-defined STYLE names are:

       'Text'                 - default: black
       'Keywords'             - default: blue
       'Comments'             - default: green
       'Strings'              - default: purple
       'UnterminatedStrings'  - default: dark red
       'SystemCommands'       - default: orange
       'Errors'               - default: light red
       'Hyperlinks'           - default: underlined blue

       'Black','Cyan','Magenta','Blue','Green','Red','Yellow','White'

    STYLE beginning with '-' or '_' will be underlined. For example:
          '-Blue' is underlined blue, like 'Hyperlinks';
          '_Comments' is underlined green etc.

    STYLE beginning with '*' will be bold (R2011b+ only). For example:
          '*Blue' is bold blue;
          '*Comments' is bold green etc.
    Note: Matlab does not currently support both bold and underline,
          only one of them can be used in a single cprintf command. But of
          course bold and underline can be mixed by using separate commands.

    STYLE also accepts a regular Matlab RGB vector, that can be underlined
    and bolded: -[0,1,1] means underlined cyan, '*[1,0,0]' is bold red.

    STYLE is case-insensitive and accepts unique partial strings just
    like handle property names.

    CPRINTF by itself, without any input parameters, displays a demo

 Example:
    cprintf;   % displays the demo
    cprintf('text',   'regular black text');
    cprintf('hyper',  'followed %s','by');
    cprintf('key',    '%d colored', 4);
    cprintf('-comment','&amp underlined');
    cprintf('err',    'elements\n');
    cprintf('cyan',   'cyan');
    cprintf('_green', 'underlined green');
    cprintf(-[1,0,1], 'underlined magenta');
    cprintf([1,0.5,0],'and multi-\nline orange\n');
    cprintf('*blue',  'and *bold* (R2011b+ only)\n');
    cprintf('string');  % same as fprintf('string') and cprintf('text','string')

 Bugs and suggestions:
    Please send to Yair Altman (altmany at gmail dot com)

 Warning:
    This code heavily relies on undocumented and unsupported Matlab
    functionality. It works on Matlab 7+, but use at your own risk!

    A technical description of the implementation can be found at:
    &amplta href=&quothttp://undocumentedmatlab.com/blog/cprintf/&quot&ampgthttp://UndocumentedMatlab.com/blog/cprintf/&amplt/a&ampgt

 Limitations:
    1. In R2011a and earlier, a single space char is inserted at the
       beginning of each CPRINTF text segment (this is ok in R2011b+).

    2. In R2011a and earlier, consecutive differently-colored multi-line
       CPRINTFs sometimes display incorrectly on the bottom line.
       As far as I could tell this is due to a Matlab bug. Examples:
         &ampgt&ampgt cprintf('-str','under\nline'); cprintf('err','red\n'); % hidden 'red', unhidden '_'
         &ampgt&ampgt cprintf('str','regu\nlar'); cprintf('err','red\n'); % underline red (not purple) 'lar'

    3. Sometimes, non newline ('\n')-terminated segments display unstyled
       (black) when the command prompt chevron ('&ampgt&ampgt') regains focus on the
       continuation of that line (I can't pinpoint when this happens).
       To fix this, simply newline-terminate all command-prompt messages.

    4. In R2011b and later, the above errors appear to be fixed. However,
       the last character of an underlined segment is not underlined for
       some unknown reason (add an extra space character to make it look better)

    5. In old Matlab versions (e.g., Matlab 7.1 R14), multi-line styles
       only affect the first line. Single-line styles work as expected.
       R14 also appends a single space after underlined segments.

    6. Bold style is only supported on R2011b+, and cannot also be underlined.

 Change log:
    2012-08-09: Graceful degradation support for deployed (compiled) and non-desktop applications; minor bug fixes
    2012-08-06: Fixes for R2012b; added bold style; accept RGB string (non-numeric) style
    2011-11-27: Fixes for R2011b
    2011-08-29: Fix by Danilo (FEX comment) for non-default text colors
    2011-03-04: Performance improvement
    2010-06-27: Fix for R2010a/b; fixed edge case reported by Sharron; CPRINTF with no args runs the demo
    2009-09-28: Fixed edge-case problem reported by Swagat K
    2009-05-28: corrected nargout behavior sugegsted by Andreas G?b
    2009-05-13: First version posted on &amplta href=&quothttp://www.mathworks.com/matlabcentral/fileexchange/authors/27420&quot&ampgtMathWorks File Exchange&amplt/a&ampgt

 See also:
    sprintf, fprintf

 License to use and modify this code is granted freely to all interested, as long as the original author is
 referenced and attributed as such. The original author maintains the right to be solely associated with this work.

 Programmed and Copyright by Yair M. Altman: altmany(at)gmail.com
 $Revision: 1.08 $  $Date: 2012/10/17 21:41:09 $
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/cprintf.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="freezeColors">
<H2>freezeColors</H2></A>
<font color="blue">function freezeColors(varargin) </font>
 freezeColors  Lock colors of plot, enabling multiple colormaps per figure. (v2.3)

   Problem: There is only one colormap per figure. This function provides
       an easy solution when plots using different colomaps are desired
       in the same figure.

   freezeColors freezes the colors of graphics objects in the current axis so
       that subsequent changes to the colormap (or caxis) will not change the
       colors of these objects. freezeColors works on any graphics object
       with CData in indexed-color mode: surfaces, images, scattergroups,
       bargroups, patches, etc. It works by converting CData to true-color rgb
       based on the colormap active at the time freezeColors is called.

   The original indexed color data is saved, and can be restored using
       unfreezeColors, making the plot once again subject to the colormap and
       caxis.


   Usage:
       freezeColors        applies to all objects in current axis (gca),
       freezeColors(axh)   same, but works on axis axh.

   Example:
       subplot(2,1,1); imagesc(X); colormap hot; freezeColors
       subplot(2,1,2); imagesc(Y); colormap hsv; freezeColors etc...

       Note: colorbars must also be frozen. Due to Matlab 'improvements' this can
				no longer be done with freezeColors. Instead, please
				use the function CBFREEZE by Carlos Adrian Vargas Aguilera
				that can be downloaded from the MATLAB File Exchange
				(http://www.mathworks.com/matlabcentral/fileexchange/24371)

       h=colorbar; cbfreeze(h), or simply cbfreeze(colorbar)

       For additional examples, see test/test_main.m

   Side effect on render mode: freezeColors does not work with the painters
       renderer, because Matlab doesn't support rgb color data in
       painters mode. If the current renderer is painters, freezeColors
       changes it to zbuffer. This may have unexpected effects on other aspects
	      of your plots.

       See also unfreezeColors, freezeColors_pub.html, cbfreeze.


   John Iversen (iversen@nsi.edu) 3/23/05

   Changes:
   JRI (iversen@nsi.edu) 4/19/06   Correctly handles scaled integer cdata
   JRI 9/1/06   should now handle all objects with cdata: images, surfaces,
                scatterplots. (v 2.1)
   JRI 11/11/06 Preserves NaN colors. Hidden option (v 2.2, not uploaded)
   JRI 3/17/07  Preserve caxis after freezing--maintains colorbar scale (v 2.3)
   JRI 4/12/07  Check for painters mode as Matlab doesn't support rgb in it.
   JRI 4/9/08   Fix preserving caxis for objects within hggroups (e.g. contourf)
   JRI 4/7/10   Change documentation for colorbars

 Hidden option for NaN colors:
   Missing data are often represented by NaN in the indexed color
   data, which renders transparently. This transparency will be preserved
   when freezing colors. If instead you wish such gaps to be filled with
   a real color, add 'nancolor',[r g b] to the end of the arguments. E.g.
   freezeColors('nancolor',[r g b]) or freezeColors(axh,'nancolor',[r g b]),
   where [r g b] is a color vector. This works on images &amp pcolor, but not on
   surfaces.
   Thanks to Fabiano Busdraghi and Jody Klymak for the suggestions. Bugfixes
   attributed in the code.

 Free for all uses, but please retain the following:
   Original Author:
   John Iversen, 2005-10
   john_iversen@post.harvard.edu
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/freezeColors.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="gauss_distribution">
<H2>gauss_distribution</H2></A>
<font color="blue">function f = gauss_distribution(x, mu, s) </font>
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/gauss_distribution.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="git">
<H2>git</H2></A>
<font color="blue">function git(varargin) </font>
 A thin MATLAB wrapper for Git.
 
   Short instructions:
       Use this exactly as you would use the OS command-line verison of Git.
 
   Long instructions are:
       This is not meant to be a comprehensive guide to the near-omnipotent 
       Git SCM:
           http://git-scm.com/documentation
 
       Common MATLAB workflow: 
 
       % Creates initial repository tracking all files under some root
       % folder
       &ampgt&ampgt cd ~/
       &ampgt&ampgt git init

       % Shows changes made to all files in repo (none so far)
       &ampgt&ampgt git status

       % Create a new file and add some code
       &ampgt&ampgt edit foo.m

       % Check repo status, after new file created
       &ampgt&ampgt git status

       % Stage/unstage files for commit
       &ampgt&ampgt git add foo.m          % Add file to repo or to stage
       &ampgt&ampgt git reset HEAD .       % To unstage your files from current commit area

       % Commit your changes to a new branch, with comments
       &ampgt&ampgt git commit -m 'Created new file, foo.m'
 
       % Other useful commands (replace ellipses with appropriate args)
       &ampgt&ampgt git checkout ...       % To restore files to last commit
       &ampgt&ampgt git branch ...         % To create or move to another branch
       &ampgt&ampgt git diff ...           % See line-by-line changes 

   Useful resources:
       1. GitX: A visual interface for Git on the OS X client
       2. Github.com: Remote hosting for Git repos
       3. Git on Wikipedia: Further reading 
 
 v0.1,     27 October 2010 -- MR: Initial support for OS X &amp Linux,
                               untested on PCs, but expected to work
 
 v0.2,     11 March 2011   -- TH: Support for PCs
 
 v0.3,     12 March 2011   -- MR: Fixed man pages hang bug using redirection
 
 Contributors: (MR) Manu Raghavan
               (TH) Timothy Hansell
 Test to see if git is installed
status,~] = system('git --version');
 if git is in the path this will return a status of 0
 it will return a 1 only if the command is not found
   if (status==1)
       % If GIT Is NOT installed, then this should end the function.
       fprintf('git is not installed\n%s\n',...
              'Download it at http://git-scm.com/download');
   else
       % Otherwise we can call the real git with the arguments
       arguments = parse(varargin{:});  
       if ispc
         prog = '';
       else
         prog = ' | cat';
       end
       [~,result] = system(['git ',arguments,prog]);
       % save current status of pagination, then turn it on
       morestatus=get(0,'More');
       more('on')
       % show result
       disp(result)
       % revert pagination to previous status
       more(morestatus)
   end
nd
<font color="blue">function space_delimited_list = parse(varargin) </font>
   space_delimited_list = cell2mat(...
               cellfun(@(s)([s,' ']),varargin,'UniformOutput',false));
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/git.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="hist2d">
<H2>hist2d</H2></A>
<font color="blue">function [X,Y,H] = hist2d(D,Xn,Yn,Xrange,Yrange) </font>
 Calculates and returns the 2 Dimensional Histogram of D.
 D must be a 2 column or 2 row matrix or an array of complex numbers
 Example:
 hist2d([randn(1,10000); randn(1,10000)])

 used for climada_distribution_lon_lat
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/hist2d.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="makeColorMap">
<H2>makeColorMap</H2></A>
<font color="blue">function cMap = makeColorMap(varargin) </font>
 MAKECOLORMAP makes smoothly varying colormaps
 a = makeColorMap(beginColor, middleColor, endColor, numSteps);
 a = makeColorMap(beginColor, endColor, numSteps);
 a = makeColorMap(beginColor, middleColor, endColor);
 a = makeColorMap(beginColor, endColor);

 all colors are specified as RGB triples
 numSteps is a scalar saying howmany points are in the colormap

 Examples:

 peaks;
 a = makeColorMap([1 0 0],[1 1 1],[0 0 1],40);
 colormap(a)
 colorbar

 peaks;
 a = makeColorMap([1 0 0],[0 0 1],40);
 colormap(a)
 colorbar

 peaks;
 a = makeColorMap([1 0 0],[1 1 1],[0 0 1]);
 colormap(a)
 colorbar

 peaks;
 a = makeColorMap([1 0 0],[0 0 1]);
 colormap(a)
 colorbar

 Reference:
 A. Light &amp P.J. Bartlein, &quotThe End of the Rainbow? Color Schemes for
 Improved Data Graphics,&quot Eos,Vol. 85, No. 40, 5 October 2004.
 http://geography.uoregon.edu/datagraphics/EOS/Light&ampBartlein_EOS2004.pdf
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/makeColorMap.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="mygaussfit">
<H2>mygaussfit</H2></A>
<font color="blue">function [sigma,mu,A] = mygaussfit(x,y,h) </font>

 this function is doing fit to the function
 y = A * exp( -(x-mu)^2 / (2*sigma^2) )

 the fitting is been done by a polyfit
 the lan of the data.

 h is the threshold which is the fraction
 from the maximum y height that the data
 is been taken from.
 h should be a number between 0-1.
 if h have not been taken it is set to be 0.2
 as default.

 used in climada_distribution_v0_vi
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/mygaussfit.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="nanmax">
<H2>nanmax</H2></A>
<font color="blue">function [varargout] = nanmax(varargin) </font>
NANMAX Maximum value, ignoring NaNs.
   M = NANMAX(A) returns the maximum of A with NaNs treated as missing. 
   For vectors, M is the largest non-NaN element in A.  For matrices, M is
   a row vector containing the maximum non-NaN element from each column.
   For N-D arrays, NANMAX operates along the first non-singleton
   dimension.

   [M,NDX] = NANMAX(A) returns the indices of the maximum values in A.  If
   the values along the first non-singleton dimension contain more than
   one maximal element, the index of the first one is returned.
  
   M = NANMAX(A,B) returns an array the same size as A and B with the
   largest elements taken from A or B.  Either one can be a scalar.

   [M,NDX] = NANMAX(A,[],DIM) operates along the dimension DIM.

   See also MAX, NANMIN, NANMEAN, NANMEDIAN, NANMIN, NANVAR, NANSTD.
   Copyright 1993-2004 The MathWorks, Inc. 
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/nanmax.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="nanmean">
<H2>nanmean</H2></A>
<font color="blue">function m = nanmean(x,dim) </font>
NANMEAN Mean value, ignoring NaNs.
   M = NANMEAN(X) returns the sample mean of X, treating NaNs as missing
   values.  For vector input, M is the mean value of the non-NaN elements
   in X.  For matrix input, M is a row vector containing the mean value of
   non-NaN elements in each column.  For N-D arrays, NANMEAN operates
   along the first non-singleton dimension.

   NANMEAN(X,DIM) takes the mean along dimension DIM of X.

   See also MEAN, NANMEDIAN, NANSTD, NANVAR, NANMIN, NANMAX, NANSUM.
   Copyright 1993-2004 The MathWorks, Inc.
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/nanmean.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="parseArgs">
<H2>parseArgs</H2></A>
<font color="blue">function ArgStruct=parseArgs(args,ArgStruct,varargin) </font>
 Helper function for parsing varargin. 


 ArgStruct=parseArgs(varargin,ArgStruct[,FlagtypeParams[,Aliases]])

 * ArgStruct is the structure full of named arguments with default values.
 * Flagtype params is params that don't require a value. (the value will be set to 1 if it is present)
 * Aliases can be used to map one argument-name to several argstruct fields


 example usage: 
 --------------
 function parseargtest(varargin)

 %define the acceptable named arguments and assign default values
 Args=struct('Holdaxis',0, ...
        'SpacingVertical',0.05,'SpacingHorizontal',0.05, ...
        'PaddingLeft',0,'PaddingRight',0,'PaddingTop',0,'PaddingBottom',0, ...
        'MarginLeft',.1,'MarginRight',.1,'MarginTop',.1,'MarginBottom',.1, ...
        'rows',[],'cols',[]); 

 %The capital letters define abrreviations.  
 %  Eg. parseargtest('spacingvertical',0) is equivalent to  parseargtest('sv',0) 

 Args=parseArgs(varargin,Args, ... % fill the arg-struct with values entered by the user
           {'Holdaxis'}, ... %this argument has no value (flag-type)
           {'Spacing' {'sh','sv'}; 'Padding' {'pl','pr','pt','pb'}; 'Margin' {'ml','mr','mt','mb'}});

 disp(Args)




 % Aslak Grinsted 2003
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/parseArgs.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="plot_normal">
<H2>plot_normal</H2></A>
<font color="blue">function plot_normal( x,params,hAx,plot_num,fontsize ) </font>
 plot the normal distribution with parameter &quotu&quot and &quotsig2&quot
 
 the distribution is given by:

        p(r) = sqrt(1/2/pi/sig^2)*exp(-((r-u)^2)/(2*sig^2))

 format:   plot_normal( x,params,hAx,plot_num,fontsize )

 input:    x         - X axis, for the plot
           params    - the distribution parameter, RMS error and VAR or CRB
           hAx       - where to plot the distribution curve
           plot_num  - since the curve is added with a text to the axes,
                       this parameter specifies where the text should be displayed
                       and what color to choose for the curve
           fontsize  - size of the font of the text, default 9


 example:  plot_normal( x,fit_ML_normal(data),hAx,3 )
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/plot_normal.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="plotclr">
<H2>plotclr</H2></A>
<font color="blue">function [h, h_points] = plotclr(x,y,v, marker, markersize, colorbar_on, miv, mav, map, zero_off, v_exp) </font>
FUNCTION PLOTC(X,Y,V,'MARKER') plots the values of v colour coded
 at the positions specified by x and y, and v (z-axis) in a 3-D axis
 system. A colourbar is added on the right side of the figure.

 The colorbar strectches from the minimum value of v to its
 maximum in 9 steps (10 values).

 The last argument is optional to define the marker being used. The
 default is a point. To use a different marker (such as circles, ...) send
 its symbol to the function (which must be enclosed in '; see example).

 The plot is actually a 3D plot but the orientation of the axis is set
 such that it appears to be a plane 2D plot. However, you can toggle
 between 2D and 3D view either by using the command 'view(3)' (for 3D
 view) or 'view(2)' (for 2D), or by interactively rotating the axis
 system.

 Example:
 Define three vectors
    x=1:10;y=1:10;p=randn(10,1);
    plotc(x,y,p)

    x=randn(100,1);
    y=2*x+randn(100,1);
    p=randn(100,1);
    plotc(x,y,p,'d')
    view(3)

 Uli Theune, University of Alberta, 2004
 modified by Stephanie Contardo, British Oceanographic Data Centre, 2006
 Lea Mueller, muellele@gmail.com, 20150728, plot values above threshold mav 
 Lea Mueller, muellele@gmail.com, 20151130, bugfix colorbar if all values are equal
 Lea Mueller, muellele@gmail.com, 20151207, include climada_global.markersize
 Lea Mueller, muellele@gmail.com, 20151207, include climada_global.marker
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/plotclr.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="subaxis">
<H2>subaxis</H2></A>
<font color="blue">function h=subaxis(varargin) </font>
SUBAXIS Create axes in tiled positions. (just like subplot)
   Usage:
      h=subaxis(rows,cols,cellno[,settings])
      h=subaxis(rows,cols,cellx,celly[,settings])
      h=subaxis(rows,cols,cellx,celly,spanx,spany[,settings])

 SETTINGS: Spacing,SpacingHoriz,SpacingVert
           Padding,PaddingRight,PaddingLeft,PaddingTop,PaddingBottom
           Margin,MarginRight,MarginLeft,MarginTop,MarginBottom
           Holdaxis

           all units are relative (e.g from 0 to 1)

           Abbreviations of parameters can be used.. (Eg MR instead of MarginRight)
           (holdaxis means that it wont delete any axes below.)


 Example:

   &ampgt&ampgt subaxis(2,1,1,'SpacingVert',0,'MR',0);
   &ampgt&ampgt imagesc(magic(3))
   &ampgt&ampgt subaxis(2,'p',.02);
   &ampgt&ampgt imagesc(magic(4))

 2001 / Aslak Grinsted  (Feel free to modify this code.)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/subaxis.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="waitbar_toggle">
<H2>waitbar_toggle</H2></A>
<font color="blue">function waitbar_toggle </font>
 climada
 NAME:
   waitbar_toggle
 PURPOSE:
   toggle waitbar (calling once suppresses the waitbar, calling again
   brings it back).

   Simply sets climada_global.waitbar=0, just for ease of use,
   that's why it comes also with a function name without 'climada_'

 CALLING SEQUENCE:
   waitbar_toggle
 EXAMPLE:
   waitbar_toggle
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141123
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada/code/helper_functions/waitbar_toggle.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_naturalearthdata_add">
<H2>climada_naturalearthdata_add</H2></A>
<font color="blue">function shapes=climada_naturalearthdata_add(naturalearthdata_file,linewidth,fill_color) </font>
 climada
 NAME:
   climada_naturalearthdata_add
 PURPOSE:
   add naturalearthdat shape(s) to an existing plot, e.g. to add Admin
   (file ne_50m_admin_0_boundary_lines_land.shp or
   ne_50m_admin_1_states_provinces_lines.shp) or urban areas (file
   ne_50m_urban_areas.shp) or...
 CALLING SEQUENCE:
   climada_naturalearthdata_plot(linewidth,keep_boundary,annotate_places,urban_areas)
 EXAMPLE:
   climada_plot_world_borders;hold on % to plot world borders
   climada_naturalearthdata_add % prompt for what to add
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   naturalearthdata_file: filename of the shape (*.shp) file to be added
       to the plot
   linewidth: line width of borders, default is 1
   country_color: the RGB triple for country coloring (e.g. [255 236
       139]/255). Default set in code (yellow). Or just 'b', 'r'... as in
       plot
 OUTPUTS:
   a plot, map_data contains all the elements requested/plottet
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141125, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/Louisiana_GIS/code/climada_naturalearthdata_add.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_naturalearthdata_plot">
<H2>climada_naturalearthdata_plot</H2></A>
<font color="blue">function map_data=climada_naturalearthdata_plot(linewidth,keep_boundary,world_borders,annotate_places,urban_areas) </font>
 climada
 NAME:
   climada_naturalearthdata_plot
 PURPOSE:
   plot almost any shapes as found in www.naturalearthdata.com
   (www.naturalearthdata.com/downloads)
 CALLING SEQUENCE:
   climada_naturalearthdata_plot(linewidth,keep_boundary,annotate_places,urban_areas)
 EXAMPLE:
   climada_naturalearthdata_plot(1,0,0,1) % borders and urban areas
   climada_plot_world_borders;hold on
   climada_naturalearthdata_plot(1,0,0,0,1) % overlay urban areas
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   linewidth: line width of borders, default is 1
   keep_boundary: if =1, keep axes boundaries, default =0, undefined
   world_borders: if =1, plot world borders, =0 not
   annotate_places: if =1, annotate places (cities), =0 not (default)
   urban_areas: =1, show urban areas, =0 not (default)
 OUTPUTS:
   a plot, map_data contains all the elements requested/plottet
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141125, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/Louisiana_GIS/code/climada_naturalearthdata_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_shp_explorer">
<H2>climada_shp_explorer</H2></A>
<font color="blue">function climada_shp_explorer(shapes_folder,single_mode,fast_check) </font>
 climada
 MODULE
   _shapes
 NAME:
   climada_shp_explorer
 PURPOSE:
   explore content of shape files and folders full of shape files

   WARNING: might take a LONG time, hence see fast_check

 CALLING SEQUENCE:
   climada_shp_explorer(shapes_folder,single_mode,fast_check)
 EXAMPLE:
   climada_shp_explorer('',0,10) % plot every 10th shape (often a good start)
 INPUTS:
   shapes_folder: a folder with shape files (or a single shape file, if
       extension .shp, if single_mode=1)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   single_mode: =0, select all files in the folder
       =1 only the actually selected file
   fast_check: &ampgt1: only plot every fast check shape (to get a feel)
       start e.g. with fast_check=100 and then fast_check=10
       =1: plot all shapes (default)
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141223
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/Louisiana_GIS/code/climada_shp_explorer.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_assets_crop">
<H2>climada_assets_crop</H2></A>
<font color="blue">function assets = climada_assets_crop(assets,polygon_focus_area) </font>
 climada_assets_crop
 MODULE:
   advanced
 NAME:
   climada_assets_crop
 PURPOSE:
   Reduce assets to focus only on a given area. Very useful for large assets, 
   where only a speficic area is need. 
   Usually this is the case after climada_nightlight_entity or 
   climada_create_centroids_entity_base. Analogue to climada_hazard_crop.
 CALLING SEQUENCE:
   assets = climada_assets_crop(assets,polygon_focus_area)
 EXAMPLE:
   assets = climada_assets_crop(assets,polygon_focus_area)
 INPUTS: 
   assets: a climada assets structure
   polygon_focus_area: structure with polygon coordinate information in fields
                       .lon and .lat, or .X and .Y that define the focus
                       area, can be multiple polygon_focus_area(2) or more
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:      
   assets: a climada assets structure, with .lon, .lat and .Value,
                        where all coordinates are within the given polygon focus area.
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160314, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/climada_assets_crop.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_elevation_add">
<H2>climada_centroids_elevation_add</H2></A>
<font color="blue">function centroids = climada_centroids_elevation_add(centroids,centroids_rectangle,check_plot) </font>
 climada 
 NAME:
   climada_centroids_elevation_add
 PURPOSE:
   add elevation to given centroids or create centroids given a rectangle of
   lon/lat. Uses SRTM data (90 m digitial elevation data, climada module dem)
 CALLING SEQUENCE:
   centroids = climada_centroids_elevation_add(centroids,centroids_rectangle)
 EXAMPLE:
   centroids = climada_centroids_elevation_add;
   centroids = climada_centroids_elevation_add(centroids);
   centroids = climada_centroids_elevation_add('',[-89.15 -89.1 13.695 13.73]);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   centroids: climada centroids with lon,lat but not elevation_m info
   centroids_rectangle: rectangle that indicates the area where centroids
          should be created (on a 90 m resolution, as given by SRTM) 
          including elevation_m field
   if both inputs are empty, the user can choose a country and define a
   rectangle area in a figure
   check_plot: =1, do show check plot 
 OUTPUTS:
   centroids: a climada centroids structure with fields
       .lon, .lat, .elevation_m for elevation in meters
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151123, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/climada_centroids_elevation_add.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_generate">
<H2>climada_centroids_generate</H2></A>
<font color="blue">function centroids = climada_centroids_generate(centroids_rectORcountry_nameORshapes, resolution_km, buffer_check, save_file, check_plot) </font>
 climada generate gridded centroids
 MODULE:
   advanced
 NAME:
   climada_generate_centroids
 PURPOSE:
   Given a rectangle defining the location of interest, generate an evenly
   spaced rectilinear grid of hazard centroids
 CALLING SEQUENCE:
   centroids = climada_generate_centroids(centroids_rectORcountry_nameORshapes, resolution_km, buffer_check, save_file, check_plot)
 EXAMPLE:
   centroids = climada_generate_centroids
   centroids = climada_generate_centroids(centroids_rect, 0.5, 1, 'NO_SAVE', 1)
   centroids = climada_generate_centroids('Netherlands', 1.0, 1, '', 0)
   centroids = climada_generate_centroids(shapes, 1.0, 1, '', 0)
 INPUTS:
   centroids_rectORcountry_nameORshapes [prompted for if not given] 
       can be any one of the following:
       centroids_rect: 4-element row vector defining the longitude and latitude
           limits of the study region [min_lon max_lon min_lat max_lat]
       country_name: the name of a country of interest, or ISO3 code
       shapes: any generic shapes struct, with fields .X and .Y
           defining lat and lon coords of study boundary region respectively.
 OPTIONAL INPUT PARAMETERS:
   resolution_km: specify the centroid resolution (default = 1 km)
   buffer_check: specifies whether a lower resolution grid of centroids 
       is generated outside the boundary defined by shapes,
       or if the high resolution centroids fill the entire
       boudning box (default = 1). Can also be set to -1, for
       centroids that only fill the shape
   save_file: full pathname of save location. If set to 'AUTO',
       centroids are automatically saved in the climada global 
       data directory. If set to 'NO_SAVE', centroids will not 
       be saved. (default = 'AUTO')
 OUTPUTS:
   centroids:      climada centroids struct with fields
                     .Longitude
                     .Latitude
                     .onLand
                     .centroid_ID
                     .countryname - cell array same size as .centroid_ID
                     .admin0_name - country name char array
                     .admin0_ISO3 - ISO 3 country code
                     .comment
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150119
 Gilles Stassen, 20150128, added .comment field
 Gilles Stassen, 20150326, added buffer
 Gilles Stassen, 20150408, increased buffer size
 Gilles Stassen, 20150416, save functionality, general shape input
 Gilles Stassen, 20150423, documentation updated
 Gilles Stassen, 20150703, struct array shape input
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 Lea Mueller, muellele@gmail.com, 20151106, move to advanced
 Lea Mueller, muellele@gmail.com, 20151123, set shapes_check to 0 for centroids_rect
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_generate from climada_generate_centroids
 David N. Bresch, david.bresch@gmail.com, 20160122, ISO3 debugged
 David N. Bresch, david.bresch@gmail.com, 20160126, header updated
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/climada_centroids_generate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_circle_create">
<H2>climada_circle_create</H2></A>
<font color="blue">function circle = climada_circle_create(center_lon,center_lat,radius_deg,check_plot) </font>
 climada create circle polygon
 MODULE:
   climada advanced
 NAME:
   climada_circle_create
 PURPOSE:
   Create a circe polygon (circle.lon, .lat) based on a given center (lon,
   lat) and radius_deg. Hint: 1 is roughly 100km.
 CALLING SEQUENCE:
   circle = climada_circle_create(center_lon,center_lat,radius_deg)
 EXAMPLE:
   circle = climada_circle_create(115,23,0.1)
 INPUTS:
   center_lon: longitude of center point
   center_lat: latitude of center point
   radius_km: radius in km of circle
 OPTIONAL INPUT PARAMETERS:
   check_plot: set to 1 to show a plot
 OUTPUTS:
   circle: a struct with fields .lon, .lat, .center_lon, .center.lat and .radius_deg
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160509, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/climada_circle_create.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_crop">
<H2>climada_entity_crop</H2></A>
<font color="blue">function entity = climada_entity_crop(entity, bounding_box, entity_scale_factor) </font>
 climada
 NAME:
   climada_clip_centroids_entity
 PURPOSE:
   Given an entity struct on country level (generated using 
   climada_create_GDP_entity or climada_nightlight_entity) this function 
   crops the entity struct to a bounding box and/or scales its resolution
   (interpolating values).
 CALLING SEQUENCE:
   entity = climada_entity_crop(entity, bounding_box, [entity_scale_factor])
 EXAMPLE:
 INPUTS:
   entity:         The entity created by climada_create_GDP_entity or
                   climada_nightlight_entity
   bounding_box:   An array of size 4 bounding the region of interest,
                   defined by [min_lon max_lon min_lat max_lat]
 OPTIONAL INPUT PARAMETERS:
   entity_scale_factor: Can be a single number (scales by same factor along 
                   lat and lon), or an array of size 2, such that the first
                   index indicates the lon, and the second the lat scale 
                   factors. Default value is set to 2 along both lat and lon.
 OUTPUTS:
   entity:         Entity struct
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20141121
 Gilles Stassen, gillesstassen@hotmail.com, 20141218 change variable names whole_world_borders.lon/lat -&ampgt shapes.X/Y
 Gilles Stassen, gillesstassen@hotmail.com, 20141223 add check_country input arg.
 Gilles Stassen, gillesstassen@hotmail.com, 20150220 centroids routine removed, new function: climada_clip_centroids_entity -&ampgt climada_entity_crop
 Lea Mueller, muellele@gmail.com, 20151125, move to advanced from flood
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/climada_entity_crop.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_exceedence_freq2freq">
<H2>climada_exceedence_freq2freq</H2></A>
<font color="blue">function event_freq = climada_exceedence_freq2freq(exceedence_freq) </font>
 climada calculate event frequency based on exceedence frequency
 MODULE:
   advanced
 NAME:
   climada_exceedence_freq2freq
 PURPOSE:
   Calculate event frequency based on exceedence frequency. The reverse
   from climada_damage_exceedence.
 CALLING SEQUENCE:
   event_freq = climada_exceedence_freq2freq(exceedence_freq)
 EXAMPLE:
   event_freq = climada_exceedence_freq2freq(1./[70 10])
 INPUTS:
   exceedence_freq: exceedence frequencies, i.e. 1./return_period (array)
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   event_freq: occurrence frequency of each event damage (array)
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160308, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/climada_exceedence_freq2freq.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard2xls">
<H2>climada_hazard2xls</H2></A>
<font color="blue">function climada_hazard2xls(hazard, hazard_xls_file) </font>
 climada hazard save in xls
 MODULE:
   advanced
 NAME:
   climada_hazard2xls
 PURPOSE:
   Save hazard as xls file
 CALLING SEQUENCE:
   climada_hazard2xls(hazard, hazard_xls_file)
 EXAMPLE:
   climada_hazard2xls(hazard)
 INPUTS:
   hazard: hazard strucure to write out in excel file
   hazard_xls_file: the filename of the Excel file to be written
 OUTPUTS:
   excel file
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160308, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/climada_hazard2xls.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_crop">
<H2>climada_hazard_crop</H2></A>
<font color="blue">function hazard = climada_hazard_crop(hazard,polygon_focus_area) </font>
 climada_hazard_crop
 MODULE:
   advanced
 NAME:
   climada_hazard_crop
 PURPOSE:
   Reduce hazard to focus only on a given area. Very useful for large hazards, 
   that contain gridded information and only a speficic area is need. 
   Usually this is the case after climada_asci2hazard.m. 
 CALLING SEQUENCE:
   hazard = climada_hazard_crop(hazard, polygon_focus_area)
 EXAMPLE:
   hazard = climada_hazard_crop(hazard, polygon_focus_area)
 INPUTS: 
   hazard            : a climada hazard structure
   polygon_focus_area: structure with polygon coordinate information in fields
                       .lon and .lat, or .X and .Y that define the focus
                       area, can be multiple polygon_focus_area(2) or more
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:      
   hazard: a climada hazard structure, with .lon, .lat and .intensity,
                   where all coordinates are within the given polygon focus area.
   hazard.focus_area: copy of polygon struct
   hazard.in_focus_area: a vector to indicate in which polygon/focus_area
                   a centroid is located
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150724, init
 Lea Mueller, muellele@gmail.com, 20151106, move to advanced
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_hazard_crop from climada_hazard_focus_area
 Lea Mueller, muellele@gmail.com, 20160224, enable for multiple polygons
 Lea Mueller, muellele@gmail.com, 20160314, loop over segments divided by nans
 Lea Mueller, muellele@gmail.com, 20160318, introduce polygon_tolerance
 Lea Mueller, muellele@gmail.com, 20160427, bugfix if hazard.comment does not exist 
 Lea Mueller, muellele@gmail.com, 20160509, add in_focus_area
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/climada_hazard_crop.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_init">
<H2>climada_hazard_init</H2></A>
<font color="blue">function hazard = climada_hazard_init(hazard) </font>
 init hazard structure
 MODULE:
   climada advanced
 NAME:
   climada_hazard_init
 PURPOSE:
   init a climada hazard struct that contains the necessary fields
   (e.g. .lon, .lat, .intensity etc), or append add the necessary fields
   to an existing hazard and order fields
 CALLING SEQUENCE:
   hazard = climada_hazard_init(hazard)
 EXAMPLE:
   hazard = climada_hazard_init
 INPUTS: none
 OPTIONAL INPUT PARAMETERS:
   hazard: an existing hazard structure where one wants to add the
   necessary fields and order the fields
 OUTPUTS:
   hazard: a climada hazard struct with all the necessary fields
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160427, init
f ~exist('hazard','var'), hazard = ''; end
f ~isstruct(hazard), clear hazard; hazard.lon = []; end %init as struct
f ~isfield(hazard,'lon'), hazard.lon = []; end
f ~isfield(hazard,'lat'), hazard.lat = []; end
f ~isfield(hazard,'intensity'), hazard.intensity = []; end
f ~isfield(hazard,'frequency'), hazard.frequency = []; end
f ~isfield(hazard,'centroid_ID'), hazard.centroid_ID = ''; end
f ~isfield(hazard,'peril_ID'), hazard.peril_ID = ''; end
f ~isfield(hazard,'units'), hazard.units = ''; end
f ~isfield(hazard,'event_count'), hazard.event_count = []; end
f ~isfield(hazard,'orig_event_count'), hazard.orig_event_count = []; end
f ~isfield(hazard,'event_ID'), hazard.event_ID = []; end
f ~isfield(hazard,'orig_event_flag'), hazard.orig_event_flag = []; end
f ~isfield(hazard,'datenum'), hazard.datenum = []; end
f ~isfield(hazard,'reference_year'), hazard.reference_year = []; end
f ~isfield(hazard,'filename'), hazard.filename = ''; end
f ~isfield(hazard,'comment'), hazard.comment = ''; end
 if ~isfield(hazard,'yyyy'), hazard.yyyy = []; end
 if ~isfield(hazard,'mm'), hazard.mm = []; end
 if ~isfield(hazard,'dd'), hazard.dd = []; end
 order fields in hazard struct
ames = fieldnames(hazard);
iven_order = {'lon','lat','intensity','frequency','centroid_ID','peril_ID','units','event_count','orig_event_count','event_ID','orig_event_flag','datenum','reference_year','filename','comment'};
dditional_name = ~ismember(names,given_order);
ll_names = {given_order{:} names{additional_name}};
azard = orderfields(hazard,all_names);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/climada_hazard_init.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_construct">
<H2>climada_measures_construct</H2></A>
<font color="blue">function measures = climada_measures_construct(measures,n_measures) </font>
 create measures structure
 MODULE:
   climada advanced
 NAME:
   climada_measures_construct
 PURPOSE:
   create a climada measures struct that contains the necessary fields
   (e.g. .name, .hazard_intensity_impact_b etc), or append a new measure
   to an existing measures structure
 CALLING SEQUENCE:
   measures = climada_measures_construct(measures,n_measures)
 EXAMPLE:
   measures = climada_measures_construct
 INPUTS: none
 OPTIONAL INPUT PARAMETERS:
   measures: an existing measures structure where one want to add one or more measures 
   n_measures: number of measures to be created or added
 OUTPUTS:
   measures: a climada measures struct
 MODIFICATION HISTORY:
 Gilles Stassen, init
 Lea Mueller, muellele@gmail.com, 20150902, rename to hazard_intensity_impact_b from hazard_intensity_impact
 Lea Mueller, muellele@gmail.com, 20151117, add filename, add documentation, move to advanced
f ~exist('measures'    ,'var'),    measures = '';  end
f ~exist('n_measures'  ,'var'),    n_measures = 1; end
f isempty(measures)
   measures.name={};
   measures.color={};
   measures.color_RGB = [];
   measures.cost= [];
   measures.hazard_intensity_impact_a=[];
   measures.hazard_intensity_impact_b=[];
   measures.hazard_high_frequency_cutoff=[];
   measures.hazard_event_set={};
   measures.MDD_impact_a= [];
   measures.MDD_impact_b= [];
   measures.PAA_impact_a= [];
   measures.PAA_impact_b= [];
   measures.damagefunctions_map={}; 
   measures.entity_file={};
   measures.risk_transfer_attachement = [];
   measures.risk_transfer_cover = [];
   measures.peril_ID={}; 
   measures.hazard_event_set_operator={}; 
nd
f n_measures == 0
   return;
nd
f n_measures &ampgt=1
   for measure_i = 1:n_measures
       measures.name{end+1}    = ['measure_' num2str(measure_i+length(measures.cost))];
       R = rand; G = rand; B = rand; % random colors for a (pleasant) surprise each time :)
       measures.color{end+1}                           = [num2str(R) ' ' num2str(G) ' ' num2str(B)];
       measures.color_RGB(end+1,:)                     = [R; G; B];
       measures.cost(end+1)                            = 1;
       measures.hazard_intensity_impact_a(end+1)       = 1;
       measures.hazard_intensity_impact_b(end+1)       = 0;
       measures.hazard_high_frequency_cutoff(end+1)    = 0;
       measures.hazard_event_set{end+1}                = 'nil';
       measures.MDD_impact_a(end+1)                    = 1;
       measures.MDD_impact_b(end+1)                    = 0;
       measures.PAA_impact_a(end+1)                    = 1;
       measures.PAA_impact_b(end+1)                    = 0;
       measures.damagefunctions_map{end+1}             = 'nil';
       measures.risk_transfer_attachement(end+1)       = 0;
       measures.risk_transfer_cover(end+1)             = 0;
       measures.entity_file{end+1}                     = 'nil';
       measures.peril_ID{end+1}                        = '';
       measures.hazard_event_set_operator{end+1}       = '';
   end
nd
f all(n_measures &amplt 0)
   rm_measures = sort(abs(unique(n_measures)),'descend');
   flds = fieldnames(measures);
   for measure_i = rm_measures
       total_no_measures = length(measures.name);
       for fld_i = 1:length(flds)
           if length(measures.(flds{fld_i})) == total_no_measures &amp&amp ~ischar(measures.(flds{fld_i}))
               if strcmp(flds{fld_i},'color_RGB')
                   measures.(flds{fld_i})(measure_i,:) = [];
               else
                   measures.(flds{fld_i})(measure_i) = [];
               end
           end
       end
   end
nd                  
easures = climada_measures_encode(measures);
easures.filename = 'constructed directly in matlab';
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/climada_measures_construct.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_add">
<H2>climada_measures_impact_add</H2></A>
<font color="blue">function measures_impact = climada_measures_impact_add(measures_impact,EDS,entity) </font>
 climada_measures_impact_add
 MODULE:
   advanced
 NAME:
   climada_measures_impact_add
 PURPOSE:
   Add control EDS to existing measures_impact so that the before
   'control' run is the asset change run (i.e. urban planning)
 CALLING SEQUENCE:
   measures_impact = climada_measures_impact_add(measures_impact,EDS,entity)
 EXAMPLE:
   measures_impact = climada_measures_impact_add(measures_impact,EDS,entity)
 INPUTS:
   measures_impact: a climada measures_impact structure where we want to
       add a new control run from EDS.
       with fields .EDS,
       .ED, .benefit, .scenario, .peril
       &ampgt promted for if not given
   EDS: a climada EDS structure that contains the control run that will be
       added to measures_impact.
       with field .refence_year,
       .ED, .ED_at_centroid, .peril
       &ampgt promted for if not given
   entity: special case for Barisal to copy asset characteristics
       (.Category, .Caterogy_name, .Category_ID)
 OPTIONAL INPUT PARAMETERS:
   param2: as an example
 OUTPUTS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151207, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/climada_measures_impact_add.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="axescenter">
<H2>axescenter</H2></A>
<font color="blue">function [] = axescenter(ax) </font>
AXESCENTER locates axes in the center instead of at the edges.
 AXESCENTER(AX) puts axes in the center of axes AX.  If AX is not
 supplied, the current axes is assumed.  Many of the standard properties
 manipulated through the command line will also work when the axes are in
 the center, such as grid, title, and x/ylabel.  This function works by
 placing two 'fake' axes in the center of the current axes and hiding the
 ticks and other signs of AX, while property listeners are attached to the
 relevant properties of AX.  An exception to this is the deletefcn
 property. Apparently no listener can be attached to this property so that
 calling 'delete(AX)' will leave the center axes intact.  In this case,
 the user can find the handles using:
 H = findall(gcf,'type','axes','handlev','off') 
 then the center axes can be deleted manually.
 Another exception is the dataaspectratio property.  If the user sets the
 dataaspectratio property, the center axes will not line up correctly.
 Thus any function that changes this property, such as 'axis equal' will
 not yield the correct alignment for the center axes.  For now it is
 recommended to set the axes position property to get a similar effect.

 Notes:
 The goal of this work is that the user will not see any difference in
 functionality between having the axes at the center, and having them at   
 the edges.  Obviously this goal has not been fully met: there are 
 exceptions.  It is hoped that improvements will be continuously added 
 through feedback from users and the authors own effort.  If you see a 
 way around one of the exceptions, please contact the author!  I am 
 particularly interested in finding ways to match the dataaspect/plotbox  
 ratios so that functions like axis square can be used.  I have been using
 Matlab for years now, and I have NO CLUE how to do this after much  
 wasted effort, though I am certain that it can be done.  
 Using the zoom and pan tools from the figure menubar keeps the center 
 axes correct.
 As of now, AXESCENTER does not work if either axis of AX is log scaled,
 or if the plot is 3D.
 The workings of the code are simple enough that modification/extension
 should be easy.
 Several solutions were sought to allow the user to use delete(AX) and 
 have the center axes be deleted as well.  No method was found that
 worked for both this case and the case where the user closes the figure
 by clicking the x.  If you find a solution to this dilemma, please
 contact the author.
 I would like to acknowledge the work of Yair Altman. A piece of his
 proplistener code, available on the FEX, was incorporated into this 
 work.  As with his work, this function relies on undocumented Matlab
 functions and properties, so it cannot be guaranteed to work on all
 versions of Matlab.

 Perhaps the best way to see this function in action is to copy the demo
 below into a script and run it.  The demo manipulates many of the axes
 properties using gca, as one would normally do.  The demo lasts about 24
 seconds.  When the demo is over, feel free to zoom in and out, and pan
 the plot using the figure's menubar.

 Demo: (Copy and paste into a script, or to the command line.)

   f = figure('position',[100 100 700 680]);
   str = 'Click to continue.';
   x = -2*pi:.01:2*pi;
   plot(x,sin(x),'r'),hold on
   pos = get(gca,'position');
   T = title('Call axescenter','fonts',14,'fontw','b');
   axescenter,uiwait(msgbox(str,'DEMO','modal'));  % Call our function
   set(T,'string','Change ylim')
   set(gca,'ylim',[-10 10]),uiwait(msgbox(str,'DEMO','modal'));
   set(T,'string','Add plot, reset ylim, change fontweight, and xlabels')
   plot(x,cos(x))
   set(gca,'ylim',[-2 2],'fontw','b')
   set(gca,'xticklabel',['2' ;'3' ;'4' ;'5' ;'6'])
   uiwait(msgbox(str,'DEMO','modal'));
   set(T,'string','Change xtick')
   set(gca,'xtick',[-4 0 4]),uiwait(msgbox(str,'DEMO','modal'));
   set(T,'string','Change xtickmode and xticklabelmode to auto')
   set(gca,'xtickmode','auto','xticklabelmode','auto'),
   uiwait(msgbox(str,'DEMO','modal'));
   set(T,'string','Turn on minor grids')
   set(gca,'fontw','n')
   set(gca,'xminorgrid','on','yminorgrid','on')
   uiwait(msgbox(str,'DEMO','modal'));
   set(T,'string','Change axes position')
   set(gca,'pos',[.1 .05 .5 .8]),uiwait(msgbox(str,'DEMO','modal'));
   set(T,'string','Move axes back, add x and y labels, change ticklength')
   set(gca,'pos',pos)
   xlabel('X','fonts',12,'fontw','b'),ylabel('Y','fonts',12,'fontw','b')
   set(gca,'tickl',[.06 .025]),uiwait(msgbox(str,'DEMO','modal'));
   set(T,'string','Change fontangle, fontsize axes linewidth')
   set(gca,'fonta','i','linewidth',2)
   set(gca,'fonts',6),uiwait(msgbox(str,'DEMO','modal'));
   set(T,'string','Change fontsize back, change axes color')
   set(gca,'fonta','n','fonts',10)
   set(gca,{'xcolor','ycolor'},{[.1 .8 .1],[.2 .2 .6]},'tickl',[.02 .025])
   pause(2)
   set(T,'string','Demo over, try zoom and pan.  Thank you.')


 Author:  Matt Fig
 Contact: popkenai@yahoo.com
 Created: 1/9/2009
f nargin&amplt1
   ax = gca;
lseif ~ishandle(ax) || isempty(strmatch('axes',get(ax,'type')))
   error('Input argument must be the handle to an axes.  See help.')
nd
f any(strmatch('log',get(gca,{'xsca','ysca'}))) || all(get(ax,'view'))
   error('AXESCENTER does not work for log scaled  or 3D axes.  See help')
nd
 = get(ax,{'pos','xlim','ylim','units','parent'}); %Set these props first.
c = get(gcf,'color'); % We are going to hide ax in the figure.
et(ax,'tickd','out',{'xcolor';'ycolor'},{fc,fc});
 = get(ax,{'xlabel','ylabel','title'}); % Don't want to hide these guys.
et([H{:}],{'color'},{'k'})
 Next create our fake axes that will act as the center axes.    
.a1 = axes('units',D{4},'posi',[D{1}(1)+D{1}(3)/2 D{1}(2) .01 D{1}(4)],...
    'ylim',D{3},'xtick',[],'handlev','of','tag','XAXIS','color','none',...
    'hittest','off','parent',D{5});  % Give this fake axis the props.
.a2 = axes('units',D{4},'posi',[D{1}(1) D{1}(2)+D{1}(4)/2 D{1}(3) .01],...
    'xlim',D{2},'ytick',[],'handlev','of','tag','YAXIS','color','none',...
    'hittest','off','parent',D{5});  % Give this fake axis the props.
etappdata(ax,'CENTERAXES',S); % Store the handles in appdata of AX.

 Use this function to set listeners for when certain of the axes
 properties change.  The properties of concern are self-explanatory.
 Follow this format to add properties.  The functions are defined below.
listener(ax,'XLim',@xylim)
listener(ax,'YLim',@xylim)
listener(ax,'XTick',@xytick)
listener(ax,'YTick',@xytick)
listener(ax,'XTickLabel',@xytickl)
listener(ax,'YTickLabel',@xytickl)
listener(ax,'FontAngle',@fonta)
listener(ax,'FontName',@fonta)
listener(ax,'FontSize',@fonta)
listener(ax,'FontWeight',@fonta)
listener(ax,'Xcolor',@xcol)
listener(ax,'YColor',@ycol)
listener(ax,'Position',@pos)
listener(ax,'XTickLabelMode',@xytlmd)
listener(ax,'YTickLabelMode',@xytlmd)
listener(ax,'YTickMode',@xytmd)
listener(ax,'XTickMode',@xytmd)
listener(ax,'LineWidth',@xylnw)
<font color="blue">function [] = plistener(ax,prp,func) </font>
 Sets the properties listeners.  From proplistener by Yair Altman.
setact = 'PropertyPostSet';
C = handle(ax);
Src = hC.findprop(prp);
l = handle.listener(hC, hSrc, psetact, {func,ax});
 = findprop(hC, 'Listeners__');
f isempty(p)
   p = schema.prop(hC, 'Listeners__', 'handle vector');
   set(p,'AccessFlags.Serialize', 'off', ...
       'AccessFlags.Copy', 'off',...
       'FactoryValue', [], 'Visible', 'off');
nd
C.Listeners__ = hC.Listeners__(ishandle(hC.Listeners__));
C.Listeners__ = [hC.Listeners__; hl];
  
<font color="blue">function [] = xylim(varargin)  </font>
 Adjusts the x and y limits.
x = varargin{3};
 = getappdata(ax);
 = S.CENTERAXES;
et(S.a1,'ylim',get(ax,'ylim'));
et(S.a2,'xlim',get(ax,'xlim'));
<font color="blue">function [] = xytick(varargin) </font>
 Adjusts the x and y ticks.
x = varargin{3};
 = getappdata(ax);
 = S.CENTERAXES;
et(S.a1,'ytick',get(ax,'ytick'));
et(S.a2,'xtick',get(ax,'xtick'));
<font color="blue">function [] = xytickl(varargin) </font>
 Adjusts the x and y tick labels.
x = varargin{3};
 = getappdata(ax);
 = S.CENTERAXES;
et(S.a1,{'yticklabel','tickl'},get(ax,{'yticklabel','tickl'}));
et(S.a2,{'xticklabel','tickl'},get(ax,{'xticklabel','tickl'}));
<font color="blue">function [] = xcol(varargin) </font>
 Adjusts the x color.
x = varargin{3};
 = getappdata(ax);
 = S.CENTERAXES;
et(S.a2,'xcolor',get(ax,'xcolor'));
c = get(gcf,'color');
et(ax,{'xcolor';'ycolor'},{fc,fc})
<font color="blue">function [] = ycol(varargin) </font>
 Adjusts the y color.
x = varargin{3};
 = getappdata(ax);
 = S.CENTERAXES;
et(S.a1,'ycolor',get(ax,'ycolor'));
c = get(gcf,'color');
et(ax,{'xcolor';'ycolor'},{fc,fc})
<font color="blue">function [] = fonta(varargin) </font>
 Adjusts the fontangle, fontsize, fontweight, fontname.
x = varargin{3};
 = getappdata(ax);
 = S.CENTERAXES;
et(S.a1,{'fonta','fontn','fonts','fontw'},...
   get(ax,{'fonta','fontn','fonts','fontw'}));
et(S.a2,{'fonta','fontn','fonts','fontw'},...
   get(ax,{'fonta','fontn','fonts','fontw'}));
<font color="blue">function [] = pos(varargin) </font>
 Adjusts the position.
x = varargin{3};
 = get(ax,'position');
 = getappdata(ax);
 = S.CENTERAXES;
et(S.a1,'pos',[p(1)+p(3)/2 p(2) eps p(4)]);
et(S.a2,'pos',[p(1) p(2)+p(4)/2  p(3) eps]);
<font color="blue">function [] = xytlmd(varargin) </font>
 Adjusts the x and y tick labels.
x = varargin{3};
 = getappdata(ax);
 = S.CENTERAXES;
et(S.a1,{'yticklabelm','tickl'},get(ax,{'yticklabelm','tickl'}));
et(S.a2,{'xticklabelm','tickl'},get(ax,{'xticklabelm','tickl'}));
<font color="blue">function [] = xytmd(varargin) </font>
 Adjusts the x and y tick labels.
x = varargin{3};
 = getappdata(ax);
 = S.CENTERAXES;
et(S.a1,{'ytickm','tickl'},get(ax,{'ytickm','tickl'}));
et(S.a2,{'xtickm','tickl'},get(ax,{'xtickm','tickl'}));
<font color="blue">function [] = xylnw(varargin) </font>
 Adjusts the x and y tick labels.
x = varargin{3};
 = getappdata(ax);
 = S.CENTERAXES;
nw = get(ax,'linewidth');
et(S.a1,'linewidth',lnw);
et(S.a2,'linewidth',lnw);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/ECA_graphics/axescenter.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="batch_create_ECA_graphics">
<H2>batch_create_ECA_graphics</H2></A>
% WATERFALL GRAPH
 set modul data directory
 dir
 modul_data_dir = [fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
 xlsfile   = 'C:\TEMP\climada_test_environment\climada_additional\ECA_graphics\data\ECA_risk_analysis.xls';
 modul_data_dir = [fileparts(climada_global.root_dir) filesep 'climada_modules' filesep 'advanced' filesep 'data'];
lsfile     = [climada_global.modules_dir filesep 'advanced' filesep 'data' filesep 'ECA_risk_analysis.xls'];
CA_studies = climada_read_risk_analysis(xlsfile,'million_USD');
o_cases    = length(ECA_studies.Today);
igits      = zeros(no_cases,1);
igits(1:3) = 3;
igits(8)   = 3;
lose all
or case_i = [1:10 17] %1:length(ECA_studies.Today)
   fig(case_i) = climada_waterfall_graph_special(ECA_studies, case_i, digits(case_i));
nd
 close all
 Tanzania special case
ase_i = 6;
ig(case_i) = climada_waterfall_graph_special_tanzania(ECA_studies, case_i, digits(case_i));
 close all
 New York special case
ase_i = 3;
ig(case_i) = climada_waterfall_graph_special_NY(ECA_studies, case_i, digits(case_i));
% ADAPTATION COST CURVE
 xlsfile        = 'C:\TEMP\climada_test_environment\climada_additional\ECA_graphics\data\ECA_risk_analysis.xls';
lsfile        = [climada_global.modules_dir filesep 'advanced' filesep 'data' filesep 'ECA_risk_analysis.xls'];
CA_adaptation = climada_read_risk_analysis(xlsfile,'adaptation');
% Example
 list_cases = unique(ECA_adaptation.ECA_case_study);
ase_i = find(strcmp(ECA_adaptation.ECA_case_study,'Example'));
lose all
 fig = climada_adaptation_graph(ECA_adaptation, case_i);
ig = climada_adaptation_graph_upsidedown(ECA_adaptation, case_i);
% Hull
 list_cases = unique(ECA_adaptation.ECA_case_study);
ase_i = find(strcmp(ECA_adaptation.ECA_case_study,'Hull, UK'));
lose all
 fig = climada_adaptation_graph(ECA_adaptation, case_i);
ig = climada_adaptation_graph_upsidedown(ECA_adaptation, case_i);
% China
ase_i = find(strcmp(ECA_adaptation.ECA_case_study,'North &amp Northeast China'));
lose all
 fig = climada_adaptation_graph(ECA_adaptation, case_i);
ig = climada_adaptation_graph_upsidedown(ECA_adaptation, case_i);
% US Gulf Coast
ase_i = find(strcmp(ECA_adaptation.ECA_case_study,'Gulf Coast, US'));
lose all
 fig = climada_adaptation_graph(ECA_adaptation, case_i);
ig = climada_adaptation_graph_upsidedown(ECA_adaptation, case_i);
% India
ase_i = find(strcmp(ECA_adaptation.ECA_case_study,'Maharasthra, India'));
lose all
 fig = climada_adaptation_graph(ECA_adaptation, case_i);
 fig = climada_adaptation_graph_upsidedown(ECA_adaptation, case_i);
ig = climada_adaptation_graph_damage(ECA_adaptation, case_i);
% Tanzania
ase_i = find(strcmp(ECA_adaptation.ECA_case_study,'Tanzania'));
lose all
 fig = climada_adaptation_graph(ECA_adaptation, case_i);
ig = climada_adaptation_graph_upsidedown(ECA_adaptation, case_i);
% Jamaica
ase_i = find(strcmp(ECA_adaptation.ECA_case_study,'Jamaica'));
lose all
 fig = climada_adaptation_graph(ECA_adaptation, case_i);
ig = climada_adaptation_graph_upsidedown(ECA_adaptation, case_i);
% Mopti, Mali
ase_i = find(strcmp(ECA_adaptation.ECA_case_study,'Mopti region, Mali'));
lose all
 fig = climada_adaptation_graph(ECA_adaptation, case_i);
ig = climada_adaptation_graph_upsidedown(ECA_adaptation, case_i);
% Samoa
ase_i = find(strcmp(ECA_adaptation.ECA_case_study,'Samoa'));
lose all
 fig = climada_adaptation_graph(ECA_adaptation, case_i);
ig = climada_adaptation_graph_upsidedown(ECA_adaptation, case_i);
% Guyana
ase_i = find(strcmp(ECA_adaptation.ECA_case_study,'Georgetown, Guyana'));
lose all
 fig = climada_adaptation_graph(ECA_adaptation, case_i);
ig = climada_adaptation_graph_upsidedown(ECA_adaptation, case_i);
% Florida
ase_i = find(strcmp(ECA_adaptation.ECA_case_study,'Florida, US'));
lose all
 fig = climada_adaptation_graph(ECA_adaptation, case_i);
ig = climada_adaptation_graph_upsidedown(ECA_adaptation, case_i);
% Florida
 list_cases = unique(ECA_adaptation.ECA_case_study);
 case_i = find(strcmp(list_cases,'Florida, US'));
 close all
 fig = climada_adaptation_graph_new(ECA_adaptation, case_i);
 
 list_cases = unique(ECA_adaptation.ECA_case_study);
 case_i = find(strcmp(list_cases,'Georgetown, Guyana'));
 close all
 fig = climada_adaptation_graph_new(ECA_adaptation, case_i);
 
 list_cases = unique(ECA_adaptation.ECA_case_study);
 case_i = find(strcmp(list_cases,'Samoa'));
 close all
 fig = climada_adaptation_graph_new(ECA_adaptation, case_i);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/ECA_graphics/batch_create_ECA_graphics.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_adaptation_graph">
<H2>climada_adaptation_graph</H2></A>
<font color="blue">function  fig = climada_adaptation_graph(ECA_adaptation, case_i, digits) </font>
lobal climada_global
f ~climada_init_vars, return; end
 poor man's version to check arguments
f ~exist('ECA_adaptation' ,'var'), ECA_adaptation  = []; end
f ~exist('case_i'         ,'var'), case_i          = []; end
f ~exist('digits'         ,'var'), digits          = []; end
f isempty(case_i)         , case_i = 1 ; end
f isempty(digits)         , digits = 6 ; end
% case i
ist_cases = unique(ECA_adaptation.ECA_case_study);
CA_name   = list_cases{case_i};
ase_index = strcmp(ECA_adaptation.ECA_case_study, ECA_name);
f any(strcmp(ECA_name,{'Florida, US' 'Gulf Coast, US' 'Hull, UK'}))
   bn_flag = 1;
lse
   bn_flag = 0;
nd
easure           = ECA_adaptation.Measure(case_index);
verted_Loss_2030 = ECA_adaptation.Averted_Loss_2030(case_index);
ostBenefit       = ECA_adaptation.CostBenefit(case_index);
enefitCost       = 1./CostBenefit;
enefitCost(isinf(BenefitCost)) = 0;
o_measures       = length(Measure);
 sort according to CostBenefit and cumulate
sort_CostBenefit, sort_index] = sort(CostBenefit(CostBenefit&ampgt0));
ort_CostBenefit  = [sort_CostBenefit; 0];
ort_index        = [sort_index; no_measures];
 cum_benefit       = cumsum(Averted_Loss_2030(sort_index));
um_benefit       = [0; cumsum(Averted_Loss_2030(sort_index))];
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/ECA_graphics/climada_adaptation_graph.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_adaptation_graph_damage">
<H2>climada_adaptation_graph_damage</H2></A>
<font color="blue">function  fig = climada_adaptation_graph_damage(ECA_adaptation, case_i, digits) </font>
lobal climada_global
f ~climada_init_vars, return; end
 poor man's version to check arguments
f ~exist('ECA_adaptation' ,'var'), ECA_adaptation  = []; end
f ~exist('case_i'         ,'var'), case_i          = []; end
f ~exist('digits'         ,'var'), digits          = []; end
f isempty(case_i)         , case_i = 1 ; end
f isempty(digits)         , digits = 6 ; end
% case i
ase_index = case_i;
CA_name   = ECA_adaptation.ECA_case_study{case_i(1)};
 list_cases = unique(ECA_adaptation.ECA_case_study);
 ECA_name   = list_cases{case_i};
 case_index = strcmp(ECA_adaptation.ECA_case_study, ECA_name);
x_flag = 0;
f strcmp(ECA_name,'Example')
   ex_flag = 1;
nd
n_flag = 0;
 if any(strcmp(ECA_name,{'Florida, US' 'Gulf Coast, US'}))
     bn_flag = 1;
 else
     bn_flag = 0;
 end
 shorten measures name, lea, 20150220
CA_adaptation.Measure{46} = 'Rain water harvesting';
easure           = ECA_adaptation.Measure(case_index);
verted_Loss_2030 = ECA_adaptation.Averted_Loss_2030(case_index);
ostBenefit       = ECA_adaptation.CostBenefit(case_index);
enefitCost       = 1./CostBenefit;
enefitCost(1)    = 20; % for nicer figure, lea, 20150220
enefitCost(isinf(BenefitCost)) = 0;
o_measures       = length(Measure);
 sort according to CostBenefit and cumulate
sort_BenefitCost, sort_index] = sort(BenefitCost,'descend');
 sort_CostBenefit  = [sort_CostBenefit; 0];
 sort_index        = [sort_index; no_measures];
 % cum_benefit       = cumsum(Averted_Loss_2030(sort_index));
um_benefit       = [0; cumsum(Averted_Loss_2030(sort_index))];
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/ECA_graphics/climada_adaptation_graph_damage.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_adaptation_graph_new">
<H2>climada_adaptation_graph_new</H2></A>
<font color="blue">function  fig = climada_adaptation_graph_new(ECA_adaptation, case_i, digits) </font>
lobal climada_global
f ~climada_init_vars, return; end
 poor man's version to check arguments
f ~exist('ECA_adaptation' ,'var'), ECA_adaptation  = []; end
f ~exist('case_i'         ,'var'), case_i          = []; end
f ~exist('digits'         ,'var'), digits          = []; end
f isempty(case_i)         , case_i = 1 ; end
f isempty(digits)         , digits = 6 ; end
% case i
ist_cases = unique(ECA_adaptation.ECA_case_study);
CA_name   = list_cases{case_i};
ase_index = strcmp(ECA_adaptation.ECA_case_study, ECA_name);
f any(strcmp(ECA_name,{'Florida, US' 'Gulf Coast, US' 'Hull, UK'}))
   bn_flag = 1;
lse
   bn_flag = 0;
nd
easure           = ECA_adaptation.Measure(case_index);
verted_Loss_2030 = ECA_adaptation.Averted_Loss_2030(case_index);
ostBenefit       = ECA_adaptation.CostBenefit(case_index);
enefitCost       = 1./CostBenefit;
enefitCost(isinf(BenefitCost)) = 0;
o_measures       = length(Measure);
 sort according to CostBenefit and cumulate
sort_CostBenefit, sort_index] = sort(CostBenefit(CostBenefit&ampgt0));
ort_CostBenefit  = [sort_CostBenefit; 0];
ort_index        = [sort_index; no_measures];
 cum_benefit       = cumsum(Averted_Loss_2030(sort_index));
um_benefit       = [0; cumsum(Averted_Loss_2030(sort_index))];
um_reduction     = cum_benefit(end)-cum_benefit;
um_cost          = [0; cumsum(sort_CostBenefit.*diff(cum_benefit))];
ax_              = max([cum_cost; cum_reduction])*1.25;
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/ECA_graphics/climada_adaptation_graph_new.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_adaptation_graph_upsidedown">
<H2>climada_adaptation_graph_upsidedown</H2></A>
<font color="blue">function  fig = climada_adaptation_graph_upsidedown(ECA_adaptation, case_i, digits) </font>
lobal climada_global
f ~climada_init_vars, return; end
 poor man's version to check arguments
f ~exist('ECA_adaptation' ,'var'), ECA_adaptation  = []; end
f ~exist('case_i'         ,'var'), case_i          = []; end
f ~exist('digits'         ,'var'), digits          = []; end
f isempty(case_i)         , case_i = 1 ; end
f isempty(digits)         , digits = 6 ; end
% case i
ase_index = case_i;
CA_name   = ECA_adaptation.ECA_case_study{case_i(1)};
 list_cases = unique(ECA_adaptation.ECA_case_study);
 ECA_name   = list_cases{case_i};
 case_index = strcmp(ECA_adaptation.ECA_case_study, ECA_name);
x_flag = 0;
f strcmp(ECA_name,'Example')
   ex_flag = 1;
nd
n_flag = 0;
 if any(strcmp(ECA_name,{'Florida, US' 'Gulf Coast, US'}))
     bn_flag = 1;
 else
     bn_flag = 0;
 end
easure           = ECA_adaptation.Measure(case_index);
verted_Loss_2030 = ECA_adaptation.Averted_Loss_2030(case_index);
ostBenefit       = ECA_adaptation.CostBenefit(case_index);
enefitCost       = 1./CostBenefit;
enefitCost(isinf(BenefitCost)) = 0;
o_measures       = length(Measure);
 sort according to CostBenefit and cumulate
sort_BenefitCost, sort_index] = sort(BenefitCost,'descend');
 sort_CostBenefit  = [sort_CostBenefit; 0];
 sort_index        = [sort_index; no_measures];
 % cum_benefit       = cumsum(Averted_Loss_2030(sort_index));
um_benefit       = [0; cumsum(Averted_Loss_2030(sort_index))];
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/ECA_graphics/climada_adaptation_graph_upsidedown.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_read_risk_analysis">
<H2>climada_read_risk_analysis</H2></A>
<font color="blue">function ECA_studies = climada_read_risk_analysis(xlsfile, sheet_name) </font>
 climada
 MODULE:
   ECA_graphics
 NAME:
   climada_read_risk_analysis
 PURPOSE:
   read structure ECA_studies with ECA results from all previuous studies
   (Florida, Gulf Coast, New York, Guyana, Mali, Tanzania, India, China,
   Samoa, Hull, Bermuda, Cayman Islands, Barbados, Angtigua&ampBarbuda,
   Anguilla, St. Lucia, Jamaica and Dominica)
   includes: 
   - Waterfall graphic: today, economic growth, climate change, 
       total climate risk, percentage of all cost-effective measures, residual loss 
   - adaptation cost curve: name of measures, averted loss, cost-benefit ratio
 CALLING SEQUENCE:
   ECA_studies = climada_read_risk_analysis(xlsfile, sheet_name)
 EXAMPLE:
   ECA_studies = climada_read_risk_analysis([],'million_USD')
   ECA_studies = climada_read_risk_analysis([],'adaptation')
 INPUTS:
   sheet_name: sheet name of excel sheet to be read
 OPTIONAL INPUT PARAMETERS:
   xlsfile: file name of xls sheet
 OUTPUTS:
   structure ECA_studies with ECA results from all previuous studies
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20131024, initial
 Lea Mueller, muellele@gmail.com, 20150107, update
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/ECA_graphics/climada_read_risk_analysis.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_waterfall_graph_special">
<H2>climada_waterfall_graph_special</H2></A>
<font color="blue">function  fig = climada_waterfall_graph_special(ECA_studies, case_i, digits) </font>
 waterfall figure, expected damage for specified return period for 
 - today,
 - increase from economic growth, 
 - increase from high climate change, total expected damage 2030
 for the three EDS quoted above
 NAME:
   climada_waterfall_graph
 PURPOSE:
   plot expected damage for specific return period
 CALLING SEQUENCE:
   climada_waterfall_graph(EDS1, EDS2, EDS3, return_period,
   check_printplot)
 EXAMPLE:
   climada_waterfall_graph
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   EDS:            three event damage sets 
                   - today
                   - economic growth
                   - cc combined with economic growth, future
   return_period:  requested return period for according expected damage,or
                   annual expted damage, prompted if not given
   check_printplot:if set to 1, figure saved, default 0. 
 OUTPUTS:
   waterfall graph
 MODIFICATION HISTORY:
 Lea Mueller, 20110622
 Martin Heynen, 20120329
 David N. Bresch, david.bresch@gmail.com, 20130316 EDS-&ampgtEDS
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/ECA_graphics/climada_waterfall_graph_special.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_waterfall_graph_special_NY">
<H2>climada_waterfall_graph_special_NY</H2></A>
<font color="blue">function  fig = climada_waterfall_graph_special_NY(ECA_studies, case_i, digits) </font>
 waterfall figure, expected damage for specified return period for 
 - today,
 - increase from economic growth, 
 - increase from high climate change, total expected damage 2030
 for the three EDS quoted above
 NAME:
   climada_waterfall_graph
 PURPOSE:
   plot expected damage for specific return period
 CALLING SEQUENCE:
   climada_waterfall_graph(EDS1, EDS2, EDS3, return_period,
   check_printplot)
 EXAMPLE:
   climada_waterfall_graph
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   EDS:            three event damage sets 
                   - today
                   - economic growth
                   - cc combined with economic growth, future
   return_period:  requested return period for according expected damage,or
                   annual expted damage, prompted if not given
   check_printplot:if set to 1, figure saved, default 0. 
 OUTPUTS:
   waterfall graph
 MODIFICATION HISTORY:
 Lea MuEDler, 20110622
 Martin Heynen, 20120329
 David N. Bresch, david.bresch@gmail.com, 20130316 EDS-&ampgtEDS
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/ECA_graphics/climada_waterfall_graph_special_NY.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_waterfall_graph_special_tanzania">
<H2>climada_waterfall_graph_special_tanzania</H2></A>
<font color="blue">function  fig = climada_waterfall_graph_special_tanzania(ECA_studies, case_i, digits) </font>
 waterfall figure, expected damage for specified return period for 
 - today,
 - increase from economic growth, 
 - increase from high climate change, total expected damage 2030
 for the three EDS quoted above
 NAME:
   climada_waterfall_graph
 PURPOSE:
   plot expected damage for specific return period
 CALLING SEQUENCE:
   climada_waterfall_graph(EDS1, EDS2, EDS3, return_period,
   check_printplot)
 EXAMPLE:
   climada_waterfall_graph
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   EDS:            three event damage sets 
                   - today
                   - economic growth
                   - cc combined with economic growth, future
   return_period:  requested return period for according expected damage,or
                   annual expted damage, prompted if not given
   check_printplot:if set to 1, figure saved, default 0. 
 OUTPUTS:
   waterfall graph
 MODIFICATION HISTORY:
 Lea MuEDler, 20110622
 Martin Heynen, 20120329
 David N. Bresch, david.bresch@gmail.com, 20130316 EDS-&ampgtEDS
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/ECA_graphics/climada_waterfall_graph_special_tanzania.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="font_test">
<H2>font_test</H2></A>
 Script File: ShowFonts
 How choose a font, a size, a weight, and an angle.
lose all
A = 'HorizontalAlign';
onts = {'Times-Roman' 'Helvetica' 'AvantGarde' 'Comic Sans MS' 'Palatino'...
ZapfChancery' 'Courier' 'NewCenturySchlbk' 'Helvetica-Narrow'};
or k=1:length(fonts)
igure
xis([-20 100 -5 60])
xis off
old on
ill([-20 100 100 -20 -20],[-5 -5 60 60 -5],'w')
lot([-20 100 100 -20 -20],[-5 -5 60 60 -5],'k','Linewidth',3)
=38;
 = fonts{k};
ext(45,55,F,'color','r','FontName',F,'FontSize',24,HA,'center')
ext(10,47,'Plain','color','b','FontName',F,'FontSize',22,HA,'center')
ext(45,47,'Bold','color','b','FontName',F,'Fontweight','bold','FontSize',22,HA,'center')
ext(82,47,'Oblique','color','b','FontName',F,'FontAngle','oblique','FontSize',22,HA,'center')
or size=[22 18 14 12 11 10 9]
ext(-12,v,int2str(size),'FontName',F,'FontSize',size,HA,'center')
ext(10,v,'Matlab','FontName',F,'FontSize',size,HA,'center')
ext(45,v,'Matlab','FontName',F,'FontSize',size,HA,'center','FontWeight','bold')
ext(82,v,'Matlab','FontName',F,'FontSize',size,HA,'center','FontAngle','oblique')
 = v-6;
nd
old off
ause(1)
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/ECA_graphics/font_test.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="isassets">
<H2>isassets</H2></A>
<font color="blue">function ok = isassets(assets) </font>
 check if valid assets struct
 MODULE:
   core
 NAME:
   isassets
 PURPOSE:
   For quick arg checking, defining and standardising assets structs to have the
   minimum required fields
 PREVIOUS STEP:
 CALLING SEQUENCE:
   ok = isassets(assets)
 EXAMPLE:
   ok = isassets(assets)
 INPUTS:
   assets:     any struct
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   ok:         1 if input satisfies the conditions to be an assets struct
               0 otherwise
 MODIFICATION HISTORY:
   Gilles Stassen, gillesstassen@hotmail.com, 20150826 init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/argument_checks/isassets.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="iscentroids">
<H2>iscentroids</H2></A>
<font color="blue">function ok = iscentroids(centroids) </font>
 check if valid centroids struct
 MODULE:
   core
 NAME:
   iscentroids
 PURPOSE:
   For quick arg checking, defining and standardising centroids structs to have the
   minimum required fields
 PREVIOUS STEP:
 CALLING SEQUENCE:
   ok = iscentroids(centroids)
 EXAMPLE:
   ok = iscentroids(centroids)
 INPUTS:
   centroids:     any struct
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   ok:         1 if input satisfies the conditions to be an centroids struct
               0 otherwise
 MODIFICATION HISTORY:
   Gilles Stassen, gillesstassen@hotmail.com, 20150826 init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/argument_checks/iscentroids.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="isdamagefunctions">
<H2>isdamagefunctions</H2></A>
<font color="blue">function ok = isdamagefunctions(damagefunctions) </font>
 check if valid damagefunctions struct
 MODULE:
   core
 NAME:
   isdamagefunctions
 PURPOSE:
   For quick arg checking, defining and standardising damagefunctions 
   structs to have the minimum required fields.
 PREVIOUS STEP:
 CALLING SEQUENCE:
   ok = isdamagefunctions(damagefunctions)
 EXAMPLE:
   ok = isdamagefunctions(damagefunctions)
 INPUTS:
   damagefunctions:     any struct
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   ok:         1 if input satisfies the conditions to be an entity struct
               0 otherwise
 MODIFICATION HISTORY:
   Gilles Stassen, gillesstassen@hotmail.com, 20150826 init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/argument_checks/isdamagefunctions.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="isentity">
<H2>isentity</H2></A>
<font color="blue">function ok = isentity(entity) </font>
 check if valid entity struct
 MODULE:
   core
 NAME:
   isentity
 PURPOSE:
   For quick arg checking, defining and standardising entity structs to have the
   minimum required fields. For the entity, .assets and .damagefunctions
   are required, function gives warning if entity doesn't contain
   .measures or .discount fields, but still returns 1. Function calls
   isassets and isdamagefunctions
 PREVIOUS STEP:
 CALLING SEQUENCE:
   ok = isentity(entity)
 EXAMPLE:
   ok = isentity(entity)
 INPUTS:
   entity:     any struct
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   ok:         1 if input satisfies the conditions to be an entity struct
               0 otherwise
 MODIFICATION HISTORY:
   Gilles Stassen, gillesstassen@hotmail.com, 20150826 init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/argument_checks/isentity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="ishazard">
<H2>ishazard</H2></A>
<font color="blue">function ok = ishazard(hazard) </font>
 check if valid hazard struct
 MODULE:
   core
 NAME:
   ishazard
 PURPOSE:
   For quick arg checking, defining and standardising hazard structs to have the
   minimum required fields.
 PREVIOUS STEP:
 CALLING SEQUENCE:
   ok = ishazard(hazard)
 EXAMPLE:
   ok = ishazard(hazard)
 INPUTS:
   hazard:     any struct to be checked
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   ok:         1 if input satisfies the conditions to be a hazard struct
               0 otherwise
 MODIFICATION HISTORY:
   Gilles Stassen, gillesstassen@hotmail.com, 20150826 init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/advanced/code/argument_checks/ishazard.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_ED_find_most_vulnerable">
<H2>barisal_ED_find_most_vulnerable</H2></A>
<font color="blue">function entity = barisal_ED_find_most_vulnerable(entity, EDS, criterion_A, criterion_B) </font>
% compare AED with income
 set to small income numbers to zero
ntity.assets.income(entity.assets.income&amplt1) = 0;
 calculate relative AED, relative to income
ED_rel = EDS(1).ED_at_centroid(:) ./entity.assets.income(:) ;
 AED_rel = measures_impact3(1).EDS(1).ED_at_centroid(:) ./entity.assets.income(:) ;
ED_rel(isinf(AED_rel)) = 0;
ED_rel(isnan(AED_rel)) = 0;
 find top-most relative AEDs
 Y = prctile(AED_rel,75) 
AED_sort AED_sort_indx] = sort(AED_rel,'descend');
 number of centroids with residential categories
_residential = 6*7753;
 find most vulnerable buildings
riterion_absolute_A      = int64(criterion_A*n_residential);
riterion_absolute_B      = int64(criterion_B*n_residential);
ndx_most_vuln_building_A = AED_sort_indx(1:criterion_absolute_A);
ndx_most_vuln_building_B = AED_sort_indx(1:criterion_absolute_B);
 index with centroids that point to the most vulnerable residential buildings
ndx_all = 1:numel(entity.assets.lon);
ndx_most_vuln_building_A = ismember(indx_all, indx_most_vuln_building_A);
ndx_most_vuln_building_B = ismember(indx_all, indx_most_vuln_building_B);
 sum(indx_most_vuln_building)
 load resilient_buildings_zone_B
arisal_data_dir= [fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
oad([barisal_data_dir filesep 'entities' filesep 'Measures_package' filesep 'resilient_buildings_zones_B.mat'])
 find lat/lon in zone B
ndx_zone_B = inpoly([entity.assets.lon entity.assets.lat],[resilient_buildings_zone_B.lon' resilient_buildings_zone_B.lat']);
 create vector with 
     - zeros (not most vulnerable)
     - A (most vulnerable buildings in zone A) and 
     - B (most vulnerable buildings in zone B)
ost_vuln_zone_B   = logical(indx_most_vuln_building_B .* indx_zone_B');
ost_vuln_zone_A   = logical(indx_most_vuln_building_A .* ~indx_zone_B');
ost_vuln_building = cell(size(entity.assets.lon));
ost_vuln_building(most_vuln_zone_A) = repmat({'A'},sum(most_vuln_zone_A),1);
ost_vuln_building(most_vuln_zone_B) = repmat({'B'},sum(most_vuln_zone_B),1);
ntity.assets.most_vuln_building     = most_vuln_building;
limada_figuresize(0.4,0.4)
lot(entity.assets.lon(most_vuln_zone_A), entity.assets.lat(most_vuln_zone_A),'or','markersize',2)
old on
lot(entity.assets.lon(most_vuln_zone_B), entity.assets.lat(most_vuln_zone_B),'ob','markersize',2)
itle(sprintf('%d%% most vulnerable res. buildings in Zone A (red) and %d%% in Zone B (blue)',criterion_A*100,criterion_B*100),'fontsize',10)
xis equal
% extend to other buildings
 % unique asset categories
 [categories_uni ia ic] = unique(entity.assets.Category);
 residential categories that we have income information for
ategories_residential = {'Residential_buildings_Pucca_ASSETS'...
                         'Residential_buildings_Semi_Pucca_ASSETS'...
                         'Residential_buildings_Katcha_ASSETS'...
                         'Residential_buildings_Pucca_ASSETS_30_cm_elevation_'...
                         'Residential_buildings_Semi_Pucca_ASSETS_30_cm_elevation_'};
ore_building_categories = {'Commercial' 'industry' 'public'};
 loop over construction types
or c_i = 1:numel(categories_residential)
   
   indx = strcmp(entity.assets.Category, categories_residential{c_i});
   %sum(indx)
   
   % loop over building categories
   for c_ii = 1:numel(more_building_categories)
       category_name = strrep(categories_residential{c_i},'Residential',more_building_categories{c_ii});
       indx_2        = strcmp(entity.assets.Category, category_name);
       %sum(indx_2)
       entity.assets.most_vuln_building(indx_2) = entity.assets.most_vuln_building(indx);
   end
nd
                         
 climada_figuresize(0.4,0.4)
 indxA = strcmp(entity.assets.most_vuln_building,'B') &amp strcmp(entity.assets.Category, 'public_buildings_Pucca_ASSETS')';
 plot(entity.assets.lon(indxA), entity.assets.lat(indxA),'or','markersize',2)
 hold on
 plot(entity.assets.lon(strcmp(entity.assets.most_vuln_building,'B')), entity.assets.lat(strcmp(entity.assets.most_vuln_building,'B')),'ob','markersize',2)
 title(sprintf('%d%% most vulnerable res. buildings in Zone A (red) and B (blue)',criterion*100),'fontsize',10)
 axis equal
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_ED_find_most_vulnerable.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_MI_per_peril">
<H2>barisal_MI_per_peril</H2></A>
<font color="blue">function barisal_MI_per_peril(measures_impact5,measures,peril_IDs) </font>
 climada barisal demo
 NAME:
   barisal_EDS_DFC, special version for BARISAL
 PURPOSE:
   create xls-report for measures impact per peril (and overall effectiveness 
   of measures)

View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_MI_per_peril.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_adaptation_bar_chart">
<H2>barisal_adaptation_bar_chart</H2></A>
 barisal measures adaptation bar chart
 ------------------------------------
 create adaptation bar chart based on measures information from table 5.3
 from Vulnerability Analysis Report
 ------------------------------------
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_adaptation_bar_chart from climada_adaptation_bar_chart_v2
 set directory
arisal_data_dir= [fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
esults_dir     = [barisal_data_dir filesep 'results' filesep '20150916_new_runs'];
eturn
 read input from excel (table 5.3)
xcel_file = [climada_global.project_dir filesep 'results' filesep '20150916_new_runs' filesep 'measures' filesep 'measures_impact.xlsx'];
easures = climada_xlsread(0,excel_file,'measures',0);
 create measures_impact structure and set values according to xls-input
 today (cost capex+opex, benefit 2015)
easures_impact.Value_unit = 'Tk. Crore';
easures_impact.title_str = 'Benefit 2015';
 measures_impact.NPV_total_climate_risk = 100;
easures_impact.NPV_total_climate_risk = 90;
easures_impact.benefit = measures.benefit_2015;
easures_impact.cb_ratio = 1./measures.bc_ratio;
easures_impact.measures.name = measures.name;
easures_impact.measures.cost = measures.cost_capex_opex;
 reference (cost capex benefit 2050)
 measures_impact_reference = measures_impact;
 measures_impact_reference.benefit = measures.benefit_2050;
 measures_impact_reference.measures.cost = measures.cost_capex;
easures_impact(2) = measures_impact;
easures_impact(2).benefit = measures.benefit_2050;
easures_impact(2).measures.cost = measures.cost_capex;
easures_impact(2).title_str = 'Benefit 2050';
ave([results_dir filesep 'measures' filesep 'measures_impact_BDT'],'measures_impact');
 create adaptation bar chart
enefit_str = 'Risk reduction in AED (%)';
cale_benefit = 2.5;
cr_off = 1;
ort_benefit = 1;
ig = climada_adaptation_bar_chart(measures_impact,sort_benefit,scale_benefit,benefit_str,'south',tcr_off);
rint(fig,'-dpdf',[results_dir filesep sprintf('Barisal_measures_proposal.pdf')]);
   
 sort_benefit = 0;
 fig = climada_adaptation_bar_chart(measures_impact,measures_impact_reference,sort_benefit,'',sort_benefit,scale_benefit,benefit_str,'east',tcr_off);
 print(fig,'-dpdf',[results_dir filesep sprintf('Barisal_measures_proposal_sorted.pdf')]);
 sort_benefit = 0;
 fig = climada_adaptation_bar_chart(measures_impact,measures_impact_reference,sort_benefit,'',sort_benefit,scale_benefit,benefit_str,'east',tcr_off);
 print(fig,'-dpdf',[results_dir filesep sprintf('Barisal_measures_proposal_sorted.pdf')]);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_adaptation_bar_chart.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_adaptation_cost_curve">
<H2>barisal_adaptation_cost_curve</H2></A>
<font color="blue">function [insurance_benefit,insurance_cost]=barisal_adaptation_cost_curve(measures_impact, measures_impact_comparison,x_text_control,y_text_control,scaled_AED,nice_numbers,reverse_cb,plot_arrows) </font>
 climada measures impact climate adaptation cost curve
 NAME:
   climada_adaptation_cost_curve
 PURPOSE:
   plot adaptation cost curve
   see also: climada_adaptation_event_view

   NOTE: The mode with output arguments insurance_benefit and
   insurance_cost is only used when called from climada_demo (the flag
   called_from_climada_demo), no relevance for standard use .
 CALLING SEQUENCE:
   climada_adaptation_cost_curve(measures_impact,measures_impact_comparison)
 EXAMPLE:
   climada_adaptation_cost_curve(climada_measures_impact(climada_entity_read)) % from scratch
   climada_adaptation_cost_curve(climada_measures_impact,climada_measures_impact) % one needs to really understand what's going on
   climada_adaptation_cost_curve('','','','',0,0,1) % inverted c/b
 INPUTS:
   measures_impact: either a struct containing the impacts of measures or a measures_impact file (.mat with a struct)
       see climada_measures_impact
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   measures_impact_comparison: same as measures_impact, but for comparison
       (will be shown in overlay). Not prompted for, so please specify in
       call, or enter 'ASK' in climada_adaptation_cost_curve('','ASK')
   x_text_control: controls the horizontal distribution of the text labels
       (divider of the length of the x-axis, default=20)
   y_text_control: controls the vertical distribution of the text labels
       (divider of the length of the y-axis, default=50)
   scaled_AED: scaled annual expected damage (only used by Lea Mueller),
       default=0 (inactive)
   nice_numbers: used in the special mode for the climada_play_gui, where
       this code is called from climada_play_adapt_cost_curve,
       default=0 (inactive)
   reverse_cb: reverse the vertical axis (=1), instead of cost/benefit,
       show benefit per cost, default=0
   plot_arrows: whether we do (=1) or don't (=0, default) plot arrows
   underneath the x-axis to show cost-effective measures and
   non-cost-effective measures extent.
 OUTPUTS:
   insurance_benefit and insurance_cost: only used when called from
       climada_play_adapt_cost_curve, see there (in essence to write
       insurance cost on the GUI)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091228
 David N. Bresch, david.bresch@gmail.com, 20091230 major revision, appreance similar to ECA graphs
 David N. Bresch, david.bresch@gmail.com, 20130316 EDS-&ampgtEDS
 David N. Bresch, david.bresch@gmail.com, 20130316 compatibility for both direct call as well as via climada_demo_gui
 Gilles Stassen gillesstassen@hotmail.com 20141212 fixed the arrow issue; changed labeling of total climate risk to BDT x m rounded to 2 s.f.
 David N. Bresch, david.bresch@gmail.com, 20141213 plot_arrows=0 by default and climada_demo option cleaned up
 David N. Bresch, david.bresch@gmail.com, 20141231 subaxis removed (not clean, troubles in Octave)
 Lea Mueller, muellele@gmail.com, 20150617, set to bc_ratio (benefits per cost) instead of cb_ratio
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_adaptation_cost_curve.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_entity_pre_process">
<H2>barisal_entity_pre_process</H2></A>
<font color="blue">function entity = barisal_entity_pre_process(entity_in) </font>
 barisal_entity_pre_process
 MODULE:
   barisal_demo
 NAME:
   barisal_entity_pre_process
 PURPOSE:
   Pre process entity into climada entity format from input as provided
   by Barisal/Ecorys team, where assetinformation is in a matrix 
   (lon, lat, Ward Nr, and two columns for every category (one with 
   category name ASSETS and second with category name DAMAGE FUNCTION).
   check that column headers have unique names, otherwise data is lost.
 CALLING SEQUENCE:
   entity = barisal_entity_pre_process(entity_in)
 EXAMPLE:
   entity = barisal_entity_pre_process(entity_in)
 INPUTS:
   entity_in: entity as read from Ecorys input in matrix format
       climada_xlsread('no',ecorys_entity_file_xls,'Floods_2014',1);
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   entity: a climada entity structure
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150909, add documentation
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_entity_pre_process.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_entity_pre_process_income">
<H2>barisal_entity_pre_process_income</H2></A>
<font color="blue">function entity = barisal_entity_pre_process_income(entity) </font>
% create income column in entity.assets structure, so that the income 
 corresponds to the residential buildings
 - 4 different income figures for Juphri, Katcha, Pucca and Semi-Pucca houses
 - Pucca and Semi-Pucca house values are distributed to normal and +30cm houses, 
   whereas we need to assign the income value relative to the portion of normal or +30cm houses
 unique asset categories
ategories_uni = unique(entity.assets.Category);
 residential categories that we have income information for
ategories_residential = {'buildings_Juphri' 'buildings_Katcha' 'buildings_Pucca' 'buildings_Semi_Pucca'};
 income field names
lds_names_income = {'Income_of_juphri_residents' 'Income_of_katcha_residents' 'Income_of_semipucca_residents' 'Income_of_pucca_residents'};
 all categories that contain residential categories
ndx_residential = strfind(categories_uni,'Residential');
ndx_residential = find(~cellfun(@isempty,indx_residential));
 all categories that are part of the +30 cm category
ndx_30 = strfind(categories_uni,'30');
ndx_30 = find(~cellfun(@isempty,indx_30));
 find asset categories where we have income information for
or c_i = 1:numel(categories_residential)
   indx  = strfind(categories_uni,categories_residential{c_i});
   indx  = find(~cellfun(@isempty,indx));
   indx  = indx(ismember(indx, indx_residential));  
   %indx  = indx(~ismember(indx, indx_30));  
   %fprintf('%s, %s\n',categories_residential{c_i},categories_uni{indx});
   income2category_indx{c_i} = indx;
nd
 init income vector
ntity.assets.income = zeros(size(entity.assets.lon));
or c_i = 1:numel(categories_residential)
   
   Value_temp = [];
   % find all values that belong to this income information
   indx = income2category_indx{c_i};
   for ii = 1:numel(indx)
       assets_indx = strcmp(entity.assets.Category,categories_uni{indx(ii)});
       Value_temp(:,ii) = entity.assets.Value(assets_indx);
   end
   % add up all values for this income information (e.g. residential pucca &amp residential pucca +30cm)
   Value_temp_tot = sum(Value_temp,2);
   
   % assign income value relative to building values (portion)
   for ii = 1:numel(indx)
       assets_indx = strcmp(entity.assets.Category,categories_uni{indx(ii)});
       portion = Value_temp(:,ii)./Value_temp_tot;
       portion(isnan(portion)) = 0;
       entity.assets.income(assets_indx) = entity.assets.(flds_names_income{c_i})(1:sum(assets_indx)) .*portion;
   end
   
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_entity_pre_process_income.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_get_EDS">
<H2>barisal_get_EDS</H2></A>
<font color="blue">function [EDS, eds_i] = barisal_get_EDS(EDS,entity_file,hazard_file) </font>
or eds_i =1:length(EDS)
   if strcmp(EDS(eds_i).assets.filename,entity_file) ...
           &amp&amp strcmp(EDS(eds_i).hazard.filename,hazard_file)
       EDS = EDS(eds_i);
       return
   end
nd
printf('ERROR: EDS not found\n')
DS = []; eds_i = [];
eturn
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_get_EDS.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_get_entity">
<H2>barisal_get_entity</H2></A>
<font color="blue">function [entity, e_i] = barisal_get_entity(reference_year,peril,entity_files,eco_scen) </font>
 barisal_get_entity
 MODULE:
   barisal_demo
 NAME:
   barisal_get_entity
 PURPOSE:
   Get/load entity for barisal, based on exisiting mat-files that are
   saved in barisal_demo/data/entities/....mat as specified in entiy_files
 CALLING SEQUENCE:
   [entity, e_i] = barisal_get_entity(reference_year,peril,entity_files,eco_scen)
 EXAMPLE:
   entity = barisal_get_entity(2014,'cyclones',entity_files,'scenario 1')
 INPUTS:
   reference_year: 2014, 2030 or 2050
   peril: 'cyclones' or 'floods'
   entity_files: a cell with all the existing entity-mat files e.g. 
        entity_files{1} = '...barisal_demo\data\entities\Assets_at_risk_100x100_09092015 Baseline scenario 1_cyclones_2014.mat';
        entity_files{2} = '...barisal_demo\data\entities\Assets_at_risk_100x100_09092015 Baseline scenario 1_cyclones_2030.mat';
   eco_scen: 'scenario 1', or 'scenario 2', or 'scenario 3'
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   entity: a climada entity structure, loaded
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150909, add documentation
 Lea Mueller, muellele@gmail.com, 20150910, load entity 2014 scenario 1 to copy damagefunctions and discount
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_get_entity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_get_hazard">
<H2>barisal_get_hazard</H2></A>
<font color="blue">function [hazard, h_i] = barisal_get_hazard(reference_year,cc,peril_ID,hazard_files) </font>
f iscell(peril_ID), peril_ID = char(peril_ID); end
f iscell(cc),       cc       = char(cc);       end
or h_i = 1:length(hazard_files)
   if isempty(strfind(hazard_files{h_i},num2str(reference_year)))
       continue
   end
   if ~isempty(cc) &amp&amp isempty(strfind(hazard_files{h_i},cc))
       continue
   end
   if ~isempty(strfind(hazard_files{h_i},peril_ID))
       load(hazard_files{h_i})
       return;
   end
nd
printf('ERROR: specified hazard not found\n')
azard = []; h_i = [];
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_get_hazard.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_measure_zones">
<H2>barisal_measure_zones</H2></A>
ilename = 'M:\BGCC\CHR\RK\RS\A_Sustainable_Development\Projects\ECA\BarisalBangladesh\risk_modelling\4_measures\adaptation_strategy\Measure_zone.shp';
ones = shaperead(filename);
 figure
 climada_shapeplotter(zones,'Zones_code')
igure
ill(zones(1).X(~isnan(zones(1).X)),zones(1).Y(~isnan(zones(1).X)),'-b')
old on
ill(zones(2).X(~isnan(zones(2).X)),zones(2).Y(~isnan(zones(2).X)),'-c')
ill(zones(3).X(~isnan(zones(3).X)),zones(3).Y(~isnan(zones(3).X)),'-g')
ill(zones(4).X(~isnan(zones(4).X)),zones(4).Y(~isnan(zones(4).X)),'-r')
or s = 1:4
   text(mean(zones(s).X(~isnan(zones(s).X))),mean(zones(s).Y(~isnan(zones(s).X))),int2str(s),'fontsize',14)
nd
xis equal
esilient_buildings_zone_B.X = zones(1).X(~isnan(zones(1).X));
esilient_buildings_zone_B.Y = zones(1).Y(~isnan(zones(1).Y));
resilient_buildings_zone_B.lon resilient_buildings_zone_B.lat] = utm2ll_shift(resilient_buildings_zone_B.X, resilient_buildings_zone_B.Y);
igure
ill(resilient_buildings_zone_B.X, resilient_buildings_zone_B.Y ,'-b')
igure
ill(resilient_buildings_zone_B.lon, resilient_buildings_zone_B.lat ,'-b')
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_measure_zones.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_plot_adaptation_cost_curve">
<H2>barisal_plot_adaptation_cost_curve</H2></A>
 plot selection of measures impact for barisal
 Lea Mueller, 20160531, for ECA publication Barisal
easures_filename = [climada_global.data_dir filesep 'results' filesep 'measures_impact_barisal.xlsx'];
measures, measures_impact] = climada_measures_read(measures_filename);
easures_impact.color_keep = 1;
ig = climada_figuresize(0.4,0.95);
limada_adaptation_cost_curve(measures_impact)
rint(fig,'-dpdf',[climada_global.data_dir filesep 'results' filesep 'adaptation_cost_curve_barisal.pdf'])
 climada_adaptation_cost_curve(measures_impact,'','','','','','',1)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_plot_adaptation_cost_curve.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_risk_calculations">
<H2>barisal_risk_calculations</H2></A>
% Barisal Risk Calculations
 Lea Mueller, muellele@gmail.com, 20150906, baseline run for scenarios 1, 2, 3
 Lea Mueller, muellele@gmail.com, 20151117, project package run for scenario 1 based on a 
           - new assets (location, values and damage function change)
           - reduced hazard (FL depth monsoon, FL duration mosoon, FL depth cyclone, FL duration cyclone)
           - land raising by 0.3 m(hazard_intensity_impact_b = -0.3)
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
lc
limada_global.waitbar = 0;
limada_global.EDS_at_centroid = 0;
% Directories
arisal_data_dir = climada_global.data_dir;
 barisal_data_dir= [fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
ntities_dir    = [barisal_data_dir filesep 'entities'];
azards_dir     = [barisal_data_dir filesep 'hazards'];
esults_dir     = [barisal_data_dir filesep 'results' filesep '20151116_measure_project_package'];
 results_dir     = [barisal_data_dir filesep 'results' filesep '20150909_new_runs'];
 results_dir     = [barisal_data_dir filesep 'results'];
% load barisal specifics
CC_border_file = [entities_dir filesep 'BCC_border.mat'];
oad(BCC_border_file)
 load BCC ward boundaries (35 polygons)
CC_wards_file = [entities_dir filesep 'BCC_wards_number_added.mat'];
oad(BCC_wards_file)
CC_wards_ll     = BCC_wards;
BCC_wards_ll.x] = BCC_wards_ll.X;      BCC_wards_ll = rmfield(BCC_wards_ll,'X');
BCC_wards_ll.y] = BCC_wards_ll.Y;      BCC_wards_ll = rmfield(BCC_wards_ll,'Y');
BCC_wards_ll.X] = BCC_wards_ll.lon;    BCC_wards_ll = rmfield(BCC_wards_ll,'lon');
BCC_wards_ll.Y] = BCC_wards_ll.lat;    BCC_wards_ll = rmfield(BCC_wards_ll,'lat');
limada_admin_name('Bangladesh','Barisal S.',4,1);
lear BCC_border_file BCC_wards_file
% hazard file name
 This section stores the filenames of all the relevant hazards in a cell
 array for easy retrieval later (using barisal_get_hazard)
 Step 1: call barisal_hazard_read to read Witteveen &amp Bos hazard asci
 files and save resulting hazard structs as .mat files in the climada_GIT
 barisal_demo module data directory.
orce_hazard_asci_read = 0;
f force_hazard_asci_read
   barisal_hazard_read
nd
 Step 2: construct a cell array with all the hazard file names
azard_file_tmp = 'Barisal_BCC_hazard_PIDSPEC_CCSCEN.mat';
 loop over climate change scenarios
CSCEN  = {'2014' 'cc_2030_moderate' 'cc_2030_extreme' 'cc_2050_moderate' 'cc_2050_extreme'};
 loop over hazard perils
ID = {'TC' 'FL_depth_cyclone' 'FL_depth_monsoon' 'FL_duration_cyclone' 'FL_duration_monsoon'};
PEC= {'' }; %'_rain_only'};
ile_i = 0; hazard_files = {};
or cc = CCSCEN
   for pid = PID
       for spec = SPEC
           hazard_file = hazard_file_tmp;
           hazard_file = strrep(hazard_file,'PID',char(pid));
           hazard_file = strrep(hazard_file,'SPEC',char(spec));
           hazard_file = strrep(hazard_file,'CCSCEN',char(cc));
           if exist([hazards_dir filesep hazard_file],'file')
               file_i = file_i+1;
               hazard_files{file_i} = [hazards_dir filesep hazard_file];
               load(hazard_files{file_i})
               % ensure peril ID is correct
               if ~isempty(strfind(hazard_file,'duration'))
                   hazard.peril_ID = 'FL_';
               end
               % consistency in hazard.comment
               if strcmp(hazard.peril_ID,'TC')
                   % hazard.comment = strrep(strrep(hazard_file,'_',' '),'.mat','');
                   hazard.comment = ['TC wind speed ' strrep(char(cc),'_',' ')];
                   fprintf('%s\n',hazard.comment)
               else
                   hazard.comment = strrep([char(pid) ' ' char(cc) ', modelled by W+B'],'_',' ');
                   fprintf('%s\n',hazard.comment)
               end
               
               % datenum for monsoon hazard events
               if ~isempty(strfind(pid,'monsoon'))
                   hazard.yyyy     = [1:length(hazard.yyyy)]+1982;
                   hazard.datenum  = datenum(hazard.yyyy,hazard.mm,hazard.dd);
               end
               
               % consistency in hazard.filename
               hazard.filename = hazard_files{file_i};
               % save corrected hazard
               save(hazard.filename,'hazard')
           end
       end
   end
nd
lear cc CCSCEN pid PID spec SPEC file_i hazard_file_tmp hazard_file force_hazard_asci_read
eturn 
% entity
 This section constructs a cell array with entity file names for easy
 retrieval later with barisal_get_entity
 Entity excel file from Ecorys (unstructured)
 entity_file_xls = [entities_dir filesep 'BCC_entity_260615_se_1.xls'];
 entity_file_xls = [entities_dir filesep 'Asset Entity CLIMADA - Effect Project Package 07072015.xls'];
 run 20151116 measure project package
ntity_file_xls{1} = [entities_dir filesep '20151116_measure_project_package' filesep 'Assets_at_risk_100x100_16112015 Final FS Project package - scenario 1.xlsx'];
 run 20150909 baseline
 entity_file_xls{1} = [entities_dir filesep '20150909_new_runs' filesep 'Assets_at_risk_100x100_09092015 Baseline scenario 1.xlsx'];
 entity_file_xls{2} = [entities_dir filesep '20150909_new_runs' filesep 'Assets_at_risk_100x100_09092015 Baseline scenario 2.xlsx'];
 entity_file_xls{3} = [entities_dir filesep '20150909_new_runs' filesep 'Assets_at_risk_100x100_09092015 Baseline scenario 3.xlsx'];
 % Different entities for the adaptation measures
 % entity_file_xls = [entities_dir filesep 'Measure_spatial_planning_290615_se_1.xls'];
 % entity_file_xls = [entities_dir filesep 'Measure_early_warning_system_290615_se_1.xls'];
 % entity_file_xls = [entities_dir filesep 'Measure_Flood_proof_road_infrastructure_290615_se_1.xls'];
 entity_file_xls = [entities_dir filesep 'Measure_package_070715_se_1.xls'];
 Damage function file from Ecorys
amfun_file_xls = [entities_dir filesep 'BCC_dmg_functions_260615.xls'];
 Entity template file from global data dir
ntity_temp_xls = [climada_global.data_dir filesep 'entities' filesep 'entity_template.xls'];
 Sheet names in Ecorys entity xls file
heets          = {'Floods_2014' 'Floods_2030' 'Floods_2050' 'Cyclones_2014' 'Cyclones_2030' 'Cyclones_2050'};
 sheets          = {'2014' '2030' '2050'}; % for population entity
 Whether to re-read entity/damagefunctions from Ecorys xls (1) or load matfiles (0)
orce_assets_re_read   = 0;
orce_damfun_re_read   = 0;
dd_measures = 1;
ounter = 0;
 counter = 6;
or scenario_eco_i = 1:numel(entity_file_xls)
   for s_i = 1:length(sheets)
       clear entity
       % mat file name - separate mat file for each sheet in Ecorys entity xls
       entity_file_mat     = strrep(entity_file_xls{scenario_eco_i},'.xlsx',['_' lower(sheets{s_i}) '.mat']);
       counter = counter+1;
       
       if exist(entity_file_mat,'file') &amp&amp ~force_assets_re_read
           % Load mat file
           [~,fN] = fileparts(entity_file_mat);
           fprintf('entity %s already exists, skipping\n',fN)
           entity_files{counter} = entity_file_mat;
   %         load(entity_file_mat)
   %         % append filename for consistency
   %         entity.assets.filename = entity_file_mat;
   % 
   %         % get reference year, comment from sheet name
   %         [~,yr_]                         = strtok(sheets{s_i},'_');
   %         entity.assets.reference_year    = str2num(yr_(2:end));
   % 
   %         % add income information to entity.assets for residential categories only
   %         entity = barisal_entity_pre_process_income(entity);
   %         
   %         % find top-most vulnerable buildings -- load specific EDS before
   %         switch entity.assets.reference_year
   %             case 2030,  criterion_A = 0.25;     criterion_B = 0.10;
   %             case 2050,  criterion_A = 0.50;     criterion_B = 0.15;
   %             otherwise, continue;
   %         end
   %         load([entities_dir filesep 'ED_at_centroid_baseline.mat'])
   %         entity    = barisal_ED_find_most_vulnerable(entity, EDS_FL, criterion_A,criterion_B);
   % 
   %         % save corrected entity
   %         save(entity.assets.filename,'entity')
   % ==================
   % This section for looking at slum houses only. Be careful when
   % uncommenting!
   % ==================
   %         entity.assets.Value(~(strcmp(entity.assets.Category,'Residential_buildings_Juphri_ASSETS')...
   %             | strcmp(entity.assets.Category,'Residential_buildings_Katcha_ASSETS')))=0;
   %
   %         figure; hold on
   %         climada_entity_plot(entity,5,'BDT',0);
   %         box on
   %         climada_shapeplotter(BCC_wards_ll,'','linewidth',1,'color',[81 81 81]/255);
   %         axis([min(entity.assets.lon)-0.01 max(entity.assets.lon)+0.01 min(entity.assets.lat)-0.01 max(entity.assets.lat)+0.01])
   %
   %         entity_file_mat = strrep(entity_file_mat,'.mat','_slums.mat');
   %         [~,fN] = fileparts(entity_file_mat);
   %         print(gcf,'-dpng',[results_dir filesep fN '.png'])
   %         clear fN
   %         close
   %====================
       else
           force_damfun_re_read = 1; % since file does not yet exist
           % read in entity from Ecorys xls
           % assets
           entity.assets = climada_xlsread('no',entity_file_xls{scenario_eco_i},sheets{s_i},1);
           % restructure into climada entity format (not necessary for
           % population entity)
           entity        = barisal_entity_pre_process(entity);
           % remove NaN entries in assets uniformly from all fields
           nan_ndx = isnan(entity.assets.Ward_Nr);
           flds = fieldnames(entity.assets);
           for fld_i = 1:length(flds)
               if (iscell(entity.assets.(flds{fld_i})) || isnumeric(entity.assets.(flds{fld_i}))) ...
                       &amp&amp length(entity.assets.(flds{fld_i}))==length(nan_ndx)
                   entity.assets.(flds{fld_i})(nan_ndx) = [];
               end
           end
           entity.assets.Value(isnan(entity.assets.Value)) = 0;
           % set negative asset values to 0
           fprintf('setting %d negative asset values to zero\n',sum(entity.assets.Value&amplt0))
           entity.assets.Value(entity.assets.Value&amplt0) = 0;
           % set deductible &amp cover
           fprintf('setting deductible and cover\n')
           entity.assets.Deductible    = entity.assets.Value .* 0;
           entity.assets.Cover         = entity.assets.Value;
           % add income information to entity.assets for residential categories only
           %entity = barisal_entity_pre_process_income(entity);
           % find top-most vulnerable buildings -- load specific EDS before
           %criterion = 0.050;
           %entity    = barisal_ED_find_most_vulnerable(entity, EDS, criterion);
           % coord transformation from UTM to lat lon
           [entity.assets.lon, entity.assets.lat] = utm2ll_shift(entity.assets.lon, entity.assets.lat);
           % get reference year, comment from sheet name
           [region,yr_]                    = strtok(sheets{s_i},'_');
           entity.assets.reference_year    = str2num(yr_(2:end));
           entity.assets.comment           = strrep(sheets{s_i},'_',' ');
           entity.assets.filename          = entity_file_mat;
           entity.assets.region            = sprintf('Barisal, Scenario %d',scenario_eco_i);
           fprintf('saving entity as %s\n',entity.assets.filename)
           save(entity.assets.filename,'entity')
           entity_files{counter} = entity.assets.filename; % for filename consistency
       end
       if force_damfun_re_read
           fprintf('adding damage functions from %s\n',damfun_file_xls)
           load(entity_file_mat)
           
           %add region
           [region,yr_]                    = strtok(sheets{s_i},'_');
           entity.assets.region            = sprintf('Barisal assets exposed to %s',lower(region));
           
           % damagefunctions from Ecorys xls
           entity.damagefunctions          = climada_xlsread(0,damfun_file_xls,'formatted',1);
           % find TC damfuns
           tc_ndx                          = strcmp(entity.damagefunctions.peril_ID,'TC');
           % widnspeed conversion from km/h to m/s
           entity.damagefunctions.Intensity(tc_ndx) = entity.damagefunctions.Intensity(tc_ndx)./3.6;
           entity.damagefunctions.units    (tc_ndx) = {'m/s'};
           % need MDD and PAA for EDS_calc, not given in Ecorys entity, so
           % take sqrt of MDR instead.
           entity.damagefunctions.MDD = sqrt(entity.damagefunctions.MDR);
           entity.damagefunctions.PAA = sqrt(entity.damagefunctions.MDR);
           % discount
           entity.discount          = climada_xlsread(0,entity_temp_xls,'discount',1);
           fprintf('saving entity as %s\n',entity.assets.filename)
           entity_files{counter} = entity.assets.filename;
           save(entity.assets.filename,'entity')
       end
       
       if add_measures
           fprintf('adding measures\n')
           load(entity_file_mat)
           load([entities_dir filesep '20151116_measure_project_package' filesep 'measures_project_package.mat'])
           entity.measures = measures;
           
           % add assets specifics
           entity.assets.filename = entity_file_mat;
           entity.assets.region   = sprintf('Barisal, Scenario %d',scenario_eco_i);
           entity.assets = climada_assets_category_ID(entity.assets); % add .Category_name and .Category_ID
           if isfield(entity.assets,'X')
               entity.assets = rmfield(entity.assets,'X');
               entity.assets = rmfield(entity.assets,'Y');
           end
           save(entity.assets.filename,'entity')
       end
       
   end %sheets
nd % scenario_eco_i
lear entity_file_xls sheets ul_loc s_i tc_ndx damfun_file_xls entity_temp_xls fN yr_
lear fld_i flds nan_ndx entity_file_mat force_damfun_re_read force_assets_re_read asci_file
% create measures to represent project package (20151117)
 create four measures
  1. reduced FL depth due to a package of measures
  2. regional scope of land raising on top of reduced FL depth, read regional scope from excel file, given from Ecorys  
  3. reduced FL duration due to a package of measures
  4. TC with no measures so that it runs through the calculation nontheless
ntity_file_xls{1} = [entities_dir filesep '20151116_measure_project_package' filesep 'Assets_at_risk_100x100_16112015 Final FS Project package - scenario 1.xlsx'];
oad([strrep(entity_file_xls{1},'.xlsx','') '_floods_2014'])
lear measures
_measures = 4;
easures = climada_measures_construct('',n_measures);
 reduced FL depth hazard due to a package of measures
sci_path = [barisal_data_dir filesep 'entities' filesep '20151116_measure_project_package' filesep 'reduced_FL_hazard'];
easure_i = 1; 
easures.name{measure_i} = 'FL depth project package';
easures.peril_ID(measure_i) = {'FL'};
easures.hazard_event_set{measure_i} = [asci_path filesep 'CaseDifferenceDepth_m.asc'];
easures.hazard_event_set_operator{measure_i} = 'plus';
 land raising at selected locations
easure_i = 2; 
easures.name{measure_i} = 'final package';%'land raising';
easures.hazard_event_set{measure_i} = [asci_path filesep 'CaseDifferenceDepth_m.asc'];
easures.hazard_event_set_operator{measure_i} = 'plus';
easures.hazard_intensity_impact_b(measure_i) = -0.3; % land raising by 0.3m
easures.peril_ID(measure_i) = {'FL'};
easure_location = climada_xlsread('no',...
   [entities_dir filesep '20151116_measure_project_package' filesep 'Locations for resilient buildings measure.xlsx'],'Assets',1);
_categories = length(entity.assets.lon)/length(measure_location.flood_resilient_buildings);
 replicate matrix for all categories
egional_scope = repmat(measure_location.flood_resilient_buildings,n_categories,1);
printf('Measure final package (asset change, hazard change, land raising at selected locations)\n')
printf('\t - %d locations (1 category), %d locations with land raising \n',length(measure_location.flood_resilient_buildings),sum(measure_location.flood_resilient_buildings))
printf('\t - %d all locations (%d categories) \n',length(entity.assets.lon),n_categories)
 initialize logical index to define the regional scope of measures
easures.regional_scope = ones(length(entity.assets.Value),n_measures);
 create logical 
easures.regional_scope(:,measure_i) = logical(regional_scope);
 reduced FL duration hazard due to a package of measures
easure_i = 3; 
easures.name{measure_i} = 'final package'; %'FL duration project package';
easures.peril_ID(measure_i) = {'FL_'};
easures.hazard_event_set{measure_i} = [asci_path filesep 'CaseDifferenceDuration_fraction.asc'];
easures.hazard_event_set_operator{measure_i} = 'times';
 TC with no measures so that it runs through the calculation nontheless
easure_i = 4; 
easures.name{measure_i} = 'final package'; %'TC control';
easures.peril_ID(measure_i) = {'TC'};
ave([entities_dir filesep '20151116_measure_project_package' filesep 'measures_project_package.mat'],'measures')
 measures = climada_measures_check(measures,entity.assets);
 entity.measures = measures;
% measures impact calc for today, 2030 and 2050 including climate change
 calculate measures_impact for each peril in different scenarios specified below. 
================
eril_IDs   = {'FL_depth_monsoon' 'FL_duration_monsoon' 'FL_depth_cyclone' 'FL_duration_cyclone' 'TC'};
 peril_IDs   = {'TC'};
co_scen    = 1; %[1 2 3];
c_scen     = 'moderate'; %{'moderate' 'extreme'}; %
ear_i      = 2014;
ear_f      = [2030 2050];
ilent_mode = 0;
anity_check = 1;
init
lear measures_impact1 measures_impact3 measures_impact5 measures_impact2 measures_impact4
or scenario_eco_i = 1:numel(eco_scen)
   for p_i = 1:numel(peril_IDs); %peril_IDs(1) %peril_ID = peril_IDs %
       peril_ID = peril_IDs{p_i};
       if strcmp(peril_ID,'TC')
           peril = 'cyclone';
       else
           peril = 'flood';
       end
       ed_i = p_i; % counter for EDS entries
       year_f = 2030;
       climada_global.future_reference_year = year_f;
       % EDS1 for scenario hazard and entity in present reference year
       [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files); 
       [entity,e_i] = barisal_get_entity(year_i,peril,entity_files,eco_scen(scenario_eco_i));
       hazard.scenario = 'no change';
       %entity.assets.region = sprintf('BCC %s', peril_ID);
       %fprintf('\n***** Scenario %d, EDS1 for %s | %s *****\n', scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       %scen_name1 = ['Today''s; expected damage; ' num2str(year_i)];
       scenario = climada_scenario_name(entity,hazard); fprintf('\n***** %s: %s *****\n', scenario.name_simple, peril_ID)
       measures_impact1(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
       measures_impact1(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_' num2str(year_i) '.mat'];
       %for i = 1:length(measures_impact1(ed_i).EDS)
       %    % convert back to UTM
       %    [measures_impact1(ed_i).EDS(i).assets.X,measures_impact1(ed_i).EDS(i).assets.Y] = ...
       %        ll2utm_shift(measures_impact1(ed_i).EDS(i).assets.lat,measures_impact1(ed_i).EDS(i).assets.lon);
       %end
       save(measures_impact1(ed_i).filename,'measures_impact1')   
       
       % ----2030-----
       % EDS2 for no change hazard and entity in future reference year
       [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files); 
       [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
       hazard.scenario = 'no change';
       %fprintf('\n***** Scenario %d, EDS1 for %s | %s *****\n', scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       %scen_name1 = ['Today''s; expected damage; ' num2str(year_i)];
       scenario = climada_scenario_name(entity,hazard); fprintf('\n***** %s: %s *****\n', scenario.name_simple, peril_ID)
       measures_impact2(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
       measures_impact2(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_' num2str(year_f) '.mat'];
       %for i = 1:length(measures_impact2(ed_i).EDS)
       %    % convert back to UTM
       %    [measures_impact1(ed_i).EDS(i).assets.X,measures_impact1(ed_i).EDS(i).assets.Y] = ...
       %        ll2utm_shift(measures_impact2(ed_i).EDS(i).assets.lat,measures_impact1(ed_i).EDS(i).assets.lon);
       %end
       save(measures_impact2(ed_i).filename,'measures_impact2')   
       
       % EDS3 for climate change scenario: future entity 2030, future hazard 2030
       if scenario_eco_i == 2
           cc_scen = 'extreme';
       else 
           cc_scen = 'moderate';
       end
       [hazard,h_i] = barisal_get_hazard(year_f,cc_scen,peril_ID,hazard_files);
       [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
       hazard.scenario = sprintf('%s change',cc_scen);
       %entity.assets.region = sprintf('BCC %s', peril_ID);
       %fprintf('\n***** Scenario %d, EDS3 for %s | %s *****\n',scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       %scen_name3 = sprintf('Increase;from %s;climate change;%d',cc_scen,num2str(year_f));
       scenario = climada_scenario_name(entity,hazard); fprintf('\n***** %s: %s *****\n', scenario.name_simple, peril_ID)
       measures_impact3(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
       measures_impact3(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_' num2str(year_f) '_cc_' cc_scen '_' num2str(year_f) '.mat'];
       %for i = 1:length(measures_impact3(ed_i).EDS)
       %    % convert back to UTM
       %    [measures_impact3(ed_i).EDS(i).assets.X,measures_impact3(ed_i).EDS(i).assets.Y] = ...
       %        ll2utm_shift(measures_impact3(ed_i).EDS(i).assets.lat,measures_impact3(ed_i).EDS(i).assets.lon);
       %end
       save(measures_impact3(ed_i).filename,'measures_impact3')
       
       % ----2050-----
       year_f = 2050;
       climada_global.future_reference_year = year_f;
       
       % EDS4 for future entity 2050, no climate change scenario
       [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files);
       [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
       hazard.scenario = 'no change';
       scenario = climada_scenario_name(entity,hazard); fprintf('\n***** %s: %s *****\n', scenario.name_simple, peril_ID)
       measures_impact4(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
       measures_impact4(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_' num2str(year_f) '.mat'];
       %for i = 1:length(measures_impact4(ed_i).EDS)
       %    % convert back to UTM
       %    [measures_impact4(ed_i).EDS(i).assets.X,measures_impact4(ed_i).EDS(i).assets.Y] = ...
       %        ll2utm_shift(measures_impact4(ed_i).EDS(i).assets.lat,measures_impact4(ed_i).EDS(i).assets.lon);
       %end
       save(measures_impact4(ed_i).filename,'measures_impact4')
       
       % EDS5 for climate change scenario: future entity 2050, future hazard 2050
       if scenario_eco_i == 2
           cc_scen = 'extreme';
       else 
           cc_scen = 'moderate';
       end
       [hazard,h_i] = barisal_get_hazard(year_f,cc_scen,peril_ID,hazard_files);
       [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
       hazard.scenario = sprintf('%s change',cc_scen);
       %entity.assets.region = sprintf('BCC %s', peril_ID);
       %fprintf('\n***** Scenario %d, EDS5 for %s | %s *****\n',scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       %scen_name5 = ['Increase; from ' cc_scen '; climate change; ' num2str(year_f)];
       %scen_name5 = sprintf('Increase;from %s;climate change;%d',cc_scen,num2str(year_f));
       scenario = climada_scenario_name(entity,hazard); fprintf('\n***** %s: %s *****\n', scenario.name_simple, peril_ID)
       measures_impact5(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
       measures_impact5(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_' num2str(year_f) '_cc_' cc_scen '_' num2str(year_f) '.mat'];
       %for i = 1:length(measures_impact5(ed_i).EDS)
       %    % convert back to UTM
       %    [measures_impact5(ed_i).EDS(i).assets.X,measures_impact5(ed_i).EDS(i).assets.Y] = ...
       %        ll2utm_shift(measures_impact5(ed_i).EDS(i).assets.lat,measures_impact5(ed_i).EDS(i).assets.lon);
       %end
       save(measures_impact5(ed_i).filename,'measures_impact5')
   end
nd %scenario_eco_i
% add baseline results to measures_impact
oad(['\\CHRB1065.CORP.GWPNET.COM\homes\X\S3BXXW\Documents\lea\climada_git\climada_data_barisal\results\20150916_baseline' filesep 'EDS_scenario_1'])
 load([results_dir filesep 'EDS_scenario_1'])
easures_impact1_baseline = climada_measures_impact_add(measures_impact1,EDS1,entity);
easures_impact2_baseline = climada_measures_impact_add(measures_impact2,EDS2,entity);
easures_impact3_baseline = climada_measures_impact_add(measures_impact3,EDS3,entity);
easures_impact4_baseline = climada_measures_impact_add(measures_impact4,EDS4,entity);
easures_impact5_baseline = climada_measures_impact_add(measures_impact5,EDS5,entity);
d_i = 1;
ave(measures_impact1_baseline(ed_i).filename,'measures_impact1_baseline')
ave(measures_impact2_baseline(ed_i).filename,'measures_impact2_baseline')
ave(measures_impact3_baseline(ed_i).filename,'measures_impact3_baseline')
ave(measures_impact4_baseline(ed_i).filename,'measures_impact4_baseline')
ave(measures_impact5_baseline(ed_i).filename,'measures_impact5_baseline')
easures_impact = measures_impact1_baseline;
easures_impact(6:10) = measures_impact2_baseline;
easures_impact(11:15) = measures_impact3_baseline;
 measures_impact(16:20) = measures_impact4_baseline;
 measures_impact(21:25) = measures_impact5_baseline;
 measures_impact(1).filename = [results_dir filesep 'measures_impact_2014_2030_2050_scenario_1']
easures_impact(1).filename = [results_dir filesep 'measures_impact_2014_2030_scenario_1']
ave(measures_impact(1).filename,'measures_impact')
 % maybe add category tables to baseline scenario
 n_scenarios = numel(measures_impact);
 for scenario_i = 1:n_scenarios  
     % change Value_unit to BDT, add asset Categories, remove X, Y
     for m_i = 1:numel(measures_impact(scenario_i).EDS)
         measures_impact(scenario_i).EDS(m_i).assets.Category = entity.assets.Category;
         measures_impact(scenario_i).EDS(m_i).assets.Category_name = entity.assets.Category_name;
         measures_impact(scenario_i).EDS(m_i).assets.Category_ID = entity.assets.Category_ID;
         if isfield(measures_impact(scenario_i).EDS(m_i).assets,'X')
             measures_impact(scenario_i).EDS(m_i).assets = rmfield(measures_impact(scenario_i).EDS(m_i).assets,'X');
             measures_impact(scenario_i).EDS(m_i).assets = rmfield(measures_impact(scenario_i).EDS(m_i).assets,'Y');
         end
     end
 end %scenario_i
 measures_impact(1).filename = [results_dir filesep 'measures_impact_2014_2030_scenario_1']
 save(measures_impact(1).filename,'measures_impact')
 % save(measures_impact(1).filename,'measures_impact','-v7.3')
 
 filename = entity(1).assets.filename;
 category_selected = 'Commercial_buildings_Pucca_ASSETS';
 entity.assets = climada_asset_categories(entity.assets);
 save([results_dir filesep 'entity_test.mat'],'entity')
% combine measures_impact for all perils per scenario (timehorizon)
eril_list = {'FL monsoon' 'FL monsoon duration' 'FL cyclone' 'FL cyclone duration' 'TC'};
easures_impact_combined = climada_measures_impact_combine_scenario(measures_impact,'','',peril_list);
% create some benefit plots
easure_no = 1; fieldname_to_plot = {'ED_at_centroid' 'benefit'}; plot_method= 'plotclr'; 
imehorizon = 1;% time horizon
 category_criterium = '';
easures_impact_to_plot = measures_impact_combined(timehorizon);
~, fig] = climada_map_plot(measures_impact_to_plot,fieldname_to_plot,plot_method,measure_no,category_criterium);
easure_no = 4;
ieldname_to_plot = {'ED_at_centroid'};
truct_no = 1;% peril type
ategory_criterium = '';
~, fig] = climada_map_plot(measures_impact1_baseline,fieldname_to_plot,plot_method,measure_no,struct_no,category_criterium);
ategory_criterium = {'industry_buildings_Semi_Pucca_ASSETS_30_cm_elevation_' 'Residential_buildings_Pucca_ASSETS'};
ategory_criterium = 'Residential_buildings_Pucca_ASSETS';
ategory_criterium = categories(3:4);
ntity.assets.Category = unique(entity.assets.Category);
easure_no = 1;
ieldname_to_plot = 'Value'; plot_method= 'plotclr'; 
truct_no = 1;% peril type
~, fig] = climada_map_plot(entity,fieldname_to_plot,plot_method,measure_no,struct_no,category_criterium);
vent_no = 1721;
ieldname_to_plot = 'intensity'; plot_method= 'plotclr'; 
truct_no = 1;% peril type
~, fig] = climada_map_plot(hazard,fieldname_to_plot,plot_method,event_no,struct_no);
vent_no = 1;
ieldname_to_plot = 'intensity'; plot_method= 'plotclr'; 
truct_no = 1;% peril type
~, fig] = climada_map_plot('Barisal_BCC_hazard_FL_depth_cyclone_2014',fieldname_to_plot,plot_method,event_no,struct_no);
vent_no = 1721;
ieldname_to_plot = 'intensity'; plot_method= 'contourf'; 
truct_no = 1;% peril type
~, fig] = climada_map_plot('Barisal_BCC_hazard_TC_2014',fieldname_to_plot,plot_method,event_no,struct_no);
% write ED output for measures_impact
lear EDS_project_package_1 EDS_project_package_3 EDS_project_package_5 EDS_project_package
 collect EDS for all perils (FL depth, FL duration, FL depth cyclone, FL duration cyclone, TC)
DS_project_package_1 = [measures_impact1(1).EDS measures_impact1(2).EDS measures_impact1(3).EDS...
                       measures_impact1(4).EDS measures_impact1(5).EDS(1)];
 EDS_project_package_1 = [measures_impact1(3).EDS measures_impact1(4).EDS];    
DS_project_package_3 = [measures_impact3(1).EDS measures_impact3(2).EDS measures_impact3(3).EDS...
                       measures_impact3(4).EDS measures_impact3(5).EDS(1)];
DS_project_package_5 = [measures_impact5(1).EDS measures_impact5(2).EDS measures_impact5(3).EDS...
                       measures_impact5(4).EDS measures_impact5(5).EDS(1)];
 convert back to UTM
or ed_i = 1:length(EDS_project_package_1)
   [EDS_project_package_1(ed_i).assets.X,EDS_project_package_1(ed_i).assets.Y] = ...
                  ll2utm_shift(EDS_project_package_1(ed_i).assets.lat, EDS_project_package_1(ed_i).assets.lon);
   [EDS_project_package_3(ed_i).assets.X,EDS_project_package_3(ed_i).assets.Y] = ...
                  ll2utm_shift(EDS_project_package_3(ed_i).assets.lat, EDS_project_package_3(ed_i).assets.lon);
   [EDS_project_package_5(ed_i).assets.X,EDS_project_package_5(ed_i).assets.Y] = ...
                  ll2utm_shift(EDS_project_package_5(ed_i).assets.lat, EDS_project_package_5(ed_i).assets.lon);           
   EDS_project_package_1(ed_i).peril_ID = '';
   EDS_project_package_3(ed_i).peril_ID = '';
   EDS_project_package_5(ed_i).peril_ID = '';
nd                    
               
 loop over three time horizons
imehorizons = [2014 2030 2050];                    
or t_i = 1%:3
   % fill variable with a specific time horizon
   switch t_i
       case 1
           EDS_project_package = EDS_project_package_1;
       case 2 
           EDS_project_package = EDS_project_package_3;
       case 3
           EDS_project_package = EDS_project_package_5;
   end
   
   % write ED per category report
   EDS_report_xls = [results_dir filesep sprintf('BCC_ED_report_scenario_%d_project_package_%s.xls',eco_scen(scenario_eco_i),datestr(now,'yyyymmdd'))];
   %if exist(EDS_report_xls,'file'), delete(EDS_report_xls); end
   benefit_flag = 0;
   assets_flag = 1;
   sheetname = sprintf('ED_per_category_%d',timehorizons(t_i));
   output_report = climada_EDS_ED_per_category_report(entity, EDS_project_package, EDS_report_xls,sheetname,benefit_flag,0,assets_flag);
   
   % write ED at centroid to excel
   EDS_report_xls = [results_dir filesep sprintf('BCC_ED_report_scenario_%d_project_package_at_centroid_%s.xls',eco_scen(scenario_eco_i),datestr(now,'yyyymmdd'))];
   sheetname = sprintf('ED_at_centroid_%d',timehorizons(t_i));
   climada_EDS_ED_at_centroid_report_xls(EDS_project_package,EDS_report_xls,sheetname);
nd
%
igure
ssets_indx = strcmp(entity.assets.Category,'Residential_buildings_Pucca_ASSETS');
lotclr(entity.assets.lon(assets_indx), entity.assets.lat(assets_indx), AED_rel(assets_indx),'','',1,0.01,5)
itle('AED relative, Residential_buildings_Pucca_ASSETS')
igure
ssets_indx = strcmp(entity.assets.Category,'Residential_buildings_Pucca_ASSETS');
lotclr(entity.assets.lon(assets_indx), entity.assets.lat(assets_indx), AED_rel(assets_indx),'','',1)
itle('AED relative, Residential_buildings_Pucca_ASSETS')
igure
ssets_indx = strcmp(entity.assets.Category,'Residential_buildings_Katcha_ASSETS');
lotclr(entity.assets.lon(assets_indx), entity.assets.lat(assets_indx), AED_rel(assets_indx),'','',1,0.01,5)
itle('AED relative, Residential_buildings_Katcha_ASSETS')
igure
ssets_indx = strcmp(entity.assets.Category,'Residential_buildings_Pucca_ASSETS');
lotclr(entity.assets.lon(assets_indx), entity.assets.lat(assets_indx), entity.assets.income(assets_indx),'','',1)
itle('Income, Residential_buildings_Pucca_ASSETS')
igure
ssets_indx = strcmp(entity.assets.Category,'Residential_buildings_Pucca_ASSETS');
lotclr(entity.assets.lon(assets_indx), entity.assets.lat(assets_indx), measures_impact3(1).EDS(1).ED_at_centroid(assets_indx),'','',1)
itle('ED, Residential_buildings_Pucca_ASSETS')
eturn
% measures construction
 structure measures, assign measures.hazard_event_set by searching through
 barisal entities folder and finding measure folders starting with the
 substring &quotMeasures&quot
_dir_ = dir(entities_dir);
init
lear measures; measures = climada_measures_construct([],0);
 hazard modifying measures
or e_dir_i = 1:length(e_dir_)
   if e_dir_(e_dir_i).isdir &amp&amp ...
           ~isempty(strfind(upper(e_dir_(e_dir_i).name),'MEASURES'))
       
       e_subdir_ = dir([entities_dir filesep e_dir_(e_dir_i).name]);
       
       for m_i = 1:length(e_subdir_)
           if e_subdir_(m_i).name(1) == '.', continue; end
           asci_file = [entities_dir filesep e_dir_(e_dir_i).name filesep e_subdir_(m_i).name];
           % construct name from folder and file
           name    = strrep([e_dir_(e_dir_i).name],'Measures_','');
           name(1) = upper(name(1)); name = strrep(name,'_',' ');
           
           measures = climada_measures_construct(measures,1);
           
           measures.name{end}              = name;
           measures.hazard_event_set{end}  =  asci_file;
           % operator required for call to climada_distributed_measures in
           % climada_measures_impact_advanced. Make sure it is correct by
           % checking peril ID =&ampgt multiplication for flood duration and
           % addition for flood depth
           if ~isempty(strfind(e_subdir_(m_i).name,'Duration'))
               measures.peril_ID{end} = 'FL_';
               measures.hazard_event_set_operator{end} = 'times';
           else
               measures.peril_ID{end} = 'FL';
               measures.hazard_event_set_operator{end} = 'plus';
           end
           % fprintf('%s \t%s\n',name,measures.peril_ID{end})
       end
   end
nd
 % assign measures struct to entities and save each one again
easures                              = climada_measures_construct(measures,4);
easures.name{end-3}                  = 'Flood resilient crops';
easures.damagefunctions_map{end-3}   = '1320to1321';
easures.peril_ID{end-3}              = 'FL_';
 save measures struct (before adding entity file)
easures.filename = [entities_dir filesep 'BCC_measures_' datestr(now,'ddmmyy') '.mat'];
printf('saving measures as %s\n',measures.filename)
ave(measures.filename,'measures')
easures_ori = measures; % for ponds retain routine
or e_i = 1:length(entity_files)
   
   measures = measures_ori;
   
   load(entity_files{e_i})
   
   % remove old measures, just in case
   if isfield(entity,'measures'),entity = rmfield(entity,'measures'); end
   
   measures.name{end-2}        = 'Spatial planning';
   measures.entity_file{end-2} = [fileparts(entity_files{e_i}) filesep...
       'Measure_Spatial_planning_290615_se_1_' lower(strrep(entity.assets.comment,' ','_')) '.mat'];
   if ~exist(measures.entity_file{end-2},'file')
       cprintf([ 1 0.5 0],'WARNING: entity file for measure %s does not exist\n',measures.name{end-2})
   end
   
   measures.name{end-1}        = 'Early warning system';
   measures.entity_file{end-1} = [fileparts(entity_files{e_i}) filesep...
       'Measure_Early_warning_system_290615_se_1_' lower(strrep(entity.assets.comment,' ','_')) '.mat'];
   measures.damagefunctions_map{end-1}   = '1210to1211;1220to1221';
   if ~exist(measures.entity_file{end-1},'file')
       cprintf([ 1 0.5 0],'WARNING: entity file for measure %s does not exist\n',measures.name{end-1})
   end
   measures.name{end}          = 'Flood proof road infrastructure';
   measures.entity_file{end}   = [fileparts(entity_files{e_i}) filesep...
       'Measure_Flood_proof_road_infrastructure_290615_se_1_' lower(strrep(entity.assets.comment,' ','_')) '.mat'];

   if ~exist(measures.entity_file{end},'file')
       cprintf([ 1 0.5 0],'WARNING: entity file for measure %s does not exist\n',measures.name{end})
   end   
   % drainage for correct refence year
   rm_ndx = [];
   for m_i = 1:length(measures.name)
       if ~isempty(strfind(measures.name{m_i},'Ponds retain'))
           if isempty(strfind(measures.name{m_i},num2str(entity.assets.reference_year)))
               rm_ndx = [rm_ndx m_i];
           end
           measures.name{m_i} = 'Ponds retain';
       end
   end
   
   entity.measures = climada_measures_construct(measures,-rm_ndx);
     entity.measures = measures;
   fprintf('measures assigned to entity %s:\n',entity.assets.comment)
   for measure_i = 1:length(entity.measures.name)
       cprintf(entity.measures.color_RGB(measure_i,:),'\t%s\n',entity.measures.name{measure_i});
   end
   
   fprintf('saving entity with measures to %s\n',entity.assets.filename)
   
   save(entity.assets.filename,'entity')
nd
 display measures in their respective colours
 for measure_i = 1:length(measures.name),cprintf(measures.color_RGB(measure_i,:),'%s\n',measures.name{measure_i}); end
lear e_i e_dir_i e_dir_ e_subdir_ e_subdir_ m_i m_i measure_i rm_ndx name
% measures package construction
init
lear measures; measures = climada_measures_construct([],3);
 hazard modifying measures
sci_path = [barisal_data_dir filesep 'entities' filesep 'Measures_package'];
 flood depth
easures.name{1}                =   'Measure package';
easures.hazard_event_set{1}    =   [asci_path filesep 'CaseDifferenceDepth_m.asc'];
easures.peril_ID{1}            =   'FL';
easures.hazard_event_set_operator{1} = 'plus';
easures.damagefunctions_map{1}   = '1210to1211;1220to1221'; % vehicles
 flood duration
easures.name{2}                =   'Measure package';
easures.hazard_event_set{2}    =   [asci_path filesep 'CaseDifferenceDuration_fraction.asc'];
easures.peril_ID{2}            =   'FL_';
easures.hazard_event_set_operator{2} = 'times';
easures.damagefunctions_map{2} = '1320to1321'; % Flood resilient crops (only for duration)
 cyclone wind
easures.name{3}                =   'Measure package';
easures.peril_ID{3}            =   'TC';
 save measures struct (before adding entity file)
easures.filename = [entities_dir filesep 'BCC_measure_package' datestr(now,'ddmmyy') '.mat'];
printf('saving measures as %s\n',measures.filename)
ave(measures.filename,'measures')
or y_i = [2014 2030 2050]
   % set correct measure entity file
   measures.entity_file{1} = [entities_dir filesep...
       'Measure_package_070715_se_1_floods_' num2str(y_i) '.mat'];
   measures.entity_file{2} = [entities_dir filesep...
       'Measure_package_070715_se_1_floods_' num2str(y_i) '.mat'];
   measures.entity_file{3} = [entities_dir filesep...
       'Measure_package_070715_se_1_cyclones_' num2str(y_i) '.mat'];
   
   % assign measures to baseline entity struct
   % for both flood depth and duration
   [entity, e_i] = barisal_get_entity(y_i,'floods',entity_files);
   % remove old measures, just in case
   if isfield(entity,'measures'),entity = rmfield(entity,'measures'); end
   entity.measures = measures;
   fprintf('saving entity with measures to %s\n',entity.assets.filename)
   save(entity.assets.filename,'entity')
   
   % for TC
   [entity, e_i] = barisal_get_entity(y_i,'cyclones',entity_files);
   % remove old measures, just in case
   if isfield(entity,'measures'),entity = rmfield(entity,'measures'); end
   entity.measures = measures;
   fprintf('saving entity with measures to %s\n',entity.assets.filename)
   save(entity.assets.filename,'entity')
nd
 display measures in their respective colours
or measure_i = 1:length(measures.name),cprintf(measures.color_RGB(measure_i,:),'%s\n',measures.name{measure_i}); end
lear e_i e_dir_i e_dir_ e_subdir_ e_subdir_ m_i m_i measure_i rm_ndx name
% population entity &amp casualties [uncomment, but be careful]
 
 Entity excel file from Ecorys (unstructured)
ntity_file_xls = [entities_dir filesep 'BCC_entity_210615_scenario 1_population.xls'];
 Entity template file from global data dir
ntity_temp_xls = [climada_global.data_dir filesep 'entities' filesep 'entity_template.xls'];
heets          = {'2014' '2030' '2050'}; % for population entity
 load damagefunctions
oad([entities_dir filesep 'BCC_population_entity_090615.mat'])
amagefunctions = entity.damagefunctions;
orce_assets_re_read   = 1;% Whether to re-read entity from xls (1) or load matfiles (0)
or s_i = 1:length(sheets)
   clear entity
   
   % mat file name - separate mat file for each sheet in entity xls
   entity_file_mat     = strrep(entity_file_xls,'.xls',['_' lower(sheets{s_i}) '.mat']);
   
   if exist(entity_file_mat,'file') &amp&amp ~force_assets_re_read
       % Load mat file
       fprintf('entity %s .mat file already exists, skipping\n',lower(sheets{s_i}))
       entity_files{s_i} = entity_file_mat;
       load(entity_file_mat)
       % append filename for consistency
       entity.assets.filename = entity_file_mat;
       % save corrected entity
       save(entity.assets.filename,'entity')
   else
       % read in entity from xls
       entity = climada_entity_read(entity_temp_xls);
       %entity = climada_entity_read_wo_assets(entity_temp_xls);
       entity.assets = climada_xlsread('no',entity_file_xls,sheets{s_i},1);
       entity.assets.comment = ['Population entity ' sheets{s_i}];
       entity.assets.reference_year = str2num(sheets{s_i});
       % coord transformation from UTM to lat lon
       [entity.assets.lon, entity.assets.lat] = utm2ll_shift(entity.assets.lon, entity.assets.lat);
       entity.assets.filename          = entity_file_mat; % for filename consistency
       % use people damagefunctions
       entity.damagefunctions = damagefunctions;
       fprintf('saving entity as %s\n',entity.assets.filename)
       save(entity.assets.filename,'entity')
       entity_files{s_i} = entity.assets.filename;
   end
   
nd
lear entity_file_xls sheets s_i entity_temp_xls entity_file_mat force_assets_re_read
%
limada_global.Value_unit = 'people';
ear_i = 2014; climada_global.present_reference_year = year_i;
ear_f = 2030; climada_global.future_reference_year  = year_f;
c_scen = 'moderate'; ed_i = 0; clear EDS1 EDS2 EDS3 % init
or peril_ID = {'FL_depth_monsoon' 'FL_depth_cyclone'}
   ed_i = ed_i +1;
   % EDS1 for scenario hazard and entity in present reference year
   [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files);
   [entity,e_i] = barisal_get_entity(year_i,'population',entity_files);
   fprintf('***** EDS1 for %s | %s *****\n',char(entity.assets.comment),char(strtok(hazard.comment,',')))
   EDS1(ed_i)    = climada_EDS_calc(entity,hazard,'',1,'',1);
   scen_name1 = ['Today''s; expected casualties; ' num2str(year_i)];
   fprintf('Annual expected casualties: %2.2f mn\n',EDS1(ed_i).ED)
   
   % EDS2 economic growth, no climate change
   [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files);
   [entity,e_i] = barisal_get_entity(year_f,'population',entity_files);
   fprintf('***** EDS2 for %s | %s *****\n',char(entity.assets.comment),char(strtok(hazard.comment,',')))
   EDS2(ed_i)    = climada_EDS_calc(entity,hazard,'',1);
   scen_name2 = ['Increase; from population; growth ' num2str(year_f)];
   fprintf('Annual expected casualties: %2.2f mn\n',EDS2(ed_i).ED)
   
   % EDS3 climate change + economic growth
   [hazard,h_i] = barisal_get_hazard(year_f,cc_scen,peril_ID,hazard_files);
   [entity,e_i] = barisal_get_entity(year_f,'population',entity_files);
   fprintf('***** EDS3 for %s | %s *****\n',char(entity.assets.comment),char(strtok(hazard.comment,',')))
   EDS3(ed_i)    = climada_EDS_calc(entity,hazard,'',1);
   scen_name3 = ['Increase; from ' cc_scen '; climate change; ' num2str(year_f)];
   fprintf('Annual expected casualties: %2.2f mn\n',EDS3(ed_i).ED)
nd
 figure; climada_ED_plot(EDS1, 0,'people',0,0)
 figure; climada_ED_plot(EDS2, 0,'people',0,0)
 figure; climada_ED_plot(EDS3, 0,'people',0,0)
limada_waterfall_graph_multi_peril(0,'people',EDS1,scen_name1,EDS2,scen_name2,EDS3,scen_name3)
 print(gcf,'-dpng',[results_dir filesep 'BCC_Barisal_population_waterfall_2030.png'])
 
 
ave([results_dir filesep 'Barisal_EDS_people_2014_2030_FL_monsoon_cyclone.mat'],'EDS1', 'EDS2', 'EDS3')
 EDS(1) = climada_EDS_combine(EDS1(1),EDS1(2));
DS(1) = EDS1(1);
DS(1).ED = sum([EDS1.ED]);
DS(2) = EDS2(1);
DS(2).ED = sum([EDS2.ED]);
DS(3) = EDS3(1);
DS(3).ED = sum([EDS3.ED]);
DS(1).hazard.comment = 'FL (monsoon and cyclone)';
DS(2).hazard.comment = 'FL (monsoon and cyclone)';
DS(3).hazard.comment = 'FL (monsoon and cyclone)';
DS(1).assets.filename = 'BCC population 2014';
DS(2).assets.filename = 'BCC population 2030';
DS(3).assets.filename = 'BCC population 2030';
limada_waterfall_graph(EDS(1), EDS(2), EDS(3),'AED');
ave([results_dir filesep 'Barisal_EDS_people_2014_2030.mat'],'EDS')
avefig([results_dir filesep 'Barisal_EDS_people_2014_2030.fig'])
% Multi scenario EDS calc for waterfall
================
 This section is key for measure impact calculations
================
 calculate EDS for each peril in different scenarios specified below. Each
 EDSn corresponds to one bar in the waterfall graph. They should have the
 same length, and each entry in each EDSn corresponds to a peril_ID
 measure impact is also calculated, unless EDS_only is set to 1
eril_IDs   = {'FL_depth_monsoon' 'FL_duration_monsoon' 'FL_depth_cyclone' 'FL_duration_cyclone' 'TC'};
 peril_IDs   = {'TC'};
co_scen    = 1; %[1 2 3];
c_scen     = 'moderate'; %{'moderate' 'extreme'}; %
ear_i      = 2014;
ear_f      = [2030 2050];
DS_only    = 0; %1; %EDS_only    = 0;
ilent_mode = 0;
anity_check = 1;
init
 clear EDS1 EDS2 EDS3 EDS4 EDS5 
 clear measures_impact1 measures_impact3 measures_impact5
or scenario_eco_i = 1:numel(eco_scen)
   % for year_f = [2050 2030]
   %ed_i = 0;
   for p_i = 4%1:numel(peril_IDs); %peril_IDs(1) %peril_ID = peril_IDs %
       peril_ID = peril_IDs{p_i};
       if strcmp(peril_ID,'TC')
           peril = 'cyclone';
       else
           peril = 'flood';
       end
       %ed_i = ed_i+1; % counter for EDS entries
       ed_i = p_i; % counter for EDS entries
       year_f = 2030;
       climada_global.future_reference_year = year_f;
       % EDS1 for scenario hazard and entity in present reference year
       [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files);
       [entity,e_i] = barisal_get_entity(year_i,peril,entity_files,eco_scen(scenario_eco_i));
       %EDS1    = barisal_get_EDS(EDS,entity_files{e_i},hazard_files{h_i});
       fprintf('\n***** Scenario %d, EDS1 for %s | %s *****\n', scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       scen_name1 = ['Today''s; expected damage; ' num2str(year_i)];
       %fprintf('Annual expected damage: %2.2f mn\n',EDS1(ed_i).ED/1000000)
       if ~EDS_only
           measures_impact1(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
           measures_impact1(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_' num2str(year_i) '.mat'];
           for i = 1:length(measures_impact1(ed_i).EDS)
               % convert back to UTM
               [measures_impact1(ed_i).EDS(i).assets.X,measures_impact1(ed_i).EDS(i).assets.Y] = ...
                   ll2utm_shift(measures_impact1(ed_i).EDS(i).assets.lat,measures_impact1(ed_i).EDS(i).assets.lon);
           end
           save(measures_impact1(ed_i).filename,'measures_impact1')
       else
           EDS1(ed_i)    = climada_EDS_calc(entity,hazard,'',1,silent_mode,sanity_check);
       end        
       if EDS_only
           % EDS2 for socio-economic growth scenario: present hazard, future entity 2030
           [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files);
           [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
           %EDS2    = barisal_get_EDS(EDS,entity_files{e_i},hazard_files{h_i});
           fprintf('\n***** Scenario %d, EDS2 for %s | %s *****\n',scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
           EDS2(ed_i)    = climada_EDS_calc(entity,hazard,'',1,silent_mode,sanity_check);
           scen_name2 = sprintf('Increase;from economic;growth %d;scenario %d',num2str(year_f),eco_scen(scenario_eco_i));
           fprintf('Annual expected damage: %2.2f mn\n',EDS2(ed_i).ED/1000000)
           %entity.measures = climada_measures_construct([],1);
           %entity.measures.name{1} = 'control';
           %measures_impact2(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
           %for i = 1:length(measures_impact2(ed_i).EDS)
           %    % convert back to UTM
           %    [measures_impact2(ed_i).EDS(i).assets.X,measures_impact2(ed_i).EDS(i).assets.Y] = ...
           %        ll2utm_shift(measures_impact2(ed_i).EDS(i).assets.lat,measures_impact2(ed_i).EDS(i).assets.lon);
           %end
       end
       % EDS3 for climate change scenario: future entity 2030, future hazard 2030
       if scenario_eco_i == 2
           cc_scen = 'extreme';
       else 
           cc_scen = 'moderate';
       end
       [hazard,h_i] = barisal_get_hazard(year_f,cc_scen,peril_ID,hazard_files);
       [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
       fprintf('\n***** Scenario %d, EDS3 for %s | %s *****\n',scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       %scen_name3 = ['Increase; from ' cc_scen '; climate change; ' num2str(year_f)];
       scen_name3 = sprintf('Increase;from %s;climate change;%d',cc_scen,num2str(year_f));
       %fprintf('Annual expected damage: %2.2f mn\n',EDS3(ed_i).ED/1000000)
       if ~EDS_only
           measures_impact3(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
           measures_impact3(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_cc_' cc_scen '_' num2str(year_f) '.mat'];
           for i = 1:length(measures_impact3(ed_i).EDS)
               % convert back to UTM
               [measures_impact3(ed_i).EDS(i).assets.X,measures_impact3(ed_i).EDS(i).assets.Y] = ...
                   ll2utm_shift(measures_impact3(ed_i).EDS(i).assets.lat,measures_impact3(ed_i).EDS(i).assets.lon);
           end
           save(measures_impact3(ed_i).filename,'measures_impact3')
       else
           EDS3(ed_i)    = climada_EDS_calc(entity,hazard,'',1,silent_mode,sanity_check);
       end
       year_f = 2050;
       climada_global.future_reference_year = year_f;
       if EDS_only
           % EDS4 for socio-economic growth scenario: present hazard, future entity 2050
           [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files);
           [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
           fprintf('\n***** Scenario %d, EDS4 for %s | %s *****\n',scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
           EDS4(ed_i)    = climada_EDS_calc(entity,hazard,'',1,silent_mode,sanity_check);
           %scen_name4 = ['Increase; from economic; growth ' num2str(year_f)];
           scen_name4 = sprintf('Increase;from economic; growth %d;scenario %d',num2str(year_f),eco_scen(scenario_eco_i));
           fprintf('Annual expected damage: %2.2f mn\n',EDS4(ed_i).ED/1000000)
           %entity.measures = climada_measures_construct([],1);
           %entity.measures.name{1} = 'control';
           %measures_impact4(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
           %for i = 1:length(measures_impact4(ed_i).EDS)
           %    % convert back to UTM
           %    [measures_impact4(ed_i).EDS(i).assets.X,measures_impact4(ed_i).EDS(i).assets.Y] = ...
           %        ll2utm_shift(measures_impact4(ed_i).EDS(i).assets.lat,measures_impact4(ed_i).EDS(i).assets.lon);
           %end
       end
       % EDS5 for climate change scenario: future entity 2050, future hazard 2050
       if scenario_eco_i == 2
           cc_scen = 'extreme';
       else 
           cc_scen = 'moderate';
       end
       [hazard,h_i] = barisal_get_hazard(year_f,cc_scen,peril_ID,hazard_files);
       [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
       fprintf('\n***** Scenario %d, EDS5 for %s | %s *****\n',scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       %scen_name5 = ['Increase; from ' cc_scen '; climate change; ' num2str(year_f)];
       scen_name5 = sprintf('Increase;from %s;climate change;%d',cc_scen,num2str(year_f));
       if ~EDS_only
           measures_impact5(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
           measures_impact5(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_cc_' cc_scen '_' num2str(year_f) '.mat'];
           for i = 1:length(measures_impact5(ed_i).EDS)
               % convert back to UTM
               [measures_impact5(ed_i).EDS(i).assets.X,measures_impact5(ed_i).EDS(i).assets.Y] = ...
                   ll2utm_shift(measures_impact5(ed_i).EDS(i).assets.lat,measures_impact5(ed_i).EDS(i).assets.lon);
           end
           save(measures_impact5(ed_i).filename,'measures_impact5')
       else
           EDS5(ed_i)    = climada_EDS_calc(entity,hazard,'',1,silent_mode,sanity_check);
           fprintf('Annual expected damage: %2.2f mn\n',EDS5(ed_i).ED/1000000)
       end
   end
   %save([results_dir filesep sprintf('EDS_scenario_%d.mat',scenario_eco_i)], 'EDS1', 'EDS2', 'EDS3', 'EDS4', 'EDS5')
   clear EDS1 EDS2 EDS3 EDS4 EDS5
nd %scenario_eco_i
%
I_EDS_report_xls = [results_dir filesep 'BCC_ED_report_Measure_package_' datestr(now,'ddmmyy') '.xls'];
f ~EDS_only
   for m = [1 3 5]
       measures_impact = eval(['measures_impact' num2str(m)]);
         eval(['MI_EDS_combined' num2str(m) ' = climada_measures_impact_report(measures_impact,''NO_SAVE''); '])
       eval(['MI_EDS_combined' num2str(m) ' = climada_measures_impact_report(measures_impact,MI_EDS_report_xls); '])
   end
nd
%
 plotting frenzy
 for ed_i = 1:length(EDS1)
     climada_ED_plot(EDS1(ed_i), 0,'BDT',0,0)
     print(gcf,'-dpng',[results_dir filesep 'BCC_dmg_slums_' strrep(strtok(EDS1(ed_i).hazard.comment,','),' ','_') '.png'])
     climada_shapeplotter(BCC_wards_ll,'','linewidth',1,'color',[81 81 81]/255);
     close
     climada_ED_plot(EDS3(ed_i), 0,'BDT',0,0)
     print(gcf,'-dpng',[results_dir filesep 'BCC_dmg_slums_' strrep(strtok(EDS3(ed_i).hazard.comment,','),' ','_') '.png'])
     climada_shapeplotter(BCC_wards_ll,'','linewidth',1,'color',[81 81 81]/255);
     close
     climada_ED_plot(EDS5(ed_i), 0,'BDT',0,0)
     print(gcf,'-dpng',[results_dir filesep 'BCC_dmg_slums_' strrep(strtok(EDS5(ed_i).hazard.comment,','),' ','_') '.png'])
     climada_shapeplotter(BCC_wards_ll,'','linewidth',1,'color',[81 81 81]/255);
     close
 end
% measures impact (benefits) report per peril
arisal_MI_per_peril(measures_impact5,measures,peril_IDs)
% multi peril waterfall graph
ear_i = 2014;
cen_name1 = ['Today''s; expected damage; ' num2str(year_i)];
ear_f = 2030;
co_scen    = [1 2 3];scenario_eco_i = 2;
cen_name2 = sprintf('Increase;from economic;growth %d;scenario %d',num2str(year_f),eco_scen(scenario_eco_i));
c_scen = 'moderate';
cen_name3 = sprintf('Increase;from %s;climate change;%d',cc_scen,num2str(year_f));
f exist('EDS1','var') &amp&amp exist('EDS2','var') &amp&amp exist('EDS3','var') &amp&amp exist('EDS4','var') &amp&amp exist('EDS5','var')
   % multi peril waterfall 2030
   fig = climada_waterfall_graph_multi_peril(0,'BDT',EDS1,scen_name1,EDS2,scen_name2,EDS3,scen_name3);
   print(fig,'-dpng',[results_dir filesep 'BCC_waterfall_multi_peril_2030_' char(cc_scen) '.png'])
   % multi peril waterfall 2050
   fig = climada_waterfall_graph_multi_peril(0,'BDT',EDS1,scen_name1,EDS4,scen_name4,EDS5,scen_name5);
   print(fig,'-dpng',[results_dir filesep 'BCC_waterfall_multi_peril_2050_' char(cc_scen) '.png'])
   
   % multi horizon waterfall (watch out! may be a bit dodgy...)
   %fig = climada_waterfall_graph_2timehorizons('AED',0,'BDT',...
   %    MI_EDS_combined1(end),   ...
   %    MI_EDS_combined2(end),   ...
   %    MI_EDS_combined3(end),   ...
   %    MI_EDS_combined4(end),   ...
   %    MI_EDS_combined5(end)          );
   %print(fig,'-dpng',[results_dir filesep 'BCC_waterfall_multi_horizon_' char(cc_scen) '.png'])
nd
or s_i = [1 3 5]
   MI_EDS_combined = eval(['MI_EDS_combined' num2str(s_i)]);
   for ed_i = 1:length(MI_EDS_combined)
       % use UTM X/Y instead of lat/lon, temporarily overwrite lat/lon
       MI_EDS_combined(ed_i).assets.lon = MI_EDS_combined(ed_i).assets.X;
       MI_EDS_combined(ed_i).assets.lat = MI_EDS_combined(ed_i).assets.Y;
       climada_MI_plot(MI_EDS_combined(ed_i), 0,'BDT',0,0,1)
       climada_shapeplotter(BCC_wards_ll,'','x','y','linewidth',1,'color',[81 81 81]/255);
       print(gcf,'-dpng',[results_dir filesep 'BCC_measure_benefit_' ...
           strrep(MI_EDS_combined(ed_i).annotation_name,' ','_') '_' ...
           num2str(MI_EDS_combined(1).reference_year) '.png'])
       close
   end
nd
lear -regexp ^scen_name\d{1}$
lear m measures_impact cc_scen ed_i s_i 
% baseline EDS for ED report for Ecorys
 EDS_baseline = [EDS1 EDS2 EDS3 EDS4 EDS5]; save([results_dir filesep 'EDS_baseline.mat'],'EDS_baseline')
limada_global.present_reference_year = 2014;
co_scen    = [1 2 3];
c_scen     = 'moderate';
or scenario_eco_i = 1:numel(eco_scen)
   clear EDS_baseline 
   
   load([results_dir filesep sprintf('EDS_scenario_%d.mat',eco_scen(scenario_eco_i))])
   
   if scenario_eco_i == 2
       cc_scen = 'extreme';
   else 
       cc_scen = 'moderate';
   end
   % annotation 
   year_i = 2014;
   scen_name1 = ['Today''s; expected damage; ' num2str(year_i)];
   year_f = 2030;
   scen_name2 = sprintf('Increase\nfrom economic\ngrowth %d,\nscenario %d',year_f,eco_scen(scenario_eco_i));
   scen_name3 = sprintf('Increase\nfrom %s\nclimate change\n%d',cc_scen,year_f);
   year_f = 2050;
   scen_name4 = sprintf('Increase\nfrom economic\ngrowth %d,\nscenario %d',year_f,eco_scen(scenario_eco_i));
   scen_name5 = sprintf('Increase\nfrom %s\nclimate change\n%d',cc_scen,year_f);
   
   % multi peril waterfall 2030
   fig = climada_waterfall_graph_multi_peril(0,'BDT',EDS1,scen_name1,EDS2,scen_name2,EDS3,scen_name3);
   print(fig,'-dpdf',[results_dir filesep sprintf('BCC_waterfall_multi_peril_scenario_%d_2030_%s.pdf',eco_scen(scenario_eco_i),char(cc_scen))])
   % multi peril waterfall 2050
   fig = climada_waterfall_graph_multi_peril(0,'BDT',EDS1,scen_name1,EDS4,scen_name4,EDS5,scen_name5);
   print(fig,'-dpdf',[results_dir filesep sprintf('BCC_waterfall_multi_peril_scenario_%d_2050_%s.pdf',eco_scen(scenario_eco_i),char(cc_scen))])
     EDS_baseline = [EDS1 EDS3 EDS5]; %save([results_dir filesep 'EDS_baseline.mat'],'EDS_baseline')
     EDS_report_xls = [results_dir filesep sprintf('BCC_ED_report_scenario_%d_%s.xls',eco_scen(scenario_eco_i),datestr(now,'yyyymmdd'))];
     EDS_report_csv = [results_dir filesep sprintf('BCC_ED_report_scenario_%d_%s.csv',eco_scen(scenario_eco_i),datestr(now,'yyyymmdd'))];
 
     if exist(EDS_report_xls,'file'), delete(EDS_report_xls); end
     % convert back to UTM
     for ed_i = 1:length(EDS_baseline)
         [EDS_baseline(ed_i).assets.X,EDS_baseline(ed_i).assets.Y] = ...
             ll2utm_shift(EDS_baseline(ed_i).assets.lat,EDS_baseline(ed_i).assets.lon);
         EDS_baseline(ed_i).peril_ID = '';
     end
 
     % write to csv
     % climada_EDS_ED_at_centroid_report(EDS_baseline,EDS_report_csv);
 
     % write to excel
     climada_EDS_ED_at_centroid_report_xls(EDS_baseline,EDS_report_xls,'ED_at_centroid');
     
     % write ED per category report
     benefit_flag = 0;
     assets_flag = 1;
     output_report = climada_EDS_ED_per_category_report(entity, EDS_baseline, EDS_report_xls,'ED_per_category',benefit_flag,0,assets_flag);
nd
lear peril_ID peril year_i year_f EDS_only EDS_report_xls h_i e_i peril_IDs CC_SCEN YEAR_F EDS_report_csv
% damage calc
 This section has become somewhat redundant.
 calculate EDS for each entity-hazard pair, where they have coinciding
 reference years and the correct peril_ID matching. Store as struct array
 and save as EDS_save_file
DS_save_file = [results_dir filesep 'BCC_EDS_' datestr(now,'ddmmyy') '.mat'];
DS_load_file = [results_dir filesep 'BCC_EDS_090615.mat'];
DS_force_recalc = 0;
f exist(EDS_load_file,'file') &amp&amp ~EDS_force_recalc
   load(EDS_load_file)
lse
   EDS        = climada_EDS_multi_calc(entity_files,hazard_files,EDS_save_file,1,0);
nd
 But this may still be useful to get the total asset base into the EDS
 struct for climada_ED_plot
 total value from max of flood entity and cyclone entity at each point
or i = 1:5
   EDS = eval(['EDS' num2str(i)]);
   for ed_i = 1:length(EDS)
       ndx = find([EDS.reference_year] == EDS(ed_i).reference_year);
       max_val = [];
       for ndx_i = ndx
           max_val = max([max_val EDS(ndx_i).assets.Value],[],2);
       end
       
       EDS(ed_i).Value_total = sum(max_val);
   end
   eval(['EDS' num2str(i) '=EDS;']);
nd
lear max_val ndx EDS_force_recalc ed_i EDS_load_file EDS_save_file ndx_i
% multi peril adaptation cost curve
 set parameters to key scenario 2030, moderate climate change, so far
 measures for flood only (TC wind excluded)
azard_ref_year = 2030;
ntity_ref_year = 2030;
c_scen         = 'extreme'; %{'moderate' 'extreme'};
eril_IDs       = {'FL_depth_monsoon' 'FL_duration_monsoon' 'FL_depth_cyclone' 'FL_duration_cyclone'};
 init
easures_impact = [];
 load flood entity, is always the same and does not need to be reloaded in
 the loop
ntity = barisal_get_entity(entity_ref_year,'flood',entity_files);
ntity.measures.cost = (entity.measures.cost)*0 + 10^4;
 loop over the four different flood perils
or peril_i = 1:length(peril_IDs)
   
   % load hazard
   hazard = barisal_get_hazard(hazard_ref_year,cc_scen,peril_IDs(peril_i),hazard_files);
   
   % calculate measures impact
   measures_impact_peril = climada_measures_impact_advanced(entity,hazard,'no');
   
   % combine measures_impact with measures_impact, that will contain the
   % added up benefits and cost_benefit_ratio
   if isempty(measures_impact)
       fprintf('\t-Start with measures impact from %s. \n', peril_IDs{peril_i})
       measures_impact = measures_impact_peril;
   else
       fprintf('\t-Add measures impact from %s. \n', peril_IDs{peril_i})
       measures_impact = climada_measures_impact_combine(measures_impact,measures_impact_peril);
   end
nd
 finally create figure (multi peril adaptation cost curve)
igure
arisal_adaptation_cost_curve(measures_impact,[],[],[],0,0,1,0)
itlestr = sprintf('Barisal, %d, %s climate change', hazard_ref_year, CC_SCEN);
itle({titlestr;'All perils combined (FL depth, duration, monsoon and cyclone, except TC wind)'})
azard_name = 'all_perils';
ntity_name = '2030_moderate_cc';
rint(gcf,'-dpng',[results_dir filesep 'CBA_Barisal_BCC_' hazard_name '_' entity_name '.png']) % save as png
% measures impact for specific scenario
 calculate the impact of measures for 1 scenario specified below
azard_ref_year = 2014;
ntity_ref_year = 2030;
eril_ID        = 'FL_depth_monsoon'; % Should be found in hazard filename
eril           = 'floods';           % Should be found in entity filename
c_scen         = '';                 % Should be found in hazard filename
 retrieve relevant hazard and entity. The index (h_i/e_i) is for the cell
 arrays containing respective filenames
hazard,h_i] = barisal_get_hazard(hazard_ref_year,cc_scen,peril_ID,hazard_files);
entity,e_i] = barisal_get_entity(entity_ref_year,peril,entity_files);
 get name of entity/hazard
~,hazard_name] = fileparts(hazard_files{h_i});
~,entity_name] = fileparts(entity_files{e_i});
 calculate impact
printf('%s | %s | %d\n',entity.assets.comment,hazard.comment,hazard.reference_year) % to monitor
ntity.measures.cost = (entity.measures.cost)*0 + 10^4;
easures_impact = climada_measures_impact_advanced(entity,hazard,'no');
 plot cost curve (barisal_adaptation_cost_curve is identical to climada_adaptation_cost_curve
 but sets currency to BDT)
 measures_impact.measures.cost = zeros(size(measures_impact.measures.cost))+10^4;
igure
arisal_adaptation_cost_curve(measures_impact,[],[],[],0,0,1,0)
rint(gcf,'-dpng',[results_dir filesep 'CBA_' hazard_name '_' entity_name '.png']) % save as png
lear hazard_ref_year entity_ref_year peril_ID peril cc_scen hazard_name entity_name
% stats for Gerbrand v Bork
ard_ndx = [32 34 27 28 33 29 30]; %shape index for wards 1-7
or ward_i = ward_ndx
   [POI.lon(find(ward_ndx == ward_i)),POI.lat(find(ward_ndx == ward_i))] ...
       = utm2ll_shift(mean(BCC_wards(ward_i).BoundingBox(:,1)),...
       mean(BCC_wards(ward_i).BoundingBox(:,2)));
   POI.name{find(ward_ndx == ward_i)}= BCC_wards(ward_i).UNION_NAME;
nd
azard = barisal_get_hazard(2030,'extreme','FL_duration_monsoon',hazard_files);
FC = climada_hazard2IFC(hazard,POI,1);
lear POI ward_i ward_ndx
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_risk_calculations.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_tc_hazard_prob">
<H2>barisal_tc_hazard_prob</H2></A>
amplt&amplt&amplt&amplt&amplt&amplt&amplt HEAD
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
% plot historical tc tracks
c_track_file = [climada_global.data_dir filesep 'tc_tracks' filesep 'tracks_n_indian_proc'];
oad(tc_track_file)
ig = climada_figuresize(0.5,0.7);
heck_country = 'Bangladesh';
eep_boundary = 0;
limada_plot_world_borders(1,check_country,'',keep_boundary,'');
rack_count = numel(tc_track);
or track_i = 1:track_count
   h = climada_plot_tc_track_stormcategory(tc_track(track_i),5,[]);
nd
add legend, makes it quite slow
limada_plot_tc_track_stormcategory(0,8,1);
xis equal
xis([79 98 14 28])
 axis([70 110 06 32])   
ilename = [filesep 'results' filesep 'TC_tracks_NIO_hist.pdf'];
rint(fig,'-dpdf',[climada_global.data_dir filename])
printf('figure saved in %s \n', filename) 
atestr(tc_track(1).datenum(1))
atestr(tc_track(end).datenum(end))
% create tc track probabilistic for barisal
c_track_file = [climada_global.data_dir filesep 'tc_tracks' filesep 'tracks_n_indian_proc'];
oad(tc_track_file)
c_track_save = [tc_track_file '_prob.mat'];
ns_size      = 9;
ns_amp       = 0.2; %degree
axangle      = pi/4;
c_track      = climada_tc_random_walk_position_windspeed(tc_track,tc_track_save,ens_size,ens_amp,maxangle,1, 0);
 ens_amp  = [];
 Maxangle = [];
 tc_track_out  = climada_tc_random_walk(tc_track,ens_size,ens_amp,Maxangle,0);
ave(tc_track_save, 'tc_track')
oad(tc_track_save)
% create tc track figure
 load BCC boundaries file
hp_mat_file = [climada_global.data_dir filesep 'results' filesep 'BCC_boundary_shp.mat'];
oad(shp_mat_file)
ig = climada_figuresize(0.5,0.7);
vent_i = 173;
heck_country = 'Bangladesh';
eep_boundary = 0;
limada_plot_world_borders(1,check_country,'',keep_boundary,'');
or t_i = (event_i-1)*(ens_size+1)+1:1:(event_i+0)*(ens_size+1)  %1:numel(tc_track)
   if tc_track(t_i).orig_event_flag == 1
       plot(tc_track(t_i).lon, tc_track(t_i).lat,'.-r','markersize',3)
       hold on
   else
       plot(tc_track(t_i).lon, tc_track(t_i).lat,'.-b','markersize',3)
       hold on
   end
nd
or s_i = 1:numel(BCC_boundary)
   plot(BCC_boundary(s_i).X, BCC_boundary(s_i).Y,'-k');
nd
xis([82 97 17 28])
xis equal
 axis([82 97 17 28])
xis([70 110 06 32])
label('Longitude'); ylabel('Latitude')
oldername  = [filesep 'results' filesep 'Sidr_probabilistic_daughters.pdf'];
rint(fig,'-dpdf',[climada_global.data_dir foldername])
 datestr(hazard.datenum(172*4+1:173*4))
 datestr(hazard.datenum((event_i-1)*(ens_size+1)+1:1:event_i*(ens_size+1)))
limada_plot_probabilistic_wind_speed_map(tc_track, (event_i-1)*(ens_size+1)+1)
% footprint figure
 climada_plot_tc_footprint(hazard,tc_track((event_i-1)*(ens_size+1)+1))
 caxis_range = '';
 res=climada_hazard_plot(hazard,(event_i-1)*(ens_size+1)+1);
 
 load([climada_global.modules_dir filesep 'barisal_demo' filesep 'data' filesep 'entities' filesep 'Barisal_BCC_1km_100.mat'])
 focus_region = [70 110 06 32];
 check_mode = '';
 tc_track_1 = tc_track((event_i-1)*(ens_size+1)+1);
 hazard = climada_event_damage_data_tc(tc_track_1,entity,'',0,check_mode,focus_region);
 climada_event_damage_animation
% create probabilistic tc hazard set
entroids_file  = [climada_global.centroids_dir filesep 'Barisal_BCC_centroids'];
oad(centroids_file)
azard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_TC_prob'];
azard = climada_tc_hazard_set(tc_track, hazard_set_file, centroids);
 tweek the frequencies
azard.frequency_ori = hazard.frequency;
azard.frequency     = hazard.frequency_ori*6;
 ori_flag          = logical(hazard.orig_event_flag);
 hazard.frequency(ori_flag) = hazard.frequency_ori(ori_flag);
ave(hazard_set_file,'hazard')
 add tc track category manually
 hazard.category = [tc_track.category];
 hazard.category(hazard.category&amplt0) = 0;
 just loading not calculating
azard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_TC_prob'];
oad(hazard_set_file)
% view wind results in Barisal (centroid ID 30)
entroid_ID = [30];
FC = climada_hazard2IFC(hazard, centroid_ID);
lose all
limada_IFC_plot(IFC,0)
oldername  = [filesep 'results' filesep 'TC_wind_intensity_Barisal.pdf'];
rint(gcf,'-dpdf',[climada_global.data_dir foldername])
% was the max event Sidr? (Nov 2007)
rig_event_flag = logical(hazard.orig_event_flag);
int_max indx]  = max(full(hazard.intensity(orig_event_flag,centroid_ID)));
ndx = (indx-1)*(ens_size+1)+1;
azard.name{indx}
atestr(hazard.datenum(indx))
 yes, this is Sidr: 46.8 m/s at centroid_ID 30, 10 Nov 2007
 datestr(hazard.datenum(172*4+1:173*4))
 int_Sidr = full(hazard.intensity(172*10+1,centroid_ID))
 event_i = 172*4+1;
 figure
 res=climada_hazard_plot(hazard,event_i,'','','');
 res=climada_hazard_plot(hazard,event_i+1,'','','');
 figure
 res=climada_hazard_plot(hazard,event_i+2,'','','');
 figure
 res=climada_hazard_plot(hazard,event_i+3,'','','');
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/barisal_tc_hazard_prob.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_ED_at_centroid_report_xls">
<H2>climada_EDS_ED_at_centroid_report_xls</H2></A>
<font color="blue">function climada_EDS_ED_at_centroid_report_xls(EDS,xls_file,sheet,varargin) </font>
 climada
 NAME:
   climada_EDS_ED_at_centroid_report
 PURPOSE:
   Write out ED at centroids for one or multiple EDS structures into .csv
   file
   previous call: climada_EDS_calc
 CALLING SEQUENCE:
   climada_EDS_ED_at_centroid_report(EDS,entity,xls_file)
 EXAMPLE:
   climada_EDS_ED_at_centroid_report(climada_EDS_calc(climada_entity_read), climada_entity_read)
 INPUTS:
   EDS: either an event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       SPECIAL: we also accept a structure which contains an EDS, like
       measures_impact.EDS
       if EDS has the field annotation_name, the legend will show this
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   xls_file: filename (and path) to save the report to (as .xls), if
       empty, prompted for
 OUTPUTS:
   none, report file written as .xls
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150430, init
 Gilles Stassen, gillesstassen@hotmail.com, 20150625, generalisation with varargin
 Lea Mueller, muellele@gmail.com, 20150730, check that category iscell, otherwise convert to cell from numeric
 Lea Mueller, muellele@gmail.com, 20150805, check if data is on lat/lon or X/Y basis
 Lea Mueller, muellele@gmail.com, 20150910, check first lat/lon, then additionally X/Y can be added
 Lea Mueller, muellele@gmail.com, 20150930, ignore EDS that contains different length of centroids
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/climada_EDS_ED_at_centroid_report_xls.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_multi_calc">
<H2>climada_EDS_multi_calc</H2></A>
<font color="blue">function [EDS, hazards, entities] = climada_EDS_multi_calc(entities,hazards,EDS_save_file,sync_check,check_plots) </font>
 damage calc for combination of hazards and entities
lobal climada_global
f ~climada_init_vars, return; end
f ~exist('entities',       'var'), entities        = '';   end
f ~exist('hazards',        'var'), hazards         = '';   end
f ~exist('EDS_save_file',  'var'), EDS_save_file   = '';   end
f ~exist('sync_check',     'var'), sync_check      = 1;    end
f ~exist('check_plots',    'var'), check_plots 	= 0;    end
odule_data_dir=[fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
 prompt for entity
f isempty(entities)
   entities=[module_data_dir filesep 'entities' filesep '*.mat'];
   [fN, fP] = uigetfile(entities, 'Select entities:','MultiSelect','on');
lse
   if ischar(entities) % only one filename passed
       [fP, fN] = fileparts(entities);
       if ~climada_check_matfile(entities)
           climada_entity_read(entities,'NOENCODE')
       end
       fN = [fN '.mat'];
   elseif iscellstr(entities) % multiple filenames passed in 
       for e_i = 1:length(entities)
           [fP, fN{e_i}] = fileparts(entities{e_i});
           fN{e_i} = [fN{e_i} '.mat'];
       end   
   end
nd
lear entities
f isequal(fN,0) || isequal(fP,0)
   return; % cancel
lse
   if iscell(fN)
       fmt_str = '%s';
       for e_i = 1 : length(fN)
           msg_str = sprintf('loading entity file: %s',fN{e_i});
           fprintf(fmt_str,msg_str)
           fmt_str = [repmat('\b',size(msg_str)) '%s'];
           load(fullfile(fP,fN{e_i}));
           if ~exist('entity','var'), cprintf([1 0 0],'ERROR: invalid entity file \n'); return; end
           entities(e_i) = entity;
           % for consistency
           entities(e_i).assets.filename = fullfile(fP,fN{e_i});
       end
       fprintf(fmt_str,'entity files loaded \n')
   else
       fprintf('loading entity file: %s... ',fN);
       load(fullfile(fP,fN));
       if ~exist('entity','var'), cprintf([1 0 0],'ERROR: invalid entity file \n'); return; end
       entities = entity;
       % for consistency
       entities(e_i).assets.filename = fullfile(fP,fN{e_i});
       fprintf('done \n')
   end
   clear entity
nd
or e_i = 1:length(entities)
   if ~isfield(entities(e_i).assets,'reference_year')
       entities(e_i).assets.reference_year = climada_global.present_reference_year;
   end
   
   flds = fieldnames(entities(e_i).assets);
   rm_flds = {};
   for fld_i = 1:length(flds)
       if strfind(flds{fld_i},'Value_')
           rm_flds(end+1) = flds(fld_i);
           
           tmp_assets          = entities(e_i).assets;
           %             tmp_assets          = rmfield(entity(e_i).assets,flds{fld_i});
           
           tmp_assets.Value    = entities(e_i).assets.(flds{fld_i});
           C = strsplit(flds{fld_i},'_');
           tmp_assets.reference_year = str2double(C{2});
           
           entities(end+1).damagefunctions   = entities(e_i).damagefunctions;
           entities(end).measures            = entities(e_i).measures;
           entities(end).discount            = entities(e_i).discount;
           entities(end).assets              = tmp_assets;
           
       end
       clear tmp_assets
   end
nd
or e_i = 1:length(entities)
   a_flds = fieldnames(entities(e_i).assets);
   for a_fld_i = 1:length(a_flds)
       if ismember(a_flds{a_fld_i},rm_flds)
           entities(e_i).assets  = rmfield(entities(e_i).assets,a_flds{a_fld_i});
       end
   end
nd
lear e_i a_flds a_fld_i flds fld_i rm_flds
 fields necessary for damage calc
 prompt for hazard set
f isempty(hazards)
   hazards=[module_data_dir filesep 'hazards' filesep '*.mat'];
   [fN, fP] = uigetfile(hazards, 'Select hazard:','MultiSelect','on');
lse
   if ischar(hazards) % only one filename passed
       [fP, fN] = fileparts(hazards);
       fN = [fN '.mat'];
   elseif iscellstr(hazards) % multiple filenames passed in 
       for h_i = 1:length(hazards)
           [fP, fN{h_i}] = fileparts(hazards{h_i});
           fN{h_i} = [fN{h_i} '.mat'];
       end
   end
nd
lear hazards
f isequal(fN,0) || isequal(fP,0)
   return; % cancel
lse
   if iscell(fN)
       fmt_str = '%s'; hazards = {};
       for h_i = 1 : length(fN)
           msg_str = sprintf('loading hazard file: %s',fN{h_i});
           fprintf(fmt_str,msg_str)
           fmt_str = [repmat('\b',size(msg_str)) '%s'];
           load(fullfile(fP,fN{h_i}));
           if ~exist('hazard','var'), cprintf([1 0 0],'ERROR: invalid hazard file \n'); return; end
           
           if ~isfield(hazard,'reference_year')
               cprintf([1 0.5 0],sprintf('WARNING: no reference year for %s - using default %4.0f\n',...
                   fN{h_i},climada_global.present_reference_year));
               hazard.reference_year = climada_global.present_reference_year;
           end
           
           % for consistency
           hazard.filename = fullfile(fP,fN{h_i});
           hazard.comment = strrep(strtok(fN{h_i},'.'),'_',' ');
           hazards{h_i}=hazard;
           
       end
       fprintf(fmt_str,'hazard files loaded \n');
   else
       fprintf('loading hazard file: %s... ',fN);
       load(fullfile(fP,fN));
       if ~exist('hazard','var'), cprintf([1 0 0],'ERROR: invalid hazard file \n'); return; end
       
       if ~isfield(hazard,'reference_year')
           cprintf([1 0.5 0],sprintf('WARNING: no reference year for %s - using default %4.0f\n',...
               fN{h_i},climada_global.present_reference_year));
           hazard.reference_year = climada_global.present_reference_year;
       end
       
       % for consistency
       hazard.filename = fullfile(fP,fN);
       hazard.comment = strrep(strtok(fN{h_i},'.'),'_',' ');
       hazards={hazard};
       fprintf('done \n')
   end
   clear hazard
nd
d_i = 0;
or e_i = 1: length(entities)
   for h_i = 1: length(hazards)
       hazard_i = hazards{h_i};
       
       if sync_check &amp&amp (hazard_i.reference_year ~= entities(e_i).assets.reference_year) ...
               &amp&amp (~(~isempty(strfind(entities(e_i).assets.comment,'Flood')) &amp&amp strcmp(hazard_i.peril_ID,'FL')) ...
               || ~(~isempty(strfind(entities(e_i).assets.comment,'Cyclone')) &amp&amp strcmp(hazard_i.peril_ID,'TC')))
           continue;
       end
       
       ed_i = ed_i +1;
         fprintf('hazard.comment = ''%s'' \n- would you like to use this for the EDS annotation?\n',hazard(h_i).comment)
         h_str = input('to continue press ''y'', otherwise type a new hazard title:\n','s');

         if strcmp(h_str,'y'),   h_str = hazard(h_i).comment;        end

        	fprintf('entity.assets.comment = ''%s'' \n- would you like to use this for the EDS annotation?\n',entity(e_i).assets.comment)
         e_str = input('to continue press ''y'', otherwise type a new entity title:\n','s');

         if strcmp(e_str,'y'),   e_str = entity(e_i).assets.comment; end
       
       h_str = hazard_i.comment;
       e_str = entities(e_i).assets.comment;
       
         annotation  = sprintf('%s | %s (%d)',h_str,e_str,entities(e_i).assets.reference_year);
       annotation  = sprintf(h_str);
       EDS(ed_i)   = climada_EDS_calc(entities(e_i),hazard_i,annotation);
       if EDS(ed_i).ED == 0
           msg = sprintf('WARNING: expected damage equals zero for entity %s and hazard %s, removing from EDS structure\n',...
               e_str,h_str);
           cprintf([1 0.5 0],msg)
           EDS(ed_i) = [];
           ed_i = ed_i - 1;
       end
   end
nd
f ~isempty(EDS_save_file) &amp&amp ischar(EDS_save_file) &amp&amp ~strcmp(EDS_save_file,'NO_SAVE')
   save(EDS_save_file,'EDS')
lseif isempty(EDS_save_file)
   uisave('EDS',[module_data_dir filesep 'results' filesep 'multi_EDS.mat']);
nd
f check_plots
   figure('color','w','name',annotation)
   climada_ED_plot(EDS,0);
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/climada_EDS_multi_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ED_plot_per_point">
<H2>climada_ED_plot_per_point</H2></A>
<font color="blue">function fig = climada_ED_plot_per_point(EDS, BCC_wards, timehorizon, hazard_name) </font>
 create figure to plot expected damage per ward in barisal
 MODULE: 
   barisal_demo
 NAME:
   climada_ED_plot_per_ward
 PURPOSE:
   plot annual expected damage per ward on a map
 CALLING SEQUENCE:
   fig = climada_ED_plot_per_ward(EDS,entity, BCC_wards, timehorizon, hazard_name)
 EXAMPLE:
   fig = climada_ED_plot_per_ward(EDS,entity, BCC_wards, timehorizon, hazard_name)
 INPUTS:
   EDS: event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       EDS can contain multiple EDS, however default is that first EDS
       will be used.
   entity: an entity (see climada_entity_read)
       &ampgt promted for if not given
   BCC_wards: structure with shape file (polygons for all 30 wards in
       Barisal)
 OPTIONAL INPUT PARAMETERS:
   timehorizon: just for figure title, empty if not specified
   hazard_name: just for figure title, empty if not specified
 OUTPUTS:
   figure with damage per ward on a map 
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150429, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/climada_ED_plot_per_point.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_MI_plot">
<H2>climada_MI_plot</H2></A>
<font color="blue">function climada_MI_plot(EDS, percentage_of_value_flag,currency,unit_exp,logscale_check,schematic_check) </font>
 visualize Annual Expected Damage per centroid as a map
 NAME:
   climada_MI_plot
 PURPOSE:
   plot annual expected measure impact
 CALLING SEQUENCE:
   climada_MI_plot(EDS, percentage_of_value_flag)
 EXAMPLE:
   climada_MI_plot(EDS, percentage_of_value_flag)
 INPUTS:
   EDS output from climada_measures_impact_report (which has field
   .MI_at_centroid)
 OPTIONAL INPUT PARAMETERS:
   percentage_of_value_flag: Set to 1 if you wish to plot damages as
                             percentage of asset values
 OUTPUTS:
   figure
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150625 init
 Gilles Stassen, gillesstassen@hotmail.com, 20150628 - schematic_check added
 Lea Mueller, muellele@gmail.com, 20150706, add switch for UTM instead of lat/lon coordinates, inhibit limiting latitude values to -60 and +80
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/climada_MI_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_advanced">
<H2>climada_measures_impact_advanced</H2></A>
<font color="blue">function measures_impact=climada_measures_impact_advanced(entity,hazard,measures_impact_reference,measures,map_risk_premium,sanity_check) </font>
 special measures impact function for Barisal
 MODULE:
   barisal_demo
 NAME:
   climada_measures_impact_advanced
 PURPOSE:
   special measures impact function for barisal, that includes hazard
   modification files (i.e. absolute or percentage reduction of flood
   depths and duration)
   see climada_measures_impact for more information
 CALLING SEQUENCE:
   measures_impact = climada_measures_impact_advanced(entity,hazard,measures_impact_reference,measures,map_risk_premium,sanity_check)
 EXAMPLE:
   measures_impact = climada_measures_impact_advanced % all prompted for
   hazard_set_file='...\climada\data\hazards\TCNA_A_Probabilistic.mat';
   measures_impact=climada_measures_impact(climada_entity_read('',hazard_set_file),hazard_set_file,'no')
   measures_impact=climada_measures_impact('','','','',1) % all interactive, show risk premium map
 INPUTS:
   entity: a read and encoded assets and damagefunctions file, see climada_assets_encode(climada_assets_read)
       &ampgt promted for if not given
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   measures_impact: a structure with
       EDS(measure_i): the event damage set for each measure, last one EDS(end) for no measures
       ED(measure_i): the annual expected damage to the assets under measure_i,
           last one ED(end) for no measures
       benefit(measure_i): the benefit of measure_i
       cb_ratio(measure_i): the cost/benefit ratio of measure_i
       measures: just a copy of measures, so we have all we need together
       title_str: a meaningful title, of the format: measures @ assets | hazard
       NOTE: currently measures_impact is also stored (with a lengthy filename)
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150611, created from
               original climada_measures_impact; added functionality for
               hazard_event_set_operator &amp measures_distributed
 Gilles Stassen, gillesstassen@hotmail.com, 20150616, entity switch added
 Lea Mueller, muellele@gmail.com, 20150902, rename to hazard_intensity_impact_b from hazard_intensity_impact
 Lea Mueller, muellele@gmail.com, 20151116, add regional scope, add documentation
 Lea Mueller, muellele@gmail.com, 20151127, add measures_impact.scenario
 Lea Mueller, muellele@gmail.com, 20151202, invoke climada_measures_impact_discount
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/climada_measures_impact_advanced.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_waterfall_graph_multi_peril">
<H2>climada_waterfall_graph_multi_peril</H2></A>
<font color="blue">function  fig = climada_waterfall_graph_multi_peril(check_printplot,currency,varargin) </font>
 waterfall figure, expected damage for specified return period for
 - today,
 - increase from economic growth,
 - increase from high climate change, total expected damage 2030
 for multiple hazard types (flood, cyclone, etc). Hardwired for Barisal,
 see event_selection, which lists the index of today's damage for
 different hazard types.
 NAME:
   climada_waterfall_graph_barisal_combined
 PURPOSE:
   plot waterfall graph based on annual expected damage for different hazard types
 CALLING SEQUENCE:
   fig = climada_waterfall_graph_barisal_combined(EDS, check_printplot)
 EXAMPLE:
   climada_waterfall_graph_barisal_combined
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   EDS: multiple event damage sets that contain scenarios on today,
   economic growth, climate change for a future time horizon, for
   different hazard types. The vector event_selection points to today's
   damage fordifferent hazard types.
 OUTPUTS:
   waterfall graph
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150610, init
 Lea Mueller, muellele@gmail.com, 20150917, add special colours for Barisal
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/climada_waterfall_graph_multi_peril.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="BCC_plot">
<H2>BCC_plot</H2></A>
<font color="blue">function BCC_plot </font>
 climada
 MODULE
   barisal_demo
 NAME:
   BCC_plot
 PURPOSE:
   plot Barisal map, including all relevant information (BCC GIS, BCC wards 
   polygon and open data). Hardwired for Barisal.
 CALLING SEQUENCE:
   BCC_plot
 EXAMPLE:
   BCC_plot
 INPUTS:
   none, all hardwired for Barisal
 OUTPUTS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150305, 
 Lea Mueller, muellele@gmail.com, 20150506, add new BCC ward polygons
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/BCC_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_barisal_entity_prepare">
<H2>_barisal_entity_prepare</H2></A>
% prepare barisal entity
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
% --------------------
  FLOOD
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/_barisal_entity_prepare.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_barisal_entity_prepare_ward">
<H2>_barisal_entity_prepare_ward</H2></A>
% prepare barisal entity
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
% --------------------
  FLOOD
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/_barisal_entity_prepare_ward.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_barisal_risk_calculation_excel_old">
<H2>_barisal_risk_calculation_excel_old</H2></A>
% barisal_risk_calculations
 - tc wind hazard: use barisal_tc_hazard_prob.m to create wind hazard
 - flood hazard: read asci-file from Ruud (Witteveen+Bos), load flood hazard
% set hazard type
azard_names = {'flood_depth' 'flood_duration' 'cyclone_wind'}; 
% load barisal specifics
CC_savename = [climada_global.data_dir filesep 'entities' filesep 'BCC_border.mat'];
oad(BCC_savename)
 load BCC ward boundaries (30 polygons, rough indication of polygons only!)
 BCC_wards_savename = [climada_global.data_dir filesep 'entities' filesep 'BCC_wards.mat'];
CC_wards_savename = [climada_global.data_dir filesep 'entities' filesep 'BCC_wards_Ward_no_added.mat'];
oad(BCC_wards_savename)
ndx = strfind(BCC_savename,filesep);
ndx2 = strfind(BCC_wards_savename,filesep);
printf('\t - loaded BCC specifics: %s and %s\n', BCC_savename(indx(end)+1:end), BCC_wards_savename(indx2(end)+1:end))
%
or h_i = 3%1:length(hazard_names)
   
   hazard_name = hazard_names{h_i};
   %% hazard
   switch hazard_name
       case 'flood_depth'
           % hazard = climada_asci2hazard(asci_file);
           hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_FL'];
           flood_depth = 1; flood_duration = 0; cyclone_wind   = 0;
       case 'flood_duration' % hazard duration (too be prepared!)
           hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_FL_duration'];
           flood_duration = 1; flood_depth    = 0; cyclone_wind   = 0;
       case 'cyclone_wind'
           hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_TC_prob'];
           cyclone_wind   = 1; flood_depth    = 0; flood_duration = 0; 
           % wind centroids
           %centroids_file  = [climada_global.data_dir filesep 'system' filesep 'Barisal_BCC_centroids'];
           %load(centroids_file)   
   end
   load(hazard_set_file)
   fprintf('\n-----------\nSELECTED HAZARD TYPE: %s\n-----------\n', hazard_name)
   
   
   %% next time only load entities
   if flood_depth ==1
       entity_filename = [climada_global.data_dir filesep 'entities' filesep '20150416_values_Barisal_flood_depth.mat'];
   elseif flood_duration ==1
       entity_filename = [climada_global.data_dir filesep 'entities' filesep '20150416_values_Barisal_flood_duration.mat'];
   elseif cyclone_wind == 1
       % tc wind
       entity_filename = [climada_global.data_dir filesep 'entities' filesep '20150416_values_Barisal_cyclones.mat'];
   end
   load(entity_filename)
   % create copy
   entity_ori = entity;
   indx = strfind(entity_filename,filesep);
   fprintf('\t - Loaded entity: %s\n', entity_filename(indx(end)+1:end))
   
   
   %% waterfall graph for today, 2030, 2050
   asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
   timehorizon = [2015 2030 2050];
   EDS         = []; 
   silent_mode = 1;
   for t_i = 1:length(timehorizon);
       for cat_i = length(asset_cat)+1%1:length(asset_cat)+1
           switch t_i
               case 1
                   % risk today
                   entity.assets.Value = entity_ori.assets.Value;
                   titlestr = 'Risk today';
               case 2
                   % risk 2030
                   entity.assets.Value = entity.assets.Value_2030;
                   titlestr = 'Socio-economic 2030 (scenario 1)';
               case 3
                   % risk 2050
                   entity.assets.Value = entity.assets.Value_2050;
                   titlestr = 'Socio-economic 2050 (scenario 1)';
           end
           % select only assets in specific category
           if cat_i&amplt=length(asset_cat)
               %indx = strcmp(entity.assets.Category, asset_cat{cat_i});
               indx = ismember(entity.assets.Category, asset_cat(1:cat_i));
               annotation_name = asset_cat{cat_i};
           else
               indx = ones(size(entity.assets.Category));
               annotation_name = 'All asset categories';
           end
           entity.assets.Value(~indx) = 0;
           force_re_encode = 0;
           if isempty(EDS)
               EDS = climada_EDS_calc(entity,hazard,titlestr,force_re_encode,silent_mode);
           else
               %EDS_ = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
               %EDS(cat_i) = EDS_;
               EDS(t_i) = climada_EDS_calc(entity,hazard,titlestr,force_re_encode,silent_mode);
           end
       end %cat_i    
   end %t_i
   climada_waterfall_graph_barisal(EDS(1), EDS(2), EDS(3), 'AED');
   % at the end of calculations, overwrite with original entity again
   entity = entity_ori;
   
   
   
   %% write annual damage results to excel
   buffer_hazard = 0;
   if flood_depth == 1
       indx = strfind(entity_filename,'_');
       xls_filename = sprintf('%s.xls',entity_filename(1:indx(end-1)-1));
       sheet_name = 'assets';
       
   elseif flood_duration == 1   
       indx = strfind(entity_filename,'_');
       xls_filename = sprintf('%s.xls',entity_filename(1:indx(end-1)-1));
       sheet_name = 'assets';
       buffer_hazard = 4;
       
   elseif cyclone_wind == 1
       % tc wind
       indx = strfind(entity_filename,'_');
       xls_filename = sprintf('%s.xls',entity_filename(1:indx(end)-1));
       sheet_name = 'assets cyclones';
       buffer_hazard = 0;
   end
   filename_add = sprintf('_annual_damage_calculated_%s.xls',datestr(now,'YYYYmmDD'));
   new_xls_filename = strrep(xls_filename,'.xls',filename_add);
   new_xls_filename = strrep(new_xls_filename,'entities','results');
   
   if ~exist(new_xls_filename,'file')
       % copy and rename xls-file
       copyfile(xls_filename,new_xls_filename);
   end
   
   % add annual damage column to existing xls-file 
   existing_row_no = numel(fieldnames(entity.assets));
   buffer_rows     = 3;
   row_no          = existing_row_no+buffer_rows+buffer_hazard;
   alphabet_no     = 26;
   if row_no&ampgt=alphabet_no
       multiple = row_no/alphabet_no;
       row_no = rem(row_no, alphabet_no);
       multiple = char('A'+multiple-1);
   else
       multiple = '';
   end
   xlRange         = sprintf('%s%s1',multiple,char('A'+row_no));
   fprintf('\t - Results into xls: Write annual damages from %s to sheet &quot%s&quot (row %s)\n', strrep(hazard_name,'_',' '), sheet_name, xlRange(1:end-1))
   matr     = cell(length(EDS(1).ED_at_centroid)+3,numel(EDS));
   for e_i = 1:numel(EDS)
       matr{1,e_i} = sprintf('Annual damage from %s, %d, %s', strrep(hazard_name,'_',' '), timehorizon(e_i), EDS(e_i).annotation_name);
       matr(2:end-2,e_i) = num2cell(EDS(e_i).ED_at_centroid);
       matr{end-1,e_i}   = sprintf('Total damage');
       matr{end,e_i}     = sum(EDS(e_i).ED_at_centroid);
   end
   xlswrite(new_xls_filename, matr,sheet_name,xlRange)
   
   %% figure for damage per ward
   t_i = 1;
   fig = climada_ED_plot_per_ward(EDS(t_i),entity,BCC_wards, timehorizon(t_i), hazard_name);
   foldername = sprintf('%sresults%sDamage_from_%s_%d.pdf', filesep,filesep,hazard_name,timehorizon(t_i));
   print(fig,'-dpdf',[climada_global.data_dir foldername])
   %close
   
   
nd %h_i
% check hazard intensity and max hazard event
 [max_int, max_event] = max(full(sum(hazard.intensity,2)));
 % % [max_int, max_event] = max(full(max(hazard.intensity,[],2)));
 % % climada_hazard_footprint_plot(hazard, max_event, '');
 % hazard_sum = hazard;
 % hazard_sum.intensity(1,:) = sum(hazard_sum.intensity);
 
 % for e_i = 1:1:29
     fig = climada_figuresize(0.75,0.75);
     %%climada_hazard_plot(hazard_sum,1)
     %e_i = 27;
     %e_i = 8;
     e_i = max_event;
     climada_hazard_plot(hazard,e_i);
     
     % plot Wards
     hold on
     for w_i=1:length(BCC_wards)
         h = plot(BCC_wards(w_i).lon,BCC_wards(w_i).lat,'color',[244 164 96 ]/255);%sandybrown;
         %text(mean(BCC_wards(w_i).lon),mean(BCC_wards(w_i).lat),sprintf('Ward %d',BCC_wards(w_i).Ward_no));%sandybrown;
         g = text(entity.assets.lon(w_i), entity.assets.lat(w_i),sprintf('Ward %d',w_i),'Horizontalalignment','center','verticalalignment','bottom');
     end
     indx_a = entity.assets.Value&ampgt0;
     g = plot(entity.assets.lon(indx_a),entity.assets.lat(indx_a),'kx','markersize',8,'LineWidth',1.5);
     legend([h g], 'Ward boundaries', 'Lat/lon coordinates for assets')
     xlabel('Longitude'); ylabel('Latitude')
     foldername = sprintf('%sresults%sHazard_%s_event_%d.pdf',filesep, filesep,hazard_name,e_i);
     print(fig,'-dpdf',[climada_global.data_dir foldername])
     close
 % end
 %figure
 %[h h_points] = plotclr(hazard.lon,hazard.lat,hazard.intensity(e_i,:), 'o', 5, 1, 0, 0.5, '', 0, 0);
 
 % ward11_no = 11;
 % entity.assets.Value(ward11_no);
 % plot(entity.assets.lon(ward11_no), entity.assets.lat(ward11_no),'dr')
 % c = entity.assets.centroid_index(ward11_no);
 % plot(hazard.lon(c), hazard.lat(c),'pb')
 % int = full(hazard.intensity(:,c));
 % plot(hazard.lon, hazard.lat, 'x')
 % int = full(hazard.intensity(:,c+128));
 % int = full(hazard.intensity(:,c+0));
 % 
 % ward6_no = 6;
 % plot(entity.assets.lon(ward6_no), entity.assets.lat(ward6_no),'dr')
 % c6 = entity.assets.centroid_index(ward6_no);
 % plot(hazard.lon(c6), hazard.lat(c6),'pb')
 % int = full(hazard.intensity(:,c6));
 % end
 
 % % load entity (asset portfolio)
 % entity_file = [climada_global.data_dir filesep 'entities' filesep 'Barisal_BCC_1km_100.mat'];
 % if exist(entity_file,'file')
 %     load(entity_file)
 % end
% read ecorys entities (flood depth, flood duration and cyclone wind)
 barisal_entity_prepare
% calculate damage today
 if flood_depth ==1
     annotation_name = 'Flood today (depth)';
     
 elseif flood_duration == 1
     annotation_name = 'Flood today (duration)';
     
 elseif cyclone_wind == 1
     % tc wind
     annotation_name = 'Cyclones today';
 end
 
 force_re_encode = 1;
 silent_mode     = 0;
 EDS = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
 climada_EDS_DFC(EDS);
% see damage functions for different asset categories
 % asset_cat = unique(entity.assets.Category);
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 for cat_i = 1:length(asset_cat)
     fprintf('-----------\n-----------\nAsset category: %s \n-----------\n',asset_cat{cat_i})
     indx = strcmp(entity.assets.Category, asset_cat{cat_i});
     DamageFunID = unique(entity.assets.DamageFunID(indx));
     
     for ii = 1:numel(DamageFunID)
         fprintf('Asset DamageFunID: %d \n',DamageFunID(ii))
         indxx = find(entity.damagefunctions.DamageFunID == DamageFunID(ii));
         indxx = indxx(end);
         fprintf('DamageFunID: %d, %s \n',entity.damagefunctions.DamageFunID(indxx), entity.damagefunctions.Description{indxx})
         fprintf('max intensity %2.1f, max MDD %2.1f, \n\n', entity.damagefunctions.Intensity(indxx), entity.damagefunctions.MDD(indxx))     
     end
 end
% figure to check if max hazard (flood duration) touches upon asset values
 figure
 [max_int, max_event] = max(full(sum(hazard.intensity,2)));
 climada_hazard_footprint_plot(hazard, max_event, '');
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 color_ = jet(length(asset_cat));
 marker_ = {'+','o','d','*','s','p','x'};
 for cat_i = 1:length(asset_cat)
     indx = strcmp(entity.assets.Category,asset_cat(cat_i));
     hold on
     if cat_i&amplt=length(marker_)
         h(cat_i) = plot(entity.assets.lon(indx), entity.assets.lat(indx),marker_{cat_i},'color',color_(cat_i,:));
     else
         h(cat_i) = plot(entity.assets.lon(indx), entity.assets.lat(indx),'p','color',color_(cat_i,:));
     end
 end
 legend(h,asset_cat)
% figure BCC wards and numbers
 climada_figuresize(0.7,0.5)
 for w_i=1:length(BCC_wards)
     hold on
     h(3)= plot(BCC_wards(w_i).lon,BCC_wards(w_i).lat,'color',[244 164 96 ]/255);%sandybrown;
     %text(mean(BCC_wards(w_i).lon), mean(BCC_wards(w_i).lat), int2str(BCC_wards(w_i).WARDS_F_ID))
     text(mean(BCC_wards(w_i).lon), mean(BCC_wards(w_i).lat), int2str(BCC_wards(w_i).Ward_no))
 end
 plot(entity.assets.lon(1:30),entity.assets.lat(1:30), 'x')
 for a_i = 1:30
     text(entity.assets.lon(a_i),entity.assets.lat(a_i), int2str(entity.assets.Ward(a_i)))
 end
% assign ward numbers to ward shapefile
 ward_points = [entity.assets.lon(1:30) entity.assets.lat(1:30)];
 for w_i=1:length(BCC_wards)
     polygon_nodes = [BCC_wards(w_i).lon' BCC_wards(w_i).lat'];
     [cn,on] = inpoly(ward_points,polygon_nodes);
     BCC_wards(w_i).Ward_no = find(cn);
 end
 % hand corrections
 BCC_wards(2).Ward_no = 6;
 BCC_wards(3).Ward_no = 5;
 BCC_wards_savename = [climada_global.data_dir filesep 'entities' filesep 'BCC_wards.mat'];
 save(BCC_wards_savename,'BCC_wards')
% damage calculation per ward (per category, for today, 2030 and 2050)
 silent_mode= 1;
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 ward_no    = unique(entity.assets.Ward);
 
 timehorizon = [2014 2030 2050];
 EDS         = [];
 for t_i = 1:length(timehorizon);
      
     counter     = 0;
 
     % select ward
     for ward_i = 1:length(ward_no) 
         
         % select only one ward
         if ward_i&amplt=length(ward_no)
             indx_w = ismember(entity.assets.Ward, ward_no(ward_i));
             %indx_w = ismember(entity.assets.Ward, ward_no(1:ward_i));
             annotation_name_ward = sprintf('Ward %d',ward_no(ward_i));
         else
             indx_w = ones(size(entity.assets.Ward));
             annotation_name_ward = 'All Wards';
         end
         
         % select asset category
         for cat_i = 1:length(asset_cat)+1%length(asset_cat)+1 
 
             %select time horizone
             switch t_i 
                 case 1
                     % risk today
                     entity.assets.Value = entity_ori.assets.Value;
                     titlestr = 'Risk today';
                 case 2
                     % risk 2030
                     entity.assets.Value = entity.assets.Value_2030;
                     titlestr = 'Socio-economic 2030 (scenario 1)';
                 case 3
                     % risk 2050
                     entity.assets.Value = entity.assets.Value_2050;
                     titlestr = 'Socio-economic 2050 (scenario 1)';
             end
 
             % select only assets in specific category
             if cat_i&amplt=length(asset_cat)
                 %indx = strcmp(entity.assets.Category, asset_cat{cat_i});
                 indx = ismember(entity.assets.Category, asset_cat(1:cat_i));
                 annotation_name = asset_cat{cat_i};
             else
                 indx = ones(size(entity.assets.Category));
                 annotation_name = 'All asset categories';
             end
             
             %------
             % combine ward and category index
             %------
             indx      = logical(indx);
             indx_w    = logical(indx_w);
             indx_comb = logical(indx.*indx_w);
             counter   = counter+1;
             annotation_name_comb = sprintf('%d, %s, %s', timehorizon(t_i), annotation_name_ward, annotation_name);
             
             % a quick check
             %entity.assets.Ward(indx_comb)
             %entity.assets.Category(indx_comb)
             %entity.assets.Value(indx_comb)
 
             entity.assets.Value(~indx_comb) = 0;
             force_re_encode = 0;
             if isempty(EDS)
                 EDS = climada_EDS_calc(entity,hazard,annotation_name_comb,force_re_encode,silent_mode);
             else
                 %EDS_ = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
                 %EDS(cat_i) = EDS_;
                 EDS(counter) = climada_EDS_calc(entity,hazard,annotation_name_comb,force_re_encode,silent_mode);
             end
             
         end %cat_i  
     end %ward_i
 end %t_i
 % climada_waterfall_graph_barisal(EDS(1), EDS(2), EDS(3), 'AED')
 
 % at the end of calculations, overwrite with original entity again
 entity = entity_ori;
 
 return
% figures for specific asset categories and time horizons
 EDS_annotation_names = {EDS.annotation_name};
 for t_i = 1:length(timehorizon);
     for cat_i = 1:length(asset_cat)+1
         
         % select only assets in specific category
         if cat_i&amplt=length(asset_cat)           
             annotation_name = asset_cat{cat_i};
         else
             annotation_name = 'All asset categories';
         end
         indx_2 = strfind(EDS_annotation_names, annotation_name);
         indx_2 = find(~cellfun(@isempty,indx_2)); 
         
         indx_3 = strfind(EDS_annotation_names, sprintf('%d',timehorizon(t_i)));
         
         %-------
         %annual expected damage
         %-------
         fig = climada_figuresize(0.75,0.75);
         no_colors    = 10;
         cbar         = jet(no_colors);
         ED           = [EDS(indx_2).ED];
         pos_indx     = ED&ampgt0;
         min_value    = min(ED(pos_indx));
         max_value    = max(ED);
         range_values = linspace(min_value,max_value,no_colors);
         BCC_ward_no  = [BCC_wards.Ward_no];
         for ward_i = 1:length(ward_no) 
             indx = find(EDS(indx_2(ward_i)).ED&amplt=range_values);
             indx = indx(1);
             %h(3)= plot(BCC_wards(w_i).lon,BCC_wards(w_i).lat,'color',[244 164 96 ]/255);%sandybrown
             indx_w = find(BCC_ward_no == ward_i);
             h(3)   = fill(BCC_wards(indx_w).lon,BCC_wards(indx_w).lat,cbar(indx,:));
             hold on
             indx_a = find(EDS(indx_2(ward_i)).assets.Value);
             if ~isempty(indx_a); indx_a = indx_a(1);end
             indx_text = strfind(EDS(indx_2(ward_i)).annotation_name,',');
             if ~isempty(indx_a)
                 text(EDS(indx_2(ward_i)).assets.lon(indx_a), EDS(indx_2(ward_i)).assets.lat(indx_a), EDS(indx_2(ward_i)).annotation_name(1:indx_text-1),...
                     'Horizontalalignment','center','verticalalignment','bottom','color','k') %brighten(cbar(indx,:),-0.8)
                 g = plot(mean(EDS(indx_2(ward_i)).assets.lon(indx_a)), mean(EDS(indx_2(ward_i)).assets.lat(indx_a)),'kx','markersize',8,'LineWidth',1.5);
             end
         end
         colormap(cbar)
         t = colorbar;
         %cbar_label = sprintf('Intensity %s (%s)', hazard.peril_ID, hazard.units);
         set(get(t,'ylabel'),'String', ('1000 BDT'),'fontsize',12);
         caxis([min_value max_value])
         %axislim = [min(EDS(1).assets.lon) max(EDS(1).assets.lon)*1 min(EDS(1).assets.lat) max(EDS(1).assets.lat)*1];
         %axislim = [min(hazard.lon) max(hazard.lon)*1 min(hazard.lat) max(hazard.lat)*1];
         %axislim = [90.25 90.45 22.6 22.8]; %barisal close up BCC 
         axislim = [90.297 90.3957 22.64 22.752]; %barisal close up BCC 
         axis(axislim)
         axis equal
         %titlestr = sprintf('%d, Annual damage, %s - %s', timehorizon(t_i), EDS(1).annotation_name, EDS(end).annotation_name);
         titlestr = sprintf('%d: Annual damage from %s', timehorizon(t_i), strrep(hazard_name,'_',' '));
         title({titlestr; annotation_name})
         legend(g,'Lat/lon coordinates for assets')
         foldername = sprintf('%sresults%sDamage_from_%s_%d.pdf', filesep,filesep,hazard_name,timehorizon(t_i));
         print(fig,'-dpdf',[climada_global.data_dir foldername])
         %close
 
         %-------
         %values
         %-------
 %         fig = climada_figuresize(0.75,0.75);
 %         no_colors    = 10;
 %         cbar         = jet(no_colors);
 %         Value        = [EDS.Value];
 %         pos_indx     = Value&ampgt0;
 %         min_value    = min(Value(pos_indx));
 %         max_value    = max(Value);
 %         range_values = linspace(min_value,max_value,no_colors);
 %         BCC_ward_no  = [BCC_wards.Ward_no];
 %         for ward_i = 1:length(ward_no) 
 %             indx   = find(EDS(ward_i).Value&amplt=range_values);
 %             indx   = indx(1);
 %             %h(3)  = plot(BCC_wards(w_i).lon,BCC_wards(w_i).lat,'color',[244 164 96 ]/255);%sandybrown
 %             indx_w = find(BCC_ward_no == ward_i);
 %             h(3)   = fill(BCC_wards(indx_w).lon,BCC_wards(indx_w).lat,cbar(indx,:));
 %             indx_a = find(EDS(ward_i).assets.Value);
 %             indx_a = indx_a(1);
 %             indx_text = strfind(EDS(ward_i).annotation_name,',');
 %             text(EDS(ward_i).assets.lon(indx_a), EDS(ward_i).assets.lat(indx_a), EDS(ward_i).annotation_name(1:indx_text-1),...
 %                 'Horizontalalignment','center','verticalalignment','bottom','color','k')%brighten(cbar(indx,:),-0.8
 %             hold on
 %             g = plot(mean(EDS(ward_i).assets.lon(indx_a)), mean(EDS(ward_i).assets.lat(indx_a)),'kx','markersize',8,'LineWidth',1.5);
 %         end
 %         colormap(cbar)
 %         t = colorbar;
 %         %cbar_label = sprintf('Intensity %s (%s)', hazard.peril_ID, hazard.units);
 %         set(get(t,'ylabel'),'String', ('1000 BDT'),'fontsize',12);
 %         caxis([min_value max_value])
 %         axis(axislim)
 %         axis equal
 %         %titlestr = sprintf('%d, Values, %s - %s', timehorizon(t_i), EDS(1).annotation_name, EDS(end).annotation_name);
 %         titlestr = sprintf('%d: Values', timehorizon(t_i));
 %         title({titlestr; annotation_name})
 %         legend(g,'Lat/lon coordinates for assets')
 %         foldername = sprintf('%sresults%sValues_for_%s_%d.pdf', filesep,filesep,hazard_name,timehorizon(t_i));
 %         print(fig,'-dpdf',[climada_global.data_dir foldername])
 %         close
     end %cat_i
 end %t_i
   
% damage calculations per time horizon
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 entity_ori = entity;
 
 timehorizon = [2015 2030 2050];
 
 for t_i = 2%:length(timehorizon);
         
     EDS = [];   
 
     for cat_i = 1:length(asset_cat)+1
         
         switch t_i
             case 1
                 % risk today
                 entity.assets.Value = entity_ori.assets.Value;
                 titlestr = 'Risk today';
             case 2
                 % risk 2030
                 entity.assets.Value = entity.assets.Value_2030;
                 titlestr = 'Socio-economic 2030 (scenario 1)';
             case 3
                 % risk 2050
                 entity.assets.Value = entity.assets.Value_2050;
                 titlestr = 'Socio-economic 2050 (scenario 1)';
         end
     
         % select only assets in specific category
         if cat_i&amplt=length(asset_cat)
             %indx = strcmp(entity.assets.Category, asset_cat{cat_i});
             indx = ismember(entity.assets.Category, asset_cat(1:cat_i));
             annotation_name = asset_cat{cat_i};
         else
             indx = ones(size(entity.assets.Category));
             annotation_name = 'All asset categories';
         end
 
         entity.assets.Value(~indx) = 0;
         force_re_encode = 0;
         if isempty(EDS)
             EDS = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
         else
             EDS_ = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
             EDS(cat_i) = EDS_;
             %EDS(t_i) = climada_EDS_calc(entity,hazard,titlestr,force_re_encode,silent_mode);
         end
     end %cat_i
     
     % create figure
     figure
     climada_EDS_DFC(EDS);
     title(titlestr)
     %climada_waterfall_graph_barisal(EDS(1), EDS(2), EDS(3), 'AED')
 end %t_i
 
 % at the end of calculations, overwrite with original entity again
 entity = entity_ori;
% damage calculations per asset category
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 entity_ori = entity;
 
 for cat_i = 1:length(asset_cat)+1
     
     EDS = [];
     
     % select only assets in specific category
     if cat_i&amplt=length(asset_cat)
         indx = strcmp(entity.assets.Category, asset_cat{cat_i});
     else
         indx = ones(size(entity.assets.Category));
     end
 
     % risk today
     entity.assets.Value = entity_ori.assets.Value;
     entity.assets.Value(~indx) = 0;
     annotation_name = 'Risk today';
     force_re_encode = 0;
     EDS = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
     EDS(1) = EDS;
     
     % risk 2030
     entity.assets.Value = entity.assets.Value_2030;
     entity.assets.Value(~indx) = 0;
     annotation_name = 'Socio-economic 2030 (scenario 1)';
     EDS(2) = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
     
     % risk 2050
     entity.assets.Value = entity.assets.Value_2050;
     entity.assets.Value(~indx) = 0;
     annotation_name = 'Socio-economic 2050 (scenario 1)';
     EDS(3) = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
     
     % create figure
     figure
     climada_EDS_DFC(EDS);
     if cat_i&amplt=length(asset_cat)
         title(asset_cat{cat_i})
     else
         title('All asset categories')
         % at the end of calculations, overwrite with original entity again
         entity = entity_ori;
     end
     %climada_waterfall_graph_barisal(EDS(1), EDS(2), EDS(3), 'AED')
 end
%
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/_barisal_risk_calculation_excel_old.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_barisal_risk_calculations">
<H2>_barisal_risk_calculations</H2></A>
% barisal_risk_calculations
 - tc wind hazard: use barisal_tc_hazard_prob.m to create wind hazard
 - flood hazard: read asci-file from Ruud (Witteveen+Bos), load flood hazard
% set hazard type
azard_name = 'flood_depth';
 hazard_name = 'flood_duration';
 hazard_name = 'cyclone_wind';
 flood_depth = 1; flood_duration = 0; cyclone_wind   = 0;
 flood_duration = 1; flood_depth    = 0; cyclone_wind   = 0;
 cyclone_wind   = 1; flood_depth    = 0; flood_duration = 0; 
% hazard
witch hazard_name
   case 'flood_depth'
       % hazard = climada_asci2hazard(asci_file);
       hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_FL'];
       flood_depth = 1; flood_duration = 0; cyclone_wind   = 0;
   
   case 'flood_duration' % hazard duration (too be prepared!)
       hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_FL_duration'];
       flood_duration = 1; flood_depth    = 0; cyclone_wind   = 0;
 
   case 'cyclone_wind'
       hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_TC_prob'];
       cyclone_wind   = 1; flood_depth    = 0; flood_duration = 0; 
       % wind centroids
       %centroids_file  = [climada_global.data_dir filesep 'system' filesep 'Barisal_BCC_centroids'];
       %load(centroids_file)   
nd
oad(hazard_set_file)
printf('\n-----------\nSELECTED HAZARD TYPE: %s\n-----------\n', hazard_name)
% check hazard intensity and max hazard event
 [max_int, max_event] = max(full(sum(hazard.intensity,2)));
 % % [max_int, max_event] = max(full(max(hazard.intensity,[],2)));
 % % climada_hazard_footprint_plot(hazard, max_event, '');
 % hazard_sum = hazard;
 % hazard_sum.intensity(1,:) = sum(hazard_sum.intensity);
 
 % for e_i = 1:1:29
     fig = climada_figuresize(0.75,0.75);
     %%climada_hazard_plot(hazard_sum,1)
     %e_i = 27;
     %e_i = 8;
     e_i = max_event;
     climada_hazard_plot(hazard,e_i);
     
     % plot Wards
     hold on
     for w_i=1:length(BCC_wards)
         h = plot(BCC_wards(w_i).lon,BCC_wards(w_i).lat,'color',[244 164 96 ]/255);%sandybrown;
         %text(mean(BCC_wards(w_i).lon),mean(BCC_wards(w_i).lat),sprintf('Ward %d',BCC_wards(w_i).Ward_no));%sandybrown;
         g = text(entity.assets.lon(w_i), entity.assets.lat(w_i),sprintf('Ward %d',w_i),'Horizontalalignment','center','verticalalignment','bottom');
     end
     indx_a = entity.assets.Value&ampgt0;
     g = plot(entity.assets.lon(indx_a),entity.assets.lat(indx_a),'kx','markersize',8,'LineWidth',1.5);
     legend([h g], 'Ward boundaries', 'Lat/lon coordinates for assets')
     xlabel('Longitude'); ylabel('Latitude')
     foldername = sprintf('%sresults%sHazard_%s_event_%d.pdf',filesep, filesep,hazard_name,e_i);
     print(fig,'-dpdf',[climada_global.data_dir foldername])
     close
 % end
 %figure
 %[h h_points] = plotclr(hazard.lon,hazard.lat,hazard.intensity(e_i,:), 'o', 5, 1, 0, 0.5, '', 0, 0);
 
 % ward11_no = 11;
 % entity.assets.Value(ward11_no);
 % plot(entity.assets.lon(ward11_no), entity.assets.lat(ward11_no),'dr')
 % c = entity.assets.centroid_index(ward11_no);
 % plot(hazard.lon(c), hazard.lat(c),'pb')
 % int = full(hazard.intensity(:,c));
 % plot(hazard.lon, hazard.lat, 'x')
 % int = full(hazard.intensity(:,c+128));
 % int = full(hazard.intensity(:,c+0));
 % 
 % ward6_no = 6;
 % plot(entity.assets.lon(ward6_no), entity.assets.lat(ward6_no),'dr')
 % c6 = entity.assets.centroid_index(ward6_no);
 % plot(hazard.lon(c6), hazard.lat(c6),'pb')
 % int = full(hazard.intensity(:,c6));
 % end
 
 % % load entity (asset portfolio)
 % entity_file = [climada_global.data_dir filesep 'entities' filesep 'Barisal_BCC_1km_100.mat'];
 % if exist(entity_file,'file')
 %     load(entity_file)
 % end
% read ecorys entities (flood depth, flood duration and cyclone wind)
 barisal_entity_prepare
% next time only load entities
f flood_depth ==1
   entity_filename = [climada_global.data_dir filesep 'entities' filesep '20150416_values_Barisal_flood_depth.mat'];
   
lseif flood_duration ==1
   entity_filename = [climada_global.data_dir filesep 'entities' filesep '20150416_values_Barisal_flood_duration.mat'];
   
lseif cyclone_wind == 1
   % tc wind
   entity_filename = [climada_global.data_dir filesep 'entities' filesep '20150416_values_Barisal_cyclones.mat'];
nd
oad(entity_filename)
 create copy
ntity_ori = entity;
ndx = strfind(entity_filename,filesep);
printf('\t - loaded entity: %s\n', entity_filename(indx(end)+1:end))
% load barisal specifics
CC_savename = [climada_global.data_dir filesep 'entities' filesep 'BCC_border.mat'];
oad(BCC_savename)
 load BCC ward boundaries (30 polygons)
CC_wards_savename = [climada_global.data_dir filesep 'entities' filesep 'BCC_wards.mat'];
oad(BCC_wards_savename)
ndx = strfind(BCC_savename,filesep);
ndx2 = strfind(BCC_wards_savename,filesep);
printf('\t - loaded BCC specifics: %s and %s\n', BCC_savename(indx(end)+1:end), BCC_wards_savename(indx2(end)+1:end))
% calculate damage today
 if flood_depth ==1
     annotation_name = 'Flood today (depth)';
     
 elseif flood_duration == 1
     annotation_name = 'Flood today (duration)';
     
 elseif cyclone_wind == 1
     % tc wind
     annotation_name = 'Cyclones today';
 end
 
 force_re_encode = 1;
 silent_mode     = 0;
 EDS = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
 climada_EDS_DFC(EDS);
% see damage functions for different asset categories
 % asset_cat = unique(entity.assets.Category);
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 for cat_i = 1:length(asset_cat)
     fprintf('-----------\n-----------\nAsset category: %s \n-----------\n',asset_cat{cat_i})
     indx = strcmp(entity.assets.Category, asset_cat{cat_i});
     DamageFunID = unique(entity.assets.DamageFunID(indx));
     
     for ii = 1:numel(DamageFunID)
         fprintf('Asset DamageFunID: %d \n',DamageFunID(ii))
         indxx = find(entity.damagefunctions.DamageFunID == DamageFunID(ii));
         indxx = indxx(end);
         fprintf('DamageFunID: %d, %s \n',entity.damagefunctions.DamageFunID(indxx), entity.damagefunctions.Description{indxx})
         fprintf('max intensity %2.1f, max MDD %2.1f, \n\n', entity.damagefunctions.Intensity(indxx), entity.damagefunctions.MDD(indxx))     
     end
 end
% figure to check if max hazard (flood duration) touches upon asset values
 figure
 [max_int, max_event] = max(full(sum(hazard.intensity,2)));
 climada_hazard_footprint_plot(hazard, max_event, '');
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 color_ = jet(length(asset_cat));
 marker_ = {'+','o','d','*','s','p','x'};
 for cat_i = 1:length(asset_cat)
     indx = strcmp(entity.assets.Category,asset_cat(cat_i));
     hold on
     if cat_i&amplt=length(marker_)
         h(cat_i) = plot(entity.assets.lon(indx), entity.assets.lat(indx),marker_{cat_i},'color',color_(cat_i,:));
     else
         h(cat_i) = plot(entity.assets.lon(indx), entity.assets.lat(indx),'p','color',color_(cat_i,:));
     end
 end
 legend(h,asset_cat)
% figure BCC wards and numbers
 climada_figuresize(0.7,0.5)
 for w_i=1:length(BCC_wards)
     hold on
     h(3)= plot(BCC_wards(w_i).lon,BCC_wards(w_i).lat,'color',[244 164 96 ]/255);%sandybrown;
     %text(mean(BCC_wards(w_i).lon), mean(BCC_wards(w_i).lat), int2str(BCC_wards(w_i).WARDS_F_ID))
     text(mean(BCC_wards(w_i).lon), mean(BCC_wards(w_i).lat), int2str(BCC_wards(w_i).Ward_no))
 end
 plot(entity.assets.lon(1:30),entity.assets.lat(1:30), 'x')
 for a_i = 1:30
     text(entity.assets.lon(a_i),entity.assets.lat(a_i), int2str(entity.assets.Ward(a_i)))
 end
% assign ward numbers to ward shapefile
ard_points = [entity.assets.lon(1:30) entity.assets.lat(1:30)];
or w_i=1:length(BCC_wards)
   polygon_nodes = [BCC_wards(w_i).lon' BCC_wards(w_i).lat'];
   [cn,on] = inpoly(ward_points,polygon_nodes);
   BCC_wards(w_i).Ward_no = find(cn);
nd
 hand corrections
CC_wards(2).Ward_no = 6;
CC_wards(3).Ward_no = 5;
CC_wards_savename = [climada_global.data_dir filesep 'entities' filesep 'BCC_wards_Ward_no_added.mat'];
ave(BCC_wards_savename,'BCC_wards')
% waterfall graph for today, 2030, 2050
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 
 timehorizon = [2015 2030 2050];
 EDS         = []; 
 silent_mode = 1;
 for t_i = 1:length(timehorizon);
     for cat_i = length(asset_cat)+1%1:length(asset_cat)+1
         
         switch t_i
             case 1
                 % risk today
                 entity.assets.Value = entity_ori.assets.Value;
                 titlestr = 'Risk today';
             case 2
                 % risk 2030
                 entity.assets.Value = entity.assets.Value_2030;
                 titlestr = 'Socio-economic 2030 (scenario 1)';
             case 3
                 % risk 2050
                 entity.assets.Value = entity.assets.Value_2050;
                 titlestr = 'Socio-economic 2050 (scenario 1)';
         end
     
         % select only assets in specific category
         if cat_i&amplt=length(asset_cat)
             %indx = strcmp(entity.assets.Category, asset_cat{cat_i});
             indx = ismember(entity.assets.Category, asset_cat(1:cat_i));
             annotation_name = asset_cat{cat_i};
         else
             indx = ones(size(entity.assets.Category));
             annotation_name = 'All asset categories';
         end
 
         entity.assets.Value(~indx) = 0;
         force_re_encode = 0;
         if isempty(EDS)
             EDS = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
         else
             %EDS_ = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
             %EDS(cat_i) = EDS_;
             EDS(t_i) = climada_EDS_calc(entity,hazard,titlestr,force_re_encode,silent_mode);
         end
     end %cat_i    
 end %t_i
 
 climada_waterfall_graph_barisal(EDS(1), EDS(2), EDS(3), 'AED');
 
 % at the end of calculations, overwrite with original entity again
 entity = entity_ori;
% damage calculation per ward (per category, for today, 2030 and 2050)
 silent_mode= 1;
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 ward_no    = unique(entity.assets.Ward);
 
 timehorizon = [2014 2030 2050];
 EDS         = [];
 for t_i = 1:length(timehorizon);
      
     counter     = 0;
 
     % select ward
     for ward_i = 1:length(ward_no) 
         
         % select only one ward
         if ward_i&amplt=length(ward_no)
             indx_w = ismember(entity.assets.Ward, ward_no(ward_i));
             %indx_w = ismember(entity.assets.Ward, ward_no(1:ward_i));
             annotation_name_ward = sprintf('Ward %d',ward_no(ward_i));
         else
             indx_w = ones(size(entity.assets.Ward));
             annotation_name_ward = 'All Wards';
         end
         
         % select asset category
         for cat_i = 1:length(asset_cat)+1%length(asset_cat)+1 
 
             %select time horizone
             switch t_i 
                 case 1
                     % risk today
                     entity.assets.Value = entity_ori.assets.Value;
                     titlestr = 'Risk today';
                 case 2
                     % risk 2030
                     entity.assets.Value = entity.assets.Value_2030;
                     titlestr = 'Socio-economic 2030 (scenario 1)';
                 case 3
                     % risk 2050
                     entity.assets.Value = entity.assets.Value_2050;
                     titlestr = 'Socio-economic 2050 (scenario 1)';
             end
 
             % select only assets in specific category
             if cat_i&amplt=length(asset_cat)
                 %indx = strcmp(entity.assets.Category, asset_cat{cat_i});
                 indx = ismember(entity.assets.Category, asset_cat(1:cat_i));
                 annotation_name = asset_cat{cat_i};
             else
                 indx = ones(size(entity.assets.Category));
                 annotation_name = 'All asset categories';
             end
             
             %------
             % combine ward and category index
             %------
             indx      = logical(indx);
             indx_w    = logical(indx_w);
             indx_comb = logical(indx.*indx_w);
             counter   = counter+1;
             annotation_name_comb = sprintf('%d, %s, %s', timehorizon(t_i), annotation_name_ward, annotation_name);
             
             % a quick check
             %entity.assets.Ward(indx_comb)
             %entity.assets.Category(indx_comb)
             %entity.assets.Value(indx_comb)
 
             entity.assets.Value(~indx_comb) = 0;
             force_re_encode = 0;
             if isempty(EDS)
                 EDS = climada_EDS_calc(entity,hazard,annotation_name_comb,force_re_encode,silent_mode);
             else
                 %EDS_ = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
                 %EDS(cat_i) = EDS_;
                 EDS(counter) = climada_EDS_calc(entity,hazard,annotation_name_comb,force_re_encode,silent_mode);
             end
             
         end %cat_i  
     end %ward_i
 end %t_i
 % climada_waterfall_graph_barisal(EDS(1), EDS(2), EDS(3), 'AED')
 
 % at the end of calculations, overwrite with original entity again
 entity = entity_ori;
 
 return
% figures for specific asset categories and time horizons
 EDS_annotation_names = {EDS.annotation_name};
 for t_i = 1:length(timehorizon);
     for cat_i = 1:length(asset_cat)+1
         
         % select only assets in specific category
         if cat_i&amplt=length(asset_cat)           
             annotation_name = asset_cat{cat_i};
         else
             annotation_name = 'All asset categories';
         end
         indx_2 = strfind(EDS_annotation_names, annotation_name);
         indx_2 = find(~cellfun(@isempty,indx_2)); 
         
         indx_3 = strfind(EDS_annotation_names, sprintf('%d',timehorizon(t_i)));
         
         %-------
         %annual expected damage
         %-------
         fig = climada_figuresize(0.75,0.75);
         no_colors    = 10;
         cbar         = jet(no_colors);
         ED           = [EDS(indx_2).ED];
         pos_indx     = ED&ampgt0;
         min_value    = min(ED(pos_indx));
         max_value    = max(ED);
         range_values = linspace(min_value,max_value,no_colors);
         BCC_ward_no  = [BCC_wards.Ward_no];
         for ward_i = 1:length(ward_no) 
             indx = find(EDS(indx_2(ward_i)).ED&amplt=range_values);
             indx = indx(1);
             %h(3)= plot(BCC_wards(w_i).lon,BCC_wards(w_i).lat,'color',[244 164 96 ]/255);%sandybrown
             indx_w = find(BCC_ward_no == ward_i);
             h(3)   = fill(BCC_wards(indx_w).lon,BCC_wards(indx_w).lat,cbar(indx,:));
             hold on
             indx_a = find(EDS(indx_2(ward_i)).assets.Value);
             if ~isempty(indx_a); indx_a = indx_a(1);end
             indx_text = strfind(EDS(indx_2(ward_i)).annotation_name,',');
             if ~isempty(indx_a)
                 text(EDS(indx_2(ward_i)).assets.lon(indx_a), EDS(indx_2(ward_i)).assets.lat(indx_a), EDS(indx_2(ward_i)).annotation_name(1:indx_text-1),...
                     'Horizontalalignment','center','verticalalignment','bottom','color','k') %brighten(cbar(indx,:),-0.8)
                 g = plot(mean(EDS(indx_2(ward_i)).assets.lon(indx_a)), mean(EDS(indx_2(ward_i)).assets.lat(indx_a)),'kx','markersize',8,'LineWidth',1.5);
             end
         end
         colormap(cbar)
         t = colorbar;
         %cbar_label = sprintf('Intensity %s (%s)', hazard.peril_ID, hazard.units);
         set(get(t,'ylabel'),'String', ('1000 BDT'),'fontsize',12);
         caxis([min_value max_value])
         %axislim = [min(EDS(1).assets.lon) max(EDS(1).assets.lon)*1 min(EDS(1).assets.lat) max(EDS(1).assets.lat)*1];
         %axislim = [min(hazard.lon) max(hazard.lon)*1 min(hazard.lat) max(hazard.lat)*1];
         %axislim = [90.25 90.45 22.6 22.8]; %barisal close up BCC 
         axislim = [90.297 90.3957 22.64 22.752]; %barisal close up BCC 
         axis(axislim)
         axis equal
         %titlestr = sprintf('%d, Annual damage, %s - %s', timehorizon(t_i), EDS(1).annotation_name, EDS(end).annotation_name);
         titlestr = sprintf('%d: Annual damage from %s', timehorizon(t_i), strrep(hazard_name,'_',' '));
         title({titlestr; annotation_name})
         legend(g,'Lat/lon coordinates for assets')
         foldername = sprintf('%sresults%sDamage_from_%s_%d.pdf', filesep,filesep,hazard_name,timehorizon(t_i));
         print(fig,'-dpdf',[climada_global.data_dir foldername])
         %close
 
         %-------
         %values
         %-------
 %         fig = climada_figuresize(0.75,0.75);
 %         no_colors    = 10;
 %         cbar         = jet(no_colors);
 %         Value        = [EDS.Value];
 %         pos_indx     = Value&ampgt0;
 %         min_value    = min(Value(pos_indx));
 %         max_value    = max(Value);
 %         range_values = linspace(min_value,max_value,no_colors);
 %         BCC_ward_no  = [BCC_wards.Ward_no];
 %         for ward_i = 1:length(ward_no) 
 %             indx   = find(EDS(ward_i).Value&amplt=range_values);
 %             indx   = indx(1);
 %             %h(3)  = plot(BCC_wards(w_i).lon,BCC_wards(w_i).lat,'color',[244 164 96 ]/255);%sandybrown
 %             indx_w = find(BCC_ward_no == ward_i);
 %             h(3)   = fill(BCC_wards(indx_w).lon,BCC_wards(indx_w).lat,cbar(indx,:));
 %             indx_a = find(EDS(ward_i).assets.Value);
 %             indx_a = indx_a(1);
 %             indx_text = strfind(EDS(ward_i).annotation_name,',');
 %             text(EDS(ward_i).assets.lon(indx_a), EDS(ward_i).assets.lat(indx_a), EDS(ward_i).annotation_name(1:indx_text-1),...
 %                 'Horizontalalignment','center','verticalalignment','bottom','color','k')%brighten(cbar(indx,:),-0.8
 %             hold on
 %             g = plot(mean(EDS(ward_i).assets.lon(indx_a)), mean(EDS(ward_i).assets.lat(indx_a)),'kx','markersize',8,'LineWidth',1.5);
 %         end
 %         colormap(cbar)
 %         t = colorbar;
 %         %cbar_label = sprintf('Intensity %s (%s)', hazard.peril_ID, hazard.units);
 %         set(get(t,'ylabel'),'String', ('1000 BDT'),'fontsize',12);
 %         caxis([min_value max_value])
 %         axis(axislim)
 %         axis equal
 %         %titlestr = sprintf('%d, Values, %s - %s', timehorizon(t_i), EDS(1).annotation_name, EDS(end).annotation_name);
 %         titlestr = sprintf('%d: Values', timehorizon(t_i));
 %         title({titlestr; annotation_name})
 %         legend(g,'Lat/lon coordinates for assets')
 %         foldername = sprintf('%sresults%sValues_for_%s_%d.pdf', filesep,filesep,hazard_name,timehorizon(t_i));
 %         print(fig,'-dpdf',[climada_global.data_dir foldername])
 %         close
     end %cat_i
 end %t_i
   
% damage calculations per time horizon
sset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
ntity_ori = entity;
imehorizon = [2015 2030 2050];
or t_i = 2%:length(timehorizon);
       
   EDS = [];   
   for cat_i = 1:length(asset_cat)+1
       
       switch t_i
           case 1
               % risk today
               entity.assets.Value = entity_ori.assets.Value;
               titlestr = 'Risk today';
           case 2
               % risk 2030
               entity.assets.Value = entity.assets.Value_2030;
               titlestr = 'Socio-economic 2030 (scenario 1)';
           case 3
               % risk 2050
               entity.assets.Value = entity.assets.Value_2050;
               titlestr = 'Socio-economic 2050 (scenario 1)';
       end
   
       % select only assets in specific category
       if cat_i&amplt=length(asset_cat)
           %indx = strcmp(entity.assets.Category, asset_cat{cat_i});
           indx = ismember(entity.assets.Category, asset_cat(1:cat_i));
           annotation_name = asset_cat{cat_i};
       else
           indx = ones(size(entity.assets.Category));
           annotation_name = 'All asset categories';
       end
       entity.assets.Value(~indx) = 0;
       force_re_encode = 0;
       if isempty(EDS)
           EDS = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
       else
           EDS_ = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
           EDS(cat_i) = EDS_;
           %EDS(t_i) = climada_EDS_calc(entity,hazard,titlestr,force_re_encode,silent_mode);
       end
   end %cat_i
   
   % create figure
   figure
   climada_EDS_DFC(EDS);
   title(titlestr)
   %climada_waterfall_graph_barisal(EDS(1), EDS(2), EDS(3), 'AED')
nd %t_i
 at the end of calculations, overwrite with original entity again
ntity = entity_ori;
% damage calculations per asset category
sset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
ntity_ori = entity;
or cat_i = 1:length(asset_cat)+1
   
   EDS = [];
   
   % select only assets in specific category
   if cat_i&amplt=length(asset_cat)
       indx = strcmp(entity.assets.Category, asset_cat{cat_i});
   else
       indx = ones(size(entity.assets.Category));
   end
   % risk today
   entity.assets.Value = entity_ori.assets.Value;
   entity.assets.Value(~indx) = 0;
   annotation_name = 'Risk today';
   force_re_encode = 0;
   EDS = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
   EDS(1) = EDS;
   
   % risk 2030
   entity.assets.Value = entity.assets.Value_2030;
   entity.assets.Value(~indx) = 0;
   annotation_name = 'Socio-economic 2030 (scenario 1)';
   EDS(2) = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
   
   % risk 2050
   entity.assets.Value = entity.assets.Value_2050;
   entity.assets.Value(~indx) = 0;
   annotation_name = 'Socio-economic 2050 (scenario 1)';
   EDS(3) = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
   
   % create figure
   figure
   climada_EDS_DFC(EDS);
   if cat_i&amplt=length(asset_cat)
       title(asset_cat{cat_i})
   else
       title('All asset categories')
       % at the end of calculations, overwrite with original entity again
       entity = entity_ori;
   end
   %climada_waterfall_graph_barisal(EDS(1), EDS(2), EDS(3), 'AED')
nd
%
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/_barisal_risk_calculations.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_BCC_boundaries_ge">
<H2>barisal_BCC_boundaries_ge</H2></A>
<font color="blue">function barisal_BCC_boundaries_ge(google_earth_save) </font>
 climada
 MODULE:
   barisal_demo
 NAME:
   barisal_BCC_boundaries_ge
 PURPOSE:
   visualisation of BCC boundaries in google earth
 CALLING SEQUENCE:
   barisal_BCC_boundaries_ge(google_earth_save)
 EXAMPLE:
   barisal_BCC_boundaries_ge
 INPUTS:
   google_earth_save: the filename of the resulting .kmz google earth file
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150315, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/barisal_BCC_boundaries_ge.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_BCC_ward_shp_add_no">
<H2>barisal_BCC_ward_shp_add_no</H2></A>
% assign ward numbers to ward shapefile
 load BCC wards
CC_wards_savename = [climada_global.data_dir filesep 'entities' filesep 'BCC_wards.mat'];
 BCC_wards_savename = [climada_global.data_dir filesep 'entities' filesep 'BCC_wards_Ward_no_added.mat'];
oad(BCC_wards_savename)
ndx2 = strfind(BCC_wards_savename,filesep);
printf('\t - loaded BCC specifics: %s\n', BCC_wards_savename(indx2(end)+1:end))
 load entity
hazard, entity, label] = barisal_hazard_entity_load('flood_depth_monsoon', 'no change', 2010);
ard_no = unique(entity.assets.Ward_Nr);
or w_i=1:length(ward_no)
   indx = find(entity.assets.Ward_Nr == ward_no(w_i));
   ward_points(w_i,1) = mean(entity.assets.lon(indx));
   ward_points(w_i,2) = mean(entity.assets.lat(indx));
nd
 ward_points = [entity.assets.lon(1:30) entity.assets.lat(1:30)];
 go through all ward points and find polygon which is point is inside
or w_i=1:length(BCC_wards)
   polygon_nodes = [BCC_wards(w_i).lon' BCC_wards(w_i).lat'];
   [cn,on] = inpoly(ward_points,polygon_nodes);
   cn = find(cn);
   if ~isempty(cn)
       BCC_wards(w_i).Ward_no = cn(1);
   else
       BCC_wards(w_i).Ward_no = 0;
   end
nd
 hand corrections
 BCC_wards(2).Ward_no = 6;
 BCC_wards(3).Ward_no = 5;
 BCC_wards_savename = [climada_global.data_dir filesep 'entities' filesep 'BCC_wards.mat'];
 save(BCC_wards_savename,'BCC_wards')
 BCC_wards( 2).Ward_no = 31;
 BCC_wards(13).Ward_no =  7;
 BCC_wards( 3).Ward_no = 34;
 BCC_wards( 6).Ward_no = 32;
CC_wards( 5).Ward_no = 32;
CC_wards(35).Ward_no = 34;
CC_wards( 2).Ward_no = 31;
CC_wards(12).Ward_no =  7;
CC_wards_savename = [climada_global.data_dir filesep 'entities' filesep 'BCC_wards_number_added.mat'];
ave(BCC_wards_savename,'BCC_wards')
 check with figure
limada_figuresize(0.7,0.5)
or w_i=1:length(BCC_wards)
   hold on
   h(3)= plot(BCC_wards(w_i).lon,BCC_wards(w_i).lat,'color',[244 164 96 ]/255);%sandybrown;
   %text(mean(BCC_wards(w_i).lon), mean(BCC_wards(w_i).lat), int2str(BCC_wards(w_i).WARDS_F_ID))
   text(mean(BCC_wards(w_i).lon), mean(BCC_wards(w_i).lat), sprintf('%d:%d',w_i, BCC_wards(w_i).Ward_no))
nd
lot(ward_points(:,1),ward_points(:,2), 'x','markersize',2)
or a_i = 1:length(ward_no)
   text(ward_points(a_i,1),ward_points(a_i,2), int2str(ward_no(a_i)),'color','b','Horizontalalignment','center','verticalalignment','bottom')
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/barisal_BCC_ward_shp_add_no.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_DFC_graph">
<H2>barisal_DFC_graph</H2></A>
 create Damage-Frequency-Graph for Barisal, showing one DFC per peril
% Directories
arisal_data_dir= ['\\CHRB1065.CORP.GWPNET.COM\homes\X\S3BXXW\Documents\lea\climada_git\climada_modules\barisal_demo\data'];
 barisal_data_dir= [fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
ntities_dir    = [barisal_data_dir filesep 'entities'];
azards_dir     = [barisal_data_dir filesep 'hazards'];
esults_dir     = [barisal_data_dir filesep 'results'];
 
DS_file= 'EDS_230615';
oad([results_dir filesep EDS_file])
% create DFC graph with different perils
lose all
limada_figuresize(0.5,0.9);
fig,legend_str,return_period,sorted_damage] = barisal_EDS_DFC(EDS([3 4 1 2 5]));
rint(fig,'-dpdf',[results_dir filesep 'DFC_2014.pdf'])
   
% create DFC report (xls) with different perils
DS_no = 15;
atr          = cell(29+2,EDS_no*2);
or i = 1:EDS_no
   matr{1,(i-1)*2+1} = EDS(i).annotation_name;
   matr{2,(i-1)*2+1} = 'Return period (years)';
   matr{2,(i-1)*2+2} = 'Damage (BDT)';
   [~,~,return_period,sorted_damage] = climada_EDS_DFC(EDS(i));
   close all
   no = numel(return_period);
   if strcmp(EDS(i).annotation_name,'Barisal_BCC_hazard_FL_depth_cyclone_cc_2030_moderate') |...
           strcmp(EDS(i).annotation_name,'Barisal_BCC_hazard_FL_duration_cyclone_cc_2030_moderate');
       return_period = return_period*1.009;
   end
   if strcmp(EDS(i).annotation_name,'Barisal_BCC_hazard_FL_depth_cyclone_cc_2050_moderate') |...
           strcmp(EDS(i).annotation_name,'Barisal_BCC_hazard_FL_duration_cyclone_cc_2050_moderate');
       return_period = return_period*1.018;
   end
   matr(3:3+no-1,(i-1)*2+1) = num2cell(return_period);
   matr(3:3+no-1,(i-1)*2+2) = num2cell(sorted_damage);
nd
ls_file = [results_dir filesep 'Damage_frequency_curve.xls'];
lswrite(xls_file,matr)
%
limada_figuresize(0.5,0.9);
fig,legend_str,return_period,sorted_damage] = barisal_EDS_DFC(EDS([3 4 1 2 5]));
limada_figuresize(0.5,0.9);
fig,legend_str,return_period,sorted_damage] = barisal_EDS_DFC(EDS([8 9 6 7 10]));
 comparison of moonsoon and cyclone flooding (depth damage only, as this
 is the driver of losses) in 2014 and 2030 (scenario 1, moderate climate change)
limada_figuresize(0.5,0.9);
fig,legend_str,return_period,sorted_damage] = climada_EDS_DFC(EDS([3 8 1 6]));
rint(fig,'-dpdf',[results_dir filesep 'DFC_2014_2030_monsoon_vs_cyclone_flooding.pdf'])
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/barisal_DFC_graph.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_EDS_DFC">
<H2>barisal_EDS_DFC</H2></A>
<font color="blue">function [fig,legend_str,return_period,sorted_damage] = barisal_EDS_DFC(EDS,EDS_comparison,Percentage_Of_Value_Flag,plot_loglog) </font>
 climada
 NAME:
   barisal_EDS_DFC, special version for BARISAL
 PURPOSE:
   plot occurrence Damage exceedence Frequency Curve (DFC)

   See also: climada_EDS_DFC_match and climada_DFC_compare
 CALLING SEQUENCE:
   climada_EDS_DFC(EDS,EDS_comparison,Percentage_Of_Value_Flag)
 EXAMPLE:
   climada_EDS_DFC(climada_EDS_calc(climada_entity_read))
 INPUTS:
   EDS: either an event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       SPECIAL: we also accept a structure which contains an EDS, like
       measures_impact.EDS
       if EDS has the field annotation_name, the legend will show this
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   EDS_comparison: like EDS see above, plotted (fine lines) for comparison
       not prompted for, if not given,unless set to 'ASK'
   Percentage_Of_Value_Flag: if =1, scale vertical axis with Value, such
       that damage as percentage of value is shown, instead of damage amount,
       default=0 (damage amount shown). Very useful to compare DFCs of
       different portfolios to see relative differences in risk
   plot_loglog: if =1, plot logarithmic scale both axes, =0 plot linear
       axes (default)
 OUTPUTS:
   a figure with the DFC plot
   legend_str: the legend string
   return_period: the return periods as shown (for the last DFC plottet,
       be careful)
   sorted_damage: the damage as shown (for the last DFC plottet,
       be careful)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150625, init, copied from
 climada_EDS_DFC, special modifications to work for BARISAL
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/barisal_EDS_DFC.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_climate_screw">
<H2>barisal_climate_screw</H2></A>
<font color="blue">function screw = barisal_climate_screw(peril_ID, time_horizon, scen_type) </font>
 NAME:
 barisal_climate_screw
 PURPOSE:
   Generate a climate change screw structure for the city of Barisal,
   based on the data and methodology outlined in the ECA Barisal base line
   report.
 CALLING SEQUENCE:
   screw = barisal_climate_screw(peril_ID, time_horizon, scen_type)
 EXAMPLE:
   screw = barisal_climate_screw('TC', 2050, 'extreme')
 INPUTS:
   if no input provided, the default climate screw for TC 2030 moderate
   scenario will be returned.
 OPTIONAL INPUT PARAMETERS:
   peril_ID:       defines the peril to which the screw applies
   time_horizon:   defines the year at which the screw applies [2030 or 2050]
   scen_type:      defines the scenario type to which the screw applies [moderate or extreme]
 OUTPUTS:
   screw:      defines the climate change scenario. A 1xN structure with
               fields:
                   .hazard_fld     defines the hazard field to be changed
                   .change         extent of the change at time horizon
                   .year           time horizon
                   .hazard_crit    hazard field to which criteria apply
                   .criteria       criteria for events/locations to change
                   .bsxfun_op      operation of change (e.g. @times,@plus) (function handle)
               specifying N transformations to the original hazard set.
 MODIFICATION HISTORY:
   Gilles Stassen, gillesstassen@hotmail.com, 20150421 
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/barisal_climate_screw.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_dmgfun_filter">
<H2>barisal_dmgfun_filter</H2></A>
<font color="blue">function [DamFunID indx_depth indx_duration indx_windspeed] = barisal_dmgfun_filter(entity) </font>
 find damagefunctions for flood duration (max intensity value is 14 days)
 fprintf('\t- Organize damage functions (flood depth, flood duration, cyclone wind speed)\n')
ax_value_duration =  14.0;
ax_value_depth    =   4.0;
ax_value_windspeed= 400.0;
amFunID       = unique(entity.damagefunctions.DamageFunID);
ndx_depth     = zeros(size(DamFunID));
ndx_duration  = zeros(size(DamFunID));
ndx_windspeed = zeros(size(DamFunID));
or d_i = 1:length(DamFunID)
   indx = entity.damagefunctions.DamageFunID == DamFunID(d_i);
   max_value = max(entity.damagefunctions.Intensity(indx));
   
   if max_value&amplt=max_value_depth+10^-2 &amp max_value&ampgt=max_value_depth-10^-2
       indx_depth(d_i) = 1;
   elseif max_value&amplt=max_value_duration+10^-2 &amp max_value&ampgt=max_value_duration-10^-2
       indx_duration(d_i) = 1;
   elseif max_value&amplt=max_value_windspeed+10^-2 &amp max_value&ampgt=max_value_windspeed-10^-2
       indx_windspeed(d_i) = 1;
   end
nd
ndx_depth     = logical(indx_depth);
ndx_duration  = logical(indx_duration);
ndx_windspeed = logical(indx_windspeed);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/barisal_dmgfun_filter.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_entity_prepare_100m_cells">
<H2>barisal_entity_prepare_100m_cells</H2></A>
% prepare barisal entity, for 100 m cells basis
 entity values are in 1'000'000 BDT (Bangladesh Taka)
hazard type
azard_names = {'flood' 'cyclone_wind'}; 
uture_years = [2014 2030 2050];
 to combine with damage functions, etc from previous ward entity file 
ntity_template_filename = [climada_global.data_dir filesep 'entities' filesep '20150416_values_Barisal_flood_depth.mat'];
   
% loop over hazards
or h_i = 1:length(hazard_names)
   % set some input files
   switch hazard_names{h_i}
       case 'flood'
           hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_FL_depth_monsoon_2014'];
           hazard_name = 'Floods';
           % entity_filename = [climada_global.data_dir filesep 'entities' filesep '20150416_values_Barisal.xls'];
           % entity_filename = [climada_global.data_dir filesep 'entities' filesep '20150504_values_Barisal_100m_Flooding.xls'];
           % entity_filename = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Flooding 040515.xls'];
           entity_filename = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Flooding 060515.xls'];
           
       case 'cyclone_wind'
           hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_TC_2014'];
           hazard_name = 'Cyclones';
           % entity_filename = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Cyclones 040515.xls'];
           entity_filename = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Cyclones 060515.xls'];
   end
   load(hazard_set_file)
   %% read ecorys entities
   % entity floods 2014, 2030 and 2050
   % entity cyclones 2014, 2030 and 2050
   entity       = [];
   for i = 1:length(future_years)
       entity_temp = [];
       fprintf('\n---------------\n\t - Read entity %s %d\n',hazard_name,future_years(i))
       if future_years(i) == 2014
           entity_filename_mat = strrep(entity_filename,'.xls', '.mat');
           if exist(entity_filename_mat,'file')
               delete(entity_filename_mat)
           end
           [entity,entity_save_file] = climada_entity_read(entity_filename,hazard);
           % convert local coordinates to lat lon and reencode
           fprintf('\t- Convert to lat lon and reencode\n')
           entity.assets.X = entity.assets.lon;
           entity.assets.Y = entity.assets.lat;
           [entity.assets.lon, entity.assets.lat] = utm2ll_shift(entity.assets.X, entity.assets.Y);
           entity = climada_assets_encode(entity,hazard);
           % pre-process entity in the special Barisal case (Ecorys formatting)
           entity = barisal_entity_pre_process(entity);
       else
           sheetname = sprintf('%s_%d',hazard_name,future_years(i));
           entity_temp.assets = climada_spreadsheet_read('no',entity_filename,sheetname,1);
           % convert local coordinates to lat lon and reencode
           %fprintf('\t- Convert to lat lon and reencode\n')
           %[entity_temp.assets.lon, entity_temp.assets.lat] = utm2ll_shift(entity_temp.assets.X, entity_temp.assets.Y);
           if isfield(entity_temp.assets,'X')
               entity_temp.assets.Value       = nan(size(entity_temp.assets.X));
               entity_temp.assets.DamageFunID = nan(size(entity_temp.assets.X));
           else
               entity_temp.assets.Value       = nan(size(entity_temp.assets.lon));
               entity_temp.assets.DamageFunID = nan(size(entity_temp.assets.lon));
           end
           %entity_temp = climada_assets_encode(entity_temp,hazard);
           % pre-process entity in the special Barisal case (Ecorys formatting)
           entity_temp = barisal_entity_pre_process(entity_temp);
       end
       switch future_years(i)
           case 2030
               entity.assets.Value_2030 = entity_temp.assets.Value;
           case 2050
               entity.assets.Value_2050 = entity_temp.assets.Value;
       end 
   end
   
   % we use only the assets
   assets = entity.assets;
   % to combine with damage functions, etc from previous ward entity file 
   load(entity_template_filename)
   entity.assets = assets;
   % save
   save(entity_save_file, 'entity')
   fprintf('\t -Entity %s saved\n--------------\n',hazard_name)
   
nd %h_i
% save specific entity files for flood depth, flood duration and cyclone wind speed
 hazard type
azard_names     = {'flood_depth' 'flood_duration' 'cyclone_wind'};     
   
 loop over hazards
or h_i = 1:length(hazard_names)
    
   switch hazard_names{h_i}
       case 'flood_depth'
           %entity_filename     = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Flooding 040515.mat'];
           entity_filename     = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Flooding 060515.mat'];
           entity_filename_new = strrep(entity_filename,'.mat', '_flood_depth.mat');
           comment             = 'Flood depth (m)';
       case 'flood_duration'
           %entity_filename     = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Flooding 040515.mat'];
           entity_filename     = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Flooding 060515.mat'];
           entity_filename_new = strrep(entity_filename,'.mat', '_flood_duration.mat');
           comment             = 'Flood duration (days)';
       case 'cyclone_wind'
           %entity_filename    = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Cyclones 040515.mat'];
           entity_filename    = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Cyclones 060515.mat'];
           entity_filename_new = strrep(entity_filename,'.mat', '_cyclone_windspeed.mat');
           comment             = 'Cyclone wind speed (m/s)';           
   end
   load(entity_filename)
   
   % find unique damage functions and their peril_ID (flood depth, flood duration, cyclone wind speed)
   [DamFunID indx_depth indx_duration indx_windspeed] = barisal_dmgfun_filter(entity);
   
   switch hazard_names{h_i}
       case 'flood_depth'
           non_valid_DamFun    = DamFunID(~indx_depth);
       case 'flood_duration'
           non_valid_DamFun    = DamFunID(~indx_duration);
       case 'cyclone_wind'
           non_valid_DamFun    = DamFunID(~indx_windspeed);
   end
   
   if strcmp(hazard_names{h_i},'cyclone_wind')
       % check that cyclone wind speed is in m/s
       valid_indx = ~ismember(entity.damagefunctions.DamageFunID,non_valid_DamFun);
       
       % transform from kilometers per hour (kph) to m/s
       if max(entity.damagefunctions.Intensity(valid_indx)) == 400
           entity.damagefunctions.Intensity_ori         = entity.damagefunctions.Intensity;
           entity.damagefunctions.Intensity(valid_indx) = entity.damagefunctions.Intensity_ori(valid_indx)/3.6;
           entity.damagefunctions.comment               = 'Transformed intensity to m/s from km/h';
       end
   end
   % set non_hazard_type asset values to zero
   non_valid_indx                           = ismember(entity.assets.DamageFunID, non_valid_DamFun);
   entity.assets.Value(non_valid_indx)      = 0;
   entity.assets.Value_2030(non_valid_indx) = 0;
   entity.assets.Value_2050(non_valid_indx) = 0;
   entity.assets.comment                    = comment;
   % save final entity for a specific hazard type
   save(entity_filename_new, 'entity')
   fprintf('\t- Save entity %s as \n\t%s\n\n', hazard_names{h_i},entity_filename_new)
nd
% see damage functions for different asset categories
 
 asset_cat = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 for cat_i = 1:length(asset_cat)
     fprintf('-----------\n-----------\nAsset category: %s \n-----------\n',asset_cat{cat_i})
     indx = strcmp(entity.assets.Category, asset_cat{cat_i});
     indx(entity.assets.Value&amplt=0) = 0;
     
     DamageFunID = unique(entity.assets.DamageFunID(indx));
     
     for ii = 1:numel(DamageFunID)
         fprintf('Asset DamageFunID: %d \n',DamageFunID(ii))
         indxx = find(entity.damagefunctions.DamageFunID == DamageFunID(ii));
         indxx = indxx(end);
         fprintf('DamageFunID: %d, %s \n',entity.damagefunctions.DamageFunID(indxx), entity.damagefunctions.Description{indxx})
         fprintf('max intensity %2.1f, max MDD %2.1f, \n\n', entity.damagefunctions.Intensity(indxx), entity.damagefunctions.MDD(indxx))     
     end
 end
% 
 % flood depth
 % find all assets that do not correspond to the specific index (damage function unit)
 fprintf('\t- DamageFunctions for flood depth: %d\n', numel(DamFunID(indx_depth)))
 fprintf('%d, ', DamFunID(indx_depth))
 fprintf('\n')
 entity           = entity_ori;
 non_valid_DamFun = DamFunID(~indx_depth);
 non_valid_indx   = ismember(entity.assets.DamageFunID, non_valid_DamFun);
 entity.assets.Value(non_valid_indx)      = 0;
 entity.assets.Value_2030(non_valid_indx) = 0;
 entity.assets.Value_2050(non_valid_indx) = 0;
 entity.assets.comment = 'Flood depth (m)';
 entity_filename       = [climada_global.data_dir filesep 'entities' filesep '20150416_values_Barisal_flood_depth.mat'];
 save(entity_filename, 'entity')
 fprintf('\t- Save entity flood depth as \n\t%s\n\n', entity_filename)
 
 % flood duration
 % find all assets that do not correspond to the specific index (damage function unit)
 fprintf('\t- DamageFunctions for flood duration: %d\n', numel(DamFunID(indx_duration)))
 fprintf('%d, ', DamFunID(indx_duration))
 fprintf('\n')
 entity           = entity_ori;
 non_valid_DamFun = DamFunID(~indx_duration);
 non_valid_indx   = ismember(entity.assets.DamageFunID, non_valid_DamFun);
 entity.assets.Value(non_valid_indx)      = 0;
 entity.assets.Value_2030(non_valid_indx) = 0;
 entity.assets.Value_2050(non_valid_indx) = 0;
 entity.assets.comment = 'Flood duration (days)';
 entity_filename = [climada_global.data_dir filesep 'entities' filesep '20150416_values_Barisal_flood_duration.mat'];
 save(entity_filename, 'entity')
 fprintf('\t- Save entity flood duration as \n\t%s\n\n', entity_filename)
% hazard
 if flood == 1
     % hazard flood
     % asci_file = ;
     % hazard = climada_asci2hazard(asci_file);
     hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_FL_2014'];
     load(hazard_set_file)
     hazard_name = 'Floods';
 
 else    
     % hazard tc wind
     hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_TC_2014'];
     load(hazard_set_file)
     hazard_name = 'Cyclones';
 
     % wind centroids
     centroids_file  = [climada_global.data_dir filesep 'system' filesep 'Barisal_BCC_centroids'];
     load(centroids_file)
 end
% --------------------
  CYCLONE WIND
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/barisal_entity_prepare_100m_cells.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_hazard_FL_ge">
<H2>barisal_hazard_FL_ge</H2></A>
<font color="blue">function barisal_hazard_FL_ge(hazard,google_earth_save,schematic_tag) </font>
 hazard = []; %init
 MODULE:
   barisal_demo
 NAME:
   hazard = []; %init
 PURPOSE:
   flood hazard footprints visualisation in google earth
 CALLING SEQUENCE:
   barisal_hazard_FL_ge(hazard,google_earth_save,schematic_tag)
 EXAMPLE:
   barisal_hazard_FL_ge
 INPUTS:
   hazard: flood hazard
       &ampgt promted for if not given
   google_earth_save: the filename of the resulting .kmz google earth file
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   schematic_tag: set to 1 if schematic plot (no colorbar, indicative
   colorscale). if set to 0, e.g. tc wind color scale is yellow
   (20-30 m/s), orange (30-40 m/s), dark orange (40-50 m/s), etc...
 OUTPUTS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150313, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/barisal_hazard_FL_ge.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_hazard_entity_load">
<H2>barisal_hazard_entity_load</H2></A>
<font color="blue">function [hazard, entity, label] = barisal_hazard_entity_load(hazard_name, cc_scenario, timehorizon) </font>
 load hazard and entity for a given hazard, timehorizon and cc_scenario
 MODULE: 
   barisal_demo
 NAME:
   barisal_hazard_entity_load
 PURPOSE:
   load hazard and entity for a given hazard, timehorizon and cc_scenario
 CALLING SEQUENCE:
   [hazard, entity, label] = barisal_hazard_entity_load(hazard_name, cc_scenario, timehorizon)
 EXAMPLE:
   [hazard, entity, label] = barisal_hazard_entity_load('flood_depth', 'moderate', 2030)
 INPUTS:
   hazard_name: can either be 'flood_depth', 'flood_duration', or 'cyclone_wind'
   cc_scenario: can either be 'no change', 'moderate', or 'extreme'
   timehorizon: can either be 2014, 2030, or 2050
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   load hazard and entity for a given hazard, timehorizon and cc_scenario,
   label: a structure with .hazad_name, .timehorizon, .cc_scenario and
   .titlestr to characterize the scenario
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150429, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/barisal_hazard_entity_load.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_hazard_plot_all">
<H2>barisal_hazard_plot_all</H2></A>
 create hazard plots for all hazard types, time horizons and climate
 change scenarios
% preparations
hazard type
 hazard_names = {'flood_depth_monsoon' 'flood_depth_cyclone' 'flood_duration_monsoon' 'flood_duration_cyclone' 'cyclone_wind'}; 
 hazard_names = {'flood_depth_monsoon' 'flood_depth_cyclone' 'flood_duration_monsoon' 'flood_duration_cyclone'}; 
azard_names = {'flood_duration_monsoon' 'flood_duration_cyclone'}; 
climate change scenario
c_scenario = {'no change' 'moderate' 'extreme'}; 
timehorizon
imehorizon = [2014 2030 2050];
% load barisal wards
CC_wards_savename = [climada_global.data_dir filesep 'entities' filesep 'BCC_wards_number_added.mat'];
oad(BCC_wards_savename)
% find max flood depth (monsoon and cyclone)
 hazard = barisal_hazard_entity_load('flood_depth_monsoon', cc_scenario{3}, timehorizon(3));
 event_max1 = max(full(hazard.intensity(:)));
 hazard = barisal_hazard_entity_load('flood_depth_cyclone', cc_scenario{3}, timehorizon(3));
 event_max2 = max(full(hazard.intensity(:)));
 fprintf('\n\t - Maximum flood depth from monsoon is %2.2fm.\n', event_max1)
 fprintf('\t - Maximum flood depth from cyclone is %2.2fm.\n', event_max2)
 % find max flood duration (monsoon and cyclone)
 hazard = barisal_hazard_entity_load('flood_duration_monsoon', cc_scenario{3}, timehorizon(3));
 event_max1 = max(full(hazard.intensity(:)));
 hazard = barisal_hazard_entity_load('flood_duration_cyclone', cc_scenario{3}, timehorizon(3));
 event_max2 = max(full(hazard.intensity(:)));
 fprintf('\n\t - Maximum flood duration from monsoon is %2.2f days.\n', event_max1)
 fprintf('\t - Maximum flood duration from cyclone is %2.2f days.\n', event_max2)
 % event_min2 = min(nonzeros(full(hazard.intensity(:))));
% loop over hazards
or h_i = 1:length(hazard_names)
   hazard_name = hazard_names{h_i};
   switch hazard_name
       case {'flood_depth_monsoon','flood_depth_cyclone'}
           caxis_range = [0 2.7];
       case {'flood_duration_monsoon','flood_duration_cyclone'}
           caxis_range = [0 50]; %[0 120];
   end
   % loop over time horizons
   for t_i = 1:length(timehorizon)
       
       % loop over climate change scenarios
       for cc_i = 1:length(cc_scenario)
           if ~(t_i==1 &amp cc_i &ampgt1) &amp ~(t_i&ampgt1 &amp cc_i== 1)
               
               % load hazard and entity and create label
               [hazard, entity, label] = barisal_hazard_entity_load(hazard_name, cc_scenario{cc_i}, timehorizon(t_i));
               
               if ~isempty(hazard) &amp ~isempty(entity) 

                   %event_sum = sum(full(hazard.intensity),2);
                   %[a,sorted_i] =sort(event_sum,'descend');
                   
                   % create hazard plots
                   for i = 1:size(hazard.intensity,1)
                       %create figure
                       fig = climada_figuresize(0.6,0.8);
                       climada_hazard_plot(hazard, i,'',caxis_range);
                       %climada_hazard_plot_hr(hazard, i);
                       %set(gca,'layer','top')
                       set(get(colorbar,'ylabel'),'string',sprintf('hazard intensity (%s)',hazard.units),'fontsize',12)
                           hazard_name_string = strrep(regexprep(hazard_name,'(\&amplt[a-z])','${upper($1)}'),'_',' ');
                       if t_i&ampgt1
                           titlestr = sprintf('%s, (%d %s climate change), event %d', hazard_name_string,timehorizon(t_i),cc_scenario{cc_i},i);
                       else
                           titlestr = sprintf('%s (%d %s), event %d', hazard_name_string,timehorizon(t_i),cc_scenario{cc_i},i);
                       end
                       title(titlestr)
                       hold on
                       % loop over all words to plot color according to flood damage
                       BCC_ward_no  = [BCC_wards.Ward_no];
                       for ward_i = 1:length(BCC_ward_no) 
                           %indx   = find(values(ward_i)&amplt=range_values);
                           %indx   = indx(1);
                           %indx_w = find(BCC_ward_no == ward_i);
                           plot(BCC_wards(ward_i).lon,BCC_wards(ward_i).lat,'color',[89 89 89]/255,'linewidth',1); %dark grey
                           %text(mean(BCC_wards(ward_i).lon),mean(BCC_wards(ward_i).lat),BCC_wards(ward_i).UNION_NAME,...
                           %    'Horizontalalignment','center','verticalalignment','bottom'); %grey
                       end
                       foldername = sprintf('%sresults%sdamage_plots%sHazard_%s_%d_%s_event_%d.pdf', filesep,filesep,filesep,...
                                            hazard_name,timehorizon(t_i),strrep(cc_scenario{cc_i},' ','_'),i);
                       print(gcf,'-dpdf',[climada_global.data_dir foldername])
                       close
                   end                    
               end %isempty
           end
       end %cc_i
   end %t_i
nd %h_i
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/barisal_hazard_plot_all.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_hazard_read">
<H2>barisal_hazard_read</H2></A>
 barisal_hazard_read
odule_data_dir = climada_global.data_dir;
 module_data_dir=[climada_modules_dir filesep 'climada_module_barisal_demo' filesep 'data'];
pec = '_rain_only';
azard_names = {'flood_depth_monsoon' 'flood_depth_cyclone' 'flood_duration_monsoon' 'flood_duration_cyclone'};% 'cyclone_wind'}; 
climate change scenario
c_scenario = {'no change' 'moderate' 'extreme'}; 
timehorizon
imehorizon = [2014 2030 2050];
uture_reference_year = 2050;
 set foldername
 foldername = 'M:\BGCC\CHR\RK\RS\A_Sustainable_Development\Projects\ECA\BarisalBangladesh\risk_modelling\flood\';
 foldername = [climada_global.data_dir filesep 'hazards' filesep 'Flood_Barisal\'];
oldername = [module_data_dir filesep 'hazards' filesep 'Flood_Barisal' filesep];
oldername = '\\CHRB1048.CORP.GWPNET.COM\homes\E\S1T2EN\Documents\climada_GIT\vulnerability_analysis_barisal\3_results\';
oldername = '\\CHRB1065.CORP.GWPNET.COM\homes\X\S3BXXW\Documents\lea\climada_git\Vulnerability_Analysis_Barisal\3_results\';
% loop over hazards
or y_i = future_reference_year
or h_i = 1:length(hazard_names)
   hazard_name = hazard_names{h_i};
   
   switch hazard_name
       case 'flood_depth_monsoon';
           filename = 'MonsoonMaxInundationDepths1983.asc';
           units = 'm';
           hazard_set_file = [module_data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_FL_depth_monsoon' ];
           
       case 'flood_depth_cyclone';
           filename = 'CycloneMaxInundationDepths10-11-2007.asc';  
           units = 'm';
           hazard_set_file = [module_data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_FL_depth_cyclone' ];
           
       case 'flood_duration_monsoon';
           filename = 'MonsoonMaxInundationDurations1983.asc';
           units = 'days';
           hazard_set_file = [module_data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_FL_duration_monsoon' ];
           
       case 'flood_duration_cyclone';
           filename = 'CycloneMaxInundationDurations10-11-2007.asc';
           units = 'days';
           hazard_set_file = [module_data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_FL_duration_cyclone' ];
   end   
   
   % loop over climate change scenarios
   for cc_i = 1:length(cc_scenario)
       switch cc_scenario{cc_i}
           case 'no change'
               folder_ = ['Floods_current_scenario' filesep];
               reference_year = 2014;
               hazard_set_file_ = sprintf('%s_%d.mat',hazard_set_file,reference_year);
               
           case 'moderate'
               folder_ = ['Floods_' num2str(y_i) '_CCMod' filesep];
               reference_year = y_i;
               %folder_ = 'Floods_2050_CCMod\';
               %reference_year = 2050;
               hazard_set_file_ = sprintf('%s_cc_%d_%s.mat',hazard_set_file,reference_year,cc_scenario{cc_i});
                
           case 'extreme'
               folder_ = ['Floods_' num2str(y_i) '_CCHigh' filesep];
               reference_year = y_i;
               %folder_ = 'Floods_2050_CCHigh\';
               %reference_year = 2050;
               hazard_set_file_ = sprintf('%s_cc_%d_%s.mat',hazard_set_file,reference_year,cc_scenario{cc_i});
       end
       
       fprintf('%s\n',[foldername folder_ filename])
         hazard = climada_asci2hazard([foldername folder_ filename],6);
       hazard = climada_asci2hazard([foldername folder_ filename]);
       hazard.comment = sprintf('%s %s, modelled by W+B', strrep(hazard_name,'_',' '), cc_scenario{cc_i});
       hazard.reference_year = reference_year;
       % add fieldname .scenario
       hazard.scenario = cc_scenario{cc_i};
       if ~isempty(strfind(upper(hazard_name), 'DURATION'))
           hazard.peril_ID = 'FL_';
       else
           hazard.peril_ID = 'FL';
       end
       
       hazard.units    = units;
       if ~isempty(strfind(hazard_name,'cyclone'))
           hazard.frequency    = [0.05 0.05 0.02 0.03]*1.2;
           hazard.dd           = [10 22 25 30];
           hazard.mm           = [11 11 05 11];
           hazard.yyyy         = [2007 1998 2009 1988];
           hazard.datenum      = datenum(hazard.yyyy,hazard.mm,hazard.dd);
       elseif ~isempty(strfind(hazard_name,'monsoon'))
       end
       
       save(hazard_set_file_, 'hazard');        
   end
nd
nd
lear hazard_set_file_ reference_year folder_ filename units hazard_set_file 
lear cc_scenario cc_i hazard_name h_i y_i future_reference_year hazard_names 
lear foldername timehorizon spec module_data_dir
%
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/barisal_hazard_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_plot_3d">
<H2>climada_EDS_plot_3d</H2></A>
<font color="blue">function fig=climada_EDS_plot_3d(hazard,EDS,event_i,check_labels,varargin) </font>
 climada visualise event damage
 NAME:
   climada_plot_EDS_3d
 PURPOSE:
   Plot the damage to assets from event damage set (EDS - calculated using
   climada_EDS_calc) as a 3d bar chart, overlaying the country borders.
   Further, a surface (for TS) or a contour (for other hazards) is plotted
   to show the spatial extent.
 CALLING SEQUENCE:
   fig = climada_plot_EDS_3d(hazard,EDS,event_i)
 EXAMPLE:
   climada_plot_EDS_3d(hazard,EDS,event_i)
 INPUTS:
   hazard: hazard structure
   EDS: event damage set structure, see climada_EDS_calc
 OPTIONAL INPUT PARAMETERS:
   event_i: specify event number of interest (e.g. use climada_hazard_plot
       to figure ID of largest, 2nd largest... event)
       If empty, the largest event is displayed
 OUTPUTS:
   fig             : figure handle
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com 20141204
 David N. Bresch, david.bresch@gmail.com, 20141215, cleanup
 Gilles Stassen, 20150114 fixed conversion issues + cleanup
 Gilles Stassen, 20150517 added varargin for plotting extra features, fixed issue with axis labeling
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/climada_EDS_plot_3d.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ED_plot_per_ward">
<H2>climada_ED_plot_per_ward</H2></A>
<font color="blue">function fig = climada_ED_plot_per_ward(EDS,entity, BCC_wards, timehorizon, hazard_name) </font>
 create figure to plot expected damage per ward in barisal
 MODULE: 
   barisal_demo
 NAME:
   climada_ED_plot_per_ward
 PURPOSE:
   plot annual expected damage per ward on a map
 CALLING SEQUENCE:
   fig = climada_ED_plot_per_ward(EDS,entity, BCC_wards, timehorizon, hazard_name)
 EXAMPLE:
   fig = climada_ED_plot_per_ward(EDS,entity, BCC_wards, timehorizon, hazard_name)
 INPUTS:
   EDS: event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       EDS can contain multiple EDS, however default is that first EDS
       will be used.
   entity: an entity (see climada_entity_read)
       &ampgt promted for if not given
   BCC_wards: structure with shape file (polygons for all 30 wards in
       Barisal)
 OPTIONAL INPUT PARAMETERS:
   timehorizon: just for figure title, empty if not specified
   hazard_name: just for figure title, empty if not specified
 OUTPUTS:
   figure with damage per ward on a map 
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150429, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/climada_ED_plot_per_ward.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ascii_read">
<H2>climada_ascii_read</H2></A>
<font color="blue">function output = climada_ascii_read(asci_file,save_file,check_plot,delim) </font>
 climada_ascii_read
 MODULE:
   climada core
 NAME:
   climada_ascii_read
 PURPOSE:
   read asci file and store as struct
 CALLING SEQUENCE:
   hazard=climada_asci2hazard(asci_file)
 EXAMPLE:
   hazard=climada_asci2hazard
 INPUTS: 
 OPTIONAL INPUT PARAMETERS:
   asci_file: prompted for if not given. Asci file is delimited by tabs
   (\t) and has 6 rows of information (ncols, nrows, xllcorner, yllcorner,
   cellsize, NODATA_value).
 OUTPUTS: hazard
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150511, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/climada_ascii_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_assets_plot_per_point">
<H2>climada_assets_plot_per_point</H2></A>
<font color="blue">function fig = climada_ED_plot_per_point(EDS,entity, BCC_wards, timehorizon, hazard_name) </font>
 create figure to plot expected damage per ward in barisal
 MODULE: 
   barisal_demo
 NAME:
   climada_ED_plot_per_ward
 PURPOSE:
   plot annual expected damage per ward on a map
 CALLING SEQUENCE:
   fig = climada_ED_plot_per_ward(EDS,entity, BCC_wards, timehorizon, hazard_name)
 EXAMPLE:
   fig = climada_ED_plot_per_ward(EDS,entity, BCC_wards, timehorizon, hazard_name)
 INPUTS:
   EDS: event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       EDS can contain multiple EDS, however default is that first EDS
       will be used.
   entity: an entity (see climada_entity_read)
       &ampgt promted for if not given
   BCC_wards: structure with shape file (polygons for all 30 wards in
       Barisal)
 OPTIONAL INPUT PARAMETERS:
   timehorizon: just for figure title, empty if not specified
   hazard_name: just for figure title, empty if not specified
 OUTPUTS:
   figure with damage per ward on a map 
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150429, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/climada_assets_plot_per_point.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_distributed_measures">
<H2>climada_distributed_measures</H2></A>
<font color="blue">function [hazard,measure]= climada_distributed_measures(measure_file, hazard,bsxfun_op,save_file,check_plot) </font>
climada_distributed_measures
 NAME:
   climada_distributed_measures
 PURPOSE:
  function to account for measures that are introduced via an ascii file
  the script reduces a selected hazard intensity by the grid value after
  checking for NaN value and ensuring no minus values are produced.
 CALLING SEQUENCE:
   climada_distributed_measures
 EXAMPLE:
   climada_distributed_measures
 INPUTS:
   acsii grid
   .mat hazard file
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   new hazard file called hazard_w_measures, hazard, measure_grid (reduction from ascii
   file)
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 Jacob Anz, j.anz@gmx.net, 20150609
 Gilles Stassen, gillesstassen@hotmail.com, 20150610, clean up, bsx_fun_op added               
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/climada_distributed_measures.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_waterfall_graph_barisal">
<H2>climada_waterfall_graph_barisal</H2></A>
<font color="blue">function  fig = climada_waterfall_graph_barisal(EDS, return_period, check_printplot) </font>
 waterfall figure, expected damage for specified return period for
 - today,
 - increase from economic growth,
 - increase from high climate change, total expected damage 2030
 for the three EDS quoted above
 NAME:
   climada_waterfall_graph
 PURPOSE:
   plot expected damage for specific return period
 CALLING SEQUENCE:
   climada_waterfall_graph(EDS1, EDS2, EDS3, return_period,
   check_printplot)
 EXAMPLE:
   climada_waterfall_graph
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   EDS:            three event damage sets
                   - today
                   - economic growth
                   - cc combined with economic growth, future
   return_period:  requested return period for according expected damage,or
                   annual expted damage, prompted if not given
   check_printplot:if set to 1, figure saved, default 0.
 OUTPUTS:
   waterfall graph
 MODIFICATION HISTORY:
 Lea Mueller, 20110622
 Martin Heynen, 20120329
 David N. Bresch, david.bresch@gmail.com, 20130316 EDS-&ampgtEDS
 David N. Bresch, david.bresch@gmail.com, 20150419 try-catch for arrow plotting
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/climada_waterfall_graph_barisal.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_waterfall_graph_barisal_combined">
<H2>climada_waterfall_graph_barisal_combined</H2></A>
<font color="blue">function  fig = climada_waterfall_graph_barisal_combined(EDS, check_printplot) </font>
 waterfall figure, expected damage for specified return period for
 - today,
 - increase from economic growth,
 - increase from high climate change, total expected damage 2030
 for multiple hazard types (flood, cyclone, etc). Hardwired for Barisal,
 see event_selection, which lists the index of today's damage for
 different hazard types.
 NAME:
   climada_waterfall_graph_barisal_combined
 PURPOSE:
   plot waterfall graph based on annual expected damage for different hazard types 
 CALLING SEQUENCE:
   fig = climada_waterfall_graph_barisal_combined(EDS, check_printplot)
 EXAMPLE:
   climada_waterfall_graph_barisal_combined
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   EDS: multiple event damage sets that contain scenarios on today,
   economic growth, climate change for a future time horizon, for
   different hazard types. The vector event_selection points to today's 
   damage fordifferent hazard types.
 OUTPUTS:
   waterfall graph
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150511, init, hard-wired for Barisal
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/climada_waterfall_graph_barisal_combined.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="ll2btm">
<H2>ll2btm</H2></A>
<font color="blue">function [x,y,f]=ll2btm(varargin) </font>
LL2UTM Lat/Lon to BTM coordinates precise conversion.
	[X,Y]=LL2BTM2(LAT,LON) or LL2BTM([LAT,LON]) converts coordinates 
	LAT,LON (in degrees) to UTM X and Y (in meters). Default datum is WGS84.

	LAT and LON can be scalars, vectors or matrix. Outputs X and Y will
	have the same size as inputs.

	LL2BTM(...,DATUM) uses specific DATUM for conversion. DATUM can be one
	of the following char strings:
		'wgs84': World Geodetic System 1984 (default)
		'nad27': North American Datum 1927
		'clk66': Clarke 1866
		'nad83': North American Datum 1983
		'grs80': Geodetic Reference System 1980
		'int24': International 1924 / Hayford 1909
	or DATUM can be a 2-element vector [A,F] where A is semimajor axis (in
	meters)	and F is flattening of the user-defined ellipsoid.

	XY=LL2BTM(...) or without any output argument returns a 2-column 
	matrix [X,Y].

	Note:
		- LL2BTM does not perform cross-datum conversion.
		- precision is near a millimeter.


	Reference:
		I.G.N., Projection cartographique Mercator Transverse: Algorithmes,
		   Notes Techniques NT/G 76, janvier 1995.

	Acknowledgments: Mathieu, Frederic Christen.


	Author: Francois Beauducel, &ampltbeauducel@ipgp.fr&ampgt
	Created: 2003-12-02
	Updated: 2015-01-29
   Changed to BTM: Ruud van der Ent, 2015-03-13
	Copyright (c) 2001-2015, Franois Beauducel, covered by BSD License.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without 
	modification, are permitted provided that the following conditions are 
	met:

	   * Redistributions of source code must retain the above copyright 
	     notice, this list of conditions and the following disclaimer.
	   * Redistributions in binary form must reproduce the above copyright 
	     notice, this list of conditions and the following disclaimer in 
	     the documentation and/or other materials provided with the distribution
	                           
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quotAS IS&quot 
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
	CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
	INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
	POSSIBILITY OF SUCH DAMAGE.
 Available datums
atums = [ ...
{ 'wgs84', 6378137.0, 298.257223563 };
{ 'nad83', 6378137.0, 298.257222101 };
{ 'grs80', 6378137.0, 298.257222101 };
{ 'nad27', 6378206.4, 294.978698214 };
{ 'int24', 6378388.0, 297.000000000 };
{ 'clk66', 6378206.4, 294.978698214 };
   { 'eve30', 6377299.36, 300.8017 };
;
 constants
0 = 180/pi;	% conversion rad to deg
0 = 0.9996;	% BTM scale factor
0 = 500000;	% BTM false East (m)
 defaults
atum = 'wgs84';
f nargin &amplt 1
error('Not enough input arguments.')
nd
f nargin &ampgt 1 &amp&amp isnumeric(varargin{1}) &amp&amp isnumeric(varargin{2}) &amp&amp all(size(varargin{1})==size(varargin{2}))
lat = varargin{1};
lon = varargin{2};
v = 2;
lseif isnumeric(varargin{1}) &amp&amp size(varargin{1},2) == 2
lat = varargin{1}(:,1);
lon = varargin{1}(:,2);
v = 1;
lse
error('Single input argument must be a 2-column matrix [LAT,LON].')
nd
f all([numel(lat),numel(lon)] &ampgt 1) &amp&amp any(size(lat) ~= size(lon))
error('LAT and LON must be the same size or scalars.')
nd
or n = (v+1):nargin
% LL2UTM(...,DATUM)
if ischar(varargin{n}) || (isnumeric(varargin{n}) &amp&amp numel(varargin{n})==2)
	datum = varargin{n};
% LL2UTM(...,ZONE)
else
	error('Unknown argument #%d. See documentation.',n)
end
nd
f ischar(datum)
% LL2UTM(...,DATUM) with DATUM as char
if ~any(strcmpi(datum,datums(:,1)))
	error('Unkown DATUM name &quot%s&quot',datum);
end
k = find(strcmpi(datum,datums(:,1)));
A1 = datums{k,2};
F1 = datums{k,3};	
lse
% LL2UTM(...,DATUM) with DATUM as [A,F] user-defined
A1 = datum(1);
F1 = datum(2);
nd
1 = lat/D0;			% Phi = Latitude (rad)
1 = lon/D0;			% Lambda = Longitude (rad)
1 = A1*(1 - 1/F1);
1 = sqrt((A1*A1 - B1*B1)/(A1*A1));
0 = 0;
0 = 90/D0;	% BTM origin longitude (rad)
0 = -2000000;		% UTM false northern (m)
 = K0*A1;
 = coef(E1,0);
 = C(1)*P0 + C(2)*sin(2*P0) + C(3)*sin(4*P0) + C(4)*sin(6*P0) + C(5)*sin(8*P0);
S = Y0 - N*B;
 = coef(E1,2);
 = log(tan(pi/4 + p1/2).*(((1 - E1*sin(p1))./(1 + E1*sin(p1))).^(E1/2)));
 = complex(atan(sinh(L)./cos(l1 - L0)),log(tan(pi/4 + asin(sin(l1 - L0)./cosh(L))/2)));
 = N.*C(1).*z + N.*(C(2)*sin(2*z) + C(3)*sin(4*z) + C(4)*sin(6*z) + C(5)*sin(8*z));
s = imag(Z) + X0;
s = real(Z) + YS;
 outputs zone if needed: scalar value if unique, or vector/matrix of the
 same size as x/y in case of crossed zones
f nargout &ampgt 2
  	f = F0.*sign(lat);
fu = unique(f);
if isscalar(fu)
	f = fu;
end
nd
f nargout &amplt 2
x = [xs(:),ys(:)];
lse
x = xs;
y = ys;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function c = coef(e,m) </font>
COEF Projection coefficients
	COEF(E,M) returns a vector of 5 coefficients from:
		E = first ellipsoid excentricity
		M = 0 for transverse mercator
		M = 1 for transverse mercator reverse coefficients
		M = 2 for merdian arc
f nargin &amplt 2
m = 0;
nd
witch m
case 0
c0 = [-175/16384, 0,   -5/256, 0,  -3/64, 0, -1/4, 0, 1;
          -105/4096, 0, -45/1024, 0,  -3/32, 0, -3/8, 0, 0;
          525/16384, 0,  45/1024, 0, 15/256, 0,    0, 0, 0;
         -175/12288, 0, -35/3072, 0,      0, 0,    0, 0, 0;
         315/131072, 0,        0, 0,      0, 0,    0, 0, 0];
  
case 1
c0 = [-175/16384, 0,   -5/256, 0,  -3/64, 0, -1/4, 0, 1;
            1/61440, 0,   7/2048, 0,   1/48, 0,  1/8, 0, 0;
         559/368640, 0,   3/1280, 0,  1/768, 0,    0, 0, 0;
         283/430080, 0, 17/30720, 0,      0, 0,    0, 0, 0;
      4397/41287680, 0,        0, 0,      0, 0,    0, 0, 0];
case 2
c0 = [-175/16384, 0,   -5/256, 0,  -3/64, 0, -1/4, 0, 1;
        -901/184320, 0,  -9/1024, 0,  -1/96, 0,  1/8, 0, 0;
        -311/737280, 0,  17/5120, 0, 13/768, 0,    0, 0, 0;
         899/430080, 0, 61/15360, 0,      0, 0,    0, 0, 0;
     49561/41287680, 0,        0, 0,      0, 0,    0, 0, 0];
  
nd
 = zeros(size(c0,1),1);
or i = 1:size(c0,1)
   c(i) = polyval(c0(i,:),e);
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/ll2btm.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="ll2utm_shift">
<H2>ll2utm_shift</H2></A>
<font color="blue">function [X, Y] = ll2utm_shift(lat,lon) </font>
 climada
 MODULE:
   barisal_demo
 NAME:
   utm2ll_shift
 PURPOSE:
   Transform local UTM/btm coordinates (GCS  Everest 1830, used in
   Barisal, Bangladesh, X,Y (in meters)) into worldwide
   lon-lat-coordinates (in degrees). Additionally a shift is added to
   improve the transformation. Default datum is WGS84.
 CALLING SEQUENCE:
   [lon,lat] = utm2ll_shift(X,Y,datum)
 EXAMPLE:
   [lon,lat] = utm2ll_shift(X,Y)
 INPUTS:
   lon: 	longitude
   lat: 	latitude
 OPTIONAL INPUT PARAMETERS:
   DATUM can be astring in the following list:
		'wgs84': World Geodetic System 1984 (default)
		'nad27': North American Datum 1927
		'clk66': Clarke 1866
		'nad83': North American Datum 1983
		'grs80': Geodetic Reference System 1980
		'int24': International 1924 / Hayford 1909
 OUTPUTS:
   X: Eastin meter
   Y: North in meter
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150617 init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/ll2utm_shift.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="subdir">
<H2>subdir</H2></A>
<font color="blue">function varargout = subdir(varargin) </font>
SUBDIR Performs a recursive file search

 subdir
 subdir(name)
 files = subdir(...)

 This function performs a recursive file search.  The input and output
 format is identical to the dir function.

 Input variables:

   name:   pathname or filename for search, can be absolute or relative
           and wildcards (*) are allowed.  If ommitted, the files in the
           current working directory and its child folders are returned    

 Output variables:

   files:  m x 1 structure with the following fields:
           name:   full filename
           date:   modification date timestamp
           bytes:  number of bytes allocated to the file
           isdir:  1 if name is a directory; 0 if no

 Example:

   &ampgt&ampgt a = subdir(fullfile(matlabroot, 'toolbox', 'matlab', '*.mat'))

   a = 

   67x1 struct array with fields:
       name
       date
       bytes
       isdir

   &ampgt&ampgt a(2)

   ans = 

        name: '/Applications/MATLAB73/toolbox/matlab/audiovideo/chirp.mat'
        date: '14-Mar-2004 07:31:48'
       bytes: 25276
       isdir: 0

 See also:

   dir
 Copyright 2006 Kelly Kearney
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/subdir.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="tc_surge_plot_3d_Barisal">
<H2>tc_surge_plot_3d_Barisal</H2></A>
<font color="blue">function tc_surge_plot_3d_Barisal(hazard,event_i,seashore,EDS) </font>
 climada
 NAME:
   tc_surge_plot_3d_Barisal
 PURPOSE:
   plot surge hazard as 3D surface, 'overshadowing' terrain
 CALLING SEQUENCE:
   tc_surge_plot3d(hazard,event_i);
 EXAMPLE:
   climada_hazard_plot(climada_hazard_load);
 INPUTS:
   hazard: hazard structure
       consider to use climada_hazard_load, as in the example
   event_i: the i-th event in the hazard event set to be displayed
       if event_i=0, the maximum intensity at each centroid is shown
       if event_i=-i, the i-th 'largest' event (sum of intensities) is shown
           e.g. for event_i=-2, the second largest event is shown
       default=-1 (just to get something on the screen ;-)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   figure
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140503
 Gilles Stassen, gillesstassen@hotmail.com 20141126 adapted
 tc_surge_plot_3d with some Barisal specific modifications.
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/tc_surge_plot_3d_Barisal.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="utm2ll">
<H2>utm2ll</H2></A>
<font color="blue">function [lon,lat] = utm2ll(x,y,datum,varargin) </font>
UTM2LL UTM to Lat/Lon coordinates precise conversion.
	[LON,LAT]=UTM2LL(X,Y,ZONE) converts BTM coordinates X,Y (in meters)
	defined in the UTM ZONE (integer) to longitude LON and latitude LAT
	(in degrees). Default datum is WGS84.

	X, Y and F can be scalars, vectors or matrix. Outputs LAT and LON will
	have the same size as inputs.

	For southern hemisphere points, use negative zone -ZONE.

	UTM2LL(X,Y,ZONE,DATUM) uses specific DATUM for conversion. DATUM can be
	a string in the following list:
		'wgs84': World Geodetic System 1984 (default)
		'nad27': North American Datum 1927
		'clk66': Clarke 1866
		'nad83': North American Datum 1983
		'grs80': Geodetic Reference System 1980
		'int24': International 1924 / Hayford 1909
	or DATUM can be a 2-element vector [A,F] where A is semimajor axis (in
	meters)	and F is flattening of the user-defined ellipsoid.

	Notice:
		- BTM2LL does not perform cross-datum conversion.
		- precision is near a millimeter.


	Reference:
		I.G.N., Projection cartographique Mercator Transverse: Algorithmes,
		   Notes Techniques NT/G 76, janvier 1995.

	Author: Francois Beauducel, &ampltbeauducel@ipgp.fr&ampgt
	Created: 2001-08-23
	Updated: 2015-01-29
   Changed to BTM: Ruud van der Ent, 2015-03-13
   Lea Mueller, muellele@gmail.com, 20150415, order change, first lon, then lat
	Copyright (c) 2001-2015, Franois Beauducel, covered by BSD License.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without 
	modification, are permitted provided that the following conditions are 
	met:

	   * Redistributions of source code must retain the above copyright 
	     notice, this list of conditions and the following disclaimer.
	   * Redistributions in binary form must reproduce the above copyright 
	     notice, this list of conditions and the following disclaimer in 
	     the documentation and/or other materials provided with the distribution
	                           
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quotAS IS&quot 
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
	CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
	INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
	POSSIBILITY OF SUCH DAMAGE.
 Available datums
atums = [ ...
{ 'wgs84', 6378137.0, 298.257223563 };
{ 'nad83', 6378137.0, 298.257222101 };
{ 'grs80', 6378137.0, 298.257222101 };
{ 'nad27', 6378206.4, 294.978698214 };
{ 'int24', 6378388.0, 297.000000000 };
{ 'clk66', 6378206.4, 294.978698214 };
   { 'eve30', 6377299.36, 300.8017 };
;
f nargin &amplt 2
error('Not enough input arguments.')
nd
f all([numel(x),numel(y)] &ampgt 1) &amp&amp any(size(x) ~= size(y))
error('X and Y must be the same size or scalars.')
nd
f ~exist('datum','var'), datum = ''; end
f isempty(datum), datum = 'wgs84'; end
f nargin &amplt 3
datum = 'wgs84';
nd
f ischar(datum)
if ~any(strcmpi(datum,datums(:,1)))
	error('Unkown DATUM name &quot%s&quot',datum);
end
k = find(strcmpi(datum,datums(:,1)));
A1 = datums{k,2};
F1 = datums{k,3};	
lse
if numel(datum) ~= 2
	error('User defined DATUM must be a vector [A,F].');
end
A1 = datum(1);
F1 = datum(2);
nd
 constants
0 = 180/pi;	% conversion rad to deg
axiter = 100;	% maximum iteration for latitude computation
ps = 1e-11;	% minimum residue for latitude computation
0 = 0.9996;				% BTM scale factor
0 = 500000;				% BTM false East (m)
0 = -2000000;				% BTM false North (m)
0 = 0;						% BTM origin latitude (rad)
0 = 90/D0;                 % BTM origin longitude (rad)
1 = sqrt((A1^2 - (A1*(1 - 1/F1))^2)/A1^2);	% ellpsoid excentricity
 = K0*A1;
 computing parameters for Mercator Transverse projection
 = coef(E1,0);
S = Y0 - N*(C(1)*P0 + C(2)*sin(2*P0) + C(3)*sin(4*P0) + C(4)*sin(6*P0) + C(5)*sin(8*P0));
 = coef(E1,1);
t = complex((y - YS)/N/C(1),(x - X0)/N/C(1));
 = zt - C(2)*sin(2*zt) - C(3)*sin(4*zt) - C(4)*sin(6*zt) - C(5)*sin(8*zt);
 = real(z);
S = imag(z);
 = L0 + atan(sinh(LS)./cos(L));
 = asin(sin(L)./cosh(LS));
 = log(tan(pi/4 + p/2));
 calculates latitude from the isometric latitude
 = 2*atan(exp(L)) - pi/2;
0 = NaN;
 = 0;
hile any(isnan(p0) | abs(p - p0) &ampgt eps) &amp&amp n &amplt maxiter
p0 = p;
es = E1*sin(p0);
p = 2*atan(((1 + es)./(1 - es)).^(E1/2).*exp(L)) - pi/2;
n = n + 1;
nd
f nargout &amplt 2
lat = D0*[p(:),l(:)];
lse
lat = p*D0;
lon = l*D0;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function c = coef(e,m) </font>
COEF Projection coefficients
	COEF(E,M) returns a vector of 5 coefficients from:
		E = first ellipsoid excentricity
		M = 0 for transverse mercator
		M = 1 for transverse mercator reverse coefficients
		M = 2 for merdian arc
f nargin &amplt 2
m = 0;
nd
witch m
case 0
c0 = [-175/16384, 0,   -5/256, 0,  -3/64, 0, -1/4, 0, 1;
          -105/4096, 0, -45/1024, 0,  -3/32, 0, -3/8, 0, 0;
          525/16384, 0,  45/1024, 0, 15/256, 0,    0, 0, 0;
         -175/12288, 0, -35/3072, 0,      0, 0,    0, 0, 0;
         315/131072, 0,        0, 0,      0, 0,    0, 0, 0];
  
case 1
c0 = [-175/16384, 0,   -5/256, 0,  -3/64, 0, -1/4, 0, 1;
            1/61440, 0,   7/2048, 0,   1/48, 0,  1/8, 0, 0;
         559/368640, 0,   3/1280, 0,  1/768, 0,    0, 0, 0;
         283/430080, 0, 17/30720, 0,      0, 0,    0, 0, 0;
      4397/41287680, 0,        0, 0,      0, 0,    0, 0, 0];
case 2
c0 = [-175/16384, 0,   -5/256, 0,  -3/64, 0, -1/4, 0, 1;
        -901/184320, 0,  -9/1024, 0,  -1/96, 0,  1/8, 0, 0;
        -311/737280, 0,  17/5120, 0, 13/768, 0,    0, 0, 0;
         899/430080, 0, 61/15360, 0,      0, 0,    0, 0, 0;
     49561/41287680, 0,        0, 0,      0, 0,    0, 0, 0];
  
nd
 = zeros(size(c0,1),1);
or i = 1:size(c0,1)
   c(i) = polyval(c0(i,:),e);
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/utm2ll.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="utm2ll_shift">
<H2>utm2ll_shift</H2></A>
<font color="blue">function [lon, lat] = utm2ll_shift(X,Y,datum) </font>
 climada
 MODULE:
   barisal_demo
 NAME:
   utm2ll_shift
 PURPOSE:
   Transform local UTM/btm coordinates (GCS  Everest 1830, used in
   Barisal, Bangladesh, X,Y (in meters)) into worldwide
   lon-lat-coordinates (in degrees). Additionally a shift is added to
   improve the transformation. Default datum is WGS84.
 CALLING SEQUENCE:
   [lon,lat] = utm2ll_shift(X,Y,datum)
 EXAMPLE:
   [lon,lat] = utm2ll_shift(X,Y)
 INPUTS:
   X: Eastin meter
   Y: North in meter
 OPTIONAL INPUT PARAMETERS:
   DATUM can be astring in the following list:
		'wgs84': World Geodetic System 1984 (default)
		'nad27': North American Datum 1927
		'clk66': Clarke 1866
		'nad83': North American Datum 1983
		'grs80': Geodetic Reference System 1980
		'int24': International 1924 / Hayford 1909
 OUTPUTS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150315, initial
 Lea Mueller, muellele@gmail.com, 20150415, order change, first lon, then lat
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/helper_functions/utm2ll_shift.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_climada_measures_impact_report_OLD">
<H2>_climada_measures_impact_report_OLD</H2></A>
<font color="blue">function MI_EDS_combined = climada_measures_impact_report(measures_impact,report_xls_file) </font>
 climada_measures_impact_report
 MODULE:
   climada core
 NAME:
   climada_measures_impact_report
 PURPOSE:
   combine EDS's of measures_impact structure array, then print to excel
 CALLING SEQUENCE:
   MI_EDS_combined=climada_measures_impact_report(measures_impact,report_xls_file)
 EXAMPLE:
   shape_plotter(shapes,'attribute name','linewidth',2,'color','r')
 INPUTS:
   measures_impact:   measures impact struct, see climada_measures_impact
 OPTIONAL INPUT PARAMETERS:
   report_xls_file:   xls file to save to
 OUTPUTS:
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150623, init
 Gilles Stassen, 20150707, bug fix for multiple measure matches when using find
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/old/_climada_measures_impact_report_OLD.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_risk_calculation_excel">
<H2>barisal_risk_calculation_excel</H2></A>
% barisal_risk_calculations
 - tc wind hazard: use barisal_tc_hazard_prob.m to create wind hazard
 - flood hazard: read asci-file from Ruud (Witteveen+Bos), load flood hazard
 barisal_hazard_read.m and barisal_hazard_plot_all.m
 prepare entity with 
 barisal_entity_prepare_100m_cells.m
% set scenario
hazard type
azard_names = {'flood_depth_monsoon' 'flood_depth_cyclone' 'flood_duration_monsoon' 'flood_duration_cyclone' 'cyclone_wind'}; 
azard_names = {'flood_depth_monsoon_rain_only' 'flood_depth_cyclone_rain_only' 'flood_duration_monsoon_rain_only' 'flood_duration_cyclone_rain_only'}; 
climate change scenario
c_scenario = {'no change' 'moderate' 'extreme'}; 
c_scenario = {'moderate'}; 
timehorizon
imehorizon = [2014 2030 2050];
imehorizon = [2030];
 centroid_index = entity.assets.centroid_index;
 [hazard, entity, label] = barisal_hazard_entity_load('flood_depth_cyclone', cc_scenario{cc_i}, timehorizon(t_i));
 dif = sum(entity.assets.centroid_index-centroid_index);
% load barisal specifics
odule_data_dir=[climada_modules_dir filesep 'barisal_demo' filesep 'data'];
CC_savename = [module_data_dir filesep 'entities' filesep 'BCC_border.mat'];
oad(BCC_savename)
 load BCC ward boundaries (35 polygons)
 BCC_wards_savename = [module_data_dir filesep 'entities' filesep 'BCC_wards.mat'];
 BCC_wards_savename = [module_data_dir filesep 'entities' filesep 'BCC_wards_Ward_no_added.mat'];
CC_wards_savename = [module_data_dir filesep 'entities' filesep 'BCC_wards_number_added.mat'];
oad(BCC_wards_savename)
ndx = strfind(BCC_savename,filesep);
ndx2 = strfind(BCC_wards_savename,filesep);
printf('\t - loaded BCC specifics: %s and %s\n', BCC_savename(indx(end)+1:end), BCC_wards_savename(indx2(end)+1:end))
% load hazard and entity
 counter    = 0;
DS_all    = '';
ntity_all = '';
 loop over hazards
or h_i = 1:length(hazard_names)
   hazard_name = hazard_names{h_i};
   
   counter     = 0;
   EDS         = []; 
   silent_mode = 1;
   % loop over time horizons
   for t_i = 1:length(timehorizon)
       
       % loop over climate change scenarios
       for cc_i = 1:length(cc_scenario)
           if ~(t_i == 1 &amp cc_i &ampgt1)  
               
               %% load hazard and entity and create label
               [hazard, entity, label] = barisal_hazard_entity_load(hazard_name, cc_scenario{cc_i}, timehorizon(t_i));
               
               if ~isempty(hazard) &amp ~isempty(entity) 
                   
                   % reencode assets to hazard
                   if h_i==1 &amp t_i==1 &amp cc_i==1
                       entity = climada_assets_encode(entity,hazard);
                       centroid_index = entity.assets.centroid_index;
                   else
                       encode_checksum = sum(centroid_index-entity.assets.centroid_index);
                       fprintf('\t - centroid_index difference is %2.2f\n',encode_checksum);
                       if encode_checksum == 0
                           entity.assets.centroid_index = centroid_index;
                       else
                           entity = climada_assets_encode(entity,hazard);
                           centroid_index = entity.assets.centroid_index;
                       end
                   end
                   
                   % loop over asset categories
                   asset_cat = unique(entity.assets.Category(entity.assets.Value&ampgt0));
                   for cat_i = length(asset_cat)+1%1:length(asset_cat)+1
                       %% the most inner loop, set counter
                       counter = counter+1;
                       % select only assets in specific category
                       if cat_i&amplt=length(asset_cat)
                           %indx = strcmp(entity.assets.Category, asset_cat{cat_i});
                           indx = ismember(entity.assets.Category, asset_cat(1:cat_i));
                           annotation_name = asset_cat{cat_i};
                       else
                           indx = ones(size(entity.assets.Category));
                           annotation_name = 'All asset categories';
                       end
                   
                       %% calculate expected damage set (EDS)
                       entity.assets.Value(~indx) = 0;
                       force_re_encode = 0;
                       titlestr = sprintf('%s, %s, %s',label.hazard_name, label.cc_scenario, label.titlestr);
                       if isempty(EDS)
                           EDS = climada_EDS_calc(entity,hazard,titlestr,force_re_encode,silent_mode);
                           EDS.reference_year = timehorizon(t_i);
                           %EDS.label = label;
                       else
                           %EDS_ = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
                           %EDS(cat_i) = EDS_;
                           EDS(counter) = climada_EDS_calc(entity,hazard,titlestr,force_re_encode,silent_mode);
                           EDS(counter).reference_year = timehorizon(t_i);
                           %EDS(counter).label = label;
                       end
                   end %cat_i
               end %~isempty(hazard)
           end
       end %cc_i 
   end %t_i
   
   if isempty(EDS_all)
       EDS_all    = EDS;
       %entity_all = entity;
   else
       EDS_all(end+1:end+counter)    = EDS;
       %entity_all(end+1) = entity;
   end
   %fig = climada_waterfall_graph_barisal(EDS,'AED');
   %title(sprintf('Hazard type: %s',strrep(hazard_name,'_',' ')))
   %fprintf('%s: %d scenarios\n----------------\n----------------\n', upper(hazard_name), counter)
   %foldername = sprintf('%sresults%sED_waterfall_from_%s.pdf', filesep,filesep,hazard_name);
   %print(fig,'-dpdf',[module_data_dir foldername])
   
nd %h_i
DS_all_filename = [module_data_dir filesep 'results' filesep 'EDS_all'];
ave(EDS_all_filename,'EDS_all')
% write out xls
 % Percentage_Of_Value_Flag= 0;
ls_file = [module_data_dir filesep 'results' filesep datestr(now,'YYYYmmDD') '_calc_ED_at_centroid_' int2str(length(EDS_all)) '_scenarios_new.xlsx'];
 climada_EDS_ED_at_centroid_report(EDS_all,Percentage_Of_Value_Flag,report_file)
limada_EDS_ED_at_centroid_report_xls(EDS_all,entity,xls_file)
   
% load EDS all
DS_all_filename = [module_data_dir filesep 'results' filesep 'EDS_all'];
oad(EDS_all_filename)

% figure for damage per ward
 event_selection = [1 6 11 16 21];
vent_selection = [1 8 15 22 29];
_i = 1;
 t_i = 3;
or e_i = 1:length(event_selection);
   switch e_i
       case 1
           hazard_name = 'flood depth monsoon';
       case 2
           hazard_name = 'flood depth cyclone';
       case 3
           hazard_name = 'flood duration monsoon';
       case 4
           hazard_name = 'flood duration cyclone';
       case 5
           hazard_name = 'cyclone windspeed';
   end
   
   if e_i&ampltlength(event_selection)
       fig = climada_waterfall_graph_barisal(EDS_all(event_selection(e_i):event_selection(e_i+1)-1),'AED');
   else
       fig = climada_waterfall_graph_barisal(EDS_all(event_selection(e_i):end),'AED');
   end
   title(sprintf('Hazard type: %s',strrep(hazard_name,'_',' ')))
   foldername = sprintf('%sresults%sdamage_plots%sED_waterfall_from_%s.pdf', filesep,filesep,filesep,hazard_name);
   print(fig,'-dpdf',[module_data_dir foldername])
   
   fig = climada_ED_plot_per_ward(EDS_all(event_selection(e_i)),entity,BCC_wards, timehorizon(t_i), hazard_name);
   foldername = sprintf('%sresults%sdamage_plots%sDamage_from_%s_%d.pdf', filesep,filesep,filesep,hazard_name,timehorizon(t_i));
   print(fig,'-dpdf',[module_data_dir foldername])
   
   fig = climada_ED_plot_per_point(EDS_all(event_selection(e_i)),entity,BCC_wards, timehorizon(t_i), hazard_name);
   foldername = sprintf('%sresults%sdamage_plots%sDamage_per_point_from_%s_%d.pdf', filesep,filesep,filesep,hazard_name,timehorizon(t_i));
   print(fig,'-dpdf',[module_data_dir foldername])
   
   %--ASSETS--
   fig = climada_assets_plot_per_point(EDS_all(event_selection(e_i)+0),entity,BCC_wards, timehorizon(t_i), hazard_name);
   foldername = sprintf('%sresults%sdamage_plots%sValue_per_point_from_%s_%d.pdf', filesep,filesep,filesep,hazard_name,timehorizon(t_i));
   print(fig,'-dpdf',[module_data_dir foldername])
   %close
nd
 waterfall graph for today, eco, cc, 2030, eco 2050, cc 2050, tcr 2050
vent_selection = [2 5 8 10 12];
ig = climada_waterfall_graph_barisal(EDS(event_selection),'AED');
 EDS_ori = EDS;
DS = EDS(event_selection);
ig = climada_waterfall_graph_2timehorizons(EDS,'AED');
itle(sprintf('Hazard type: %s','Monsoon'))
oldername = sprintf('%sresults%sdamage_plots%sED_waterfall_from_%s.pdf', filesep,filesep,filesep,'Monsoon_2030_2050');
rint(fig,'-dpdf',[module_data_dir foldername])
       
% create combined waterfall graph for all hazard types
 EDS_all_filename = [module_data_dir filesep 'results' filesep 'EDS_all'];
 load(EDS_all_filename)
_i = 2;
ig = climada_waterfall_graph_barisal_combined(EDS_all);
oldername = sprintf('%sresults%sdamage_plots%sED_all_hazard_types_%d.pdf', filesep,filesep,filesep,timehorizon(t_i));
rint(fig,'-dpdf',[module_data_dir foldername])
% create hazard plots
 t_i  = 1;
 cc_i = 1;
 % hazard_name = 'flood_duration_monsoon';
 hazard_name = 'flood_depth_monsoon';
 [hazard, entity, label] = barisal_hazard_entity_load(hazard_name, cc_scenario{cc_i}, timehorizon(t_i));
 %datestr(hazard.datenum)
 %[hazard.yyyy(1) hazard.mm(1) hazard.dd(1)]
 % climada_hazard_plot(hazard, sorted_i(i))
 event_sum = sum(full(hazard.intensity),2);
 [a,sorted_i] =sort(event_sum,'descend');
 for i = 1%:3
     figure
     climada_hazard_plot_hr(hazard, sorted_i(i));
     
     hold on
     % loop over all words to plot color according to flood damage
     BCC_ward_no  = [BCC_wards.Ward_no];
     for ward_i = 1:length(BCC_ward_no) 
         %indx   = find(values(ward_i)&amplt=range_values);
         %indx   = indx(1);
         %indx_w = find(BCC_ward_no == ward_i);
         plot(BCC_wards(ward_i).lon,BCC_wards(ward_i).lat,'color',[ 205 193 197 ]/255,'linewidth',2); %dark red
         text(mean(BCC_wards(ward_i).lon),mean(BCC_wards(ward_i).lat),BCC_wards(ward_i).UNION_NAME,...
             'Horizontalalignment','center','verticalalignment','bottom'); %grey
     end
 end
 
 foldername = sprintf('%sresults%sdamage_plots%sHazard_Flood_duration_monsoon_event_%d.pdf', filesep,filesep,filesep,sorted_i(i));
 print(gcf,'-dpdf',[module_data_dir foldername])
% check hazard intensity and max hazard event
 [max_int, max_event] = max(full(sum(hazard.intensity,2)));
 % % [max_int, max_event] = max(full(max(hazard.intensity,[],2)));
 % % climada_hazard_footprint_plot(hazard, max_event, '');
 % hazard_sum = hazard;
 % hazard_sum.intensity(1,:) = sum(hazard_sum.intensity);
 
 % for e_i = 1:1:29
     fig = climada_figuresize(0.75,0.75);
     %%climada_hazard_plot(hazard_sum,1)
     %e_i = 27;
     %e_i = 8;
     e_i = max_event;
     climada_hazard_plot(hazard,e_i);
     
     % plot Wards
     hold on
     for w_i=1:length(BCC_wards)
         h = plot(BCC_wards(w_i).lon,BCC_wards(w_i).lat,'color',[244 164 96 ]/255);%sandybrown;
         %text(mean(BCC_wards(w_i).lon),mean(BCC_wards(w_i).lat),sprintf('Ward %d',BCC_wards(w_i).Ward_no));%sandybrown;
         g = text(entity.assets.lon(w_i), entity.assets.lat(w_i),sprintf('Ward %d',w_i),'Horizontalalignment','center','verticalalignment','bottom');
     end
     indx_a = entity.assets.Value&ampgt0;
     g = plot(entity.assets.lon(indx_a),entity.assets.lat(indx_a),'kx','markersize',8,'LineWidth',1.5);
     legend([h g], 'Ward boundaries', 'Lat/lon coordinates for assets')
     xlabel('Longitude'); ylabel('Latitude')
     foldername = sprintf('%sresults%sHazard_%s_event_%d.pdf',filesep, filesep,hazard_name,e_i);
     print(fig,'-dpdf',[module_data_dir foldername])
     close
 % end
 %figure
 %[h h_points] = plotclr(hazard.lon,hazard.lat,hazard.intensity(e_i,:), 'o', 5, 1, 0, 0.5, '', 0, 0);
 
 % ward11_no = 11;
 % entity.assets.Value(ward11_no);
 % plot(entity.assets.lon(ward11_no), entity.assets.lat(ward11_no),'dr')
 % c = entity.assets.centroid_index(ward11_no);
 % plot(hazard.lon(c), hazard.lat(c),'pb')
 % int = full(hazard.intensity(:,c));
 % plot(hazard.lon, hazard.lat, 'x')
 % int = full(hazard.intensity(:,c+128));
 % int = full(hazard.intensity(:,c+0));
 % 
 % ward6_no = 6;
 % plot(entity.assets.lon(ward6_no), entity.assets.lat(ward6_no),'dr')
 % c6 = entity.assets.centroid_index(ward6_no);
 % plot(hazard.lon(c6), hazard.lat(c6),'pb')
 % int = full(hazard.intensity(:,c6));
 % end
 
 % % load entity (asset portfolio)
 % entity_file = [module_data_dir filesep 'entities' filesep 'Barisal_BCC_1km_100.mat'];
 % if exist(entity_file,'file')
 %     load(entity_file)
 % end
% see damage functions for different asset categories
 % asset_cat = unique(entity.assets.Category);
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 for cat_i = 1:length(asset_cat)
     fprintf('-----------\n-----------\nAsset category: %s \n-----------\n',asset_cat{cat_i})
     indx = strcmp(entity.assets.Category, asset_cat{cat_i});
     DamageFunID = unique(entity.assets.DamageFunID(indx));
     
     for ii = 1:numel(DamageFunID)
         fprintf('Asset DamageFunID: %d \n',DamageFunID(ii))
         indxx = find(entity.damagefunctions.DamageFunID == DamageFunID(ii));
         indxx = indxx(end);
         fprintf('DamageFunID: %d, %s \n',entity.damagefunctions.DamageFunID(indxx), entity.damagefunctions.Description{indxx})
         fprintf('max intensity %2.1f, max MDD %2.1f, \n\n', entity.damagefunctions.Intensity(indxx), entity.damagefunctions.MDD(indxx))     
     end
 end
% figure to check if max hazard (flood duration) touches upon asset values
 figure
 [max_int, max_event] = max(full(sum(hazard.intensity,2)));
 climada_hazard_footprint_plot(hazard, max_event, '');
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 color_ = jet(length(asset_cat));
 marker_ = {'+','o','d','*','s','p','x'};
 for cat_i = 1:length(asset_cat)
     indx = strcmp(entity.assets.Category,asset_cat(cat_i));
     hold on
     if cat_i&amplt=length(marker_)
         h(cat_i) = plot(entity.assets.lon(indx), entity.assets.lat(indx),marker_{cat_i},'color',color_(cat_i,:));
     else
         h(cat_i) = plot(entity.assets.lon(indx), entity.assets.lat(indx),'p','color',color_(cat_i,:));
     end
 end
 legend(h,asset_cat)
% damage calculation per ward (per category, for today, 2030 and 2050)
 silent_mode= 1;
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 ward_no    = unique(entity.assets.Ward);
 
 timehorizon = [2014 2030 2050];
 EDS         = [];
 for t_i = 1:length(timehorizon);
      
     counter     = 0;
 
     % select ward
     for ward_i = 1:length(ward_no) 
         
         % select only one ward
         if ward_i&amplt=length(ward_no)
             indx_w = ismember(entity.assets.Ward, ward_no(ward_i));
             %indx_w = ismember(entity.assets.Ward, ward_no(1:ward_i));
             annotation_name_ward = sprintf('Ward %d',ward_no(ward_i));
         else
             indx_w = ones(size(entity.assets.Ward));
             annotation_name_ward = 'All Wards';
         end
         
         % select asset category
         for cat_i = 1:length(asset_cat)+1%length(asset_cat)+1 
 
             %select time horizone
             switch t_i 
                 case 1
                     % risk today
                     entity.assets.Value = entity_ori.assets.Value;
                     titlestr = 'Risk today';
                 case 2
                     % risk 2030
                     entity.assets.Value = entity.assets.Value_2030;
                     titlestr = 'Socio-economic 2030 (scenario 1)';
                 case 3
                     % risk 2050
                     entity.assets.Value = entity.assets.Value_2050;
                     titlestr = 'Socio-economic 2050 (scenario 1)';
             end
 
             % select only assets in specific category
             if cat_i&amplt=length(asset_cat)
                 %indx = strcmp(entity.assets.Category, asset_cat{cat_i});
                 indx = ismember(entity.assets.Category, asset_cat(1:cat_i));
                 annotation_name = asset_cat{cat_i};
             else
                 indx = ones(size(entity.assets.Category));
                 annotation_name = 'All asset categories';
             end
             
             %------
             % combine ward and category index
             %------
             indx      = logical(indx);
             indx_w    = logical(indx_w);
             indx_comb = logical(indx.*indx_w);
             counter   = counter+1;
             annotation_name_comb = sprintf('%d, %s, %s', timehorizon(t_i), annotation_name_ward, annotation_name);
             
             % a quick check
             %entity.assets.Ward(indx_comb)
             %entity.assets.Category(indx_comb)
             %entity.assets.Value(indx_comb)
 
             entity.assets.Value(~indx_comb) = 0;
             force_re_encode = 0;
             if isempty(EDS)
                 EDS = climada_EDS_calc(entity,hazard,annotation_name_comb,force_re_encode,silent_mode);
             else
                 %EDS_ = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
                 %EDS(cat_i) = EDS_;
                 EDS(counter) = climada_EDS_calc(entity,hazard,annotation_name_comb,force_re_encode,silent_mode);
             end
             
         end %cat_i  
     end %ward_i
 end %t_i
 % climada_waterfall_graph_barisal(EDS(1), EDS(2), EDS(3), 'AED')
 
 % at the end of calculations, overwrite with original entity again
 entity = entity_ori;
 
 return
% figures for specific asset categories and time horizons
 EDS_annotation_names = {EDS.annotation_name};
 for t_i = 1:length(timehorizon);
     for cat_i = 1:length(asset_cat)+1
         
         % select only assets in specific category
         if cat_i&amplt=length(asset_cat)           
             annotation_name = asset_cat{cat_i};
         else
             annotation_name = 'All asset categories';
         end
         indx_2 = strfind(EDS_annotation_names, annotation_name);
         indx_2 = find(~cellfun(@isempty,indx_2)); 
         
         indx_3 = strfind(EDS_annotation_names, sprintf('%d',timehorizon(t_i)));
         
         %-------
         %annual expected damage
         %-------
         fig = climada_figuresize(0.75,0.75);
         no_colors    = 10;
         cbar         = jet(no_colors);
         ED           = [EDS(indx_2).ED];
         pos_indx     = ED&ampgt0;
         min_value    = min(ED(pos_indx));
         max_value    = max(ED);
         range_values = linspace(min_value,max_value,no_colors);
         BCC_ward_no  = [BCC_wards.Ward_no];
         for ward_i = 1:length(ward_no) 
             indx = find(EDS(indx_2(ward_i)).ED&amplt=range_values);
             indx = indx(1);
             %h(3)= plot(BCC_wards(w_i).lon,BCC_wards(w_i).lat,'color',[244 164 96 ]/255);%sandybrown
             indx_w = find(BCC_ward_no == ward_i);
             h(3)   = fill(BCC_wards(indx_w).lon,BCC_wards(indx_w).lat,cbar(indx,:));
             hold on
             indx_a = find(EDS(indx_2(ward_i)).assets.Value);
             if ~isempty(indx_a); indx_a = indx_a(1);end
             indx_text = strfind(EDS(indx_2(ward_i)).annotation_name,',');
             if ~isempty(indx_a)
                 text(EDS(indx_2(ward_i)).assets.lon(indx_a), EDS(indx_2(ward_i)).assets.lat(indx_a), EDS(indx_2(ward_i)).annotation_name(1:indx_text-1),...
                     'Horizontalalignment','center','verticalalignment','bottom','color','k') %brighten(cbar(indx,:),-0.8)
                 g = plot(mean(EDS(indx_2(ward_i)).assets.lon(indx_a)), mean(EDS(indx_2(ward_i)).assets.lat(indx_a)),'kx','markersize',8,'LineWidth',1.5);
             end
         end
         colormap(cbar)
         t = colorbar;
         %cbar_label = sprintf('Intensity %s (%s)', hazard.peril_ID, hazard.units);
         set(get(t,'ylabel'),'String', ('1000 BDT'),'fontsize',12);
         caxis([min_value max_value])
         %axislim = [min(EDS(1).assets.lon) max(EDS(1).assets.lon)*1 min(EDS(1).assets.lat) max(EDS(1).assets.lat)*1];
         %axislim = [min(hazard.lon) max(hazard.lon)*1 min(hazard.lat) max(hazard.lat)*1];
         %axislim = [90.25 90.45 22.6 22.8]; %barisal close up BCC 
         axislim = [90.297 90.3957 22.64 22.752]; %barisal close up BCC 
         axis(axislim)
         axis equal
         %titlestr = sprintf('%d, Annual damage, %s - %s', timehorizon(t_i), EDS(1).annotation_name, EDS(end).annotation_name);
         titlestr = sprintf('%d: Annual damage from %s', timehorizon(t_i), strrep(hazard_name,'_',' '));
         title({titlestr; annotation_name})
         legend(g,'Lat/lon coordinates for assets')
         foldername = sprintf('%sresults%sDamage_from_%s_%d.pdf', filesep,filesep,hazard_name,timehorizon(t_i));
         print(fig,'-dpdf',[module_data_dir foldername])
         %close
 
         %-------
         %values
         %-------
 %         fig = climada_figuresize(0.75,0.75);
 %         no_colors    = 10;
 %         cbar         = jet(no_colors);
 %         Value        = [EDS.Value];
 %         pos_indx     = Value&ampgt0;
 %         min_value    = min(Value(pos_indx));
 %         max_value    = max(Value);
 %         range_values = linspace(min_value,max_value,no_colors);
 %         BCC_ward_no  = [BCC_wards.Ward_no];
 %         for ward_i = 1:length(ward_no) 
 %             indx   = find(EDS(ward_i).Value&amplt=range_values);
 %             indx   = indx(1);
 %             %h(3)  = plot(BCC_wards(w_i).lon,BCC_wards(w_i).lat,'color',[244 164 96 ]/255);%sandybrown
 %             indx_w = find(BCC_ward_no == ward_i);
 %             h(3)   = fill(BCC_wards(indx_w).lon,BCC_wards(indx_w).lat,cbar(indx,:));
 %             indx_a = find(EDS(ward_i).assets.Value);
 %             indx_a = indx_a(1);
 %             indx_text = strfind(EDS(ward_i).annotation_name,',');
 %             text(EDS(ward_i).assets.lon(indx_a), EDS(ward_i).assets.lat(indx_a), EDS(ward_i).annotation_name(1:indx_text-1),...
 %                 'Horizontalalignment','center','verticalalignment','bottom','color','k')%brighten(cbar(indx,:),-0.8
 %             hold on
 %             g = plot(mean(EDS(ward_i).assets.lon(indx_a)), mean(EDS(ward_i).assets.lat(indx_a)),'kx','markersize',8,'LineWidth',1.5);
 %         end
 %         colormap(cbar)
 %         t = colorbar;
 %         %cbar_label = sprintf('Intensity %s (%s)', hazard.peril_ID, hazard.units);
 %         set(get(t,'ylabel'),'String', ('1000 BDT'),'fontsize',12);
 %         caxis([min_value max_value])
 %         axis(axislim)
 %         axis equal
 %         %titlestr = sprintf('%d, Values, %s - %s', timehorizon(t_i), EDS(1).annotation_name, EDS(end).annotation_name);
 %         titlestr = sprintf('%d: Values', timehorizon(t_i));
 %         title({titlestr; annotation_name})
 %         legend(g,'Lat/lon coordinates for assets')
 %         foldername = sprintf('%sresults%sValues_for_%s_%d.pdf', filesep,filesep,hazard_name,timehorizon(t_i));
 %         print(fig,'-dpdf',[module_data_dir foldername])
 %         close
     end %cat_i
 end %t_i
   
% damage calculations per time horizon
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 entity_ori = entity;
 
 timehorizon = [2015 2030 2050];
 
 for t_i = 2%:length(timehorizon);
         
     EDS = [];   
 
     for cat_i = 1:length(asset_cat)+1
         
         switch t_i
             case 1
                 % risk today
                 entity.assets.Value = entity_ori.assets.Value;
                 titlestr = 'Risk today';
             case 2
                 % risk 2030
                 entity.assets.Value = entity.assets.Value_2030;
                 titlestr = 'Socio-economic 2030 (scenario 1)';
             case 3
                 % risk 2050
                 entity.assets.Value = entity.assets.Value_2050;
                 titlestr = 'Socio-economic 2050 (scenario 1)';
         end
     
         % select only assets in specific category
         if cat_i&amplt=length(asset_cat)
             %indx = strcmp(entity.assets.Category, asset_cat{cat_i});
             indx = ismember(entity.assets.Category, asset_cat(1:cat_i));
             annotation_name = asset_cat{cat_i};
         else
             indx = ones(size(entity.assets.Category));
             annotation_name = 'All asset categories';
         end
 
         entity.assets.Value(~indx) = 0;
         force_re_encode = 0;
         if isempty(EDS)
             EDS = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
         else
             EDS_ = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
             EDS(cat_i) = EDS_;
             %EDS(t_i) = climada_EDS_calc(entity,hazard,titlestr,force_re_encode,silent_mode);
         end
     end %cat_i
     
     % create figure
     figure
     climada_EDS_DFC(EDS);
     title(titlestr)
     %climada_waterfall_graph_barisal(EDS(1), EDS(2), EDS(3), 'AED')
 end %t_i
 
 % at the end of calculations, overwrite with original entity again
 entity = entity_ori;
% damage calculations per asset category
 asset_cat  = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 entity_ori = entity;
 
 for cat_i = 1:length(asset_cat)+1
     
     EDS = [];
     
     % select only assets in specific category
     if cat_i&amplt=length(asset_cat)
         indx = strcmp(entity.assets.Category, asset_cat{cat_i});
     else
         indx = ones(size(entity.assets.Category));
     end
 
     % risk today
     entity.assets.Value = entity_ori.assets.Value;
     entity.assets.Value(~indx) = 0;
     annotation_name = 'Risk today';
     force_re_encode = 0;
     EDS = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
     EDS(1) = EDS;
     
     % risk 2030
     entity.assets.Value = entity.assets.Value_2030;
     entity.assets.Value(~indx) = 0;
     annotation_name = 'Socio-economic 2030 (scenario 1)';
     EDS(2) = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
     
     % risk 2050
     entity.assets.Value = entity.assets.Value_2050;
     entity.assets.Value(~indx) = 0;
     annotation_name = 'Socio-economic 2050 (scenario 1)';
     EDS(3) = climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode);
     
     % create figure
     figure
     climada_EDS_DFC(EDS);
     if cat_i&amplt=length(asset_cat)
         title(asset_cat{cat_i})
     else
         title('All asset categories')
         % at the end of calculations, overwrite with original entity again
         entity = entity_ori;
     end
     %climada_waterfall_graph_barisal(EDS(1), EDS(2), EDS(3), 'AED')
 end
%
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/old/barisal_risk_calculation_excel.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_waterfall_graph_2timehorizons">
<H2>climada_waterfall_graph_2timehorizons</H2></A>
<font color="blue">function  fig = climada_waterfall_graph_2timehorizons(return_period, check_printplot, currency,varargin) </font>
 waterfall figure, expected damage for specified return period for
 - today,
 - increase from economic growth,
 - increase from high climate change, total expected damage 2030
 for the three EDS quoted above
 NAME:
   climada_waterfall_graph
 PURPOSE:
   plot expected damage for specific return period
 CALLING SEQUENCE:
   climada_waterfall_graph(EDS1, EDS2, EDS3, return_period,
   check_printplot)
 EXAMPLE:
   climada_waterfall_graph
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   EDS:            three event damage sets
                   - today
                   - economic growth
                   - cc combined with economic growth, future
   return_period:  requested return period for according expected damage,or
                   annual expted damage, prompted if not given
   check_printplot:if set to 1, figure saved, default 0.
 OUTPUTS:
   waterfall graph
 MODIFICATION HISTORY:
 Lea Mueller, 20110622
 Martin Heynen, 20120329
 David N. Bresch, david.bresch@gmail.com, 20130316 EDS-&ampgtEDS
 David N. Bresch, david.bresch@gmail.com, 20150419 try-catch for arrow plotting
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/old/climada_waterfall_graph_2timehorizons.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="tc_surge_Barisal">
<H2>tc_surge_Barisal</H2></A>
<font color="blue">function [hazard,EDS,centroids,entity]=tc_surge_Barisal(... </font>
   adm_lvl,force_centroids_recalc,force_entity_recalc,force_hazard_recalc, check_plots)
 climada
 MODULE:
   barisal_demo
 NAME:
   tc_surge_Barisal
 PURPOSE:
   This code creates the tropical cyclone (TC) storm
   surge (TS) hazard for an area around the city of Barisal, Bangladesh.
       1) get centroids for the area of interest(see PARAMETERS)
          if they do not exist, run GDP_entity in order to create them
       2) create TC wind hazard event set
          call climada_ts_hazard_set in order to
       3) create bathymetry file for region
     	4) create TC surge hazard event set
   show the result

   See tc_surge_plot_3d for 3D plots of surge fields in general

 CALLING SEQUENCE:
   [hazard, EDS, centroids, entity] = tc_surge_Barisal
 EXAMPLE:
   tc_surge_Barisal
   [hazard, EDS, centroids, entity]=tc_surge_Barisal(1,0,1) - save output
       to variables - forces the recalculation of hazard set, but not
       entity/centroids.
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   adm_lvl: Specify the admin level of interest
       Default:set to level 2
   force_centroids_entity_recalc: Automatically set to 0. Set to 1 if you
       wish to recalculate the centroids and entity, despite the relevant
       files already existing - calculation will take longer.
   force_hazard_recalc: Automatically set to 0. Set to 1 if you
       wish to recalculate the TS and TC hazards, despite the relevant
       files already existing - calculation will take longer.
 OUTPUTS:
   hazard: Struct with fields
             .TS:    Storm surge hazard set (with usual fields)
             .TC:    Tropical cyclone hazard set
   EDS:    Struct with fields
             .TS:    Storm surge event damage set
             .TC:    Tropical cyclone event damage set
   centroids:  High resolution centroids
   entity:     High resolution entity
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20141121
 David N. Bresch, david.bresch@gmail.com, 20141215, cleanup, especially the map border stuff
 Gilles Stassen, gillesstassen@hotmail.com, 20150202, split entity and
 centroid generation into separate blocks; new input args: force_centroids_recalc, force_entity_recalc
 David N. Bresch, david.bresch@gmail.com, 20150819, centroids in their own dir
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_generate from climada_generate_centroids
 David N. Bresch, david.bresch@gmail.com, 20160529, calling climada_ts_hazard_set instead of tc_surge_hazard_create
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/barisal_demo/code/old/tc_surge_Barisal.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="centroids_generate_hazard_sets">
<H2>centroids_generate_hazard_sets</H2></A>
<font color="blue">function centroids_hazard_info=centroids_generate_hazard_sets(centroids,probabilistic,force_recalc,check_plots,peril_ID) </font>
 climada
 MODULE:
   country_risk
 NAME:
   centroids_generate_hazard_sets
 PURPOSE:
   run all (available) perils for a given set of centroids. Generate
   earthquake (EQ), volcano (VQ), tropical cyclone (TC), torrential rain
   (TR) and storm surge (TS) hazard event sets 
   1) figure which hazards affect the centroids
   2) create the hazard event sets, uses
      - climada_tc_hazard_set (wind)
      - climada_tr_hazard_set (rain)
      - climada_ts_hazard_set (surge)
      - eq_global_hazard_set (earthquake)
      - European winter storm module (existing hazard)

   Note that the code supports both TC tracks from unisys database files
   and (NCAR) netCDF TC track files. Should both exist in the active
   ..\data\tc_tracks folder, the user NEEDS to 'hide' the ones not needed
   (e.g. by moving them into a temporary subfolder). Otherwise, the code
   produces two hazard event sets (which might be intended).

   Please not further that the WS_Europe hazard event set is defined in
   PARAMETERS, as this is not freshly generated, but the country hazard
   event set is just a subset (see also climada module ws_europe)

   previous step: country_risk_calc or climada_create_GDP_entity
   next step: see country_risk_calc (if you start with your own centroids,
   you might rather calculate the risk yourself, e.g. using
   climada_EDS_calc...)
 CALLING SEQUENCE:
   centroids_hazard_info=centroids_generate_hazard_sets(centroids,probabilistic,force_recalc,check_plots,peril_ID)
 EXAMPLE:
   centroids_generate_hazard_sets; % interactive, prompt for centroids
 INPUTS:
   centroids: a centroid structure, see e.g. climada_centroids_load
       or an entity (in which case it takes the entity.assets.lat and
       entity.assets.lon)
       &ampgt prompted for if empty (centroids need to exist als .mat file
       already - otherwise run e.g. climada_centroids_read first).
       In case you select an entity, it takes entity.assets.lat and
       entity.assets.lon.
 OPTIONAL INPUT PARAMETERS:
   probabilistic: if =1, generate probabilistic hazard event sets,
       =0 generate 'historic' hazard event sets (default)
       While one need fully probabilistic sets for really meaningful
       results, the default is 'historic' as this is the first thing to
       check.
   force_recalc: if =1, recalculate the hazard sets, even if they exist
       (good for TEST while editing the code, default=0)
   check_plots: if =1, show figures to check hazards etc.
       If =0, skip figures (default)
   peril_ID: if passed on, run all calculations only for specified peril
       peril_ID can be 'TC','TS','TR','EQ','WS'..., default='' for all
 OUTPUTS:
   writes hazard event set files: III_name_rrr_PP{|_hist}.mat with III
       ISO2 country (admin0) code, country name, rrr peril region and PP
       peril_ID. Appends _hist if non-probabilistic. Note that for admin1
       hazard event sets, name does alos contain the admin1 name.
   centroids_hazard_info(centroids_i): a structure with hazard information for
       each set of centroids. See centroids_hazard_info.res.hazard with
       peril_ID: 'TC' or ...
       data_file: for TC only: the file sused to generste the event set
       hazard_set_file: the full filename of the hazard set generated
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141025, moved out of country_risk_calc
 David N. Bresch, david.bresch@gmail.com, 20141026, probabilistic as input
 David N. Bresch, david.bresch@gmail.com, 20141029, WSEU added
 David N. Bresch, david.bresch@gmail.com, 20141208, possibility to pass entity as centroids
 David N. Bresch, david.bresch@gmail.com, 20150110, save with -v7.3 (needed for large hazard sets)
 David N. Bresch, david.bresch@gmail.com, 20150112, hazard extension '_hist' for historic, '' for probabilistic
 David N. Bresch, david.bresch@gmail.com, 20150112, III_name_rrr_PP{|_hist}.mat
 David N. Bresch, david.bresch@gmail.com, 20150118, tc_track nodes file with track number
 David N. Bresch, david.bresch@gmail.com, 20150123, distance2coast_km in TC added
 David N. Bresch, david.bresch@gmail.com, 20150128, tc_track handling simplified, climada_tc_track_nodes
 David N. Bresch, david.bresch@gmail.com, 20150309, VQ (volcano) added, but switched off as default
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20151010, TR switched on as default
 David N. Bresch, david.bresch@gmail.com, 20151224, hazard module names renamed
 David N. Bresch, david.bresch@gmail.com, 20160517, double-check for tc datasets
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/centroids_generate_hazard_sets.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_create_GDP_entity">
<H2>climada_create_GDP_entity</H2></A>
<font color="blue">function [centroids,entity,entity_future]=climada_create_GDP_entity(country_name,polygon,check_figure,no_wbar) </font>
 GDP entity assets
 MODULE:
   GDP_entity
 NAME:
   climada_create_GDP_entity
 PURPOSE:
   create centroids and entity for a specific country, distribute assets
   and value according to night light intensities and scale up to match 
   GDP today (see climada_global.present_reference_year) and a future (see
   climada_global.future_reference_year) scenario 
 CALLING SEQUENCE:
   [centroids entity entity_future] = climada_create_GDP_entity(country_name,polygon,check_figure,no_wbar)
 EXAMPLE:
   [centroids entity entity_future] = climada_create_GDP_entity
   [centroids entity entity_future] = climada_create_GDP_entity('Mexico')
 INPUTS:
   country_name: the name of the country or an ISO3 country code (like
       'CHE'), see climada_country_name
   polygon: do restrict to centroids in polygon, calls
       climada_cut_out_GDP_entity, see parameters there.
   check_figure: set to 1 to visualize figures, default 1
   no_wbar: 1 to suppress waitbars
   OBSOLETE (not supported any more): GDP: GDP data within a structure, 
       prompted for if not given, loaded automatically from economic_indicators_mastertable.mat file if existing
       --&ampgt all automatic now
 OUTPUTS:
   centroids: a structure with fields centroid_ID, Latitude, Longitude,
       onLand, country_name, comment for each centroid
   entity         : a structure with fields assets, damagefunctions, measures,
                    discount. Assets values are based on night light 
                    intensity and scaled up to todays GDP (e.g. 2014)
   entity_future  : entity strucure with values scaled to a future GDP
                    scenario
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20140206
 David N. Bresch, david.bresch@gmail.com, 20141209, country ISO3 enabled
 David N. Bresch, david.bresch@gmail.com, 20141212, migrated to world_50m.gen being local to GDP_entity, as climada moved to admin0.mat
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150125, incorporated climada_entity_value_GDP_adjust to scale up the entity, ... 
                                                    climada_entity_GDP not used anymore
 David N. Bresch, david.bresch@gmail.com, 20150204, cleanup
 David N. Bresch, david.bresch@gmail.com, 20150804, cleanup
 David N. Bresch, david.bresch@gmail.com, 20160517, fix for missing entity.assets.centroid_index and entity.assets.hazard.comment
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/climada_create_GDP_entity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_GDP">
<H2>climada_entity_GDP</H2></A>
<font color="blue">function entity = climada_entity_GDP(entity_base, GDP, year_requested, centroids, borders, check_figure, check_printplot) </font>
 upscale given base entity (sum of assets is 100, or less if only coastal
 areas) to match the GDP of a specific country for a given year
 NAME:
   climada_entity_GDP
 PURPOSE:
   Upscale entity to a GDP of a given country and year, read GDP data from
   worldbank/IMF, find country for given entity/centroids
 CALLING SEQUENCE:
   entity = climada_entity_GDP(entity_100, GDP, year_start, centroids,
   borders, check_figure, check_printplot)
 EXAMPLE:
   entity = climada_entity_GDP(entity_100, GDP, 2014, centroids)
 INPUTS:
   entity_base: entity with entity.assets.Value sum up to 100 for the
   entire country (if only coastal areas, sum is less than 100)
 OPTIONAL INPUTS:
   GDP       : GDP data within a structure, prompted for if not given, loaded
               automatically from GDP.mat file if existing
   year_requested: year for GDP for a given country, default
               climada_global.present_reference_year
   centroids : prompted if not given, centroids with field .country_name
               for each centroid indicating the country matching with GDP data
   borders   : border structure (with name, polygon for every country)
   check_figure   : 1 to visualize figure
   check_printplot: 1 to print/save figure
 OUTPUTS:
   entity             : assets upscaled to a GDP of a country and a given year
   a structure, with
       assets         : a structure, with
           Latitude   : the latitude of the values
           Longitude  : the longitude of the values
           Value      : the total insurable value
           Deductible : the deductible
           Cover      : the cover
           DamageFunID: the damagefunction curve ID
       damagefunctions: a structure, with
           DamageFunID: the damagefunction curve ID
           Intensity  : the hazard intensity
           MDD        : the mean damage degree
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20140206
 David N. Bresch, david.bresch@gmail.com, 20141105,
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/climada_entity_GDP.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hybrid_entity">
<H2>climada_hybrid_entity</H2></A>
<font color="blue">function [entity,centroids]=climada_hybrid_entity(admin0_name) </font>
 climada hybrid entity
 MODULE:
   country_risk
 NAME:
   climada_hybrid_entity
 PURPOSE:
   Create a high-resolution entity (climada_nightlight_entity) for the
   country within its borders and add the mid-resolution centroids for
   offshore along the coast plus coarse resolution centroids around the
   country (from GDP_entity)
 CALLING SEQUENCE:
   [entity,centroids]=climada_hybrid_entity(admin0_name)
 EXAMPLE:
   entity=climada_hybrid_entity('Switzerland')
 INPUTS:
   admin0_name: country name
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   entity: the entity, see e.g. climada_entity_read for a description of
       the entity structure
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150915, intitial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/climada_hybrid_entity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_night_light_to_country">
<H2>climada_night_light_to_country</H2></A>
<font color="blue">function [values_distributed,pp] = climada_night_light_to_country(country_name,pp,night_light,... </font>
   borders,border_mask,check_figure,check_printplot,save_on,silent_mode)
 NAME:
   climada_night_light_to_country
 PURPOSE:
   distributed values within one country according to night light density

   geographically distribute values within one country according to
   nonlinearly tranformed night light density values (values between 1 and 63)
   based on nonlinear relationship between night light intensity and
   distribution of GDP assets, use a second order polynomial function
   without y-indent: y = pp(1) x^2 + pp(2) x;

   previous: climada_night_light_read
   next: climada_resolution_downscale
 CALLING SEQUENCE:
   [values_distributed pp] = climada_night_light_to_country(country_name, pp, night_light,...
             borders, border_mask, check_figure, check_printplot, save_on, silent_mode)
 EXAMPLE:
 values_distributed = climada_night_light_to_country('Bangladesh')
 INPUTS:
   country_name     : name of country (string)
 OPTIONAL INPUT PARAMETERS:
   pp               : parameter of second order polynomial function to transform night lights
                      nonlinearly into distribution of GDP assets
                      y = pp(1)*x^2 + pp(2)*x;
   night_light      : night light mat file (structure with values,
                      lon_range, lat_range, resolution_x, resolution_y and comment)
   borders          : climada world map country borders (structure with
                      polygon and names)
   border_mask      : structure with all country masks (zeros and ones)
   check_figure     : set to 1 to visualize figures, default 1
   check_printplot  : set to 1 to save figure, default 0
   save_on          : set to 1 to save Gvalues_distributed.mat
   silent_mode      : if set to 1, no print out messages, default 0
 OUTPUTS:
   values_distributed: a struct, with following fields
         .values       : distributed GDP per pixel
         .lon_range    : range of Longitude
         .lat_range    : range of Latitude
         .resolution_x : resolution in x-direction
         .resolution_y : resolution in y-direction
         .comment      : information about distributed GDP data, year and pp
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20130412
 David N. Bresch, david.bresch@gmail.com, 20141205, cleanup and 1km try (see parameters below)
 David N. Bresch, david.bresch@gmail.com, 20160222, module_data_dir updated
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/climada_night_light_to_country.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_nightlight_entity">
<H2>climada_nightlight_entity</H2></A>
<font color="blue">function entity=climada_nightlight_entity(admin0_name,admin1_name,selections,check_plot,scale_Value,img_filename,save_entity) </font>
 country admin0 admin1 entity high resolution
 NAME:
	climada_nightlight_entity
 PURPOSE:
   Construct an entity file based on high-res (1km!) or mid -res (10km)
   night light data.

   Reads an image file with nightlight density and matches it to the local
   geography.

   Prompts for country (admin0) and state/province (admin1), obtains the
   high-resolution night lights for this area and constrains the active
   centroids (with values&ampgt0) to the selected country or admin1 (see input
   parameter selections) and saves the entity, adding distance to coast
   (im km) and elevation (in m) for each centroid, too.

   Since we're dealing with admin1, no automatic scaling or allocation of
   GDP to centroids is performed (for this, see
   climada_create_GDP_entity), unless selection is set for full country
   (=1), in which case assets are scaled to 6 times GDP, as a proxy for
   insurable values.

   If the high-resolution night light image is stored locally (about 700MB
   as tiff, after first call about 24MB as .mat), the code works from
   there.
   See http://ngdc.noaa.gov/eog/dmsp/downloadV4composites.html#AVSLCFC3
   to obtain the file
   http://ngdc.noaa.gov/eog/data/web_data/v4composites/F182012.v4.tar
   and unzip the file F182012.v4c_web.stable_lights.avg_vis.tif in there
   to the /data folder of country_risk module. As the .tif is so much
   larger, the climada module country_risk comes with the .mat file, but
   does not contain the original (.tif). Please note that the GDP_entity
   could also deal with such a high-res dataset (see respective
   documentation) - that's why the present code does also check for the
   night light data to be stored there (see GDP_entity_CHECK in code)

   If the high-resolution night light image is stored locally, it fetches
   the tile of night light density from www (i.e. asks the user to enter a
   specific URL, to locally store the respective file) and works from
   there. (See also http://maps.ngdc.noaa.gov/viewers/dmsp_gcv4/ to obtain
   a specific 'tile' of the global high res via a web-GUI (but method with
   the coe suggesting the URL is strongly recommended).

   Programmer's remark: see fetch_mapserver_ngdc_noaa_gov_gcv4 at the
   bottom of the code, which could in theory fetch the tile from www

   See also climada_create_GDP_entity and climada_hybrid_entity
 CALLING SEQUENCE:
   entity=climada_nightlight_entity(admin0_name,admin1_name,selections,check_plot,scale_Value,img_filename,save_entity)
 EXAMPLE:
   entity=climada_nightlight_entity('Italy','',2); % good for test, as shape of Italy is well-known
   entity=climada_nightlight_entity('France','',-1); % France, scaled by GDP, 10km resolution
   entity=climada_nightlight_entity('United States of America','Florida',2,2);
   entity=climada_nightlight_entity('Sswitzerland','',1,0,[0 1 0 -1]); % scale by GDP (the -1)
   entity=climada_nightlight_entity('CHE','',1); % full country, scale by 6 times GDP as a proxy for insurable values
   entity=climada_nightlight_entity % all interacrtive
   climada_entity_plot(entity) % to check the content of the final entity
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   admin0_name: the country name, either full or ISO3
       &ampgt If empty, a list dialog lets the user select (default)
       Also useful if a img_filename is passed and thus if admin0_name is
       defined, the respective country is cut out.
       Instead of explicit country names, one can also use ISO3 country
       codes (like DEU, CHE). Note that the entity filename will use the
       full country name, but ISO3 is stored in entity.assets.admin0_ISO3
       See parameter selections, especially if you want to select a whole
       country.
   admin1_name: if passed on, do not prompt for admin1 name
       &ampgt If empty, a list dialog lets the user select (default)
       Most useful for subsequent calls, i.e. once one knows the exact
       admin1 name. Also useful if a img_filename is passed and thus if
       admin1_name is defined, the respective admin1 is cut out.
       NOTE: Still an issue with some characters, i.e. Zrich does not work
       if entered as admin1_name, please use the admin1_code, also shown
       behind the | in the list dialog, e.g. for Zurich, the call hence is
       entity=climada_nightlight_entity('CHE','CHE-176'). Note that the
       admin1_name is kept as on input, i.e. 'CHE-176' in the example, not
       'Zrich'.
   selections: =0 (default): select admin0 (country) and constrain the active
       centroids (with values&ampgt0) to the selected admin1 (state/province)
       add a regular grid outside (to allow e.g for smooth hazard
       intensity plots)
       =10: same as =0, but use 10km instead of 1km night light image
       regular grid outside hence also coarser
       resolution. See also remark about using -(selections) below.
       =1: select admin0 (full country), not admin1 (country
       state/province). The assets are scaled using climada_entity_value_GDP_adjust
       Note that selections=1 might lead to memory issues for large(r)
       countries, see option =2 or =10, too. This usage gets close to
       climada_create_GDP_entity.
       =2: select admin0 (like =1) and do not constrain the active
       centroids (with values&ampgt0) to the selected country (good for initial
       test and speedup, but less useful as an entity for damage
       calculation later).
       =3: select admin1 and do not constrain the active
       centroids (with values&ampgt0) to the selected state/province, see 2.
       &amplt0: If selections is negative, use mid-resolution nightlights (see
       PARAMETER low_img_filename below). Default is high-res (1km).

       In case selection is a vector:
       selections(2)=1 -&ampgt add distance2coast_km (takes time)
       selections(3)=1 -&ampgt add elevation_m (takes time)
   check_plot: if =1: plot nightlight data with admin0 (countries)
       superimposed, if=2 also admin1 (country states/provinces)
       =0: no plot (default)
   scale_Value: =[a b c], scale entity.assets.Value to account for high
       nightlihgt intensity to represent larger share of values, as
       entity.assets.Value =  a + b*entity.assets.Value + c*entity.assets.Value.^2
       If = [a b c d], normalize after scaling and multiply by d. If d is
       negative, scale with country GDP (only makes sense if selections=1
       or =2), but works in other cases, too (as the user might find it
       useful).
       Default= [0 1 0 1e9], except for selections=1, in which case the
       assets are scaled using climada_entity_value_GDP_adjust
   img_filename: the filename of an image with night light density, as
       created using the GUI at http://maps.ngdc.noaa.gov/viewers/dmsp_gcv4/
       and select Satellite F18, 2010, avg_lights_x_pct, then 'Download
       data' and enter the coordinates
       The filename has to be of form A_B_C_D_{|E_F}*..lzw.tiff with A,B,C and D
       the min lon, min lat, max lon and max lat (integer), like
       87_20_94_27_F182010.v4c.avg_lights_x_pct.lzw.tiff and E and F the
       country (admin0) and state/province (admin1) name, like
       -88_24_-79_32_United States of America_Florida_high_res.avg_lights.lzw.tiff

       If empty (eg run the code without any argument), it prompts for country
       and admin1 name and constructs the URL to get the corresponding
       tile from the nightlight data, e.g. a string such as:
       http://mapserver.ngdc.noaa.gov/cgi-bin/public/gcv4/F182010.v4c.
           avg_lights_x_pct.lzw.tif?request=GetCoverage&ampservice=WCS&amp
           version=1.0.0&ampCOVERAGE=F182010.v4c.avg_lights_x_pct.lzw.tif&amp
           crs=EPSG:4326&ampformat=geotiff&ampresx=0.0083333333&ampresy=0.0083333333&amp
           bbox=-88,24,-79,32

       ='ASK' prompt for an image file (without first asking for country
       where one has to press 'Cancel') to get the to filename prompt
   save_entity: whether we save the entity (=1, default) or nor (=0).
 OUTPUTS:
   entity: a full climada entity, see climada_entity_read, plus the fields
       entity.assets.distance2coast_km(i): distance to coast in km (both on-
           and offshore) for each centroid
       entity.assets.elevation_m(i): elevation in m for each centroid,
           negatove for ocean depth (needs climada module etopo, just skips
           this if module not installed)
       entity.assets.admin0_name: country name
       entity.assets.admin0_ISO3: country ISO3 code
       entity.assets.admin1_name: state/province name (if restricted to
           admin1)
       entity.assets.admin1_code: state/province code (if restricted to
           admin1)
       see e.g. climada_entity_plot to check
 RESTRICTIONS:
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20141202
 david.bresch@gmail.com, 20141203, country and admin1 selection
 david.bresch@gmail.com, 20141204, 'ASK' debugged, cleaned up
 david.bresch@gmail.com, 20141205, high-res locally stored
 david.bresch@gmail.com, 20141206, GDP scaling added
 david.bresch@gmail.com, 20141209, admin1 name issue resolved
 david.bresch@gmail.com, 20141212, compatible with new admin0.mat instead of world_50m.gen
 david.bresch@gmail.com, 20141212, renamed to climada_nightlight_entity (formerly climada_high_res_entity)
 david.bresch@gmail.com, 20141215, switch to entity_template.xls
 david.bresch@gmail.com, 20141225, SPECIAL for Alaska in plot (avoid dateline)
 david.bresch@gmail.com, 20141226, distance2coast_km and elevation_m added
 david.bresch@gmail.com, 20160303, 10km resolution: issue fixed, when using .mat file as previously generated by climada_create_GDP_entity
 david.bresch@gmail.com, 20160524, fixed issue with new climada_entity_load (allow for empty assets)
 david.bresch@gmail.com, 20160529, if restricted to values within admin0 or admin1, add a regular grid outside
 david.bresch@gmail.com, 20160603, if admin0 and admin1 names are given on input, restrict admin1 search to within admin0 (logo)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/climada_nightlight_entity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_entity_assets">
<H2>climada_plot_entity_assets</H2></A>
<font color="blue">function fig = climada_plot_entity_assets(entity,centroids,country_name,check_printplot,printname,keep_boundary) </font>
 climada plot assets from entity file and save if needed
 NAME:
   climada_plot_entity_assets
 PURPOSE:
   plot assets from entity file on a map with different colors to show the
   distribution of assets, print if needed
   normally called from: climada_create_GDP_entity
 CALLING SEQUENCE:
   fig = climada_plot_entity_assets(entity, centroids, country_name, check_printplot)
 EXAMPLE:
   climada_plot_entity_assets(entity, centroids, country_name)
 INPUTS:
   entity          : entity structure, with entity.assets field
   centroids       : centroids mat-file (struct)
       if passed empty, the information is taken from entity.assets
 OPTIONAL INPUT PARAMETERS:
   country_name_str: country name as string format
   check_printplot : 1 for printing (save as pdf), set to 0 by default
   printname       : name for pdf-file, to be saved in .../climada/data/results/Entity_printname.pdf
 OUTPUTS:
   fig             : figure handle
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20140205
 David N. Bresch, david.bresch@gmail.com, 20141127, figure creating suppressed
 David N. Bresch, david.bresch@gmail.com, 20141208, country_name='' as default
 David N. Bresch, david.bresch@gmail.com, 20141209, abort if sum(Values)=0
 Lea Mueller, muellele@gmail.com, 20140205, add keep_boundary option
 Lea Mueller, muellele@gmail.com, 20160318, use climada_colormap('assets')
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/climada_plot_entity_assets.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_admin1_risk_calc">
<H2>country_admin1_risk_calc</H2></A>
<font color="blue">function country_risk=country_admin1_risk_calc(country_name,probabilistic,check_plots,peril_ID,admin1_save_entity) </font>
 climada country admin1 risk calc
 MODULE:
   country_risk
 NAME:
   country_admin1_risk_calc
 PURPOSE:
   Run the all (available) perils for one country's admin1 level

   Obtains the admin1 boundaries (from www.naturalearthdata.com, see
   PARAMETERS in code) and carve out the respective centroids (set Value
   at all others to zero). Runs the risk calculation for each admin1 for
   all hazards. In case one would like to skip hazards, just (temporarily)
   remove the respective {country_ISO3}_{country_name}_*.mat hazard event
   sets or see parameter peril_ID. 

   ONLY makes sense if country_risk_calc has been run for the respective
   country (we keep it like this, as automatic mode might trigger lots of
   un-wanted calculations). If not, the code terminates with the
   respective messages (no entity found, no hazard set(s) found...)
   But one can run country_admin1_risk_calc for more than one
   country (see country_name), if the respective countries have been run
   as country_risk_calc.

   NOTE: Before using this code, make yourself familiar with 
   country_risk_calc

   next step: country_risk_report (same format as country_risk_calc)
 CALLING SEQUENCE:
   country_risk=country_admin1_risk_calc(country_name,probabilistic,check_plots,peril_ID,admin1_save_entity)
 EXAMPLE:
   country_risk=country_admin1_risk_calc; % interactive, select country from dropdown
   country_risk=country_admin1_risk_calc('ALL') % whole world, no figures
   country_risk=country_admin1_risk_calc({'Germany','Switzerland'}) % just two countries
 INPUTS:
   country_name: name of the country, like 'Switzerland', or a list of
       countries, like {'Switzerland','Germany','France'}, see
       climada_create_GDP_entity.
       If set to 'ALL', the code runs recursively through ALL countries
       (mind the time this will take...)
       &ampgt prompted for via dropdown list if empty (allows for single or
       multiple country selection)
 OPTIONAL INPUT PARAMETERS:
   probabilistic: Whether we use historic (=0) or probabilistic (=1,
       default) hazard event sets. Obviously depends on what hazard event sets
       have been generated in country_risk_calc
   check_plots: if =1, show figures to check hazards etc.
       If =0, skip figures (default)
       If =100, plot only, skip calculations
       If country_name is set to 'ALL', be careful to set check_plots=1
   peril_ID: if passed on, run all calculations only for specified peril
       Same behaviour as in country_risk_calc, namely:
       peril_ID can be 'TC','TS','TR','EQ','WS'..., default='' for all
       One can also specify the peril region within peril_ID, such as
       'atl_TC' and peril_ID can also contain a list, e.g. peril_ID=['atl_TC';'atl_TS';'EQ'] 
   admin1_save_entity: =1 to save each admin1 entity as single entity file
       Entity file named {country_ISO3}_{country_name}_{admin1_name}_entity.mat
       =0 to omit this (default)
 OUTPUTS:
   country_risk(1): a structure with some risk information, same structure
       as from country_risk_calc, see country_risk_report to create a
       readable report to stdout or file
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141126, initial
 David N. Bresch, david.bresch@gmail.com, 20141212, compatible with new admin0.mat instead of world_50m.gen
 David N. Bresch, david.bresch@gmail.com, 20150110, country naming as in country_risk_calc
 David N. Bresch, david.bresch@gmail.com, 20150112, hazard extension '_hist' for historic, '' for probabilistic
 David N. Bresch, david.bresch@gmail.com, 20150112, climada_hazard2octave
 David N. Bresch, david.bresch@gmail.com, 20150714, find admin1 also based on ISO3
 David N. Bresch, david.bresch@gmail.com, 20150803, peril_ID added and admin1_save_entity debugged
 David N. Bresch, david.bresch@gmail.com, 20150803, probabilistic=1 as defaut
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/country_admin1_risk_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_risk_calc">
<H2>country_risk_calc</H2></A>
<font color="blue">function country_risk=country_risk_calc(country_name,method,force_recalc,check_plots,peril_ID,damagefunctions) </font>
 climada
 MODULE:
   country_risk
 NAME:
   country_risk_calc
 PURPOSE:
   run all (available) perils for one country. I.e. generate earthquake
   (EQ), volcano (VQ), tropical cyclone (TC), torrential rain (TR), storm
   surge (TS) and European winter storm (WS) hazard event sets and run
   risk calculation for a given country:  
   1) generate centroids for the country (uses climada_create_GDP_entity)
   2) figure which hazards affect the country
   3) create the hazard event sets, uses
      - climada_tc_hazard_set (wind)
      - climada_tr_hazard_set (rain)
      - climada_ts_hazard_set (surge)
      - eq_global_hazard_set (earthquake)
      - European winter storms (existing European hazard set)
   4) run the risk calculation for all hazards

   NOTE that centroids_generate_hazard_sets is called for steps 2 and 3.
   Note further that should there be more than one source for TC tracks,
   more than one TC hazard set is generated (see centroids_generate_hazard_sets)

   next step: country_risk_report, see also country_admin1_risk_calc and
   esepcially country_risk_calibrate, plus cr_DFC_plot and cr_DFC_plot_aggregate
 CALLING SEQUENCE:
   country_risk=country_risk_calc(country_name,method,force_recalc,check_plots,peril_ID)
 EXAMPLE:
   country_risk0=country_risk_calc('CHE',1,0); % 10x10km resolution for
       % Switzerland, using climada_nightlight_entity (not GDP_entity)
   country_risk0=country_risk_calc('CHE',2,0); % 1x1km resolution for
       % Switzerland, using climada_nightlight_entity
   country_risk0=country_risk_calc('CHE',3,0); % 10x10km resolution for
       % Switzerland, using GDP_entity
   country_risk=country_risk_calc; % interactive, select country from dropdown
   country_risk=country_risk_calc('ALL',1,0,0) % whole world, no figures
   country_risk=country_risk_calc(country_name,-7,0,0,['atl_TC';'atl_TS']) % both TC and TS for atl
 INPUTS:
   country_name: name of the country, like 'Switzerland', or a list of
       countries, like {'Switzerland','Germany','France'}. See
       climada_check_country_name for the list of valid country names
       If set to 'ALL', the code runs recursively through ALL countries
       (mind the time this will take...)
       &ampgt prompted for via dropdown list if empty (allows for single or
       multiple country selection)
 OPTIONAL INPUT PARAMETERS:
   method: =1: use 10km nightlight (climada_nightlight_entity, NOT default)
       =2: use 1km nightlight (climada_nightlight_entity)
       =3: (default) use 10km nightlight (GDP_entity). In this case, USA is
           restricted to contiguous US excl. Alaska and NZL only West of dateline.

       Since the code uses the entity (III_Name, with III Iso3 code and
       Name the country name) if it exists already, the resolution only
       matters on the first call, that's why we can use force_recalc to
       direct resolution. For another entity resolution, delete or rename
       the entity.

       &amplt0: all above options *(-1) trigger the generation of the full
       probabilistic hazard sets (otherwise _hist is added to the hazard
       event sets) 
       =7 (for historic, or -7 to use probabilistic sets): skip entity and
       hazard set generation, straight to damage calculations (this allows
       to avoid any re-generation of - missing - hazard event sets, the
       code just takes what's there). In this case, peril_ID can contain
       the peril region, too, i.e. 'atl_TC' or 'glb_EQ' and peril_ID can
       be a list of IDs, such as peril_ID=['atl_TC';'atl_TS'].

       Internally: if method&amplt0, probabilistic=1, =0 else (default)
       =sign(.)*(abs(.)+100): use future entities, e.g. -107 uses
       future entity, and probabilistic hazards, but skips entity and
       hazard calculation.
       If method has two elements, the second one triggers
       EDS_emdat_adjust, i.e. if method(2)=1, we adjust the EDS by
       comparison with EM-DAT, see cr_EDS_emdat_adjust

       In case method is a vector and abs(method(1)) either 1 or 2:
       method(2)=1 -&ampgt add distance2coast_km (takes time)
       method(3)=1 -&ampgt add elevation_m (takes time)
   check_plot: if =1: plot nightlight data with admin0 (countries)
   force_recalc: if =1, recalculate the hazard sets, even if they exist
       (good for TEST while editing the code, default=0)
   check_plots: if =1, show figures to check hazards etc.
       If =0, skip figures (default)
       If country_name is set to 'ALL', be careful to set check_plots=1
   peril_ID: if passed on, run all calculations only for specified peril
       peril_ID can be 'TC','TS','TR','EQ','WS'..., default='' for all
       Once generated, one can also specify the peril region within
       peril_ID, such as 'atl_TC'. If method=+/-7, peril_ID can also
       contain a list, e.g. peril_ID=['atl_TC';'atl_TS';'EQ']
   damagefunctions: if passed, use damagefunctions instead of the one that
       comes with the entity (or entities). Replaces entity.damagefunctiuons 
       without any further tests. The user is responsible for not messing
       up, i.e. for entity.assets.DamageFunID to point to the right damage
       function, damagefunctions.peril_ID to be consistent with e.g. input
       parameter peril_ID etc.
 OUTPUTS:
   writes a couple files, such as entities and hazard event sets (the
       output to stdout lists all names)
   country_risk(country_i): a structure with some risk information for
       each country (if run eg with 'ALL'), see hazard(hazard_i).EDS
       e.g. plot damage for one hazard in one country at each centroid with
         climada_circle_plot(...
          country_risk(country_i).res.hazard(hazard_i).EDS.ED_at_centroid,...
          country_risk(country_i).res.hazard(hazard_i).EDS.assets.lon,...
          country_risk(country_i).res.hazard(hazard_i).EDS.assets.lat)
       see country_risk_report to create a readable report to stdout
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140831, initial
 David N. Bresch, david.bresch@gmail.com, 20140922, three hazards: TC,TS,TR
 David N. Bresch, david.bresch@gmail.com, 20141020, ready for checkin
 David N. Bresch, david.bresch@gmail.com, 20141025, major cleanup, WS and EQ added
 David N. Bresch, david.bresch@gmail.com, 20141026, probabilistic as input
 David N. Bresch, david.bresch@gmail.com, 20141029, force_re_encoding
 David N. Bresch, david.bresch@gmail.com, 20141103, matching peril_ID for damagefunction added
 David N. Bresch, david.bresch@gmail.com, 20141107, add ncetCFD tc_track file treatment (NCAR) (on flight to Dubai)
 David N. Bresch, david.bresch@gmail.com, 20141126, country list enabled and multiple selection added
 David N. Bresch, david.bresch@gmail.com, 20141222, method parameter simplified (replaces and includes probabilistic)
 David N. Bresch, david.bresch@gmail.com, 20150112, climada_hazard2octave
 David N. Bresch, david.bresch@gmail.com, 20150121, method=7 added
 David N. Bresch, david.bresch@gmail.com, 20150123, distance2coast_km added
 David N. Bresch, david.bresch@gmail.com, 20150213, peril_ID to contain region and multiple perils enabled (if method=+/-7)
 David N. Bresch, david.bresch@gmail.com, 20150819, centroids in their own folder
 Lea Mueller, muellele@gmail.com, 20151021, add climate change option (method=-8) (use hazard TWN_TAIWAN_wpa_TC_cc_2050.mat instead of TWN_TAIWAN_wpa_TC.mat)
 David N. Bresch, david.bresch@gmail.com, 20160303, method as vector added
 David N. Bresch, david.bresch@gmail.com, 20160517, probabilistic based on GDP entity as default
 David N. Bresch, david.bresch@gmail.com, 20160517, enabled use without tropical_cyclone or volcano_earthquake models loaded
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/country_risk_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_risk_calibrate">
<H2>country_risk_calibrate</H2></A>
<font color="blue">function ok=country_risk_calibrate(country_name) </font>
 climada template
 MODULE:
   module name
 NAME:
   country_risk_calibrate
 PURPOSE:
   Calibrate a given country (or a list of countries)
   Call country_risk_calc before

   Standard procedure is that the switch statement below has entries for
   countries (and lists of countries) and hence performs the specific
   actions. Be careful to check for repetitious application. We set the
   field entity.calibrated=1 the first time it is treated here, but since
   one might need to re-calibrate, one should rather assign absolute
   values to e.g. damagefunctions.MDD, since a mere multiplication of
   existing values might lead to troubles on subsequent calls. the code
   climada_damagefunctions_replace does indeed not replace on repetitious
   calls if the result would be exactly the same.

   See also cr_country_hazard_test in order to test country calibration

 CALLING SEQUENCE:
   ok=country_risk_calibrate(country_name)
 EXAMPLE:
   ok=country_risk_calibrate('USA')
 INPUTS:
   country_name: a single country name or a list of countries
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150214, initial
 David N. Bresch, david.bresch@gmail.com, 20150217, Philippines and Taiwan re-adjusted
 David N. Bresch, david.bresch@gmail.com, 20150715, HKG added
 David N. Bresch, david.bresch@gmail.com, 20150803, USA EQ added
 Lea Mueller, muellele@gmail.com, 20151021, add additional countries for phase 2 (Aruba, Barbados, Bermuda, Venezuela, 
            Bahamas, Cook Islands, Guatemala, Honduras, Jamaica, Mozambique, Fiji, Trinidad), calibrated by Jacob Anz
 Lea Mueller, muellele@gmail.com, 20160212, rename to climada_damagefunctionS_generate instead of without s
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/country_risk_calibrate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_risk_report">
<H2>country_risk_report</H2></A>
<font color="blue">function country_risk_report(country_risk,print_format,report_filename,DFC_return_periods,plot_DFC) </font>
 climada
 MODULE:
   country_risk
 NAME:
   country_risk_report
 PURPOSE:
   produce a report (country, peril, damage) based on the results from
   country_risk_calc and country_admin1_risk_calc

   previous call: country_risk_calc and/or country_admin1_risk_calc
   see also: country_risk_report_raw for a raw report (to stdout)
 CALLING SEQUENCE:
   country_risk_report(country_risk,print_format,report_filename,DFC_return_periods,plot_DFC)
 EXAMPLE:
   country_risk_report(country_risk_calc('Barbados')); % all in one

   country_risk0=country_risk_calc('Switzerland'); % country, admin0 level
   country_risk1=country_admin1_risk_calc('Switzerland'); % admin1 level
   country_risk_report([country_risk0 country_risk1]) % report all
   country_risk_report(country_risk,1,'',-250) % only 250yr RP
 INPUTS:
   country_risk: a structure with the results from country_risk_calc
 OPTIONAL INPUT PARAMETERS:
   print_format: =1, report damages in the order they have been calculated
       =2 show by descending damages (default)
       if negative, omit reporting all to stdout
       =0, call country_risk_report_raw (one line with ED per country)
   report_filename: the filename of the Excel file the report is written
       to. Prompted for if not given (if Cancel pressed, write to stdout only)
   DFC_return_periods: damage frequency curve return periods, define the
       return periods we report damage for set =[] to report expected damage
       (ED) only (note that the ED will be denoted as return period=0 in the
       report). Default: DFC_return_periods=[100 250];
       If you set DFC_return_periods to a negative valiue, ONLY that
       return peirod will be reported (no ED, expected damage). Useful if
       e.g. only 100yr damage is of interest (and hence sorting
       descedingly by 100yr return period works, if print_format=2
       Note: DFC_return_periods are not passed on in the old version
       (print_format=0)
   plot_DFC: if =1, plot damage frequency curves (DFC) of all EDSs (!) in
       country_risk, =0 not (default)
       if =2, plot logarithmic scale both axes
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141209, initial
 David N. Bresch, david.bresch@gmail.com, 20141211, header added to Excel report
 David N. Bresch, david.bresch@gmail.com, 20150715, bug fix for empty EDS (e.g. if combine EDS is called prior to report)
 David N. Bresch, david.bresch@gmail.com, 20150715, empty EDS not reported any more
 David N. Bresch, david.bresch@gmail.com, 20150815, option to only report one single RP (no ED)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/country_risk_report.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_risk_report_raw">
<H2>country_risk_report_raw</H2></A>
<font color="blue">function country_risk_report_raw(country_risk,print_unsorted,plot_DFC) </font>
 climada
 MODULE:
   country_risk
 NAME:
   country_risk_report_raw
 PURPOSE:
   produce a quick&ampdirty report based on the results from
   country_risk=country_risk_calc

   previous call: country_risk_calc and country_admin1_risk_calc
   see also: country_risk_report
 CALLING SEQUENCE:
   country_risk_report_raw(country_risk,print_unsorted,plot_DFC)
 EXAMPLE:
   country_risk_report_raw(country_risk_calc('Barbados')); % all in one

   country_risk0=country_risk_calc('Switzerland'); % country, admin0 level
   country_risk1=country_admin1_risk_calc('Switzerland'); % admin1 level
   country_risk_report([country_risk0 country_risk1]) % report all
 INPUTS:
   country_risk: a structure with the results from country_risk_calc
 OPTIONAL INPUT PARAMETERS:
   print_unsorted: =1, show the results in the order they have been calculated
       =0, show by descending damages (default)
   plot_DFC: if =1, plot damage frequency curves (DFC) of all EDSs (!) in
       country_risk, =0 not (default)
       if =2, plot logarithmic scale both axes
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141024, initial
 David N. Bresch, david.bresch@gmail.com, 20141025, cleanup of country_risk_report
 David N. Bresch, david.bresch@gmail.com, 20141209, renamed to country_risk_report_raw
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/country_risk_report_raw.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_risk_waterfall">
<H2>country_risk_waterfall</H2></A>
<font color="blue">function [entity, entity_future, DFC, DFC_eco, DFC_cc] = country_risk_waterfall(country_name,annual_eco_growth) </font>
 country_risk_waterfall(country_name,annual_eco_growth)
 MODULE:
   country risk
 NAME:
   country_risk_waterfall
 PURPOSE:
   Produce waterfall graph for a specific country, using the precalculated
   hazards (TC, TS, TC_cc_2050, TS_cc_2050) and entity (entity today)
 CALLING SEQUENCE:
   country_risk_waterfall(country_name,annual_eco_growth)
 EXAMPLE:
   country_risk_waterfall('Mexico',0.04)
   country_risk_waterfall({'Mexico'; 'Aruba'},0.04)
   country_risk_waterfall('ALL',0.04)
 INPUTS:
   country_name: name of the country, like 'Switzerland', or a list of
       countries, like {'Switzerland','Germany','France'}. See
       climada_check_country_name for the list of valid country names
       If set to 'ALL', the code runs recursively through ALL countries
       (mind the time this will take...)
       &ampgt prompted for via dropdown list if empty (allows for single or
       multiple country selection)
 OPTIONAL INPUT PARAMETERS:
   annual_eco_growth: annual economic growth, e.g. 0.04 for 4% growth for 
       a developing country, and 0.01 for a developed country 
 OUTPUTS:
   entity: entity structure with today's values
   entity_future: entity structure with future values
   DFC: damage frequency curve with 250 year damage for today's values
   DFC_eco: 250 year damage for economic growth
   DFC_cc: 250 year damage for economic growth and climate change
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151029, initial
 Lea Mueller, muellele@gmail.com, 20151105, call climada_entity_scaleup_factor for future entity and add output variables
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/country_risk_waterfall.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="emdat_read">
<H2>emdat_read</H2></A>
<font color="blue">function em_data=emdat_read(emdat_file,country_name,peril_ID,exposure_growth,verbose_mode,CAGR) </font>
 climada template
 MODULE:
   country_rsk
 NAME:
   emdat_read
 PURPOSE:
   Read EM-DAT database (www.emdat.be and www.emdat.be/explanatory-notes)
   from the file {country_risk_module}/data/emdat/emdat.xls

   Please note that the EM-DAT database does NOT contain its reference
   date (i.e. the last year it contains data for, see EMDAT_last_year
   in PARAMETERS)

   If requested, index past damages according to GDP (see
   exposure_growth). This feature needs t GDP_entity module to exist

   Also produce a damage frequency curve (DFC) in order to ease comparison with
   climada results, especially if EM-DAT data is filtered by country (see
   input country_name) and peril (see input peril_ID).
   Use e.g. plot(em_data.DFC.return_period,em_data.DFC.damage) to plot the
   damage excess frequency curve based on EM-DAT.

 CALLING SEQUENCE:
   em_data=emdat_read(emdat_file,country_name,peril_ID,exposure_growth,verbose_mode)
 EXAMPLE:
   em_data=emdat_read('','United States','TC');
 INPUTS:
   emdat_file: filename of the emdat database
       Default (='' or no input at all) is full global EM-DAT database, 
       see PARAMETERS for its default location
       if ='ASK', prompt for
 OPTIONAL INPUT PARAMETERS:
   country_name: if provided, only return records for specific country - r
   for the list of countries, if provided as cell, i.e. {'Vanuata','Aruba'}
       default: all countries
   peril_ID: if provided, only return records for specific peril,
       currently implemented are
       - 'TC': tropical cyclone, returns records with disaster subtype='Tropical cyclone'
       - 'TS': tropical cyclone surge, returns records with disaster subtype='Coastal flood'
       - 'FL': flood, returns records with disaster subtype='Riverine flood'
       - 'WS': winter storm, returns records with disaster subtype='Extra-tropical s'
       - 'EQ': earthquake, returns records with disaster subtype='Ground movement'
       - or just any of the disaster subtypes in EM-DAT, e.g. 'Tsunami'. You
         might use em_data=emdat_read('','China','',0,1); to get a list of all
         available disaster subtypes in China
       Default: all perils (i.e. all disaster subtypes)
   exposure_growth: =1: correct damage numbers to account for exposure
       growth (the field em_data.damage_orig contains the uncorrected numbers
       Only works if a single country is requested, i.e. if country_name
       is specified. In essence, we calculate the correction factor for
       year i as GDP(today)/GDP(year i)
       =0: no correction (default)
   verbose_mode: if =1, print list of countries and disaster subtypes that
       are returned in em_data. Default=0 (silent)
   CAGR: the compound annual growht rate (decimal). If not specified, the
       GDP development of thw past is used to index damages, and a CAGR
       default is used where no GDP exists (see PARAMETERS section, CAGR set
       to 0.02).
 OUTPUTS:
   em_data, a structure with (for each event i)
       filename: the original filename with EM-DAT fata
       year(i): the year (e.g. use hist(em_data.year) to get a feel...)
       disaster_type{i}: disaster type i, see www.emdat.be/explanatory-notes
       disaster_subtype{i}: disaster subtype i, see www.emdat.be/explanatory-notes
       occurrence(i): see www.emdat.be/explanatory-notes
       deaths(i): see www.emdat.be/explanatory-notes
       affected(i): see www.emdat.be/explanatory-notes
       injured(i): see www.emdat.be/explanatory-notes
       homeless(i): see www.emdat.be/explanatory-notes
       damage(i): the damage in USD (in units of 1 USD)
           Note that EM-DAT estimated damage in the database are given in
           US$ (?000), hence we multiply by 1000.
       damage_orig(i): the uncorrected damage in case exposure_growth=1
       frequency(i): the frequency of eaxch event (once in the years the
           database exists for)
       DFC: the damage frequency curve, a structure, see e.g.
           climada_EDS2DFC for this structures's fields, e.g.
           DFC.return_period and DFC.damage
       DFC_orig: the DFC of the original damages in case exposure_growth=1
       YDS: the year damage set, just plain summation of all damages in
           one year, use climada_EDS2DFC(em_data.YDS) to plot...
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150126, initial, Sils Maria
 David N. Bresch, david.bresch@gmail.com, 20150207, list of countries accepted
 David N. Bresch, david.bresch@gmail.com, 20150208, YDS added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/emdat_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="selected_countries_all_in_one">
<H2>selected_countries_all_in_one</H2></A>
 selected_countries_all_in_one
 climada template
 MODULE:
   module name
 NAME:
   selected_countries_all_in_one, run all project countries, all calculations

   run as a batch code, such that all is available on command line
 PURPOSE:
   Run all climada for project

   In order to synchronize all entities with GDP etc, country_risk_calc
   uses climada_entity_value_GDP_adjust

 CALLING SEQUENCE:
   selected_countries_all_in_one
 EXAMPLE:
   selected_countries_all_in_one
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150105
 David N. Bresch, david.bresch@gmail.com, 20150116, almost complete
 David N. Bresch, david.bresch@gmail.com, 20150121, GDP adjust added
 David N. Bresch, david.bresch@gmail.com, 20150121, GDP adjust added
 David N. Bresch, david.bresch@gmail.com, 20150215, country calibration added at the bottom (all commented out, see there)
 David N. Bresch, david.bresch@gmail.com, 20150225, figure name added
 David N. Bresch, david.bresch@gmail.com, 20150815, latest country list and report only for 250yr event
 David N. Bresch, david.bresch@gmail.com, 20150815, WARNING: cr_EDS_adjust_all and country_risk_EDS2YDS switched off for now
 David N. Bresch, david.bresch@gmail.com, 20150819, centroids in their own dir
 Lea Mueller, muellele@gmail.com, 20151021, add climate change calculations (country_risk_calc_method=-8)
 Lea Mueller, muellele@gmail.com, 20151021, use country_list for phase1+phase2
 David N. Bresch, david.bresch@gmail.com, 20160322, country_list for TEST phase3 (US admin1)
 David N. Bresch, david.bresch@gmail.com, 20160324, small edit
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/selected_countries_all_in_one.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="GDP_docs_test">
<H2>GDP_docs_test</H2></A>
 batch TEST code, see code
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/GDP_docs_test.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_GDP_check_countrynames">
<H2>climada_GDP_check_countrynames</H2></A>
<font color="blue">function GDP = climada_GDP_check_countrynames(GDP, borders, silent_mode) </font>
 compare countrynames of GDP with climada worldmap (borders.mat)
 NAME:
   climada_GDP_read
 PURPOSE:
   check county names of GDP (worldbank) with climada worldmap country names
   and add index within GDP structure to refer to the index of the relevant
   country within climada world map structure (borders structure)
   previous: climada_GDP_read
   next: diverse
 CALLING SEQUENCE:
   GDP = climada_GDP_check_countrynames(GDP, borders, silent_mode)
 EXAMPLE:
   GDP = climada_GDP_check_countrynames
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   GDP: a struct, if not given, prompted for, with following fields
         .country_names: sorted countrynames (207 countries)
         .year         : vector of all the years that GDP is available for
         .value        : GDP value in USD per country
         .comment      : information about GDP data
         .description  : use for plot as colorbarlabel
   borders             : the borders-strucuture-mat-file in systems folder
                         (created in function climada_world_border)
   silent_mode         :  if set to 1, no print out messages
 OUTPUTS:
  GDP: including field
        .country_borders_index: index to relate to climada worldmap
                                borders.name (can have more than one index
                                if within a group (e.g. china for china
                                and taiwan in climada worldmap))
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20120730
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_GDP_check_countrynames.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_GDP_read">
<H2>climada_GDP_read</H2></A>
<font color="blue">function GDP = climada_GDP_read(xlsfilename, special_cases_on, check_names, silent_mode) </font>
 read GDP data from worldbank (1960 - 2010, in USD)
 http://data.worldbank.org/indicator/NY.GDP.MKTP.CD/countries
 read GDP data and forecast from IMF (2000 - 2017, in national currency)
 http://www.imf.org/external/ns/cs.aspx?id=28
 NAME:
   climada_GDP_read
 PURPOSE:
   read GDP data excel-file to mat-file
   previous: diverse
   next: climada_night_light_read
 CALLING SEQUENCE:
   GDP = climada_GDP_read(xlsfilename, special_cases_on, check_names,
   save_on)
 EXAMPLE:
   GDP = climada_GDP_read(xlsfilename)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   xlsfilename     :  the filename (location) of the GDP data
                      (default World_GDP_1960_2010.xls)
   special_cases_on:  set to 1 for summing up GDP of e.g. Sudan and South
                      Sudan, not applicable for GDP per capita (set to 0)
   check_names     :  if set to 1, check GDP names with borders.name
                      (climada world map)
   save_on         :  if set to 1, GDP-mat file to be saved
   silent_mode     :  if set to 1, no print out messages
 OUTPUTS:
   GDP: a struct, with following fields
         .country_names: sorted countrynames (207 countries)
         .year         : vector of all the years that GDP is available for
         .value        : GDP value in USD per country
         .comment      : information about GDP data
         .description  : use for plot as colorbarlabel
         .country_borders_index: index to relate to climada worldmap
                                  borders.name
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20120730
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_GDP_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ask_country_name">
<H2>climada_ask_country_name</H2></A>
<font color="blue">function [country_name,country_ISO3] = climada_ask_country_name(SelectionMode,PromptString) </font>
 ask for a country name through a pop up gui
 NAME:
   climada_ask_country_name
 PURPOSE:
   ask for a country name through a pop up gui
 CALLING SEQUENCE:
   country_name = climada_ask_country_name(SelectionMode,PromptString)
 EXAMPLE:
   country_name = climada_ask_country_name
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   SelectionMode: if set to 'multiple' allow for more than one country to
       be selected, if ='single', allow for single selection only (default)
   PromptString: the prompt string, default is set according to SelectionMode
 OUTPUTS:
   country_name, a char if SelectionMode='single' (default)
       a cell if SelectionMode='multiple'
   country_ISO3: the ISO3 country code (unambiguous)
       a cell if SelectionMode='multiple'
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20141016
 David N. Bresch, david.bresch@gmail.com, 20141126, SelectionMode added
 David N. Bresch, david.bresch@gmail.com, 20141209, ISO3 country code added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_ask_country_name.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_create_centroids_entity_base">
<H2>climada_create_centroids_entity_base</H2></A>
<font color="blue">function [centroids, entity] = climada_create_centroids_entity_base(country_name, asset_resolution_km, hollowout,... </font>
   check_for_groups, night_light, pp, borders, border_mask, ...
   check_figure, save_on_entity_centroids, no_wbar)
 NAME:
   climada_create_centroids_entity_base
 PURPOSE:
   create centroids and entity for a specific country, distribute assets
   and value according to night light intensities
 CALLING SEQUENCE:
   [centroids entity] =
   climada_create_centroids_entity_base(country_name,asset_resolution_km,...
       hollowout,check_for_groups,night_light,pp,borders,border_mask,...
       check_figure,save_on_entity_centroids,no_wbar)
 EXAMPLE:
   [centroids entity] = climada_create_centroids_entity_base;
   [centroids entity] = climada_create_centroids_entity_base('Bangladesh', 10);
 INPUTS:
   country_name: the name of the country or an ISO3 country code (like
       'CHE'), see climada_check_country_name
   asset_resolution_km:resolution for centroids and assets within entity,
       default 10km
   check_for_groups: if country is within a group (e.g. China with
       Taiwan), to combine the two or more regions, default do not check
       DISABLED, run the code multiple times (see also climada module
       country risk)
   hollowout: hollwout country, so to take only points close to the coast
       line, default do not hollowout
   night_light: structure with night light intensities, automatically load
       from mat or read from default file
   pp: nonlinear transformation function of night lights to values (e.g.
       pp = [0 1 0]; y = 0*x^2 + 1*x + 0
   borders: border structure (with name, polygon for every country)
   border_mask: structure with all country masks (zeros and ones)
   check_figure: set to 1 to visualize figures, default 1
   save_on_entity_centroids: to save entity and centroids automatically,
       default 1
   no_wbar: 1 to suppress waitbars
 OUTPUTS:
   centroids: a structure with fields centroid_ID, Latitude, Longitude,
       onLand, country_name, comment for each centroid
   entity: an entity structure with fields assets, damagefunctions,
       measures, discount. Asset values from an entire country
       sum up to 100. If only coastal areas are selected,
       values sum up to less than 100.
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20140205
 david.bresch@gmail.com, 20140216, replaced variable entity_base with entity for compatibility
 david.bresch@gmail.com, 20141209, country or ISO3 enabled
 david.bresch@gmail.com, 20141229, tolerant iro country names
 david.bresch@gmail.com, 20150804, return empty if Cancel pressed
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20150819, module_data_dir updated
 Lea Mueller, muellele@gmail.com, 20160318, use climada_map_plot instead of climada_plot_centroids and climada_plot_entity_assets
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_create_centroids_entity_base.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_cut_out_GDP_entity">
<H2>climada_cut_out_GDP_entity</H2></A>
<font color="blue">function [centroids,entity,polygon] = climada_cut_out_GDP_entity(entity,centroids,polygon) </font>
 NAME:
   climada_cut_out_GDP_entity
 PURPOSE:
   Select a specific region within a country (entity and centroids).
   specify region either with a polygon or define interactively with mouse
 CALLING SEQUENCE:
   [centroids entity polygon] = climada_cut_out_GDP_entity(entity, centroids, polygon)
 EXAMPLE:
   [centroids entity polygon] = climada_cut_out_GDP_entity
 INPUTS:
 none
 OUTPUTS:
   centroids: a structure with fields centroid_ID, Latitude, Longitude,
       onLand, country_name, comment for each centroid
   entity: a structure with fields assets, damagefunctions, measures,
       discount. Assets values are based on night light
       intensity and scaled up to todays GDP (e.g. 2014)
   polygon: the polygon that specifies the region that was
       defined through mouse clicks, or self-defined input. The vertices 
       of the polygon as an Mx2 array [X1 Y1; X2 Y2; etc].
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20140206
 david.bresch@gmail.com, 20140216, _2012 replaced by _today
 david.bresch@gmail.com, 20141209, tried to fix, does not work properly
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_cut_out_GDP_entity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_define_polygon">
<H2>climada_define_polygon</H2></A>
 [x,y] = ginput(4)
 [x,y] = gline(3)
<font color="blue">function polygon = climada_define_polygon </font>
 define a polygon within an open figure
 NAME:
   climada_define_polygon
 PURPOSE:
   Define a polygon within a figure, specifically used within
   climada_cut_out_global_portfolio
 CALLING SEQUENCE:
   polygon = climada_define_polygon
 EXAMPLE:
   polygon = climada_define_polygon
 INPUTS:
   none
 OUTPUTS:
   polygon with poylgon(:,1) longitude and polygon(:2) latitude
 MODIFICATION HISTORY:
 Lea Mueller, 20130412
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_define_polygon.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_downscale">
<H2>climada_downscale</H2></A>
<font color="blue">function stru_new_res = climada_downscale(stru, downscale_factor, f_name) </font>
 see code
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_downscale.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_base_assets_add">
<H2>climada_entity_base_assets_add</H2></A>
<font color="blue">function entity_base = climada_entity_base_assets_add(values_distributed, centroids, country_name_str, matrix_hollowout,  X, Y, hollow_name, no_wbar) </font>
 climada add assets to entity base structure, from values_distributed
 NAME:
   climada_entity_base_assets_add
 PURPOSE:
   add assets to entity structure from values_distributed and find the
   closest calculation centroids (encode assets to centroids)
   normally called from: climada_create_centroids_entity_base
 CALLING SEQUENCE:
   entity_base = climada_entity_base_assets_add(values_distributed, centroids, country_name_str, matrix_hollowout,  X, Y)
 EXAMPLE:
   entity_base = climada_entity_base_assets_add(values_distributed, centroids, country_name_str, matrix_hollowout,  X, Y)
 INPUTS:
   values_distributed    : structure mat-file with the following fields
         .values         : distributed values per pixel
         .lon_range      : range of Longitude
         .lat_range      : range of Latitude
         .resolution_x   : resolution in x-direction
         .resolution_y   : resolution in y-direction
   centroids             : a centroid mat-file (struct)
   country_name_str      : country name as string format
   matrix_hollowout      : coastal area, bufferzone and hollowed out matrix,
                           masking 1 for on land, and zero for sea, 2 (max value) for buffer
   X                     : helper matrix containing Longitude information for plotting matrix
   Y                     : helper matrix containing Latitude information for plotting matrix
 OPTIONAL INPUT PARAMETERS:
   no_wbar               : set to 1 to suppress waitbar
 OUTPUTS:
   entity_base           : entity with assets from values_distributed.
                           Values sum up to 100, or if only coastal areas
                           are selected, to less than 100.
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20140205
 david.bresch@gmail.com, 20140216, _2012 replaced by _today
 david.bresch@gmail.com, 20140216, assets.comment introduced
 david.bresch@gmail.com, 20141104, climada_check_matfile used
 david.bresch@gmail.com, 20141215, switch to entity_template.xls
 Lea Mueller, muellele@gmail.com, 20150123, omit assets.Value_today, not needed
 Lea Mueller, muellele@gmail.com, 20150904, add assets.Value_unit field
 Lea Mueller, muellele@gmail.com, 20151125, invoke climada_entity_read instead of climada_entity_read_wo_assets
 Lea Mueller, muellele@gmail.com, 20160331, use entity_template.xlsx from from climad/data/entities, omit encoding
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_entity_base_assets_add.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_read_wo_assets">
<H2>climada_entity_read_wo_assets</H2></A>
<font color="blue">function entity = climada_entity_read_wo_assets(entity_filename) </font>
 climada assets read import without assets
 NAME:
   climada_entity_read_wo_assets
 PURPOSE:
   read the Excel file without assets, but with damagefunctions, measures
   etc. without encoding (climada_assets_encode)
   The code invokes climada_spreadsheet_read to really read the data,
   which implements .xls files
   For .xls, the sheet names are dynamically checked,
   'assets','damagefunctions','measures' and 'discount' need to exist.
 CALLING SEQUENCE:
   entity = climada_entity_read_wo_assets(entity_filename, assets_off)
 EXAMPLE:
   entity = climada_entity_read_wo_assets
 INPUTS:
   entity_filename: the filename of the Excel file with the assets
       &ampgt promted for if not given
 OUTPUTS:
   entity: a structure, with
       assets: a structure, with
           Latitude: the latitude of the values
           Longitude: the longitude of the values
           Value: the total insurable value
           Deductible: the deductible
           Cover: the cover
           DamageFunID: the damagefunction curve ID
       damagefunctions: a structure, with
           DamageFunID: the damagefunction curve ID
           Intensity: the hazard intensity
           MDD: the mean damage degree
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090920
 Lea Mueller, 20110720
 David N. Bresch, david.bresch@gmail.com, 20130328, vuln_MDD_impact -&ampgt
 MDD_impact ...
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_entity_read_wo_assets.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_save_xls">
<H2>climada_entity_save_xls</H2></A>
<font color="blue">function climada_entity_save_xls(entity, entity_xls_file,dam_funct_overwrite,measures_overwrite,discount_overwrite) </font>
 climada assets read import without assets
 MODULE:
   GDP_entity
 NAME:
   climada_entity_save_xls
 PURPOSE:
   Save entiy as xls file
 CALLING SEQUENCE:
   climada_entity_save_xls(entity, entity_xls_file)
 EXAMPLE:
   climada_entity_save_xls(entity)
 INPUTS:
   entity: entity strucure to write out in excel file
   entity_xls_file: the filename of the Excel file to be written
 OUTPUTS:
   excel file
 MODIFICATION HISTORY:
 Lea Mueller, 20130412
 Gilles Stassen 20141210 - change condition from
                  multiple strcmp() statements to ismember(); add relevant
                  'wrong' fields to cell array to be checked in line 64;
                  change to dynamic field referencing instead of getfield;
                  add isnumeric condition to damagefunction section to
                  include peril_ID field.
 Gilles Stassen 20141211 - add overwrite options for non-asset sheets
 Gilles Stassen 20150106 - generalise condition on entity.assets.(fields)
 David N. Bresch, david.bresch@gmail.com, 20150804, old assets.Longitude replaced by assets.lon
 Lea Mueller, muellele@gmail.com, 20160212, set dam_funct_overwrite, measures_overwrite, discount_overwrite to 1 (default)
 Lea Mueller, muellele@gmail.com, 20160212, check excel limit only for .xls version
 Lea Mueller, muellele@gmail.com, 20160307, add other fields in tab &quotothers&quot so that this function can be used for any kind of structure, not just an entity
 Lea Mueller, muellele@gmail.com, 20160318, bugfix if .damagefunctions is empty
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_entity_save_xls.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_scaleup_GDP">
<H2>climada_entity_scaleup_GDP</H2></A>
<font color="blue">function [entity,scale_up_factor]=climada_entity_scaleup_GDP(entity,GDP_future,year_future,year_start,centroids,borders,check_figure,check_printplot) </font>
 upscale a given entity based on GDP growth between two periods
 NAME:
   climada_entity_scaleup_GDP
 PURPOSE:
   upscale a given entity based on GDP growth between two periods
 CALLING SEQUENCE:
   entity = climada_entity_scaleup_GDP(entity, GDP_future,
   year_future, year_start, centroids, borders, check_figure, check_printplot)
 EXAMPLE:
   entity = climada_entity_scaleup_GDP(entity, '', 2030, 2012)
 INPUTS:
   none
 OPTIONAL INPUTS:
   entity       : entity with entity.assets, prompted for it not given
   GDP_future   : GDP data structure based on IMF data, automatically
                  loaded from mat-file or newly read from xls if available
   year_future  : e.g. 2030, default 2030
   year_start   : e.g. 2012, default 2012
   centroids    : centroids structure, with centroids.country_name to link
                  GDP data with entity.assets, prompted for if not given
   borders      : border structure (with name, polygon for every country)
   check_figure : set to 1 to visualize figures, default 1
   check_printplot : set to 1 to save figure, default 0
 OUTPUTS:
   entity: assets upscaled based on GDP growth
   a structure, with
       assets: a structure, with
           Latitude: the latitude of the values
           Longitude: the longitude of the values
           Value: the total insurable value
           Deductible: the deductible
           Cover: the cover
           DamageFunID: the damagefunction curve ID
       damagefunctions: a structure, with
           DamageFunID: the damagefunction curve ID
           Intensity: the hazard intensity
           MDD: the mean damage degree
 MODIFICATION HISTORY:
 Lea Mueller, 20130412
 Melanie Bieli, 20150125, added scale_up_factor as an additional output parameter 
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
 David N. Bresch, david.bresch@gmail.com, 20160222, module_data_dir updated
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_entity_scaleup_GDP.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_scaleup_factor">
<H2>climada_entity_scaleup_factor</H2></A>
<font color="blue">function entity = climada_entity_scaleup_factor(entity, factor_) </font>
 upscale a given entity with a specific factor
 MODULE:
   GDP_entity
 NAME:
   climada_entity_scaleup_factor
 PURPOSE:
   Upscale entity assets with a specific factor 
 CALLING SEQUENCE:
   entity = climada_entity_scaleup_factor(entity, factor_)
 EXAMPLE:
   entity = climada_entity_scaleup_factor(entity, factor_)
 INPUTS:
   entity: entity with entity.assets
   factor_: factor to multiply entity.assets.Value with
 OPTIONAL INPUTS:
   none
 OUTPUTS:
   entity: assets upscaled with a specific factor
   a structure, with
       assets: a structure, with
           Latitude: the latitude of the values
           Longitude: the longitude of the values
           Value: the total insurable value
           Deductible: the deductible
           Cover: the cover
           DamageFunID: the damagefunction curve ID
       damagefunctions: a structure, with
           DamageFunID: the damagefunction curve ID
           Intensity: the hazard intensity
           MDD: the mean damage degree
 MODIFICATION HISTORY:
 Lea Mueller, 20130412
 david.bresch@gmail.com, 20140216, _2012 replaced by _today
 david.bresch@gmail.com, 20141024, entity.assets.comment introduced
 muellele@gmail.com, 20151105, add module name in documentation
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_entity_scaleup_factor.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_load_border_mask">
<H2>climada_load_border_mask</H2></A>
<font color="blue">function border_mask = climada_load_border_mask(border_mask_DUMMY, asset_resolution_km) </font>
 load border mask
 NAME:
   climada_load_border_mask
 PURPOSE:
   load border mask
 CALLING SEQUENCE:
   border_mask = climada_load_border_mask(border_mask, asset_resolution_km)
 EXAMPLE:
   border_mask = climada_load_border_mask
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   border_mask_DUMMY: a dummy parameter for backward compatibility, not used
   asset_resolution_km: resolution in km, default=10
 OUTPUTS:
   border_mask
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20141016
 David N. Bresch, david.bresch@gmail.com, 20141229, full revision
 David N. Bresch, david.bresch@gmail.com, 20160222, module_data_dir updated
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_load_border_mask.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_load_world_borders">
<H2>climada_load_world_borders</H2></A>
<font color="blue">function borders = climada_load_world_borders </font>
 load world borders and perform basic checks
 MODULE:
   GDP_entity
 NAME:
   climada_load_world_borders

   An OLD code, please consider climada_shaperead
   Kept for backward compatibility, only used by GDP_entity

 PURPOSE:
   load world borders and perform basic checks

   Please note that this is a backward-compatibility solution, as climada
   switched to shapes-based country borders (20141212). Please consider
   climada_country_name and inspect climada_plot_world_borders as well as
   climada_shaperead.

   map_border_file: filename and path to a *.gen or *.shp border file
       if set to 'ASK', prompt for the .gen broder file

       the *.gen file has to be of the following format
       file content                        description (NOT in file)
       -------------------------------------------------------------------
       country_name                        Name of the country
       -70.6,35.2                          longitude,latitude of first polygon point
       -75.3,23.5                          longitude,latitude of second polygon point
       -75.3,23.5                          longitude,latitude of next polygon point
       END                                 marks end of one closed contour
       -45.45,23-6                         next colsed polygon (eg island)
       -67.3,23.7
       END                                 marks end of one closed contour
       country_name                        next country name
       -70.6,35.2                          longitude,latitude of first polygon point
       ...                                 etc...
       END                                 marks end of one closed contour
       END                                 last (double) end to close file (optional)
   keep_boundary: if =1, keep axes boundaries, default =0, undefined
   country_color: the RGB triple for country coloring (e.g. [255 236
       139]/255). Default set in code (yellow)

   See also climada module country_risk
 CALLING SEQUENCE:
   borders = climada_load_world_borders(borders)
 EXAMPLE:
   borders = climada_load_world_borders
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   borders
 OUTPUTS:
   borders
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20141016
 David N. Bresch, david.bresch@gmail.com, 20141126, for backward compatibility
 David N. Bresch, david.bresch@gmail.com, 20160222, module_data_dir updated
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_load_world_borders.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_mask_buffer_hollow">
<H2>climada_mask_buffer_hollow</H2></A>
<font color="blue">function matrix_buffer = climada_mask_buffer_hollow(matrix, no_pixel_buffer, no_pixel_hollow, border_mask, ... </font>
                                                   check_figure, check_printplot, printname, cbar_label, no_wbar)
 create buffer around country (matrix masking 1 for onland (or higher 
 values if more than one country), 0 for sea, max value for bufferzone)
 NAME:
   climada_bufferzone
 PURPOSE:
   create buffer around country
   previous: diverse
   next: climada_mask_hollowout, climada_matrix2centroid
 CALLING SEQUENCE:
   matrix_buffer = climada_bufferzone(matrix, no_pixel, border_mask,
   check_figure, check_printplot, printname, cbar_label)
 EXAMPLE:
   matrix_buffer = climada_bufferzone(matrix, 5)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   matrix          : matrix masking 1 for on land, and zero for sea
                     (e.g.border_mask.mask{1}), max value for buffer
   no_pixel_buffer : no of pixel that mask the bufferzone around the
                     country/countries
   no_pixel_hollow : no of pixel that mask the bufferzone around the
                     country/countries. Set to 0 if no hollowout is needed.
   border_mask     : structure containg all country masks, including field
                     .world_mask (1 for on land, and 0 for sea)
   check_figure    : set to 1 to show figure distributed GDP
   check_printplot : set to 1 to save figure
   printname       : string for title and for filename if saved
   cbar_label      : label for colorbar (ISO3 codes for country names)
   no_wbar         : 1 for not waitbar, otherwise waitbar will show up
 OUTPUTS:
   matrix_buffer   : matrix masking 1 for on land, zero for on sea, and
                     max value for bufferzone
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20120730
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_mask_buffer_hollow.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_matrix2centroid">
<H2>climada_matrix2centroid</H2></A>
<font color="blue">function centroids = climada_matrix2centroid(matrix_buffer, lon_range, lat_range, country_name) </font>
 create centroids (structure) out of matrix_buffer and according range of
 longitude and latitude
 NAME:
   climada_matrix2centroid
 PURPOSE:
   create centroids based on matrix_hollowout or matrix_buffer
   previous: climada_mask_buffer_hollow
   next    : create entity, diverse
 CALLING SEQUENCE:
   centroids = climada_matrix2centroid(matrix_buffer, lon_range, lat_range, 
   country_name)
 EXAMPLE:
   centroids = climada_matrix2centroid(matrix_buffer, lon_range, lat_range)
 INPUTS:
   matrix_buffer   : matrix masking 1 for on land (or higher values if more 
                     than one country), zero for on sea, and max value for bufferzone
   lon_range       : range of Longitude of matrix_buffer
   lat_range       : range of Latitude of matrix_buffer
 OPTIONAL INPUT PARAMETERS:
   country_name    : country name for countries in matrix_buffer
 OUTPUTS:
   centroids structure with following fields
      .centroid_ID : unambiguous ID number for each centroid
      .lon   : Longitude of centroid
      .lat    : Latitude of centroid
      .onLand      : 1 for on land (or higher if more than one country, 
                     zero for on sea, and max value for bufferzone
      .country_name: country_name for each centroid, enhanced with 
                     'buffer' and 'sea'
      .comment     : information about centroids
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20140205
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_matrix2centroid.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_night_light_read">
<H2>climada_night_light_read</H2></A>
<font color="blue">function night_light = climada_night_light_read(png_filename, check_figure, check_printplot, save_on) </font>

 NAME:
   climada_night_light_read
 PURPOSE:
   read stable night lights (2010) from NOAA

   read stable night lights, 2010 (resolution ~10km)
   http://www.ngdc.noaa.gov/dmsp/downloadV4composites.html
   http://www.ngdc.noaa.gov/dmsp/data/web_data/v4composites/F182010.v4.tar
   Version 4 DMSP-OLS Nighttime Lights Time Series

   previous: diverse
   next: climada_GDP_distribute
   see also: module country_risk, climada_nightlight_entity
 CALLING SEQUENCE:
   night_light = climada_night_light_read(png_filename, check_figure, check_printplot, save_on)
 EXAMPLE:
   night_light = climada_night_light_read
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   png_filename: the filename (location) of the png-file with night lights
       (global coverage)
       &ampgt prompted for if empty (default night_light_2010_10km.png, but not
       automatically chosen)
   check_figure: =1: show figure of night light, default=0
   check_printplot: =1 to 1 to save figure (default=0)
   save_on: =1 to save .mat file (default)
 OUTPUTS:
   night_light: a struct, with following fields
         .value        : GDP value in USD per country
         .lon_range    : range of Longitude
         .lat_range    : range of Latitude
         .resolution_x : resolution in x-direction
         .resolution_y : resolution in y-direction
         .comment      : information about night light data
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20120730
 David N. Bresch, david.bresch@gmail.com, 20141205, cleanup
 David N. Bresch, david.bresch@gmail.com, 20160222, module_data_dir updated
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_night_light_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_nightlight_nonlinear_transformation">
<H2>climada_nightlight_nonlinear_transformation</H2></A>
<font color="blue">function [values_out, pp] = climada_nightlight_nonlinear_transformation(values_in, pp, check_figure, check_printplot) </font>
 transform night light intensity values (between 1 and 63) nonlinearly 
 into distributed GDP assets (based on relationship between night lights
 and asset distribution), use a second order polynomial without y-indent,
 e.g. y = pp(1)*x^2 + pp(2)*x;
 NAME:
   climada_nightlight2GDP
 PURPOSE:
   nonlinearly transform night light with second order polynomial
   this function is used within climada_GDP_distribute
 CALLING SEQUENCE:
   [values_out pp] = climada_nightlight2GDP(values_in, pp, check_figure)
 EXAMPLE:
   [values_out pp] = climada_nightlight2GDP(values_in, pp)
 INPUTS:
   values_in   : original night light values (matrix) (values between
                 1 and 63)
   pp          : parameters of second order polynomial function, 
                 y = pp(2)*x^2 + pp(1)*x
 OPTIONAL INPUT PARAMETERS:
   check_figure   : set to 1 to show figure distributed GDP
   check_printplot: set to 1 to save figure
 OUTPUTS:
   values_out  : transformed night light values
   pp          : parameters of second order polynomial function
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20120813
 Lea Mueller, muellele@gmail.com, 20160318, add pp numbers
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_nightlight_nonlinear_transformation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_parameter_string">
<H2>climada_parameter_string</H2></A>
<font color="blue">function pp_str = climada_parameter_string(pp) </font>
 create parameter string from parameters
 NAME:
   climada_parameter_string
 PURPOSE:
   create parameter string from parameters
 CALLING SEQUENCE:
   pp_str = climada_parameter_string(pp)
 EXAMPLE:
   pp_str = climada_parameter_string
 INPUTS:
   pp
 OUTPUTS:
   pp_str
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20141017
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_parameter_string.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_centroids">
<H2>climada_plot_centroids</H2></A>
<font color="blue">function fig = climada_plot_centroids(centroids, country_name, check_printplot, printname) </font>
 plot centroids on a map, differentiate for coastal land areas,
 bufferzone, and further away (more inland and on sea)
 NAME:
   climada_plot_centroids
 PURPOSE:
   plot centroids on a map, differentiate for coastal land areas,
   bufferzone, and further away (more inland and on sea)
   next: diverse
 CALLING SEQUENCE:
   fig = climada_plot_centroids(centroids, country_name, check_printplot, printname)
 EXAMPLE:
   climada_plot_centroids(centroids, country_name)
 INPUTS:
   centroids       : centroids structure
   country_name    : name of the country (cell or string)
   check_printplot : set to 1 to save figure, default 0
   printname       : string for title and for filename if saved
 OUTPUTS:
   fig             : figure handle
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20140205
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_plot_centroids.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_polygon2raster">
<H2>climada_polygon2raster</H2></A>
<font color="blue">function border_mask = climada_polygon2raster(borders, raster_size, save_on) </font>
 create raster (mask with 1 for inside and on polygon, and zeros for
 outside polygon) based on polygon-input for a specific raster size
 NAME:
   climada_polygon2raster
 PURPOSE:
   create raster (mask with 1 for inside and on polygon, and zeros for
   outside polygon) based on polygon-input for a specific raster size
   previous: diverse
   next: diverse
 CALLING SEQUENCE:
   border_mask = climada_polygon2raster(borders, raster_size)
 EXAMPLE:
   border_mask = climada_polygon2raster(borders, raster_size)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   borders     : structure (fields with polygons and names) from climada plot
                 world map
   raster_size : size of requested matrix (e.g. [336 864], 50km
   resolution); [1680 4320], 10km; [168 432], 100km
 OUTPUTS:
  border_mask  : structure with following fields
  .mask        : 243 matrices (for each country) masking 1 for
                 within country and zero for out of country
  .name        : name of all countries
  .world_mask  : world mask (all countries), 1 for land, 0 for sea
  .lon_range   : longitudinal range of masks
  .lat_range   : latitudinal range of masks
  .resolution_x: resolution in x direction in degree
  .resolution_y: resolution in y direction in degree
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20120730
 David N. Bresch, david.bresch@gmail.com, 20141229, revision
 David N. Bresch, david.bresch@gmail.com, 20160222, module_data_dir updated
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_polygon2raster.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_resolution_downscale">
<H2>climada_resolution_downscale</H2></A>
<font color="blue">function [low_resolution_matrix, X, Y, resolution_km] = climada_resolution_downscale(high_resolution_matrix, resolution_km, specification) </font>
 downscale resolution of input matrix to requested resolution in km
 sum up the data, or take the mean, or take the maximum occurence of
 values
 NAME:
   climada_resolution_downscale
 PURPOSE:
   downscale resolution of input matrix to requested resolution in km
   previous: climada_GDP_distribute
   next: diverse
 CALLING SEQUENCE:
   [low_resolution_matrix, X, Y, resolution_km] = climada_resolution_downscale(high_resolution_matrix, resolution_km, specification)
 EXAMPLE:
   [low_resolution_matrix, X, Y, resolution_km] = climada_resolution_downscale
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   high_resolution_matrix: structure mat-file with the following fields
                           e.g. values_distributed
         .values         : distributed values per pixel
         .lon_range      : range of Longitude
         .lat_range      : range of Latitude
         .resolution_x   : resolution in x-direction
         .resolution_y   : resolution in y-direction
   resolution_km         : requested resolution in km, if empty, set to 50km
   specification         : specificy way to determine value for downscaled
                           resolution, sum up all values with keyword 'sum', 
                           take average with keyword 'average', take most 
                           counted value with keyword 'unique', if not
                           given 'sum' is taken
 OUTPUTS:
   low_resolution_matrix : structure with same fields as
                           high_resolution_matrix
         .values         : values per pixel
         .lon_range      : range of Longitude
         .lat_range      : range of Latitude
         .resolution_x   : resolution in x-direction
         .resolution_y   : resolution in y-direction
         .comment        : information 
  X                      : helper matrix containing Longitude information for
                           plotting matrix
  Y                      : helper matrix containing Latitude information for
                           plotting matrix
  resolution_km          : requested resolution in km

 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20120730
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/climada_resolution_downscale.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="inpoly">
<H2>inpoly</H2></A>
<font color="blue">function [cn,on] = inpoly(p,node,edge,TOL) </font>
  INPOLY: Point-in-polygon testing.

 Determine whether a series of points lie within the bounds of a polygon
 in the 2D plane. General non-convex, multiply-connected polygonal
 regions can be handled.

 SHORT SYNTAX:

   in = inpoly(p,node);

   p   : The points to be tested as an Nx2 array [x1 y1; x2 y2; etc].
   node: The vertices of the polygon as an Mx2 array [X1 Y1; X2 Y2; etc].
         The standard syntax assumes that the vertices are specified in
         consecutive order.

   in  : An Nx1 logical array with IN(i) = TRUE if P(i,:) lies within the
         region.

 LONG SYNTAX:

  [in,on] = inpoly(p,node,edge);

  edge: An Mx2 array of polygon edges, specified as connections between
        the vertices in NODE: [n1 n2; n3 n4; etc]. The vertices in NODE
        do not need to be specified in connsecutive order when using the
        extended syntax.

  on  : An Nx1 logical array with ON(i) = TRUE if P(i,:) lies on a
        polygon edge. (A tolerance is used to deal with numerical
        precision, so that points within a distance of
        eps^0.8*norm(node(:),inf) from a polygon edge are considered &quoton&quot
        the edge.

 EXAMPLE:

   polydemo;       % Will run a few examples

 See also INPOLYGON

 The algorithm is based on the crossing number test, which counts the
 number of times a line that extends from each point past the right-most
 region of the polygon intersects with a polygon edge. Points with odd
 counts are inside. A simple implementation of this method requires each
 wall intersection be checked for each point, resulting in an O(N*M)
 operation count.

 This implementation does better in 2 ways:

   1. The test points are sorted by y-value and a binary search is used to
      find the first point in the list that has a chance of intersecting
      with a given wall. The sorted list is also used to determine when we
      have reached the last point in the list that has a chance of
      intersection. This means that in general only a small portion of
      points are checked for each wall, rather than the whole set.

   2. The intersection test is simplified by first checking against the
      bounding box for a given wall segment. Checking against the bbox is
      an inexpensive alternative to the full intersection test and allows
      us to take a number of shortcuts, minimising the number of times the
      full test needs to be done.

   Darren Engwirda: 2005-2007
   Email          : d_engwirda@hotmail.com
   Last updated   : 23/11/2007 with MATLAB 7.0

 Problems or suggestions? Email me.
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/GDP_entity/inpoly.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_risk_EDS2YDS">
<H2>country_risk_EDS2YDS</H2></A>
<font color="blue">function country_risk=country_risk_EDS2YDS(country_risk) </font>
 climada country risk
 MODULE:
   country_risk
 NAME:
   country_risk_EDS2YDS
 PURPOSE:
   Convert event damage sets (EDS) to year damage sets (YDS) where
   appropriate (currently TC, TS and TR, see climada_EDS2YDS, where
   this is determined).

   Works properly with both country_risk_calc and
   country_admin1_risk_calc output

   Makes most sense of country_risk_EDS_combine has been applied to the
   country_risk rsult structure before

   prior call: country_risk_EDS_combine
 CALLING SEQUENCE:
   res=country_risk_EDS2YDS(country_risk)
 EXAMPLE:
   res=country_risk_EDS2YDS(country_risk)
 INPUTS:
   country_risk: a structure as returned by country_risk_calc
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   country_risk: a structure as returned by country_risk_calc, EDSs
   converted into YDSs where appropriate
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150116, initial (TC, TS, TR)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/country_risk_EDS2YDS.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_risk_EDS_combine">
<H2>country_risk_EDS_combine</H2></A>
<font color="blue">function [country_risk,EDC]=country_risk_EDS_combine(country_risk) </font>
 climada country risk
 MODULE:
   country_risk
 NAME:
   country_risk_EDS_combine
 PURPOSE:
   Combine sub-hazards TC and TS in country_risk result structure
   does NOT combine TR (rain). See output EDC for maximally combined EDS.

   Works properly with both country_risk_calc and
   country_admin1_risk_calc output

   Note assumes the TS EDS directly follows the TC EDS, does not search all EDSs
   for matching ones, just: if TC, check whether next EDS is TC (and same
   ocean basin, obviously), then combine.

   prior call: country_risk_calc
 CALLING SEQUENCE:
   res=country_risk_EDS_combine(country_risk)
 EXAMPLE:
   res=country_risk_EDS_combine(country_risk)
 INPUTS:
   country_risk: a structure as returned by country_risk_calc
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   country_risk: the same structure as returned by country_risk_calc,
       with TC and TS combined
   EDC: the maximally combined EDS, the event damage collector
       i.e. only one fully combined EDS per hazard and region (i.e. on for
       all TC atl, EQ glb...). Only assumption: the summation happens over
       EDS.damage of exact same length, i.e. should two perils (and
       regions) have exactly the same number of events, the code sums them
       up, as long as the peril_ID(1) match (it does never sum up EQ and
       TC, as E and T are different, but would sum up TC atl and TC epa
       should both basin hazard event sets have the same number of events.
       Therefore, inspect the EDC(i).EDS.annotation_name carefully, it is
       the cllection of all annotation names.
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150114, initial (only TC and TS)
 David N. Bresch, david.bresch@gmail.com, 20150203, maximally combined EDS
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/country_risk_EDS_combine.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_DFC_plot">
<H2>cr_DFC_plot</H2></A>
<font color="blue">function cr_DFC_plot(country_risk,country_i,hazard_i,CAGR,show_plot) </font>
 climada template
 MODULE:
   country_risk
 NAME:
   cr_DFC_plot
 PURPOSE:
   Plot the country damage frequency curves (DFC)

   Note that the countries and perils selected in EM-DAT are written to
   stdout for check (as a country might have no EM-DAT data and hence
   comparison with EM-DAT might be misleading - as it should anyway be
   taken with a pinch of salt...)

   Previous call: country_risk_calc or country_risk_EDS_combine
   See also: cr_DFC_plot_aggregate (aggregate results for peril regions)
 CALLING SEQUENCE:
   cr_DFC_plot(country_risk,country_i,hazard_i,CAGR,show_plot)
 EXAMPLE:
   % let's assume country_risk_calc has been run for this list with
   % method=-3 (create hazard event sets) already, then:
   country_list={'Colombia','Costa Rica','Dominican Republic'};
   country_risk=country_risk_calc(country_list,-7,0,0,['atl_TC';'atl_TS']); % calc EDS
   [country_risk,EDC]=country_risk_EDS_combine(country_risk); % combine TC and TS and calculate EDC
   cr_DFC_plot(country_risk)
   cr_DFC_plot(country_risk,1,2,[],1) % 1st country, 2nd hazard only
 INPUTS:
   country_risk: the output of country_risk_EDS_combine, see there
       note that country_risk_EDS_combine is just called after
       country_risk_calc to combine sub-peril EDSs. Present code runs also
       if country_risk_EDS_combine has not been called, but then shows
       e.g. TC and TS separately.
 OPTIONAL INPUT PARAMETERS:
   country_i: the country index (as shown when first run) to only show one
       country (usefule in the country damagefunction calibration process)
   hazard_i: the hazard index (as shown when first run) to only show one
       hazard (usefule in the country damagefunction calibration process)
   CAGR: the compound annual growth rate to inflate historic EM-DAT
       damages with, if empty, the default value is used (climada_global.global_CAGR)
   show_plot: =1 (default) show the plot, 0= just create and save the plot
 OUTPUTS:
   plot, as figure and stored to .../results/cr_results/{region}{peril}_aggregate
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150213, intial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_DFC_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_DFC_plot_aggregate">
<H2>cr_DFC_plot_aggregate</H2></A>
<font color="blue">function cr_DFC_plot_aggregate(country_risk,EDC,CAGR,show_plot) </font>
 climada template
 MODULE:
   country_risk
 NAME:
   cr_DFC_plot_aggregate
 PURPOSE:
   Plot the combined global damage frequency curve (DFC) and the annual
   aggregate DFC 

   Note that the countries and perils selected in EM-DAT are written to
   stdout for check (as a country might have no EM-DAT data and hence
   comparison with EM-DAT might be misleading - as it should anyway be
   taken with a pinch of salt...)

   Previous call: country_risk_calc or country_risk_EDS_combine
   See also: cr_DFC_plot (country instead of aggrgate results)
 CALLING SEQUENCE:
   cr_DFC_plot_aggregate(country_risk,EDC,CAGR,show_plot)
 EXAMPLE:
   % let's assume country_risk_calc has been run for this list with
   % method=-3 (create hazard event sets) already, then:
   country_list={'Colombia','Costa Rica','Dominican Republic'};
   country_risk=country_risk_calc(country_list,-7,0,0,['atl_TC';'atl_TS']); % calc EDS
   [country_risk,EDC]=country_risk_EDS_combine(country_risk); % combine TC and TS and calculate EDC
   cr_DFC_plot_aggregate(country_risk,EDC)
 INPUTS:
   country_risk: the output of country_risk_calc or country_risk_EDS_combine.
       Note that country_risk_EDS_combine is just called after
       country_risk_calc to combine sub-peril EDSs and to produce the EDC,
       the maximally combined EDS (i.e. one global EDS per peril and
       region). If you do not provide the EDC (2nd parameter),
       cr_DFC_plot_aggregate does in fact call country_risk_EDS_combine
       itself.
 OPTIONAL INPUT PARAMETERS:
   EDC: the output of country_risk_EDS_combine, see there. If empty, the
       code runs country_risk_EDS_combine to obtain it.
   CAGR: the compound annual growth rate to inflate historic EM-DAT
       damages with, if empty, the default value is used (climada_global.global_CAGR)
   show_plot: =1 (default) show the plot, 0= just create and save the plot
 OUTPUTS:
   plot, as figure and stored to .../results/cr_results/{region}{peril}_aggregate
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150213, intial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_DFC_plot_aggregate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_EDS_emdat_adjust">
<H2>cr_EDS_emdat_adjust</H2></A>
<font color="blue">function [EDS,climada2emdat_factor_weighted,em_data]=cr_EDS_emdat_adjust(EDS,verbose_mode) </font>
 climada template
 MODULE:
   country_risk
 NAME:
   cr_EDS_emdat_adjust
 PURPOSE:
   Given an event damge set (EDS), adjust results to best match EM-DAT
   damage history of a given country for a given peril, see also
   emdat_read (the raw damage from EM-DAT is scaled up for growth...)

   previous call: climada_EDS_calc and country_risk_calc
   See also: emdat_read and cr_plot_DFC
 CALLING SEQUENCE:
   [EDS,climada2emdat_factor_weighted]=cr_EDS_emdat_adjust(EDS,verbose_mode)
 EXAMPLE:
   EDS=cr_EDS_emdat_adjust(climada_EDS_calc)
 INPUTS:
   EDS: an event damge set (EDS), as calculated by climada_EDS_calc
       Only one EDS supported, e.g. use EDS(i) as input if EDS is an array
       of structs
 OPTIONAL INPUT PARAMETERS:
   verbose_mode: if =1, print list of countries and disaster subtypes that
       are returned from EM-DAT. 
       =2: also plot the damage frequency curve (DFC) before and after
       adjustment as well as the EM-DAT information
       Default=0 (silent)
 OUTPUTS:
   EDS: the adjusted EDS
   climada2emdat_factor_weighted: the weighted adjustment factor (i.e.
       EDS.damage output = EDS.damage input * climada2emdat_factor_weighted
   em_data: the EM-DAT data as used to adjust
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150127, initial
 David N. Bresch, david.bresch@gmail.com, 20150202, em_data as output
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_EDS_emdat_adjust.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_checksum">
<H2>cr_checksum</H2></A>
<font color="blue">function cr_checksum(country_name,peril_ID,report_fid) </font>
 climada template
 MODULE:
   country_risk
 NAME:
   cr_checksum
 PURPOSE:
   Calculate a checksum for entity, damage functions (the ones with ID 1)
   and hazard sets

   See also country_risk_calc
 CALLING SEQUENCE:
   cr_checksum(country_name,peril_ID)
 EXAMPLE:
   cr_checksum('Australia','TC')
   cr_checksum({'Australia','China'},'TC')
   country_list={'Japan','New Zealand','Belgium','Taiwan','Mexico','Italy','Philippines'};
   cr_checksum(country_list)
 INPUTS:
   country_name: a single country name (output to stdout) or a list of
       countries (output to file ../results/cr_checksum.csv). If ='ALL',
       run for all countries.
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   peril_ID: the peril_ID we check for
       currently aborts if no ID provided, future implementations will
       loop over perils
   report_fid: INTERNAL, to pass on the fid of the report file
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150429, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_checksum.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_country_DFC_sensitivity">
<H2>cr_country_DFC_sensitivity</H2></A>
<font color="blue">function cr_country_DFC_sensitivity(country_ISO3,show_plot,probabilistic,damagefunctions,peril_ID,peril_region) </font>
 generate damagefunction sensitivity plots of all hazards affecting a 
 given country
 MODULE:
   country_risk
 NAME:
   cr_country_DFC_sensitivity
 PURPOSE:
   For a given country (defined by its ISO3 code), generate 
   &quotdamagefunction sensitivity plots&quot (i.e., DFCs resulting from modifying 
   an entity's original damagefunctions in different ways) of all 
   available hazards and store them in a folder 
   &quotdamagefun_sensitivity_plots&quot in climada-master/data/results

   see cr_damagefunction_sensitivity for more information on how the
   damagefunctions are modified. The present code
   cr_country_DFC_sensitivity is a mere caller to cr_damagefunction_sensitivity

   For the generation of entities and hazards in one single function, see 
   country_risk_calc (in the module country_risk), which creates hazard 
   sets and an entity for a given country before it runs the risk 
   calculations. For automatic comparison of a series of countries in one
   hazard region, see selected_countries_region_peril
   
 CALLING SEQUENCE:
   cr_country_DFC_sensitivity(country_ISO3,show_plot,probabilistic,damagefunctions,peril_ID,peril_region)
 EXAMPLE:
   cr_country_DFC_sensitivity('CHN', 1) % country: China, don't show plots
 INPUTS:
   country_ISO3: ISO3 code of a country (see climada_country_name for
   valid ISO3 codes)
 OPTIONAL INPUT PARAMETERS:
   show_plot: only save the plots (=0; default), or show and save the 
       plots (=1)
   probabilistic: whether to use the probabilistic hazard sets (=1, default) 
       or the historic ones (=0)
   damagefunctions: a struct containing the damagefunctions (for one
       single peril) to overwrite the entity's damagefunctions with. See
       e.g. climada_damagefunctions_read. Replaces entity.damagefunctiuons 
       without any further tests. The user is responsible for not messing
       up, i.e. for entity.assets.DamageFunID to point to the right damage
       function, damagefunctions.peril_ID to be consistent with e.g. input
       parameter peril_ID etc.
   peril_ID: 2-digit peril ID, like 'TC','TS','TR','WS','EQ',... 
       If not provided, the peril for which the first damagefunction with
       DamageFunID =1 exists is used.
   peril_region: e.g. 'wpa' or 'atl', allows for selection of a
       specific region. If not provided, no selection of peril region,
       i.e. a country affected by tropical cyclones from two basins (such
       as El Salvador with atl and epa) is treated twice.
 OUTPUTS:
   plots of a set of DFCs (generated using different damagefunctions) for
   all perils affecting the given country (or for one specific peril, if a
   peril-specific damagefunctions struct is passed as input)
 NOTE 1:
   TR hazard sets are currently not considered since there is no
   damagefunctions implemented for that peril yet.
 NOTE 2:
   In the current implementation, a peril_ID can only be selected
   implicitly, i.e. by giving the function a peril-specific
   damagefunctions struct. One might consider adding peril_ID also as a
   separate input argument, such that a specific peril can be chosen
   without having to pass a damagefunctions struct to the function
 NOTE 3:
   This is a preliminary version that might need some clean-up /
   optimization

 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150206, initial
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150209, added damagefunctions and peril_region
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150209, simplified to one peril (and one region)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_country_DFC_sensitivity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_country_hazard_test">
<H2>cr_country_hazard_test</H2></A>
<font color="blue">function country_risk=cr_country_hazard_test(country_risk,country_i,hazard_i,CAGR,show_plot) </font>
 climada country risk calibrate test damage function
 MODULE:
   module name
 NAME:
   cr_country_hazard_test
 PURPOSE:
   Given a country_risk results structure, experiment with one country and
   hazard to test different damage function settings etc.

   This code is MOST LIKELY to be edited by the user, i.e. to set
   damagefunction parameters etc. It provides merely a TESTBED for
   efficient calibration of country results.

   Process:
   - Run country_risk_calc for either one or a set of countries. A set makes
     particularly sense for e.g. a peril region, such as TC atl, in order to
     ensure (neighbouring) countries in that region have similar
     damagefunction settings. Hence you might e.g. run
     &ampgt&ampgt country_list={'Colombia','Costa Rica','Dominican Republic','United States'};
     &ampgt&ampgt country_risk=country_risk_calc(country_list,-7,0,0,['atl_TC';'atl_TS']);
   - call cr_DFC_plot to get a first overview by country, e.g.
     &ampgt&ampgt cr_DFC_plot(country_risk)
   - call cr_DFC_plot_aggregate to get a first overview or the combined
     results of all countries, e.g.
     &ampgt&ampgt cr_DFC_plot_aggregate(country_risk) % does combine EDSs himself
     Note that especially the comparison with EM-DAT makes only sense for
     either larger countries or a group of smaller ones - otherwise it
     might be too much due to chance whether a country got hit in the past
     years or not.
   - Now, call cr_country_hazard_test to test different damagefunction
     settings (or modifications) for one country and peril, e.g.
     country_risk=cr_country_hazard_test(country_risk,2,1) % 'Costa Rica','TC'
     and occasionally call cr_DFC_plot_aggregate(country_risk) to show the
     aggregate result. Note that cr_DFC_plot_aggregate does the
     aggregation itself.
     In case you'd like to experiment only with TC, but want to compare TC
     and TS combined, proceed as follows (say hazard 1 is TC, hazard 2 TS)
     &ampgt&ampgt country_risk=cr_country_hazard_test(country_risk,2,1)
     &ampgt&ampgt [country_risk_agg,EDC]=country_risk_EDS_combine(country_risk);
     &ampgt&ampgt cr_DFC_plot(country_risk_agg,1,1)

   How to use: make your copy of the present code (name it e.g.
   cr_country_hazard_mytest) and experiment with different damage function
   settings for a given country and region (group of countries). In
   special cases, you might also consider adjusting hazard event sets.

   Next step: put your final adjustments in country_risk_calibrate
 CALLING SEQUENCE:
   country_risk=cr_country_hazard_test(country_risk,country_i,hazard_i,CAGR,show_plot)
 EXAMPLE:
   country_risk=cr_country_hazard_test(country_risk,2,1) % 2nd country, 1st haazrd
 INPUTS:
   country_risk: the output of country_risk_calc (NOT of
       country_risk_EDS_combine, as this would result in empty EDSs for
       e.g. TS).
   country_i: the country index (as shown when first run) to only show one
       country (usefule in the country damagefunction calibration process)
       Default=1 (hence the user will usually specify)
   hazard_i: the hazard index (as shown when first run) to only show one
       hazard (usefule in the country damagefunction calibration process)
       Default=1 (hence the user will usually specify)
 OPTIONAL INPUT PARAMETERS:
   CAGR: the compound annual growth rate to inflate historic EM-DAT
       damages with, if empty, the default value is used (climada_global.global_CAGR)
   show_plot: =1 (default) show the plot, 0= just create and save the plot
       =2: show not only the single DFC plot for the country, but also
       call cr_DFC_plot_aggregate
       If show_plot is negative, first delete all existing figures.
 OUTPUTS:
   country_risk: the country_risk structure with the results for country_i
       and hazard_i updated
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150213, initial
 David N. Bresch, david.bresch@gmail.com, 20150906, no change, as the user anyway needs to edit lines....
 Lea Mueller, muellele@gmail.com, 20160212, rename to climada_damagefunctionS_generate instead of without s
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_country_hazard_test.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_damage_as_percentage_of_GDP">
<H2>cr_damage_as_percentage_of_GDP</H2></A>
 create waterfall graphs and calculate damage as percentage of GDP
 for two example countries Dominican Republic and USA
 set time span
limada_global.present_reference_year = 2015;
imespan = climada_global.future_reference_year - climada_global.present_reference_year;
limada_global.font_scale = 1.3;
 -----Dom Rep-------------
nnual_eco_growth = 0.0458;
entity, entity_future, DFC, DFC_eco, DFC_cc] = country_risk_waterfall('Dominican Republic',annual_eco_growth);
DP = 6.116*10^10;
DP_future = GDP*(1+annual_eco_growth)^timespan;
printf('- Factor total assets/GDP: %2.2f\n',sum(entity.assets.Value)/GDP)
printf('- Factor assets future/today: %2.3f\n',sum(entity_future.assets.Value)/sum(entity.assets.Value))
printf('- Factor damage future/today: %2.3f\n',DFC_eco.damage/DFC.damage)
printf('\n')
printf('- Today''s damage as percentage of GDP (%d): %2.1f %%\n',2014,DFC.damage/GDP*100)
printf('- Eco damage as percentage of GDP (%d): %2.1f %%\n',climada_global.future_reference_year,DFC_eco.damage/GDP_future*100)
printf('- Cc damage as percentage of GDP (%d): %2.1f %%\n',climada_global.future_reference_year,DFC_cc.damage/GDP_future*100)
printf('\n')
printf('- Cc damage absolute increase: %2.1f %%\n', (DFC_cc.damage-DFC_eco.damage)/GDP_future*100);
printf('- Cc damage percentage increase: %2.1f %%\n', (DFC_cc.damage-DFC_eco.damage)/DFC_eco.damage*100);
 ------USA--------------
nnual_eco_growth = 0.022;
entity, entity_future, DFC, DFC_eco, DFC_cc] = country_risk_waterfall('USA',annual_eco_growth);
DP = 1.667*10^13;
DP_future = GDP*(1+annual_eco_growth)^timespan;
printf('- Factor total assets/GDP: %2.2f\n',sum(entity.assets.Value)/GDP)
printf('- Factor assets future/today: %2.3f\n',sum(entity_future.assets.Value)/sum(entity.assets.Value))
printf('- Factor damage future/today: %2.3f\n',DFC_eco.damage/DFC.damage)
printf('\n')
printf('- Today''s damage as percentage of GDP (%d): %2.1f %%\n',2014,DFC.damage/GDP*100)
printf('- Eco damage as percentage of GDP (%d): %2.1f %%\n',climada_global.future_reference_year,DFC_eco.damage/GDP_future*100)
printf('- Cc damage as percentage of GDP (%d): %2.1f %%\n',climada_global.future_reference_year,DFC_cc.damage/GDP_future*100)
printf('\n')
printf('- Cc damage absolute increase: %2.1f %%\n', (DFC_cc.damage-DFC_eco.damage)/GDP_future*100);
printf('- Cc damage percentage increase: %2.1f %%\n', (DFC_cc.damage-DFC_eco.damage)/DFC_eco.damage*100);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_damage_as_percentage_of_GDP.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_damagefunction_adjust">
<H2>cr_damagefunction_adjust</H2></A>
<font color="blue">function entity_adjusted = cr_damagefunction_adjust(entity) </font>
 adjust the data points describing the damage function 
 MODULE:
   country_risk
 NAME:
   cr_damagefunction_adjust
 PURPOSE:
   Adjust the data points describing the damage function by multiplying
   them with country-specific factors that are based on expert judgment. 
   The resulting damage function provides the basis for the final climada 
   model results of a country's expected losses over the return period(s) 
   one is interested in.
 CALLING SEQUENCE:
   entity_adjusted = cr_damagefunction_adjust(entity)
 EXAMPLE:
   entity_Australia_adjusted = cr_damagefunction_adjust(entity_Australia)
 INPUTS:
   entity: a climada entity with the fields 
       - assets
       - damagefunctions
       - measures
       - discount
   to generate an entity, see climada_nightlight_entity (in the module 
   country_risk) or climada_create_GDP_entity (in the module GDP_entity)
 OPTIONAL INPUT PARAMETERS:

 OUTPUTS:
   entity_adjusted: entity with adjusted damagefunction; contains the
   fields
       - assets
       - damagefunctions
       - measures
       - discount
       - damagefunctions_adjusted (=1; flag to show that the
       damagefunctions of that entity have been adjusted)
       - damagefunctions_orig (original/unadjusted damage functions for
       reference)
   Also, damagefunctions_adjusted contains a further field 
   'adjustment_factor_table', which contains the information on the 
   adjustment factors for that country and all perils.
   
   The field 'MDR' is removed in entity_adjusted (if it existed in the 
   input entity)

 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150202, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_damagefunction_adjust.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_damagefunction_sensitivity">
<H2>cr_damagefunction_sensitivity</H2></A>
<font color="blue">function entity_out=cr_damagefunction_sensitivity(entity,hazard,selection_i,show_plot,peril_region) </font>
 explore the DFCs' sensitivity to underlying damagefunctions
 MODULE:
   country_risk
 NAME:
   cr_damagefunction_sensitivity
 PURPOSE:
   Given an entity and a hazard, generate different event damage sets
   (EDSs) by varying the underlying damagefunctions. Plot the
   resulting damage frequency curves (DFCs) together with the two DFCs
   (indexed and original) that stem from the historic event set of the
   international disaster database EM-DAT (www.emdat.be).

   The plot then allows to determine by eye which of the damagefunctions
   used to calculate the DFCs produces the best fit to the EM-DAT data.

   If the function is given a specific selection of a damagefunction
   (selection_i), the damagefunctions in the input entity gets overwritten
   with that selected damagefunction. The default value for selection_i is
   1, which refers to the original damagefunction, such that in that case
   the entity's damagefunction is left unchanged.
   However, there is one change that applies to all input entities: If an
   entity contains a field 'MDR' (Mean Damage Ratio), this field is
   removed because it is not needed in any damage calculation in CLIMADA.

   For the generation of entities and hazards in one single function, see
   country_risk_calc (in the module country_risk), which creates hazard
   sets and an entity for a given country before it runs the risk
   calculations. For automatic comparison of a series of countries in one
   hazard region, see selected_countries_region_peril

 CALLING SEQUENCE:
   entity_out=cr_damagefunction_sensitivity(entity,hazard,selection_i,show_plot,peril_region)
 EXAMPLE:
   entity_out=cr_damagefunction_sensitivity(entity,hazard,4)
   overwrites the damagefunctions of the entity with damagefunction 4
 INPUTS:
   entity: a climada entity with the fields
       - assets
       - damagefunctions
       - measures
       - discount
       to generate an entity, see climada_nightlight_entity (in the module
       country_risk) or climada_create_GDP_entity (in the module GDP_entity)
   hazard: a climada hazard event set structure, see e.g.
        climada_tc_hazard_set
 OPTIONAL INPUT PARAMETERS:
   selection_i: selection of the damagefunction to overwrite the entity's
       damagefunction with
       1: original damagefunctions, entity is left unchanged (=default)
       2: shift to the right by 15% of max intensity
       3: shift to the left by 15% of max intensity
       4: [...]
       etc. (this is only a preliminary version of the function, further
       selections will be added later. See section 'implement
       damagefunction modifications here' in this code for the
       currently implemented damagefunctions)
   show_plot: only save the plot (=0), or show and save the plots (=1,default)
   peril_region: the peril region (only used to label the plot, such as
       'atl' or 'glb'), Default=''
   SPECIAL: if there is a file ../results/target_DFC.xls wth columns
       country, perilID, return period and damage, the matching country and
       peril DFC will be plotted for reference (i.e. to help calibrate climada
       to any given (other model) results (see target_DFC_file in PARAMETERS)
 OUTPUTS:
   entity_out: entity with the damagefunction selection_i refers to
       (default for selection_i is 1, i.e. entity_out is the same as the
       original entity).
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150203, initial
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150206, added show_plot
 David N. Bresch, david.bresch@gmail.com, 20150210, peril_region added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_damagefunction_sensitivity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_economic_loss_calc">
<H2>cr_economic_loss_calc</H2></A>
<font color="blue">function country_risk_economic_loss = cr_economic_loss_calc(country_risk,economic_data_file) </font>
 MODULE:
   country_risk
 NAME:
   cr_economic_loss_calc
 PURPOSE:
   Calculate the economic loss, i.e. the impact of a natural disaster on a
   country's economy
   method: Starting point for the economic loss calculation is 
   damage(event_i), i.e. the damage calculated by climada_EDS_calc. 
   The economic loss caused by the natural disaster is then calculated
   according to:
   economic_loss(event_i) = damage(event_i)*loss_multiplier
   with
   loss_multiplier = 
   1 + cr_get_damage_weight(damage(event_i)/GDP) * country_damage_factor
       with 
           cr_get_damage_weight: function that determines how much weight a
           damage should be given based on its ratio to GDP
           country_damage_factor = (1/financial_strength +
           BI_and_supply_chain_risk + natural_hazard_economic_exposure 
           - disaster_resilience)
           Hence, country_damage_factor consists of four terms: 
               - financial_strength measures a country's economic health and
               ability to finance the recovery
               - BI_and_supply_chain_risk measures a country's risk of
               disaster-related business and supply chain interruption
               - natural_hazard_economic_exposure assesses which countries 
               have a concentration of their total economic output exposed to 
               natural hazards
               - disaster_resilience measures the quality of a country's 
               natural hazard risk management, i.e., the country's 
               &quotpreparedness&quot to deal with the consequences of a disaster 
   See economic_indicators_mastertable.xls (in climada/data/system for 
   more information on the components of country_damage_factor
 PREVIOUS STEP:
   country_risk = country_risk_calc('country_i')
 CALLING SEQUENCE:
   country_risk_economic_loss = cr_economic_loss_calc(country_risk)
 EXAMPLE:
   country_risk_economic_loss =
   cr_economic_loss_calc(country_risk_Switzerland)
 INPUT:
   country_risk: A struct generated by country_risk_calc
   containing the fields
       peril_ID:       ID(s) of the peril(s) the country is exposed to
       raw_data_file:  the file used to generste the event set
       hazard_set_file:file with the stored hazard
       EDS:            event damage set(s) for the peril(s) 
   country_risk can contain information on a single country or on multiple
   countries
 OPTIONAL INPUT: 
   economic_data_file: the filename of the excel file with the raw data
       (country-specific economic and resilience data used to calculate the
       economic loss)
       If empty, the code uses the default table as provied with core
       climada, should it not exist, it prompts the user to locate the file 
 OUTPUT:
 	country_risk_economic_loss: The same struct as the input, but
 	country_risk.res.hazard.EDS.damage has been replaced by
 	country_risk.res.hazard.EDS.economic_loss (for all countries and 
   perils in country_risk)

 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141229, initial
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150105, compatibility with multiple country input
 David N. Bresch, david.bresch@gmail.com, 20150203, economic_indicators_mastertable part of core climada
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150210, economic_indicators_mastertable: extended and standard version

 TO DO: Modify the function such that it can also handle hazard event sets
 that have been generated by functions other than country_risk_calc, e.g.,
 by eq_global_hazard_set or climada_tc_hazard_set
 ANSWER: for the time being, running this afer country_risk_calc is OK.
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_economic_loss_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_get_damage_weight">
<H2>cr_get_damage_weight</H2></A>
<font color="blue">function damage_weight = cr_get_damage_weight(damage_per_GDP) </font>
 MODULE:
   country_risk
 NAME:
   cr_get_damage_weight
 PURPOSE:
   Get the weight of a specific damage caused by a natural hazard, i.e.,
   the factor it will be multiplied with in the calculation of the
   economic loss caused by that event (see
   climada_calculate_economic_loss). 
   The underlying assumption is that damages up to a certain threshold
   (defined in terms of damage per GDP) do not affect a country's national
   economy, but the bigger the damage, the more importance/weight is given
   to the country's socioeconomic strength and preparedness for disasters
   (as indicated by the country_damage_factor calculated in 
   climada_calculate_economic_loss).
 CALLING SEQUENCE:
   damage_weight = cr_get_damage_weight(damage_per_GDP)
 EXAMPLE:
   damage_weight = cr_get_damage_weight(0.02)
 INPUT:
   damage_per_GDP: the ratio of the damage caused by a specific event to
   the GDP of the country where the event occurred
 OUTPUT:
   damage_weight: The weighting factor for the input damage per GDP
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch 20150101, initial
 set parameters
amage_threshold=0.0001; % below this threshold, damage_weight is set to zero 
amage_size_exp=1.3; % &ampgt1: concave, &amplt1 convex, 1: linear
caling_factor=1;
 calculate damage_weight
amage_weight=scaling_factor*(min(max(damage_per_GDP-damage_threshold,0).^(damage_size_exp)...
   /((1-damage_threshold)^damage_size_exp),1));
plot(damage,damage_weight)
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_get_damage_weight.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_hazard_clim_scen">
<H2>cr_hazard_clim_scen</H2></A>
<font color="blue">function ok = cr_hazard_clim_scen(country_name,peril_ID,force_recalc) </font>
 climada
 MODULE:
   country_risk
 NAME:
   cr_hazard_clim_scen
 PURPOSE:
   create climate change hazards for 2050
   load existing hazards and modify based on TC, TS and basin

   to be called in selected_countries_all_in_one
 CALLING SEQUENCE:
   country_risk =country_risk_calc(country_name,method,force_recalc,check_plots,peril_ID)
 EXAMPLE:
   country_risk0=country_risk_calc('CHE',1,0); % 10x10km resolution for
 INPUTS:
   country_name: name of the country, like 'Switzerland', or a list of
       countries, like {'Switzerland','Germany','France'}. See
       climada_check_country_name for the list of valid country names
       If set to 'ALL', the code runs recursively through ALL countries
       (mind the time this will take...)
       &ampgt prompted for via dropdown list if empty (allows for single or
       multiple country selection)
 OPTIONAL INPUT PARAMETERS:
   peril_ID: 'TS' or 'TC', or both. If empty, all perils (TC and TS) will 
       be modified
   force_recalc: if set to 1 recalcs hazards even if they already exist,
       default 0
 OUTPUTS:
   creates climate change hazard files and saves them in the hazard
   directory. Additionally creates a diary file to save output from
   command window in the hazard directoy.
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151020, initial
 Lea Mueller, muellele@gmail.com, 20151022, bugfix mixed up intensity and frequency screw
 Lea Mueller, muellele@gmail.com, 20151023, add basin epa
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_hazard_clim_scen.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_hazard_comparison">
<H2>cr_hazard_comparison</H2></A>
<font color="blue">function res=cr_hazard_comparison(cmp_folder,cmp_file_regexp,scale_value_flag,reference_RP) </font>
 cr_hazard_comparison
 MODULE:
   module name
 NAME:
   cr_hazard_comparison
 PURPOSE:
   Model comparison (cmp) for countries and hazards

   Loops over damage frequency curve (DFC) files (see climada_DFC_read),
   indentifies the matching climada entity and hazard event set and shows
   the DFCs for comparison (and any other further use).

   See e.g. climada_DFC_comparison for further scrutiny
 CALLING SEQUENCE:
   cr_hazard_comparison(cmp_folder)
 EXAMPLE:
   cr_hazard_comparison
   cr_hazard_comparison('','*.xlsx',0); % no scaling
 INPUTS:
   cmp_folder: folder with model comparison files, i.e. DFC files with
       names III_name_rrr_PP_cmp_results with III ISO3, name country name,
       rrr the peril PP region (e.g. CHE_Switzerland_glb_EQ_cmp_results)
       &ampgt prompted for folder if not given
 OPTIONAL INPUT PARAMETERS:
   cmp_file_regexp: the regexp to find the comparison files in cmp_folder
       Default=['*' climada_global.spreadsheet_ext] (hence e.g. '*.xls')
       This way, one can also restrict files such as '*_latest.xlsx'
   scale_value_flag: =1: scale value of climada (and damages) to cmp value
       (default), =0 keep values and do not scale damages.
   reference_RP: the (few) reference return periods we report values in
       res (the output). Default: reference_RP=[100 200]. Values have to
       be return period the cmp results exist for (no interpolation).
 OUTPUTS:
   res: a struct with
       file_name: the comparison filename
       admin0_ISO3: the country ISO3 (if in entity)
       admin0_name: the country name (if in entity)
       DFC.value: the value 'underlying' the climada DFC
       DFC_cmp.value: the value 'underlying' the comparison DFC
       return_period(i): the return periods (as in reference_RP)
       DFC.damage(i): the climada damage for return_period(i)
       DFC_cmp.damage(i): the comparison damage for return_period(i)
   Plus the DFC plots and writes a small report to
       'cr_hazard_comparison.csv'
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150120, initial
 David N. Bresch, david.bresch@gmail.com, 20150122, scale_value_flag
 David N. Bresch, david.bresch@gmail.com, 20150126, ED also reported
 David N. Bresch, david.bresch@gmail.com, 20150126, renamed to cr_hazard_comparison (formerly country_hazard_comparison)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_hazard_comparison.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_loss_multiplier_plot">
<H2>cr_loss_multiplier_plot</H2></A>
<font color="blue">function country_ec_damage = cr_loss_multiplier_plot(country_names,economic_data_file) </font>
 plot the loss multiplier
 MODULE:
 country_risk
 climada template
 NAME:
   cr_loss_multiplier_plot
 PURPOSE:
   Plot the loss multiplier which is defined by:
   loss_multiplier = 1+cr_get_damage_weight(damage/GDP) * country_damage_factor; 
   see documentation climada_module_country_risk.docx for details on the 
   calculation of the loss multiplier)
 CALLING SEQUENCE:
   country_ec_damage = cr_loss_multiplier_plot(country_names,economic_data_file)
 EXAMPLE:
   country_ec_damage = cr_loss_multiplier_plot({'El Salvador','Austria'})
 INPUT:
   country_names: name of the country, like 'Switzerland', or a list of
       countries, like {'Switzerland','Germany','France'}. See
       climada_check_country_name for the list of valid country names
 OPTIONAL INPUT PARAMETERS:
   economic_data_file: the filename of the excel file with the raw data
   (country-specific economic and resilience data used to calculate the
   economic loss)
   if empty, the code tries a default name, if it does not exist, it
   prompts the user to locate the file
 OUTPUTS
   a plot showing how the loss multiplier depends on damage per GDP
   country_damage_factors: A struct wih the following fields:
       country_ec_damage.Country           country name
       country_ec_damage.ISO3              ISO3 code 
       country_ec_damage.damage_factor     country damage factor
       country_ec_damage.financial_strength financial strength
       country_ec_damage.BI_risk           BI_and_supply_chain_risk
       country_ec_damage.ec_exposure       natural_hazard_economic_exposure
       country_ec_damage.resilience        disaster_resilience
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150109, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/country_risk/code/helper_functions/cr_loss_multiplier_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="diana">
<H2>diana</H2></A>
<font color="blue">function varargout = diana(varargin) </font>
 DIANA MATLAB code for diana.fig
      DIANA, by itself, creates a new DIANA or raises the existing
      singleton*.

      H = DIANA returns the handle to a new DIANA or the handle to
      the existing singleton*.

      DIANA('CALLBACK',hObject,eventData,handles,...) calls the local
      function named CALLBACK in DIANA.M with the given input arguments.

      DIANA('Property','Value',...) creates a new DIANA or raises the
      existing singleton*.  Starting from the left, property value pairs are
      applied to the GUI before diana_OpeningFcn gets called.  An
      unrecognized property name or invalid value makes property application
      stop.  All inputs are passed to diana_OpeningFcn via varargin.

      *See GUI Options on GUIDE's Tools menu.  Choose &quotGUI allows only one
      instance to run (singleton)&quot.

 See also: GUIDE, GUIDATA, GUIHANDLES
 Edit the above text to modify the response to help diana
 Last Modified by GUIDE v2.5 20-Apr-2016 16:19:51
 Begin initialization code - DO NOT EDIT
ui_Singleton = 1;
ui_State = struct('gui_Name',       mfilename, ...
                  'gui_Singleton',  gui_Singleton, ...
                  'gui_OpeningFcn', @diana_OpeningFcn, ...
                  'gui_OutputFcn',  @diana_OutputFcn, ...
                  'gui_LayoutFcn',  [] , ...
                  'gui_Callback',   []);
f nargin &amp&amp ischar(varargin{1})
   gui_State.gui_Callback = str2func(varargin{1});
nd
f nargout
   [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
lse
   gui_mainfcn(gui_State, varargin{:});
nd
 End initialization code - DO NOT EDIT
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160303, major review
 David N. Bresch, david.bresch@gmail.com, 20160304, renamed to diana (from drf_evaluation_tool_gui)
 David N. Bresch, david.bresch@gmail.com, 20160305, diana_params call improved
 David N. Bresch, david.bresch@gmail.com, 20160420, keep figure added
 David N. Bresch, david.bresch@gmail.com, 20160422, trillion as unit added
 --- Executes just before diana is made visible.
<font color="blue">function diana_OpeningFcn(hObject, eventdata, handles, varargin) </font>
 This function has no output args, see OutputFcn.
 hObject    handle to figure
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 varargin   command line arguments to diana (see VARARGIN)
 Choose default command line output for diana
andles.output = hObject;
 Update handles structure
uidata(hObject, handles);
 UIWAIT makes diana wait for user response (see UIRESUME)
 uiwait(handles.gui_figure1);
et(handles.gui_figure1,'Name','Diana - Goddess of the Hunt');
 --- Outputs from this function are returned to the command line.
<font color="blue">function varargout = diana_OutputFcn(hObject, eventdata, handles)  </font>
 varargout  cell array for returning output args (see VARARGOUT);
 hObject    handle to figure
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Get default command line output from handles structure
arargout{1} = handles.output;
 --- Executes on selection change in entity_listbox.
<font color="blue">function entity_listbox_Callback(hObject, eventdata, handles) </font>
 hObject    handle to entity_listbox (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: contents = cellstr(get(hObject,'String')) returns entity_listbox contents as cell array
        contents{get(hObject,'Value')} returns selected item from entity_listbox
lobal drf_global
et(handles.edit_yearset_length_years,'Enable','on'); % allow to edit yearset length
rf_global.params.entity_selection=get(hObject,'Value');
rf_damage_calc(-2); % obtain hazards_liststr
et(handles.hazard_listbox,'Value',1); % (re)set to first record
et(handles.hazard_listbox,'String',drf_global.params.hazards_liststr); % populate listbox
f strcmp(drf_global.params.hazards_liststr{1},'&ampltno hazards&ampgt')
   set(handles.hazard_listbox,'Enable','off'); % make inactive
   set(handles.hazard_listbox,'Max',1); % reset
   set(handles.pushbutton_plot,'Enable','off'); % make inactive
   set(handles.pushbutton_plot,'BackgroundColor','red'); % make inactive
   set(handles.pushbutton_edit_parameters,'Enable','off'); % make inactive
lse
   set(handles.hazard_listbox,'Enable','on'); % make active
   set(handles.hazard_listbox,'Max',length(drf_global.params.hazards_liststr)); % allow Multiple selection
   set(handles.pushbutton_plot,'Enable','off'); % make inactive
   set(handles.pushbutton_plot,'BackgroundColor','red'); % make inactive
   set(handles.pushbutton_edit_parameters,'Enable','off'); % make inactive
nd
 additinally, set default parameters for selected country
et(handles.edit_yearset_length_years,'String',num2str(drf_global.params.yearset_length_years))
et(handles.edit_block_length_years,'String',num2str(drf_global.params.block_length_years))
et(handles.edit_annual_recovery_rate,'String',num2str(drf_global.params.annual_recovery_rate*100)) % to % from decimal
et(handles.text_error_msg,'String','');
rf_global.EDS=[]; % EDS (re)calculation neeed
f isfield(drf_global,'finance'),drf_global=rmfield(drf_global,'finance');end % reset
 --- Executes during object creation, after setting all properties.
<font color="blue">function entity_listbox_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to entity_listbox (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: listbox controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
lobal drf_global
rf_damage_calc(-1); % obtain entities_liststr
et(hObject,'String',drf_global.params.entities_liststr); % populate listbox
 --- Executes on selection change in hazard_listbox.
<font color="blue">function hazard_listbox_Callback(hObject, eventdata, handles) </font>
 hObject    handle to hazard_listbox (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: contents = cellstr(get(hObject,'String')) returns hazard_listbox contents as cell array
        contents{get(hObject,'Value')} returns selected item from hazard_listbox
lobal drf_global 
et(handles.pushbutton_plot,'Enable','on'); % make active
et(handles.pushbutton_plot,'BackgroundColor','green'); % make active
et(handles.pushbutton_edit_parameters,'Enable','on'); % make active
et(handles.pushbutton_edit_parameters,'TooltipString','Run analysis first to populate default parameters');
rf_damage_calc(-1); % reset (in case different hazard selected)
et(handles.text_error_msg,'String','');
rf_global.EDS=[]; % EDS (re)calculation neeed
f isfield(drf_global,'finance'),drf_global=rmfield(drf_global,'finance');end % reset
   
 --- Executes during object creation, after setting all properties.
<font color="blue">function hazard_listbox_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to hazard_listbox (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: listbox controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 --- Executes on button press in pushbutton_plot.
<font color="blue">function pushbutton_plot_Callback(hObject, eventdata, handles) </font>
 hObject    handle to pushbutton_plot (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
lobal drf_global
 set button to processing status
et(hObject,'Enable','off'); % make inactive
et(hObject,'BackgroundColor','red'); % make inactive
et(hObject,'String','..analysis..'); % make inactive
ause(0.1) % to allow GUI to be set, avoid troubles ;-)
rf_global.params.entity_selection=get(handles.entity_listbox,'Value');
rf_global.params.hazards_selection=get(handles.hazard_listbox,'Value');
rf_global.params.yearset_length_years=str2double(get(handles.edit_yearset_length_years,'String'));
rf_global.params.block_length_years=str2double(get(handles.edit_block_length_years,'String'));
rf_global.params.annual_recovery_rate=str2double(get(handles.edit_annual_recovery_rate,'String'))/100; % to decimal from %
 treat the single_block_number, which can be empty, a single integer or a vector
ingle_block_number_str=get(handles.edit_single_block_number,'String');
f ~isempty(single_block_number_str) % interpret '1' or '1,2,3' ...
   single_block_number_cell=textscan(single_block_number_str,'%f','Delimiter',',');
   drf_global.params.single_block_number=single_block_number_cell{1};
lse
   drf_global.params.single_block_number=[];
nd
witch get(handles.popupmenu_currency_unit,'Value') % figure currency unit
   % we do NOT use get(handles.popupmenu_currency_unit,'String')
   % as 'million' and 'billon' are too long for axes etc.
   case 1
       drf_global.currency.unit_fact=1;
       drf_global.currency.unit_str='';
   case 2
       drf_global.currency.unit_fact=1/1000;
       drf_global.currency.unit_str='k';
   case 3
       drf_global.currency.unit_fact=1/1e6;
       drf_global.currency.unit_str='mio';
   case 4
       drf_global.currency.unit_fact=1/1e9;
       drf_global.currency.unit_str='bn';
   case 5
       drf_global.currency.unit_fact=1/1e12;
       drf_global.currency.unit_str='tn';
   otherwise
       drf_global.currency.unit_fact=1;
       drf_global.currency.unit_str='';
nd
f get(handles.popupmenu_select_blocks,'Value')==2
   if ~isempty(drf_global.params.single_block_number)
       drf_global.params.single_block_number(1)=-drf_global.params.single_block_number(1);
   end
nd
f get(handles.popupmenu_block_length,'Value')==2
   drf_global.params.block_length_years=-drf_global.params.block_length_years;
nd
 ----------------------------------------------------------------------
et(hObject,'String','..damage calculation..'); % make inactive
_0=clock;
rf_damage_calc(-3); % run the analysis with all parameters set (-3)
_damage_calc=etime(clock,t_0);t_0=clock;
et(handles.edit_yearset_length_years,'String',num2str(drf_global.params.yearset_length_years)) % update yearset length
et(hObject,'String','..evaluation..'); % make inactive
rf_evaluation;      % evaluate insurance vs loan
_evaluation=etime(clock,t_0);t_0=clock;
et(hObject,'String','..plotting..'); % make inactive
f ishghandle(drf_global.fig1),close(drf_global.fig1);end % close previous figure
rf_plot;            % create figures
_plot=etime(clock,t_0);
printf('damage_calc %f, evaluation %f, plotting %f sec\n',t_damage_calc,t_evaluation,t_plot);
 ----------------------------------------------------------------------
et(handles.pushbutton_edit_parameters,'TooltipString','Edit risk transfer and finance instrument parameters');
et(handles.pushbutton_edit_parameters,'Enable','on'); % make active
f ~isempty(drf_global.error_msg)
   % show last error message from drf_damage_calc in GUI
   set(handles.text_error_msg,'String',drf_global.error_msg);
lse
   set(handles.text_error_msg,'String','');
nd
 set button back ready for action
et(hObject,'Enable','on'); % make active
et(hObject,'BackgroundColor','green'); % make active
et(hObject,'String','Analyze'); % make active
et(handles.pushbutton_keep_fig,'Enable','on'); % make active
<font color="blue">function edit_block_length_years_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_block_length_years (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_block_length_years as text
        str2double(get(hObject,'String')) returns contents of edit_block_length_years as a double
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_block_length_years_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_block_length_years (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_yearset_length_years_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_yearset_length_years (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_yearset_length_years as text
        str2double(get(hObject,'String')) returns contents of edit_yearset_length_years as a double
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_yearset_length_years_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_yearset_length_years (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_annual_recovery_rate_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_annual_recovery_rate (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_annual_recovery_rate as text
        str2double(get(hObject,'String')) returns contents of edit_annual_recovery_rate as a double
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_annual_recovery_rate_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_annual_recovery_rate (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_single_block_number_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_single_block_number (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_single_block_number as text
        str2double(get(hObject,'String')) returns contents of edit_single_block_number as a double
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_single_block_number_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_single_block_number (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 --- Executes on selection change in popupmenu_currency_unit.
<font color="blue">function popupmenu_currency_unit_Callback(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_currency_unit (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: contents = cellstr(get(hObject,'String')) returns popupmenu_currency_unit contents as cell array
        contents{get(hObject,'Value')} returns selected item from popupmenu_currency_unit
 --- Executes during object creation, after setting all properties.
<font color="blue">function popupmenu_currency_unit_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_currency_unit (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: popupmenu controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 --- Executes on button press in pushbutton_load_yearset.
<font color="blue">function pushbutton_load_yearset_Callback(hObject, eventdata, handles) </font>
 hObject    handle to pushbutton_load_yearset (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
lobal drf_global
 prompt user for Year damage set
f exist('climada_PLS_read','file')
   drf_global.SDS=climada_PLS_read('',1);
   if ~isempty(drf_global.SDS)
       drf_global.params.yearset_length_years=length(drf_global.SDS.yyyy);
       drf_global.params.entity_name='&ampltyearset&ampgt';
       drf_global.params.hazard_name='&ampltyearset&ampgt';
       drf_global.EDS=[];drf_global.EDS='NOT NEEDED, since SDS passed'; % to be safe
       % update GUI
       set(handles.edit_yearset_length_years,'String',num2str(drf_global.params.yearset_length_years));
       set(handles.edit_yearset_length_years,'Enable','off'); % not editable any more
       % set button ready for action
       set(handles.pushbutton_plot,'Enable','on'); % make active
       set(handles.pushbutton_plot,'BackgroundColor','green'); % make active
       set(handles.pushbutton_plot,'String','Analyze'); % make active
       drf_global.SDS(2)=drf_global.SDS(1); % as they are indeed the same
       drf_global.calc_SDS=-1; % sure no recalc of SDS
       set(handles.text_error_msg,'String','Suggestion: see command line message');
       % and we print to stdout:
       fprintf('\nIssue: Country/hazard info are currently still missing in the PLS header\n');
       fprintf('\nSuggestion: pick the corresponding climada-based country/hazard first, run one analysis\n');
       fprintf('            (this sets all financial parameters). Then load yearset again.\n\n');
   else
       set(handles.text_error_msg,'String','Cancel pressed');
   end % ~isempty(params.YDS)
lse
   set(handles.text_error_msg,'String','Error: no yearset reader installed');
   fprintf('Error: no yearset reader installed, please contact &amplta href=&quotmailto:david.bresch@gmail.com&quot&ampgtdavid.bresch@gmail.com\n&amplt/a&ampgt');
nd
 --- Executes on button press in pushbutton_edit_parameters.
<font color="blue">function pushbutton_edit_parameters_Callback(hObject, eventdata, handles) </font>
 hObject    handle to pushbutton_edit_parameters (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
lobal drf_global
f isfield(drf_global,'finance')
   diana_params;
   if ~isempty(drf_global.error_msg)
       set(handles.text_error_msg,'String',drf_global.error_msg);
   else
       set(handles.text_error_msg,'String','');
   end
lse
   set(handles.text_error_msg,'String','Run an analysis first');
nd
 --- Executes on selection change in popupmenu_block_length.
<font color="blue">function popupmenu_block_length_Callback(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_block_length (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: contents = cellstr(get(hObject,'String')) returns popupmenu_block_length contents as cell array
        contents{get(hObject,'Value')} returns selected item from popupmenu_block_length
f get(handles.popupmenu_block_length,'Value')==2 &amp&amp isempty(get(handles.edit_single_block_number,'String'))
   uiwait(msgbox('Running blocks might take a VERY LONG time to plot. Consider plotting only select blocks','WARNING','modal'));
nd
 --- Executes during object creation, after setting all properties.
<font color="blue">function popupmenu_block_length_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_block_length (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: popupmenu controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 --- Executes on selection change in popupmenu_select_blocks.
<font color="blue">function popupmenu_select_blocks_Callback(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_select_blocks (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: contents = cellstr(get(hObject,'String')) returns popupmenu_select_blocks contents as cell array
        contents{get(hObject,'Value')} returns selected item from popupmenu_select_blocks
 --- Executes during object creation, after setting all properties.
<font color="blue">function popupmenu_select_blocks_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_select_blocks (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: popupmenu controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 --- Executes on button press in pushbutton_keep_fig.
<font color="blue">function pushbutton_keep_fig_Callback(hObject, eventdata, handles) </font>
 hObject    handle to pushbutton_keep_fig (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
lobal drf_global
rf_global.fig1=''; % force new figure being created
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/disaster_risk_finance_private/code/diana/diana.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="diana_params">
<H2>diana_params</H2></A>
<font color="blue">function varargout = diana_params(varargin) </font>
 DIANA_PARAMS MATLAB code for diana_params.fig
      DIANA_PARAMS, by itself, creates a new DIANA_PARAMS or raises the existing
      singleton*.

      H = DIANA_PARAMS returns the handle to a new DIANA_PARAMS or the handle to
      the existing singleton*.

      DIANA_PARAMS('CALLBACK',hObject,eventData,handles,...) calls the local
      function named CALLBACK in DIANA_PARAMS.M with the given input arguments.

      DIANA_PARAMS('Property','Value',...) creates a new DIANA_PARAMS or raises the
      existing singleton*.  Starting from the left, property value pairs are
      applied to the GUI before diana_params_OpeningFcn gets called.  An
      unrecognized property name or invalid value makes property application
      stop.  All inputs are passed to diana_params_OpeningFcn via varargin.

      *See GUI Options on GUIDE's Tools menu.  Choose &quotGUI allows only one
      instance to run (singleton)&quot.

 See also: GUIDE, GUIDATA, GUIHANDLES
 Edit the above text to modify the response to help diana_params
 Last Modified by GUIDE v2.5 10-May-2016 15:59:40
 Begin initialization code - DO NOT EDIT
ui_Singleton = 1;
ui_State = struct('gui_Name',       mfilename, ...
   'gui_Singleton',  gui_Singleton, ...
   'gui_OpeningFcn', @diana_params_OpeningFcn, ...
   'gui_OutputFcn',  @diana_params_OutputFcn, ...
   'gui_LayoutFcn',  [] , ...
   'gui_Callback',   []);
f nargin &amp&amp ischar(varargin{1})
   gui_State.gui_Callback = str2func(varargin{1});
nd
f nargout
   [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
lse
   gui_mainfcn(gui_State, varargin{:});
nd
 End initialization code - DO NOT EDIT
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160303, major review
 David N. Bresch, david.bresch@gmail.com, 20160304, renamed from drf_evaluation_tool_params_gui to diana_params
 David N. Bresch, david.bresch@gmail.com, 20160305, parameter update more sophisticated
 David N. Bresch, david.bresch@gmail.com, 20160306, better error catch
 David N. Bresch, david.bresch@gmail.com, 20160324, major overhaul, loan2
 David N. Bresch, david.bresch@gmail.com, 20160421, n loans possible (only two implemented)
 David N. Bresch, david.bresch@gmail.com, 20160504, toggle insurance/loan to be shown in upper left panel (drf_plot, drf_global.params.RDS_index)
 David N. Bresch, david.bresch@gmail.com, 20160527, set params automatically once a number is entered
 --- Executes just before diana_params is made visible.
<font color="blue">function diana_params_OpeningFcn(hObject, eventdata, handles, varargin) </font>
 This function has no output args, see OutputFcn.
 hObject    handle to figure
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 varargin   command line arguments to diana_params (see VARARGIN)
 Choose default command line output for diana_params
andles.output = hObject;
 Update handles structure
uidata(hObject, handles);
 UIWAIT makes diana_params wait for user response (see UIRESUME)
 uiwait(handles.figure1);
et(handles.figure1,'Name','Diana parameters');
iana_params_SET_CONTENT(hObject, eventdata, handles)
 --- Outputs from this function are returned to the command line.
<font color="blue">function varargout = diana_params_OutputFcn(hObject, eventdata, handles) </font>
 varargout  cell array for returning output args (see VARARGOUT);
 hObject    handle to figure
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Get default command line output from handles structure
arargout{1} = handles.output;
<font color="blue">function edit_p01_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_p01 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_p01 as text
        str2double(get(hObject,'String')) returns contents of edit_p01 as a double
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_p01_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_p01 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_p02_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_p02 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_p02 as text
        str2double(get(hObject,'String')) returns contents of edit_p02 as a double
lobal drf_global
f isfield(drf_global,'finance')
   value=str2double(get(hObject,'String'))/drf_global.currency.unit_fact;
   element_i=get(handles.popupmenu_peril,'Value');
   set(handles.text_r02,'String',char(num2str(LOCAL_return_period(drf_global.EDS(element_i),value))));
   edit_p03_Callback(hObject, eventdata, handles) % update cover return period, too
   set(handles.text_error_msg,'String','Note: run analysis again to obtain consistent return periods');
nd
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_p02_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_p02 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_p03_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_p03 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_p03 as text
        str2double(get(hObject,'String')) returns contents of edit_p03 as a double
lobal drf_global
f isfield(drf_global,'finance')
   retention=str2double(get(handles.edit_p02,'String'))/drf_global.currency.unit_fact;
   value    =str2double(get(handles.edit_p03,'String'))/drf_global.currency.unit_fact;
   element_i=get(handles.popupmenu_peril,'Value');
   set(handles.text_r03,'String',char(num2str(LOCAL_return_period(drf_global.EDS(element_i),retention+value))));
   set(handles.text_error_msg,'String','Note: run analysis again to obtain consistent return periods');
nd
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_p03_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_p03 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_p04_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_p04 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_p04 as text
        str2double(get(hObject,'String')) returns contents of edit_p04 as a double
lobal drf_global
f isfield(drf_global,'finance')
   value=str2double(get(hObject,'String'))/drf_global.currency.unit_fact;
   element_i=get(handles.popupmenu_peril,'Value');
   set(handles.text_r04,'String',char(num2str(LOCAL_return_period(drf_global.YDS(element_i),value))));
   edit_p05_Callback(hObject, eventdata, handles) % update cover return period, too
   set(handles.text_error_msg,'String','Note: run analysis again to obtain consistent return periods');
nd
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_p04_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_p04 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_p05_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_p05 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_p05 as text
        str2double(get(hObject,'String')) returns contents of edit_p05 as a double
lobal drf_global
f isfield(drf_global,'finance')
   retention=str2double(get(handles.edit_p04,'String'))/drf_global.currency.unit_fact;
   value    =str2double(get(handles.edit_p05,'String'))/drf_global.currency.unit_fact;
   element_i=get(handles.popupmenu_peril,'Value');
   set(handles.text_r05,'String',char(num2str(LOCAL_return_period(drf_global.YDS(element_i),retention+value))));
   set(handles.text_error_msg,'String','Note: run analysis again to obtain consistent return periods');
nd
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_p05_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_p05 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_p06_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_p06 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_p06 as text
        str2double(get(hObject,'String')) returns contents of edit_p06 as a double
lobal drf_global
f isfield(drf_global,'finance')
   value=str2double(get(hObject,'String'))/drf_global.currency.unit_fact;
   set(handles.text_r06,'String',char(num2str(LOCAL_return_period(drf_global.SDS(1),value))));
   edit_p07_Callback(hObject, eventdata, handles) % update cover return period, too
   set(handles.text_error_msg,'String','Note: run analysis again to obtain consistent return periods');
nd
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_p06_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_p06 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_p07_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_p07 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_p07 as text
        str2double(get(hObject,'String')) returns contents of edit_p07 as a double
lobal drf_global
f isfield(drf_global,'finance')
   retention=str2double(get(handles.edit_p06,'String'))/drf_global.currency.unit_fact;
   value    =str2double(get(handles.edit_p07,'String'))/drf_global.currency.unit_fact;
   set(handles.text_r07,'String',char(num2str(LOCAL_return_period(drf_global.SDS(1),retention+value))));
   set(handles.text_error_msg,'String','Note: run analysis again to obtain consistent return periods');
nd
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_p07_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_p07 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_loan_amount_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan_amount (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_loan_amount as text
        str2double(get(hObject,'String')) returns contents of edit_loan_amount as a double
lobal drf_global
f isfield(drf_global,'finance')
   retention=str2double(get(handles.edit_loan_attach,'String'))/drf_global.currency.unit_fact; % loan_attachement
   value    =str2double(get(handles.edit_loan_amount,'String'))/drf_global.currency.unit_fact; % loan_amount
   set(handles.text_loan_rp,'String',char(num2str(LOCAL_return_period(drf_global.SDS(1),retention+value))));
   set(handles.text_error_msg,'String','Note: run analysis again to obtain consistent return periods');
nd
dit_loan2_amount_Callback(hObject, eventdata, handles); % affects also loan2
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_loan_amount_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan_amount (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 --- Executes on button press in pushbutton_set.
<font color="blue">function pushbutton_set_Callback(hObject, eventdata, handles) </font>
 hObject    handle to pushbutton_set (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
iana_params_GET_CONTENT(hObject, eventdata, handles)
<font color="blue">function edit_loan_interest_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan_interest (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_loan_interest as text
        str2double(get(hObject,'String')) returns contents of edit_loan_interest as a double
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_loan_interest_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan_interest (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_loan_amort_amount_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan_amort_amount (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_loan_amort_amount as text
        str2double(get(hObject,'String')) returns contents of edit_loan_amort_amount as a double
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_loan_amort_amount_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan_amort_amount (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 --- Executes on selection change in popupmenu_peril.
<font color="blue">function popupmenu_peril_Callback(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_peril (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: contents = cellstr(get(hObject,'String')) returns popupmenu_peril contents as cell array
        contents{get(hObject,'Value')} returns selected item from popupmenu_peril
iana_params_SET_CONTENT(hObject, eventdata, handles);
 --- Executes during object creation, after setting all properties.
<font color="blue">function popupmenu_peril_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_peril (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: popupmenu controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 --- Executes on button press in pushbutton_close.
<font color="blue">function pushbutton_close_Callback(hObject, eventdata, handles) </font>
 hObject    handle to pushbutton_close (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
iana_params_GET_CONTENT(hObject, eventdata, handles)
elete(handles.figure1)
 --- Executes just before diana_params is made visible.
<font color="blue">function diana_params_SET_CONTENT(hObject, eventdata, handles) </font>
 set edit field contents
 element_i points to which element of the vectors
 hObject    handle to figure
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
lobal drf_global % best way to get access to all data all times
et(handles.text_error_msg,'String','');
lement_i=get(handles.popupmenu_peril,'Value');
urstr=[' [' drf_global.currency.name_str ' ' drf_global.currency.unit_str ']'];
f isfield(drf_global,'finance')
   
   if isfield(drf_global.finance,'peril_ID')
       set(handles.popupmenu_peril,'String',drf_global.finance.peril_ID);
       
       set(handles.text_p01,'String','direct insurance coverage [%]');
       set(handles.edit_p01,'String',char(num2str(drf_global.finance.insurance_coverage(element_i)*100)));
       set(handles.edit_p01,'Visible','on'); % make visible
       
       set(handles.text_p02,'String',['event retention' curstr]);
       set(handles.edit_p02,'String',char(num2str(drf_global.finance.event_retention(element_i)*drf_global.currency.unit_fact)));
       set(handles.edit_p02,'Visible','on'); % make visible
       
       set(handles.text_p03,'String',['event cover' curstr]);
       set(handles.edit_p03,'String',char(num2str(drf_global.finance.event_cover(element_i)*drf_global.currency.unit_fact)));
       set(handles.edit_p03,'Visible','on'); % make visible
       
       set(handles.text_p04,'String',['annual retention' curstr]);
       set(handles.edit_p04,'String',char(num2str(drf_global.finance.annual_retention(element_i)*drf_global.currency.unit_fact)));
       set(handles.edit_p04,'Visible','on'); % make visible
       
       set(handles.text_p05,'String',['annual cover' curstr]);
       set(handles.edit_p05,'String',char(num2str(drf_global.finance.annual_cover(element_i)*drf_global.currency.unit_fact)));
       set(handles.edit_p05,'Visible','on'); % make visible
       
       % now, try to provide return periods for all values
       if isfield(drf_global,'EDS')
           if ~isempty(drf_global.EDS)
               set(handles.text_r02,'String',char(num2str(LOCAL_return_period(drf_global.EDS(element_i),...
                   drf_global.finance.event_retention(element_i)))));
               set(handles.text_r03,'String',char(num2str(LOCAL_return_period(drf_global.EDS(element_i),...
                   drf_global.finance.event_retention(element_i)+drf_global.finance.event_cover(element_i)))));
           end % ~isempty(drf_global.EDS)
       else
           drf_global.error_msg='Note: no EDS, run an anlysis (again)';
           set(handles.text_error_msg,'String',drf_global.error_msg);
       end % isfield(drf_global,'EDS')
       if isfield(drf_global,'YDS')
           if ~isempty(drf_global.YDS)
               set(handles.text_r04,'String',char(num2str(LOCAL_return_period(drf_global.YDS(element_i),...
                   drf_global.finance.annual_retention(element_i)))));
               set(handles.text_r05,'String',char(num2str(LOCAL_return_period(drf_global.YDS(element_i),...
                   drf_global.finance.annual_retention(element_i)+drf_global.finance.annual_cover(element_i)))));
           end % ~isempty(drf_global.YDS)
       else
           drf_global.error_msg='Note: no YDS, run an anlysis (again)';
           set(handles.text_error_msg,'String',drf_global.error_msg);
       end % isfield(drf_global,'YDS')
       
   else
       % if a yearset has been imported (
       set(handles.edit_p01,'Enable','off');
       set(handles.edit_p02,'Enable','off');
       set(handles.edit_p03,'Enable','off');
       set(handles.edit_p04,'Enable','off');
       set(handles.edit_p05,'Enable','off');
   end % isfield(drf_global.finance,'peril_ID')
   
   set(handles.text_p06,'String',['annual retention' curstr]);
   set(handles.edit_p06,'String',char(num2str(drf_global.finance.annual_retention_aggregate*drf_global.currency.unit_fact)));
   set(handles.edit_p06,'Visible','on'); % make visible
   
   set(handles.text_p07,'String',['annual cover' curstr]);
   set(handles.edit_p07,'String',char(num2str(drf_global.finance.annual_cover_aggregate*drf_global.currency.unit_fact)));
   set(handles.edit_p07,'Visible','on'); % make visible
   
   % loan
   set(handles.edit_loan_amount,'String',char(num2str(drf_global.finance.loan(1).amount*drf_global.currency.unit_fact)));
   set(handles.edit_loan_interest,'String',char(num2str(drf_global.finance.loan(1).interest*100)));
   set(handles.edit_loan_amort_amount,'String',char(num2str(drf_global.finance.loan(1).amort_amount*drf_global.currency.unit_fact)));
   set(handles.edit_loan_amort_rate,'String',char(num2str(drf_global.finance.loan(1).amort_rate*100)));
   set(handles.edit_loan_attach,'String',char(num2str(drf_global.finance.loan(1).attachement*drf_global.currency.unit_fact)));
   
   % loan2
   set(handles.edit_loan2_amount,'String',char(num2str(drf_global.finance.loan(2).amount*drf_global.currency.unit_fact)));
   set(handles.edit_loan2_interest,'String',char(num2str(drf_global.finance.loan(2).interest*100)));
   set(handles.edit_loan2_amort_amount,'String',char(num2str(drf_global.finance.loan(2).amort_amount*drf_global.currency.unit_fact)));
   set(handles.edit_loan2_amort_rate,'String',char(num2str(drf_global.finance.loan(2).amort_rate*100)));
   set(handles.edit_loan2_attach,'String',char(num2str(drf_global.finance.loan(2).attachement*drf_global.currency.unit_fact)));
   
   set(handles.edit_ins_cost_mult,'String',char(num2str(drf_global.params.insurance_cost_multiplier)));
   
   if isfield(drf_global,'SDS')
       if ~isempty(drf_global.SDS)
           set(handles.text_r06,'String',char(num2str(LOCAL_return_period(drf_global.SDS(1),...
               drf_global.finance.annual_retention_aggregate))));
           set(handles.text_r07,'String',char(num2str(LOCAL_return_period(drf_global.SDS(1),...
               drf_global.finance.annual_retention_aggregate+drf_global.finance.annual_cover_aggregate))));
           set(handles.text_loan_rp, 'String',char(num2str(LOCAL_return_period(drf_global.SDS(1),...
               drf_global.finance.loan(1).amount +drf_global.finance.loan(1).attachement)))); % show loan exit
           set(handles.text_loan2_rp,'String',char(num2str(LOCAL_return_period(drf_global.SDS(1),...
               drf_global.finance.loan(1).amount +drf_global.finance.loan(1).attachement+...
               drf_global.finance.loan(2).amount+drf_global.finance.loan(2).attachement)))); % show total combined loan exit
       end % ~isempty(drf_global.SDS)
   else
       drf_global.error_msg='Note: no SDS, run an anlysis (again)';
       set(handles.text_error_msg,'String',drf_global.error_msg);
   end % isfield(drf_global,'SDS')
   
   if drf_global.params.RDS_index==2;set(handles.radiobutton_insurance,'Value',1);set(handles.radiobutton_loan,'Value',0);end
   if drf_global.params.RDS_index==3;set(handles.radiobutton_insurance,'Value',0);set(handles.radiobutton_loan,'Value',1);end
   
lse
   drf_global.error_msg='Warning: parameters not set yet/editable, run an anlysis first';
   set(handles.text_error_msg,'String',drf_global.error_msg);
nd % isfield(drf_global,'finance')
 --- Executes just before diana_params is made visible.
<font color="blue">function diana_params_GET_CONTENT(hObject, eventdata, handles) </font>
 get edit field contents
 element_i points to which element of the vectors
 hObject    handle to figure
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
lobal drf_global % best way to get access to all data all times
lement_i=get(handles.popupmenu_peril,'Value');
f isfield(drf_global,'finance')
   
   if isfield(drf_global.finance,'peril_ID')
       
       field_str=get(handles.edit_p01,'String');
       val=str2double(field_str)/100; % to decimal from %
       if abs(val-drf_global.finance.insurance_coverage(element_i))&ampgt10*eps,drf_global.calc_SDS=1;end
       drf_global.finance.insurance_coverage(element_i)=val;
       
       field_str=get(handles.edit_p02,'String');
       val=str2double(field_str)/drf_global.currency.unit_fact;
       if abs(val-drf_global.finance.event_retention(element_i))&ampgt10*eps,drf_global.calc_SDS=1;end
       drf_global.finance.event_retention(element_i)=val;
       
       field_str=get(handles.edit_p03,'String');
       val=str2double(field_str)/drf_global.currency.unit_fact;
       if abs(val-drf_global.finance.event_cover(element_i))&ampgt10*eps,drf_global.calc_SDS=1;end
       drf_global.finance.event_cover(element_i)=val;
       
       field_str=get(handles.edit_p04,'String');
       val=str2double(field_str)/drf_global.currency.unit_fact;
       if abs(val-drf_global.finance.annual_retention(element_i))&ampgt10*eps,drf_global.calc_SDS=1;end
       drf_global.finance.annual_retention(element_i)=val;
       
       field_str=get(handles.edit_p05,'String');
       val=str2double(field_str)/drf_global.currency.unit_fact;
       if abs(val-drf_global.finance.annual_cover(element_i))&ampgt10*eps,drf_global.calc_SDS=1;end
       drf_global.finance.annual_cover(element_i)=val;
       
   end % isfield(drf_global.finance,'peril_ID')
   
   field_str=get(handles.edit_p06,'String');
   val=str2double(field_str)/drf_global.currency.unit_fact;
   drf_global.finance.annual_retention_aggregate=val;
   
   field_str=get(handles.edit_p07,'String');
   val=str2double(field_str)/drf_global.currency.unit_fact;
   drf_global.finance.annual_cover_aggregate=val;
   
   field_str=get(handles.edit_ins_cost_mult,'String');
   drf_global.params.insurance_cost_multiplier=str2double(field_str);
   
   field_str=get(handles.edit_loan_amount,'String');
   drf_global.finance.loan(1).amount=str2double(field_str)/drf_global.currency.unit_fact;
   
   field_str=get(handles.edit_loan_interest,'String');
   drf_global.finance.loan(1).interest=str2double(field_str)/100; % to decimal from %
   
   field_str=get(handles.edit_loan_amort_amount,'String');
   drf_global.finance.loan(1).amort_amount=str2double(field_str)/drf_global.currency.unit_fact;
   
   field_str=get(handles.edit_loan_amort_rate,'String');
   drf_global.finance.loan(1).amort_rate=str2double(field_str)/100; % to decimal from %
   
   field_str=get(handles.edit_loan_attach,'String');
   drf_global.finance.loan(1).attachement=str2double(field_str)/drf_global.currency.unit_fact;
   
   field_str=get(handles.edit_loan2_amount,'String');
   drf_global.finance.loan(2).amount=str2double(field_str)/drf_global.currency.unit_fact;
   
   field_str=get(handles.edit_loan2_interest,'String');
   drf_global.finance.loan(2).interest=str2double(field_str)/100; % to decimal from %
   
   field_str=get(handles.edit_loan2_amort_amount,'String');
   drf_global.finance.loan(2).amort_amount=str2double(field_str)/drf_global.currency.unit_fact;
   
   field_str=get(handles.edit_loan2_amort_rate,'String');
   drf_global.finance.loan(2).amort_rate=str2double(field_str)/100; % to decimal from %
   
   field_str=get(handles.edit_loan2_attach,'String');
   drf_global.finance.loan(2).attachement=str2double(field_str)/drf_global.currency.unit_fact;
   
   set(handles.text_error_msg,'String','');
   
   if get(handles.radiobutton_insurance,'Value'),drf_global.params.RDS_index=2;end
   if get(handles.radiobutton_loan,'Value'),drf_global.params.RDS_index=3;end
   
lse
   drf_global.error_msg='Warning: parameters not set yet/editable, run an anlysis first';
   set(handles.text_error_msg,'String',drf_global.error_msg);
nd % isfield(drf_global,'finance')
<font color="blue">function return_period=LOCAL_return_period(EDS,damage) </font>
 figure the return period for specified damage
xs_damage,xs_freq]=climada_damage_exceedence(EDS.damage,EDS.frequency);
xs_damage,j]=unique(xs_damage);xs_freq=xs_freq(j); % only unique
req=interp1(xs_damage,xs_freq,damage);
eturn_period = 1./freq;
 --- Executes on button press in pushbutton_refresh.
<font color="blue">function pushbutton_refresh_Callback(hObject, eventdata, handles) </font>
 hObject    handle to pushbutton_refresh (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
iana_params_SET_CONTENT(hObject, eventdata, handles)
<font color="blue">function edit_loan_amort_rate_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan_amort_rate (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_loan_amort_rate as text
        str2double(get(hObject,'String')) returns contents of edit_loan_amort_rate as a double
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_loan_amort_rate_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan_amort_rate (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_loan_attach_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan_attach (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_loan_attach as text
        str2double(get(hObject,'String')) returns contents of edit_loan_attach as a double
dit_loan_amount_Callback(hObject, eventdata, handles);
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_loan_attach_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan_attach (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_ins_cost_mult_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_ins_cost_mult (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_ins_cost_mult as text
        str2double(get(hObject,'String')) returns contents of edit_ins_cost_mult as a double
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_ins_cost_mult_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_ins_cost_mult (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_loan2_amount_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan2_amount (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_loan2_amount as text
        str2double(get(hObject,'String')) returns contents of edit_loan2_amount as a double
lobal drf_global
f isfield(drf_global,'finance')
   retention=str2double(get(handles.edit_loan_attach, 'String'))/drf_global.currency.unit_fact+...
       str2double(      get(handles.edit_loan2_attach,'String'))/drf_global.currency.unit_fact; % loan_attachement
   value    =str2double(get(handles.edit_loan_amount, 'String'))/drf_global.currency.unit_fact+...
       str2double(      get(handles.edit_loan2_amount,'String'))/drf_global.currency.unit_fact; % loan_amount
   set(handles.text_loan2_rp,'String',char(num2str(LOCAL_return_period(drf_global.SDS(1),retention+value))));
   set(handles.text_error_msg,'String','Note: run analysis again to obtain consistent return periods');
nd
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_loan2_amount_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan2_amount (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_loan2_interest_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan2_interest (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_loan2_interest as text
        str2double(get(hObject,'String')) returns contents of edit_loan2_interest as a double
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_loan2_interest_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan2_interest (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_loan2_amort_amount_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan2_amort_amount (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_loan2_amort_amount as text
        str2double(get(hObject,'String')) returns contents of edit_loan2_amort_amount as a double
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_loan2_amort_amount_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan2_amort_amount (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_loan2_amort_rate_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan2_amort_rate (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_loan2_amort_rate as text
        str2double(get(hObject,'String')) returns contents of edit_loan2_amort_rate as a double
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_loan2_amort_rate_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan2_amort_rate (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_loan2_attach_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan2_attach (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_loan2_attach as text
        str2double(get(hObject,'String')) returns contents of edit_loan2_attach as a double
dit_loan2_amount_Callback(hObject, eventdata, handles);
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_loan2_attach_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_loan2_attach (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 --- Executes on button press in radiobutton_insurance.
<font color="blue">function radiobutton_insurance_Callback(hObject, eventdata, handles) </font>
 hObject    handle to radiobutton_insurance (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hint: get(hObject,'Value') returns toggle state of radiobutton_insurance
et(handles.radiobutton_loan,'Value',~get(hObject,'Value'))
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes on button press in radiobutton_loan.
<font color="blue">function radiobutton_loan_Callback(hObject, eventdata, handles) </font>
 hObject    handle to radiobutton_loan (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hint: get(hObject,'Value') returns toggle state of radiobutton_loan
et(handles.radiobutton_insurance,'Value',~get(hObject,'Value'))
iana_params_GET_CONTENT(hObject, eventdata, handles)
 --- Executes on button press in radiobutton3.
<font color="blue">function radiobutton3_Callback(hObject, eventdata, handles) </font>
 hObject    handle to radiobutton3 (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hint: get(hObject,'Value') returns toggle state of radiobutton3
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/disaster_risk_finance_private/code/diana/diana_params.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="drf_damage_calc">
<H2>drf_damage_calc</H2></A>
<font color="blue">function drf_damage_calc(reinit_flag,verbose) </font>
 climada disaster risk finance drf evaluation tool
 MODULE:
   disaster_risk_finance
 NAME:
   drf_damage_calc
 PURPOSE:
   A DRAFT disaster risk finance (drf) evaluation tool. Runs on country
   (admin0) and state (admin1) level.

   See also diana GUI for a nice graphical user interface

   Prompts the user for (country or state) assets (as prepared by
   country_risk_calc) and hazard set(s). The calculation unfolds as follows: 
   - calculate the event damage set (EDS) for each (sub) peril (EQ, TC..)
   - combine sub-perils (such as TC, TS) into one EDS (eg TC) per main peril
   - apply direct proportional insurance coverage (at no cost)
     -&ampgt this forms the reference base to calculate cost of insurance and
        other financial instruments net of direct primary insurance)
   - apply per-event conditions
   - convert event damage set (EDS) to year damage set (YDS)
   - apply peril annual aggregate conditions
   - combine peril year damage sets into one aggregate year damage set
   hand over to drf_evaluation (treats combined peril annual aggregate
   conditions and does care for all other financial instruments, eg loan)
     -&ampgt this results in the cost of insurance (all risk transfer
     conditions AFTER application of direct proportional insurance
     coverage)
   
   All parameters as well as results are stored in the global variable
   drf_global (see detailed description below), which allows for easy edit
   of anything - and simple I/O with GUI.
   Use 'clear GLOBAL drf_global' to really clear and start from
   scratch, as 'clear drf_global' only clears the current workspace, but
   leaves drf_global accessible to any functions declaring it global.
   But drf_damage_calc(1) does reset all, too.

   On subsequent calls, country and hazard(s) remain, such that the user
   can experiment with disaster risk finance parameters. See reinit_flag=1
   to re-start selecting country and hazard(s). Note that re-calculating
   all the EDS(s) might often not be reuqired, but one wants to
   re-assemble the YDS(s), hence consider to set drf_global.calc_SDS=1

   As a prerequisite, run country_risk_calc (from climada module
   country_risk) to obtain assets and hazard(s), see
   https://github.com/davidnbresch/climada_module_country_risk

   The file disaster_risk_finance_mastertable.xls in the data folder of
   the disaster_risk_finance module contains default values per country.

   some abberviations used:
   EDS: event damage set(s) - generated by climada_EDS_calc
   YDS: year damage set(s) - compiled from EDS(s)
   SDS: summed-up year set(s) - either build from YDS or imported
   admin0: country
   ISO3: the admin0 (country) ISO code, such as USA for United States
   admin1: state or province

   Previous call: country_risk_calc (module country_risk, see
       https://github.com/davidnbresch/climada_module_country_risk
   Next call: drf_evaluation (called at the end of drf_damage_calc), drf_plot
   See also: diana (the GUI)
 CALLING SEQUENCE:
   drf_damage_calc(reinit_flag,verbose)
 EXAMPLE:
   drf_damage_calc
   drf_damage_calc(1) % force re-init (ask for country and hazard)
   drf_damage_calc;drf_plot % usual command sequency to calculate and show results
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   reinit_flag: if =1, re-init, i.e. ask for all inputs, re-calculate YDS
       etc. Default=0, i.e. all parameters once set remain for subsequent
       calls, such that the user can experiment with disaster risk
       finance parameters by editing fields of variable drf_global
       SPECIAL USE of reinit_flag if called from gui:
           reinit_flag=-1 to obtain entities_liststr
           reinit_flag=-2 to obtain hazards_liststr
           reinit_flag=-3 to run analysis from gui
       NOTE: in order to just set up the drf_global structure,
           call drf_damage_calc(-1)
   verbose: whether we print to stdout =1 (default) or only severe errors (=0)

   SPECIAL: parameters and data provided via global variable drf_global,
   with fields
   EDS(i): contains the (combined) EDS for (major) peril i, without risk
       transfer conditions applied
   YDS(i): contains the from ground up (fgu) annual aggregate YDS for
       (major) peril i. Does only contain the essential fields of a YDS, i.e.
       damage, frequency and peril_ID (as all other info in corresponding
       EDS(i). Sum over perils i of this YDS builds SDS(1).
   YDS_cond(i): as YDS(i), but with risk transfer conditions both per
       event and aggregate per peril applied.
   SDS(j): the compbined year damage set all subsequent calculations are based upon
       j refers to the 'level' of finance being applied, i.e.
       j=1: just the sum of all from ground up (fgu) YDS(i) (i.e. without
           any risk transfer conditions applied)
       j=2: with all risk transfer conditions (per peril and event, per
           peril annual aggregate and combined peril annual aggregate)
           applied.
       SDS(j) does not contain all fields of a YDS, it contains:
           damage: the damage vector
           frequency: the frequency vector, with sum(SDS.frequency)=1
   calc_SDS: flag to force (re)calculation of SDS.
       Note: while we can delete EDS to force starting from scratch, the GUI
       does need the SDS (even if parameters are updated), hence we can nor
       delete drf_global.SDS, but indicate its 'validity' via drf_global.calc_SDS
   finance: all the finance information, such as risk transfer parameters...
       Same field names as column headers in thre Excel. Note that in the
       Excel sheet, all values are in the user-defined currency
       (currency.name_str) and all calculations of the drf tool happen in
       this currency. Read from Excel the first time a combination of
       country and hazards is selected (and each time this selection
       changes). This way, the user can edit as long as country/hazard(s)
       selection remains the same.
       Note: peril-specific records are read and populated first.
       Therefore, (multi-peril) combined annual aggregate conditions and
       loan parameters of the record with peril ID YY (or XX or last
       peril, if there is no YY) is used to set these. If in doubt, check
       drf_global.finance on the command line
       Currently, two loans (drf_global.finance.loan(i), with i=1,2 are
       implemented, code works with n loans
   currency: the currency definition, fields:
       unit_fact: the factor used to multiply values with
           for display ONLY (default =1e-9)
       unit_str: the unit to be shown (default='bn')
       name_str: the currency name (default from climada_global.Value_unit)
       conversion: the conversion factor to get from the currency in the
           entity (climada_global.Value_unit) to the one requested
           (currency.name_str)
       Note that all calculations happen in units of 1 (unit_fact and
       unit_str are only used for display purposes) and that values are
       converted to target currency after calculation of EDS.damage (such
       that all calculations of the drf tool happen in the target currency
   ...and some more technical parameters:
   params: contais (some more technical) parameters, fields:
       yearset_length_years: length of yearset in years, default=1000.
           If =0, no re-sampling happens, i.e. if one uses only the
           historic hazard event set, one gets only the historic years
           See climada_EDS2YDS for details of yearset treatment
       block_length_years: number of years that constitute a block,
           defaut=20
           if block_length_years is negative, the blocks are running ones,
           i.e. block 1 is years 1..abs(block_length_years), block 2
           2..abs(block_length_years)+1 ...
       single_block_number: the number(s) of a single block to show, i.e.
           =[1,3] to show only two blocks, the first and the third one
           default=[] to show all blocks
       annual_recovery_rate: rate past damage (year-1) is
           amortized/rebuilt (=1: all done in one year). Default taken
           from disaster_risk_finance_mastertable
       insurance_cost_multiplier: the multiplier to get from pure
       historic_flag: to indicate a historic event only hazard set,
           default=0 (effect: labels real years in drf_plot)
       expected damage (ED) to cost of insurance. Default=2.0
       entity_name: name of entity file (w/o path and w/o '.mat',
           like 'USA_UnitedStates_entity').
           If empty, user gets prompted for (kind of default)
           Note: In case the user would like to also pass on the
           hazards(s), run drf_damage_calc(-2) to
           obtain drf_global.params.hazards_liststr, figure which hazard(s) you
           need and call again with selected hazard(s) in
           drf_global.params.hazards_selection.
       entity_liststr and entity_selection: usually only used if called
           from gui, see cases where reinit_flag&amplt0
       hazards_liststr and hazards_selection: usually only used if called
           from gui, see cases where reinit_flag&amplt0
       RDS_index: =2 to show insurance partition on top left figure (see
           drf_plot, default)
           =3: show loan partition on top left figure (see drf_plot)
   ...and some very technical parameters:
   fig1: the figure handle for graphics output (see drf_plot)
   error_msg: the last error message (to be used by the GUI for display)
 OUTPUTS:
   updates fields in drf_global, see description above
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20151229
 David N. Bresch, david.bresch@gmail.com, 20151230, prompting for inpust and forward-compatibility towards GUI
 David N. Bresch, david.bresch@gmail.com, 20151231, combinign (sub)hazards improved, (artificial) yearsets for any hazard
 David N. Bresch, david.bresch@gmail.com, 20151231, histograms (fig2) added
 David N. Bresch, david.bresch@gmail.com, 20160101, gui support added
 David N. Bresch, david.bresch@gmail.com, 20160102, single_block_number added
 David N. Bresch, david.bresch@gmail.com, 20160301, major overhaul
 David N. Bresch, david.bresch@gmail.com, 20160302, major overhaul, all data and parameters in drf_global
 David N. Bresch, david.bresch@gmail.com, 20160303, peril YDS kept, SDS, too etc.
 David N. Bresch, david.bresch@gmail.com, 20160303, header fully updated, plotting separated into drf_evaluation_plot
 David N. Bresch, david.bresch@gmail.com, 20160308, TEST data added
 David N. Bresch, david.bresch@gmail.com, 20160310, reduction to one figure pane
 David N. Bresch, david.bresch@gmail.com, 20160420, orig_year_flag added
 David N. Bresch, david.bresch@gmail.com, 20160421, drf_global structure changed to accomodate n loans in principle
 David N. Bresch, david.bresch@gmail.com, 20160422, proper treatment of historic only hazard event sets added
 David N. Bresch, david.bresch@gmail.com, 20160504, drf_global.params.RDS_index added
 David N. Bresch, david.bresch@gmail.com, 20160527, re-set all finance parameters if Excel has been edited
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/disaster_risk_finance_private/code/diana/drf_damage_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="drf_evaluation">
<H2>drf_evaluation</H2></A>
<font color="blue">function drf_evaluation(verbose) </font>
 climada disaster risk finance drf evaluation tool
 MODULE:
   disaster_risk_finance
 NAME:
   drf_evaluation
 PURPOSE:
   Evaluate options such as risk transfer and loan

   Takes ir from where drf_damage_calc left it, i.e.
   - treats combined peril annual aggregate conditions
     -&ampgt this results in the cost of insurance (all risk transfer
     conditions AFTER application of direct proportional insurance
     coverage) and
   - does care for all other financial instruments, eg loan)
     -&ampgt this results in the cost of loan (incl amortization)

   All parameters are stored in the global variable drf_global (see
   detailed description in drf_damage_calc)

   Abbreviations (explained in detail in drf_damage_calc)
   SDS: summed-up year set(s) - either built from YDS or imported
   RDS: result damage set, chopped into blocks of same length

   Previous call: drf_damage_calc
   Next call: drf_plot
   See also: diana (the GUI)
 CALLING SEQUENCE:
   drf_evaluation(verbose)
 EXAMPLE:
   drf_evaluation
 INPUTS:
   all via global variable drf_global (see detailed description in
   drf_damage_calc), mainly its field:
   SDS(j): the combined year damage set all subsequent calculations are based upon
       j refers to the 'level' of finance being applied, i.e.
       j=1: just the sum of all from ground up (fgu) YDS(i) (i.e. without
           any risk transfer conditions applied)
       j=2: with all risk transfer conditions (per peril and event, per
           peril annual aggregate and combined peril annual aggregate)
           applied.
       SDS(j) does not contain all fields of a YDS, it contains:
           damage: the damage vector
           frequency: the frequency vector, with sum(SDS.frequency)=1
   drf_global.params.single_block_number: if not empty, to select only the
       n-th largest block(s), or, if first element of
       drf_global.params.single_block_number is negative, i.e.
       drf_global.params.single_block_number=[-1,3] the n-largest single
       event (within a block)
 OPTIONAL INPUT PARAMETERS:
   verbose: whether we print regular messages to stdout =1 (default)
       or only severe errors (=0)

   SPECIAL: parameters and data provided via global variable drf_global,
       see drf_evaluation_tool
 OUTPUTS:
   adds fields RDS and recovery_balance to drf_global:
   RDS(j).damage(m,n): the SDS(j).damage 'chopped' into m blocks of length n.
       See description of SDS above and in drf_damage_calc
       j=1: after application of loan
       j=2: after application of insurance
       RDS(j).retention(m,n)=the retention of blocks m in year n
       RDS(j).layer(m,n)=the layer/loan damage of blocks m in year n
           damage covered by insurance for j=2 (insurance)
           damage covered by loan(s) for j=1 (loan)
       RDS(j).layer(m,n)=the excess damage of blocks m in year n
   recovery_balance(j,m,n): as RDS, summed up along years in each block (cumsum-like)
       with j=1: fgu, =2: after insurance, =3: after loan
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160303, separated from drf_damage_calc (formerly drf_evaluation_tool)
 David N. Bresch, david.bresch@gmail.com, 20160304, loan calculation implemented, separated from drf_damage_calc
 David N. Bresch, david.bresch@gmail.com, 20160307, taken advantage of SDS(1) now fgu, option to select max damage added
 David N. Bresch, david.bresch@gmail.com, 20160315, running blocks
 David N. Bresch, david.bresch@gmail.com, 20160412, n-th largest block or event
 David N. Bresch, david.bresch@gmail.com, 20160421, allow for n loans, plus full amortization at end of loan
 David N. Bresch, david.bresch@gmail.com, 20160422, for historic, make sure last block contains last year
 David N. Bresch, david.bresch@gmail.com, 20160504, drf_global.RDS(3).retention/layer/uncovered added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/disaster_risk_finance_private/code/diana/drf_evaluation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="drf_plot">
<H2>drf_plot</H2></A>
<font color="blue">function drf_plot(verbose) </font>
 climada disaster risk finance drf evaluation tool
 MODULE:
   disaster_risk_finance
 NAME:
   drf_plot
 PURPOSE:
   Plots the results of drf_evaluation, see its code for a full
   description

   All parameters are stored in the global variable drf_global (see
   detailed description in drf_damage_calc)

   Previous call: drf_evaluation (drf_damage_calc)
   See also: diana (the GUI)
 CALLING SEQUENCE:
   drf_plot(verbose)
 EXAMPLE:
   drf_evaluation;drf_plot % usual command sequency to calculate and show results
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   verbose: whether we print regular messages to stdout =1 (default)
       or only severe errors (=0)

   SPECIAL: parameters and data provided via global variable drf_global,
       see drf_damage_calc
 OUTPUTS:
   figures
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160303, separated from drf_evaluation_tool
 David N. Bresch, david.bresch@gmail.com, 20160304, loan calculation implemented
 David N. Bresch, david.bresch@gmail.com, 20160306, separation in drf_evaluation and drf_plot
 David N. Bresch, david.bresch@gmail.com, 20160310, reduction to one figure pane
 David N. Bresch, david.bresch@gmail.com, 20160331, reduction to two plots
 David N. Bresch, david.bresch@gmail.com, 20160412, event plot with partition and histogram
 David N. Bresch, david.bresch@gmail.com, 20160415, bar edge color 'none'
 David N. Bresch, david.bresch@gmail.com, 20160421, special treatment if original years
 David N. Bresch, david.bresch@gmail.com, 20160504, toggle insurance/loan to be shown in upper left panel (drf_global.RDS(3))
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/disaster_risk_finance_private/code/diana/drf_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="MSP_PLS_read">
<H2>MSP_PLS_read</H2></A>
<font color="blue">function PLS=MSP_PLS_read(PLS_file,verbose) </font>
 read MultiSNAP period loss set
 MODULE:
   _LOCAL
 NAME:
   MSP_PLS_read
 PURPOSE:
   read MultiSNAP (MSP) Period Loss Set (PLS) and store it into a MATLAB
   structure. See climada_PLS_read to obtain a Year Damage Set (YDS)

   A PLS .csv file contains:

       id,dataScope,totalPanjerFactor,periodAverageExpectedLoss,repetitionPeriodInYears,aggregationPeriodBeginInYearNormalised,aggregationPeriodEndInYearNormalised,nbrOfYearsSimulation,currencyCode,currencyUnit,mainNatCatHazardTypes
       2003800,201508_1MIO_YEARS,1.0315346447966625,1.5307887560850577E9,1.0,0.0,1.0,2.0E7,USD,1,
       ratingZone,panjerFactor
       651002,1.0315346447966625
       time,eventId,sampleId,event rating zone,period rating zone,loss,periodId
       0.5323603633556622,2400008019,3,651002,651002,24435.731790959577,1
       0.6820032772549107,2400111073,3,651002,651002,748944.8931435767,1
       1.8630114629304617,2394903067,4,651002,651002,4.4794916625730775E7,2
       ...

   therefore, we first read the two double loines of parameters and then
   the full block of data at once (using fscanf, built in and fast)
 CALLING SEQUENCE:
   PLS=MSP_PLS_read(PLS_file,verbose)
 EXAMPLE:
   PLS=MSP_PLS_read
 INPUTS:
   PLS_file: MultiSNAP Period Loss Set (PLS) filename with path.
       if it comes w/o path, {climada_global.data_dir}/results is assumed
       if ='TEST', use sample PLS file, see PARAMETERS section in code
 OPTIONAL INPUT PARAMETERS:
   verbose: =1 print some info to stdout, =0 not (silent, default)
 OUTPUTS:
   PLS: a structure with
       filename: the filename (with path) the data has been read from
      first all header/parameter fileds, as:
       id: MultiSNAP ID
       dataScope: scope description, like '201508_1MIO_YEARS'
       totalPanjerFactor
       periodAverageExpectedLoss
       repetitionPeriodInYears
       aggregationPeriodBeginInYearNormalised
       aggregationPeriodEndInYearNormalised
       nbrOfYearsSimulation: number os years simulated
       currencyCode: like 'USD'
       currencyUnit
       mainNatCatHazardTypes
       ratingZone
       panjerFactor
      and then the data fields, namely:
       time(n)
       eventId(n)
       sampleId(n)
       event_rating_zone(n)
       period_rating_zone(n)
       loss(n)
       periodId(n)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160107, initial
 David N. Bresch, david.bresch@gmail.com, 20160108, check for file exist
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/disaster_risk_finance_private/code/helper_functions/MSP_PLS_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_PLS_read">
<H2>climada_PLS_read</H2></A>
<font color="blue">function YDS=climada_PLS_read(PLS_file,verbose) </font>
 read MultiSNAP period loss set
 MODULE:
   _LOCAL
 NAME:
   climada_PLS_read
 PURPOSE:
   read MultiSNAP (MSP) Period Loss Set (PLS) and convert to
   climada Year Damage Set (YDS)

   calls MSP_PLS_read to read the file and then converts PLS into YDS.
   In essence, adds two fields to render the more complex MSP period set
   compatible with the straightforward climada YDS (year damage set) and
   adds all YDS fields (many with dummy values).

   See MSP_PLS_read for the low-level file i/o
 CALLING SEQUENCE:
   YDS=climada_PLS_read(PLS_file,verbose)
 EXAMPLE:
   YDS=climada_PLS_read
 INPUTS:
   PLS_file: MultiSNAP Period Loss Set (PLS) filename with path.
       if it comes w/o path, {climada_global.data_dir}/results is assumed
       if ='TEST', use sample PLS file, see PARAMETERS section in code
 OPTIONAL INPUT PARAMETERS:
   verbose: =1 print some info to stdout, =0 not (silent, default)
 OUTPUTS:
   YDS, a climada year damage set, structure with the fields:
       reference_year: set to climada_global.present_reference_year
       event_ID: =[], empty, provided for EDS compatibility
       damage(n): the damage for year n
       ED_at_centroid: [], empty, since not provided by MSP
       Value: [], empty, since not provided by MSP
       frequency: the single year frequency compared to the full YDS
       orig_event_flag: [], empty, since not needed for yearset
       peril_ID: set ='XX', since not provided by MSP
       hazard: [], empty, since not provided by MSP
       Value_unit: set to PLS.currencyCode, like 'USD'
       comment: set to ['from MSP PLS: ' PLS.filename]
       assets: [], empty, since not provided by MSP
       damagefunctions: [], empty, since not provided by MSP
       annotation_name: set to 'MSP PLS'
       ED: expected damage, set to average damage over years
       yyyy(n): the year
       orig_year_flag: all =0 since not provided by MSP
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160107, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/disaster_risk_finance_private/code/helper_functions/climada_PLS_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="bf_TEST">
<H2>bf_TEST</H2></A>
 bf_TEST: bushfire TEST batch file 
 MODULE:
   drought_fire
 NAME:
   bf_TEST
 PURPOSE:
   TEST bushfire module
   
   Uses TEST data within the module's data folder (and subfolders). For
   operational use, use the standard climada data folder (see
   climada_global.data_dir), i.e. copy centrpids, entities etc. to the
   respective sub-folders there.

   please refer to the main code climada_bf_hazard_set
 CALLING SEQUENCE:
   bf_TEST
 EXAMPLE:
   bf_TEST
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 beuschl@student.ethz.ch, 20160601, initial, key author
 horatc@student.ethz.ch, 20160601, initial, key author
 david.bresch@gmail.com, 20160601, climada-compatibility
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/drought_fire/code/bf_TEST.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="bf_generator">
<H2>bf_generator</H2></A>
<font color="blue">function bf=bf_generator(number_years,store_intensity_field) </font>
 BF event probabilistic
 MODULE:
   drought_fire
 NAME:
   bf_generator
 PURPOSE:
   generate a hazard event set of bushfires for a specified number of
   years and domain. It is currently set up for the region of Melbourne
   with corresponding data. Next step: climada_bf_hazard_set.m
 CALLING SEQUENCE:
   bf_generator(number_years);
 EXAMPLE:
   bf_generator(5);
 INPUTS:
   number_years: how many years of bushfire you want to simulate
   store_intensity_field: if non-zero: matrix of size dx times dy, 
   bf(i).intensity_field, is stored for all fires. for each fire, fire then 
   can easily be plotted with for instance contourf(bf(1).intensity_field). 
   if 0: matrix bf(i).intensity_field is not stored.
   note: for many years, intensity_field must be set to 0, because not
   enough memory capacity!
 OPTIONAL INPUT PARAMETERS:
   none 
 OUTPUTS: 
   a struct bf where bf(i) is one individual fire:
   with bf(i).lon: array with longitudes of intensities
   with bf(i).lat: array with latitudes of intensities
   with bf(i).intensity: array with intensities at locations (bf(i).lon, bf(i).lat)
   with bf(i).no_year: number of years simulated
   with bf(i).intensity_field: matrix of size dx times dy which contains
   intensities - note: only needed for plots. comment otherwise  needs a 
   lot of memory (see below)
 MODIFICATION HISTORY:
 beuschl@student.ethz.ch, 20160601, initial, key author
 horatc@student.ethz.ch, 20160601, initial, key author
 david.bresch@gmail.com, 20160601, climada-compatibility
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/drought_fire/code/bf_generator.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="bf_generator2">
<H2>bf_generator2</H2></A>
<font color="blue">function bf=bf_generator2(number_years,store_intensity_field) </font>
 BF event probabilistic
 MODULE:
   drought_fire
 NAME:
   bf_generator
 PURPOSE:

   TEST versin to improove speed, dbresch

   generate a hazard event set of bushfires for a specified number of
   years and domain. It is currently set up for the region of Melbourne
   with corresponding data. Next step: climada_bf_hazard_set.m
 CALLING SEQUENCE:
   bf_generator(number_years);
 EXAMPLE:
   bf_generator(5);
   bf_generator(0.01,1): % fast test
 INPUTS:
   number_years: how many years of bushfire you want to simulate
   store_intensity_field: if non-zero: matrix of size dx times dy,
   bf(i).intensity_field, is stored for all fires. for each fire, fire then
   can easily be plotted with for instance contourf(bf(1).intensity_field).
   if 0: matrix bf(i).intensity_field is not stored.
   note: for many years, intensity_field must be set to 0, because not
   enough memory capacity!
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   a struct bf where bf(i) is one individual fire:
   with bf(i).lon: array with longitudes of intensities
   with bf(i).lat: array with latitudes of intensities
   with bf(i).intensity: array with intensities at locations (bf(i).lon, bf(i).lat)
   with bf(i).no_year: number of years simulated
   with bf(i).intensity_field: matrix of size dx times dy which contains
   intensities - note: only needed for plots. comment otherwise  needs a
   lot of memory (see below)
 MODIFICATION HISTORY:
 beuschl@student.ethz.ch, 20160601, initial, key author
 horatc@student.ethz.ch, 20160601, initial, key author
 david.bresch@gmail.com, 20160601, climada-compatibility
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/drought_fire/code/bf_generator2.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="bf_generator_large">
<H2>bf_generator_large</H2></A>
<font color="blue">function hazard=bf_generator_large(csv_file,centroids,hazard_set_file) </font>
 climada template
 MODULE:
   drought_fire
 NAME:
   bf_generator_large
 PURPOSE:
   Process the MODIS5 firms data in order to generate large fires.
   See also bf_generator_small to generate small fires (using a cellular
   automat)

   Please proceed as follows:
   0. run bf=bf_generator_large('TEST') to test whether all works
      This generates a _TEST_BF_hazard_large hazard set
   1. Download the historic fire data (since Nov 2000-today) as .csv file
      from https://firms.modaps.eosdis.nasa.gov/download (the full global
      dataset since 2000 is too large for a single download) and store the
      .csv file as ....
   2. run bf_generate_large to process the data (calls firms_read) and to
      generate the bushfire hazard event set

   previous call: generate an entity, see e.g. climada_nightlight_entity,
   climada_srtm_entity or climada_GDP_entity (all in
   https://github.com/davidnbresch/climada_module_country_risk)
   next call: e.g. climada_EDS_calc

   Citation for both MCD14DL and MCD14ML: This data set was
   provided by the University of Maryland and NASA FIRMS operated by
   NASA/GSFC/ESDIS with funding provided by NASA/HQ
 CALLING SEQUENCE:
   hazard=bf_generator_large(csv_file,param2)
 EXAMPLE:
   hazard=bf_generator_large('TEST') % use the TEST dataset
 INPUTS:
   csv_file: the name and path of the .csv file as downloaded from
       https://firms.modaps.eosdis.nasa.gov/download
       &ampgt promted for filename for if not given
       for TESTS, there is a .csv file for Australia in the drought_fire
       module's data folder, just set csv_file='TEST'. In this case, test
       centroids are used, too.
   centroids: a centroids structure (see climada_centroids_read) or an
       entity structure (in which case entity.assets.lon and .lat are used)
       &ampgt promted for if empty
   hazard_set_file: the filename (and path, optional) of the hazard
       event set. If no path provided, default path ../data/hazards is used
       (and name can be without extension .mat)
       &ampgt promted for if empty
 OPTIONAL INPUT PARAMETERS:
   param2: as an example
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       intensity(event_i,centroid_i), sparse: the hazard intensity of
           event_i at centroid_i
       frequency(event_i): the frequency of each event
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20160703
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/drought_fire/code/bf_generator_large.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_bf_hazard_set">
<H2>climada_bf_hazard_set</H2></A>
<font color="blue">function hazard=climada_bf_hazard_set(bf,centroids,fscrew,areascrew,hazard_set_file) </font>
 climada template
 MODULE:
   drought_fire
 NAME:
   climada_bf_hazard_set
 PURPOSE:
   Generate a BF (bushfire) hazard event set. 

   The TEST case for average fires in Victoria, Australia, see code bf_TEST

   Each fire is attributed to 1 centroid (valid for centroids down to 10km
   resolution, revise if using 1km or finer).

   previous: likely climada_bf_generator.m
   next: e.g climada_EDS_calc
 CALLING SEQUENCE:
   hazard = climada_bf_hazard_set(bf,centroids,fscrew,areascrew,hazard_set_file);
 EXAMPLE:
   hazard = climada_bf_hazard_set;
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   bf: file containing lon, lat, intentsity of each wildfire and number
       of years simulated (the 'proto-hazard set')
   centroids:  centroids in my domain (to contribute intensity to)
   fscrew:     to account for climate change: constant factor I multiply
               frequency with -&ampgt if empty set to 1 by default -&ampgt input in
               format 1+%increase -&ampgt eg for 30% increase fscrew = 1.3
   areascrew:  to account for climate change: constant factor I multiply
               affected area with -&ampgt if empty set to 1 by default -&ampgt input
               in format 1+%increase -&ampgt eg for 30% increase areascrwe = 1.3
 OUTPUTS:
 MODIFICATION HISTORY:
 beuschl@student.ethz.ch, 20160601, initial, key author
 horatc@student.ethz.ch, 20160601, initial, key author
 david.bresch@gmail.com, 20160601, climada-compatibility
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/drought_fire/code/climada_bf_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="firms_read">
<H2>firms_read</H2></A>
<font color="blue">function firms=firms_read(csv_file,check_plot) </font>
 climada template
 MODULE:
   module name
 NAME:
   firms_read
 PURPOSE:
   Read the MODIS5 firms csv data

   Please proceed as follows:
   1. Download the historic fire data (since Nov 2000-today) as .csv file
      from https://firms.modaps.eosdis.nasa.gov/download (the full global
      dataset since 2000 is too large for a single download) and store the
      .csv file as ....
   2. run firms_read to read the data

   next call: bf_generator_large

   Citation for both MCD14DL and MCD14ML: This data set was
   provided by the University of Maryland and NASA FIRMS operated by
   NASA/GSFC/ESDIS with funding provided by NASA/HQ
 CALLING SEQUENCE:
   firms=firms_read(csv_file,check_plot)
 EXAMPLE:
   firms=firms_read('TEST') % use the TEST dataset
 INPUTS:
   csv_file: the name and path of the .csv file as downloaded from
       https://firms.modaps.eosdis.nasa.gov/download
       &ampgt promted for filename for if not given
       for TESTS, there is a .csv file for Australia in the drought_fire
       module's data folder, just set csv_file='TEST'
 OPTIONAL INPUT PARAMETERS:
   param2: as an example
 OUTPUTS:
   firms: the data, a structure with fields
       filename: the original .csv filename with path
       lat(i): latitudes of burning point i
       lon(i): longitudes of burning point i
       brightness(i): brightness of burning point i
       datenum(i): the matlab datenum for each point i, also
           datenum_unique: the unique datenums
           unique_IA: the positions of the first unique elements
           unique_IC: the output of [~,IA,IC]=unique
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20160703, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/drought_fire/code/firms_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="MMI_attenuation_calc">
<H2>MMI_attenuation_calc</H2></A>
<font color="blue">function MMI = MMI_attenuation_calc(mag, dist, dep, correction, a1, a2, a3, a4, b) </font>
 Calculate the attenuation of an earthquake's intensity with distance from
 the epicenter
 MODULE:
 eq_global
 NAME:
   simple_eq_MMI
 PURPOSE:
   calculate MMI at a given distance from the epicenter 
 CALLING SEQUENCE:
   MMI=MMI_attenuation_calc(mag, dist, correction,a1, a2, a3, a4)
 EXAMPLE:
   MMI=MMI_attenuation_calc(7.44,10.0,1.67,1.67,1.3,0.0026);
   MMI=MMI_attenuation_calc(8,15.5)   % using default values for
   depth, correction and the attenuation parameters a1, a2, a3, a4, 
 INPUTS:
   mag:    magnitude
   dist:   distance to epicentre [in km] 
 OPTIONAL INPUTS:
   dep: epicenter depth
   correction, a1,a2,a3,a4,b: parameters defining an attenuation function
   of the type MMI = a1 + a2*mag - a3*log(dist+correction) - a4*dist + b*dep
   where MMI is the Modified Mercalli Intensity at distance dist from the 
   epicenter and dep is the epicenter depth; log denotes the natural
   logarithm
   Have a look at eq_global-master/data/system/attenuation_parameters.xlsx 
   for a compilation of parameters for selected geographic regions
 OUTPUT:
   MMI:    the MMI at distance dist from the epicenter (Modified Mercalli
   Intensity)
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141116
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141209, added correction parameter
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150118, minor clean-up, renaming
% default values for attenuation parameters: dep, correction, a1, a2, a3, a4, b
f ~exist('dep','var') || isempty(dep), dep = 0; end
f ~exist('correction','var') || isempty(correction), correction = 0; end
f ~exist('a1','var') || isempty(a1), a1 = 1.7; end
f ~exist('a2','var') || isempty(a2), a2 = 1.5; end
f ~exist('a3','var') || isempty(a3), a3 = 1.1726; end
f ~exist('a4','var') || isempty(a4), a4 = 0.00106; end
f ~exist('b','var') || isempty(b), b = 0; end
% compute the attenuation equation 
 MMI is kept below a maximum value defined by the equation 
 I_0 = 1.5*(mag - 1), where I_0 is the epicentral intensity (in MMI)
 and mag the Richter magnitude of the earthquake
 Source: Y-X. Hu, S-C. Liu, W. Dong: Earthquake Engineering
aximum_MMI = 1.5*(mag-1);
MI = a1 + a2 * mag - a3 * log(dist+correction) - a4 * dist + b*dep;
f MMI &ampgt maximum_MMI, MMI = maximum_MMI; end
nd
       


View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/MMI_attenuation_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_get_single_event">
<H2>climada_get_single_event</H2></A>
<font color="blue">function single_eq_event = climada_get_single_event(eq_data, event_i) </font>
 get single earthquake event
 MODULE:
 eq_global
 NAME:
   climada_get_single_event
 PURPOSE:
   Extract a single event from a set of hazards
 PREVIOUS STEP:
   Generation of a hazard set, either by reading a set of historic hazard
   events (see eq_isc_gem_read) or by creating a probabilistic hazard
   event set based on a historic event set (see eq_global_probabilistic)
 INPUTS:
   eq_data, a structure with the following fields:
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       hr(line_i)  : origin hour
       min(line_i) : origin min
       sec(line_i) : origin sec
       glat(line_i): geographic latitude
       glon(line_i): geographic longitude
       dep(line_i) : focal depth
       mag(line_i) : magnitude
       country(line_i): country
   event_i: number of the event to be extracted from eq_data. If not
   given, event_i is set to 1
 OUTPUT:
   single_event: a structure with the same fields as eq_data, but 
   containing only the data for the (event_i)th hazard in eq_data
 CAUTIONARY NOTE: 
   This code has only been written for testing purposes
   (namely as a helper function for validate_eq_damage) and might need 
   some improvements for general use
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141213, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/climada_get_single_event.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_centennial_read">
<H2>eq_centennial_read</H2></A>
<font color="blue">function eq_data=eq_centennial_read(centennial_file,check_plot) </font>
 Read Centennial Earthquake Database
 MODULE:
 eq_global
 NAME:
   eq_centennial_read
 PURPOSE:
   Read earthquake (EQ) database, a raw text file downloaded from
   earthquake.usgs.gov/data/centennial/ usually the file
   http://earthquake.usgs.gov/data/centennial/centennial_Y2K.CAT
   
   see the associated readme at
   http://earthquake.usgs.gov/data/centennial/centennial_README.rtf

   next step: see eq_global_probabilistic
 CALLING SEQUENCE:
   eq_data=eq_centennial_read(centennial_file,check_plot)
 EXAMPLE:
   eq_data=eq_centennial_read('',1) % read std file, show epicenters plot
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   centennial_file: the filename of the ASCII text file with the raw data
       if empty, the code tries a default name, if it does not exist, it
       promptes the user to locate the file
   check_plot: show a check plot (=1), or not (=0, default)
 OUTPUTS:
   eq_data, a structure with
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       hr(line_i)  : origin hour
       min(line_i) : origin min
       sec(line_i) : origin sec
       glat(line_i): geographic latitude
       glon(line_i): geographic longitude
       dep(line_i) : focal depth
       mag(line_i) : magnitude
   also stored as .mat file. Please delete the .mat file manually in order
   to re-read from the original .txt file 
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141010, initial
 David N. Bresch, david.bresch@gmail.com, 20141014, some minor improvements
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/eq_centennial_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_global_attenuation">
<H2>eq_global_attenuation</H2></A>
<font color="blue">function intensity_at_centroids = eq_global_attenuation(glat,glon,mag,centroids,check_plot,dep,correction,a1,a2,a3,a4,b) </font>
 Calculate the attenuation of an earthquake's intensity with
 increasing distance from the epicenter
 MODULE:
 eq_global
 NAME:
   eq_global_attenuation
 PURPOSE:
   given an earthquake (EQ) epicenter, defined by glat,glon,dep,mag,
   calculate the resulting intensity at a set of centroids, using an attenuation
   function. Distance is on sphere iro correction for latitude, but no
   great circle distance (for speedup reasons, other errors are bigger).

   In order to speed up the calculation, no consistency checks are done,
   code assumes proper glat,glon,dep,mag and reasonable centroids input

   For basic theory, see e.g. https://en.wikipedia.org/wiki/Peak_ground_acceleration

   To test attenuation functions, see eq_global_attenuation_TEST
   then edit between *********** lines beow

   mainly called from: eq_global_hazard_set
 CALLING SEQUENCE:
   intensity_at_centroids = eq_global_attenuation(glat,glon,dep,mag,centroids,check_plot,a1,a2,a3,a4)
 EXAMPLE:
   for an earthquake in Vancouver, Canada:
   glat=49.25;glon=-123.10;
   intensity_at_centroids = eq_global_attenuation(glat,glon,5,6,centroids,0,1,2.4,1.5,1.13,0.0063)
   The parameters a1=2.4, a2=1.5, a3=1.13, a4=0.0063 describe the
   attenuation function for Western Canada; see
   eq_global-master/data/system/attenuation_parameters.xlsx
 INPUTS:
   glat: latitude of epicenter [in degrees]
   glon: longitude of epicenter [in degrees]
   dep: depth [km] of epicenter
   mag: magnitude (Richter) of epicenter
   centroids: a structure with the centroids information
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
 OPTIONAL INPUT PARAMETERS:
   correction,a1,a2,a3,a4,b: parameters defining the attenuation function. 
   See eq_global-master/data/system/attenuation_parameters.xlsx to use
   parameters for specific regions; otherwise default values representing
   a &quotglobal average attenuation function&quot will be used
   check_plot: =1, if a check plot shall be drawn (default=0)
 OUTPUTS:
   intensity_at_centroids: the MMI at centroids
 RESTRICTIONS:
   code does not quality or even consistency checks, optimized for speed.
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141013
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141106
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/eq_global_attenuation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_global_attenuation_TEST">
<H2>eq_global_attenuation_TEST</H2></A>
<font color="blue">function eq_global_attenuation_TEST </font>
 eq attenuation test
 NAME:
   eq_global_attenuation_TEST
 PURPOSE:
   Test different attenuation functions

   all set in code to allow for maximum flexibility

 CALLING SEQUENCE:
   eq_global_attenuation_TEST
 EXAMPLE:
   eq_global_attenuation_TEST
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   plots attenuation function
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141016
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/eq_global_attenuation_TEST.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_global_hazard_set">
<H2>eq_global_hazard_set</H2></A>
<font color="blue">function hazard=eq_global_hazard_set(eq_data,hazard_set_file,centroids,TEST_epicenter_preselection,correction,a1,a2,a3,a4,b) </font>
 Create earthquake hazard set
 MODULE
 eq_global
 NAME:
   eq_global_hazard_set
 PURPOSE:
   generate an earthqake (EQ) hazard event set, starting from epicenters
   calculating attenuation (distance and depth) to convert Richter
   magnitude to a modified Mercalli intensity (MMI)

   previous step: see eq_global_probabilistic or eq_isc_gem_read (or
   eq_centennial_read, or eq_signieq_read)
 CALLING SEQUENCE:
   
   hazard=eq_global_hazard_set(eq_data,hazard_set_file,centroids)
 EXAMPLE:
   eq_data=eq_global_probabilistic(eq_isc_gem_read); % global
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   hazard=eq_global_hazard_set(eq_data,'_EQ_TEST',centroids);
   %hazard=eq_global_hazard_set(eq_global_probabilistic(eq_isc_gem_read))
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   eq_data: a structure with EQ epicenters, see eq_isc_gem_read
       &ampgt promted for if not given
   hazard_set_file: the name and path of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes
           Latitude(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a .mat-file which contains a centroids struct (saved by
       climada_centroids_read) or the filename of an Excel file (the original
       input to climada_centroids_read) which holds the centroids, in
       which case climada_centroids_read is called.
       &ampgt promted for .mat or .xls filename if not given
       NOTE: if you then select Cancel, a regular default grid is used
       (TEST mode), see hard-wired definition in code (a rectangular area in California)
   TEST_epicenter_preselection: whether we show the epicenters selected
       for processing (=1) or not (=0, default)
       if =2, STOP after plot of preselection (to check preselection only)
   correction,a1,a2,a3,a4,b: parameters defining the attenuation function. See
       eq_global-master/data/system/attenuation_parameters.xlsx to use
       parameters for specific regions; otherwise the function
       eq_global_attenuation will use default values that represent a &quotglobal
       average attenuation function&quot
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'EQ' for
       earthquake
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)

   simple check for hazard content: hist(full(hazard.intensity(find(hazard.intensity))))
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141012
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141223, added correction,a1,a2,a3,a4
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150120, hazard_arr_density=0.01
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, parfor speedup, factor 3-5
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/eq_global_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_global_hazard_set_slow">
<H2>eq_global_hazard_set_slow</H2></A>
<font color="blue">function hazard=eq_global_hazard_set_slow(eq_data,hazard_set_file,centroids,TEST_epicenter_preselection,correction,a1,a2,a3,a4,b) </font>
 Create earthquake hazard set
 MODULE
 eq_global
 NAME:
   eq_global_hazard_set
 PURPOSE:
   SLOW version of eq_global_hazard_set

   generate an earthqake (EQ) hazard event set, starting from epicenters
   calculating attenuation (distance and depth) to convert Richter
   magnitude to a modified Mercalli intensity (MMI)

   previous step: see eq_global_probabilistic or eq_isc_gem_read (or
   eq_centennial_read, or eq_signieq_read)
 CALLING SEQUENCE:
   hazard=eq_global_hazard_set_slow(eq_data,hazard_set_file,centroids)
 EXAMPLE:
   hazard=eq_global_hazard_set_slow(eq_global_probabilistic(eq_isc_gem_read))
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   eq_data: a structure with EQ epicenters, see eq_isc_gem_read
       &ampgt promted for if not given
   hazard_set_file: the name and path of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes
           Latitude(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a .mat-file which contains a centroids struct (saved by
       climada_centroids_read) or the filename of an Excel file (the original
       input to climada_centroids_read) which holds the centroids, in
       which case climada_centroids_read is called.
       &ampgt promted for .mat or .xls filename if not given
       NOTE: if you then select Cancel, a regular default grid is used
       (TEST mode), see hard-wired definition in code (a rectangular area in California)
   TEST_epicenter_preselection: whether we show the epicenters selected
       for processing (=1) or not (=0, default)
       if =2, STOP after plot of preselection (to check preselection only)
   correction,a1,a2,a3,a4,b: parameters defining the attenuation function. See
       eq_global-master/data/system/attenuation_parameters.xlsx to use
       parameters for specific regions; otherwise the function
       eq_global_attenuation will use default values that represent a &quotglobal
       average attenuation function&quot
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'EQ' for
       earthquake
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)

   simple check for hazard content: hist(full(hazard.intensity(find(hazard.intensity))))
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141012
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141223, added correction,a1,a2,a3,a4
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150120, hazard_arr_density=0.01
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, renamed to eq_global_hazard_set_slow
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/eq_global_hazard_set_slow.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_global_probabilistic">
<H2>eq_global_probabilistic</H2></A>
<font color="blue">function eq_data=eq_global_probabilistic(eq_data_in,ens_size,check_plot) </font>
 generate probabilistic hazard set
 MODULE:
 eq_global
 NAME:
   eq_global_probabilistic
 PURPOSE:
   Given an earthquake(EQ) database, create a probabilistic version by
   wiggling location, depth and magnitudes of epicenters

   previous step: see eq_isc_gem_read, eq_centennial_read, or eq_signigeq_read
   next step: see eq_global_hazard_set
 CALLING SEQUENCE:
   eq_data=eq_global_probabilistic(eq_data_in,check_plot)
 EXAMPLE:
   eq_data=eq_global_probabilistic(eq_centennial_read,9,1)
 INPUTS:
   eq_data_in: an EQ database, see eq_centennial_read
 OPTIONAL INPUT PARAMETERS:
   ens_size: ensemble size, the number of 'copies' of the original
       database we create, default=9 (means 10x as original data)
   check_plot: show a check plot (=1), or not (=0, default)
 OUTPUTS:
   eq_data, a structure with
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       hr(line_i)  : origin hour
       min(line_i) : origin min
       sec(line_i) : origin sec
       glat(line_i): geographic latitude
       glon(line_i): geographic longitude
       dep(line_i) : focal depth
       mag(line_i) : magnitude
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141010, initial
 David N. Bresch, david.bresch@gmail.com, 20160423, rand('seed',0) --&ampgt rng(0)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/eq_global_probabilistic.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_isc_gem_read">
<H2>eq_isc_gem_read</H2></A>
<font color="blue">function [eq_data,isc_gem_file_mat]=eq_isc_gem_read(isc_gem_file,check_plot) </font>
 read ISC-GEM earthquake catalogue
 EQ eq data read
 NAME:
   isc_gem_read
 PURPOSE:
   Read earthquake (EQ) database, a .csv file downloaded from
   www.isc.ac.uk/iscgem/download.php
   for further information on the earthquake catalogue, see
   www.isc.ac.uk/iscgem/index.php

   Note: it can sometimes happen that the original epicenters file
   isc-gem-cat.csv gets currupted. Just donwload it from
   www.isc.ac.uk/iscgem/download.php (or directly
   http://colossus.iris.washington.edu/iscgem/download/isc-gem-cat.zip)
   again. 

   next step: see eq_global_probabilistic
 CALLING SEQUENCE:
   [eq_data,isc_gem_file_mat]=eq_isc_gem_read(isc_gem_file,check_plot)
 EXAMPLE:
   eq_data=eq_isc_gem_read('',1) % read std file, show epicenters plot
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   isc_gem_file: the filename of the .csv file with the raw data
       if empty, the code tries a default name, if it does not exist, it
       prompts the user to locate the file
   check_plot: show a check plot (=1), or not (=0, default)
 OUTPUTS:
   eq_data, a structure with
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       hr(line_i)  : origin hour
       min(line_i) : origin min
       sec(line_i) : origin sec
       glat(line_i): geographic latitude
       glon(line_i): geographic longitude
       dep(line_i) : focal depth
       mag(line_i) : magnitude (moment magnitude, mw)
       &ampgt also stored as .mat file. Please delete the .mat file manually in order
       to re-read from the original .csv file 
   isc_gem_file_mat: the name of the .mat file eq_data is stored to
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141117
 David N. Bresch, david.bresch@gmail.com, 20141210, date conversion revised
 David N. Bresch, david.bresch@gmail.com, 20141223, issue with .csv file noted
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/eq_isc_gem_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_signigeq_read">
<H2>eq_signigeq_read</H2></A>
<font color="blue">function eq_data=eq_signigeq_read(signigeq_file,check_plot) </font>
 Read Significant Earthquake Database
 MODULE:
 eq_global
 NAME:
   eq_signigeq_read
 PURPOSE:
   Read earthquake (EQ) database, an .xlsx file downloaded from
   www.ngdc.noaa.gov/nndc/struts/form?t=101650&amps=1&ampd=1

   for MATLAB to be able to read the .xlsx file, open it once in Excel,
   convert columns SECOND, LATITUDE and LONGITUDE to Number format and
   save as signigeq_CLEAN.xlsx (otherwise you will likely get errors of
   the kind &quotError using xlsread, Invalid zip file ... &quot

   next step: see eq_global_probabilistic
 CALLING SEQUENCE:
   eq_data=eq_signigeq_read(signigeq_file,check_plot)
 EXAMPLE:
   eq_data=eq_signigeq_read('',1) % read std file, show epicenters plot
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   signigeq_file: the filename of the .xlsx file with the raw data
       if empty, the code tries a default name, if it does not exist, it
       promptes the user to locate the file
   check_plot: show a check plot (=1), or not (=0, default)
 OUTPUTS:
   eq_data, a structure with
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       hr(line_i)  : origin hour
       min(line_i) : origin min
       sec(line_i) : origin sec
       glat(line_i): geographic latitude
       glon(line_i): geographic longitude
       dep(line_i) : focal depth
       mag(line_i) : magnitude
   also stored as .mat file. Please delete the .mat file manually in order
   to re-read from the original .xlsx file 
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141015, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/eq_signigeq_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="plot_attenuation_parameters">
<H2>plot_attenuation_parameters</H2></A>
<font color="blue">function plot_attenuation_parameters(mag,attenuation_file,dep) </font>
 Plot attenuation curves
 MODULE:
 eq_global
 NAME:
   plot_attenuation_parameters
 PURPOSE:
   plot the attenuation functions defined by the sets of parameters in
   earthquake_volcano/data/system/attenuation_parameters.xlsx, for a
   given magnitude
 CALLING SEQUENCE:
   plot_attenuation_parameters(magnitude, filename)
 EXAMPLE:
   plot_attenuation_parameters(8)
   plot_attenuation_parameters
 OPTIONAL INPUTS:
   mag: Richter magnitude at epicenter. If empty, 8 is used as
   default value
   attenuation_file: Name of the file that contains the attenuation 
   parameters. 
   If empty, the code tries a default name, if it does not exist, it
   prompts the user to locate the file
   dep: epicenter depth (only makes a difference for attenuation functions
   with a depth-dependent term
 OUTPUT:
   A plot showing the attenuation of intensity with distance for each set
   of parameters and for the magnitude specified in the input
 COMMENT:
   The parameters a1, a2, a3, and a4 describe an attenuantion of the type
   MMI(dist) = a1 + a2*mag - a3*log(dist+correction) - a4*dist + b*dep 
       where
       mag is the Richter magnitude at the epicenter
       dist is the distance from the epicenter (in km)
       dep is the epicenter depth
       MMI is the Mercalli Modified Intensity at distance dist from the
       epicenter

 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141209, initial
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150123, inlcuded dep and correction
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/plot_attenuation_parameters.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="plot_gutenberg_richter">
<H2>plot_gutenberg_richter</H2></A>
<font color="blue">function plot_gutenberg_richter(eq_data)  </font>
 plot a Gutenberg Richter curve
 MODULE
 eq_global
 NAME:
   plot_gutenberg_richter
 PURPOSE:
   produces a plot showing the relationship between the
   magnitude and total number of earthquakes of at least that 
   magnitude 
   see http://en.wikipedia.org/wiki/Gutenberg%E2%80%93Richter_law 
   for some background
 CALLING SEQUENCE:
   plot_gutenberg_richter(eq_data)
 EXAMPLE:
   eq_data = eq_isc_gem_read   % read historic earthquakes 
   eq_data_prob = eq_global_probabilistic(eq_data) % create probabilistic event set
   plot_gutenberg_richter(eq_data_prob)
 COMMENT:
   eq_data can be a historic data set directly generated by eq_isc_gem_read 
   or a set of probabilistic events generated based on the historic data 
   using eq_global_probabilistic
 INPUT:
   eq_data, a structure with
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       hr(line_i)  : origin hour
       min(line_i) : origin min
       sec(line_i) : origin sec
       glat(line_i): geographic latitude
       glon(line_i): geographic longitude
       dep(line_i) : focal depth
       mag(line_i) : magnitude

 OUTPUT:
   A plot showing the relationship between earthquake magnitude (mag) and 
   its relative occurrence (N/N_tot, where N is the number
   of events having a magnitude &ampgt=mag and N_tot is the total number of
   earthquakes in eq_data). The plot also shows a power law fit to the 
   input data, of form N/N_tot = 10^(a-b*mag). The parameter b, which is 
   commonly close to 1.0 in seismically active regions, can be used as a
   first check whether the input data fits empirical relations between
   earthquake magnitude and occurrence frequency

 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141119, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/plot_gutenberg_richter.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="validate_eq_damage">
<H2>validate_eq_damage</H2></A>
<font color="blue">function eq_data_calculated_damage = validate_eq_damage(eq_data, check_plot) </font>
 Calculate damages of single earthquakes (and compare to historic data)
 MODULE:
 eq_global
 NAME:
   validate_eq_damage
 PURPOSE:
   Calculate the damages (in USD) of individual events, e.g., to compare
   them to historic damage data for validation purposes 
 CALLING SEQUENCE:
   eq_data_calculated_damage = validate_eq_damage(eq_data)
 EXAMPLE:
   eq_data_calculated_damage = validate_eq_damage
 OPTIONAL INPUTS:
   eq_data, a structure generated by reading a catalog of historic
   earthquakes (see eq_isc_gem_read) or by 'boosting' historic earthquakes
   to a probabilistic event set (see eq_global_probabilistic). 
   eq_data contains the following fields:
       yyyy(line_i)    : year
       mm(line_i)      : month
       dd(line_i)      : day
       hr(line_i)      : origin hour
       min(line_i)     : origin min
       sec(line_i)     : origin sec
       glat(line_i)    : geographic latitude
       glon(line_i)    : geographic longitude
       dep(line_i)     : focal depth
       mag(line_i)     : magnitude
       country(line_i) : country

   Alternatively, eq_data can also be a filename of a saved eq_data
   structure, or the filename of an excel file to read the earthquake data
   from (e.g., the file signieq_table_for_validation.xls in 
   eq_global/data/epicenters). 
   In the latter case, the excel sheet needs to have the following
   fields:
       YEAR        : year when the earthquake happened
       MONTH       : month
       DAY         : day
       HOUR        : hour
       MINUTE      : minute
       SECOND      : second
       FOCAL_DEPTH : hypocenter depth (km)   
       MAGNITUDE   : Richter magnitude of the earthquake
       COUNTRY     : country 
       LATITUDE    : geographic latitude
       LONGITUDE   : geographic longitude
       DAMAGE_DOLLARS (optional): damage data in USD (historic estimates)

   If eq_data is not given, a dialog box opens to prompt for it.

   check_plot: show a plot of the calculated damages (=1), or not
   (=0, default). If eq_data contains estimated damage values, these data are 
   plotted as well to allow for comparison and the mean ratio of
   calculated to estimated damage is displayed.
 
 OUTPUTS:
   eq_data_calculated_damage: eq_data with an additional field  
   'calculated damage' containing the calculated damages (in USD)
   of the earthquakes

 COMMENT:
 Generating the entities and centroids via climada_create_GDP_entity can
 be pretty time consuming for large countries. If the country-specific 
 entities and centroids are already available as .mat files, the code will
 skip that step and load them directly from those .mat files instead. In
 order for this to work, the entity files need to be placed
 in the /data/entities directory of the climada-master module, and named 
 in the following way:
 ISO3_countryname_centroids.mat (e.g. ITA_Italy_centroids.mat),
 and the centroids need to be placed in the /data/system directory of the
 climada-master module, and named in the following way:
 ISO3_countryname_entity.mat (e.g. ITA_Italy_entity.mat)
 
 CAUTIONARY NOTE:
 This code was only produced for testing purposes and has not been
 optimized for general applications - it might therefore need some
 adjustment to work properly in different environments.

 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141212, initial
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150123, minor changes
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/validate_eq_damage.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="vq_global_hazard_set">
<H2>vq_global_hazard_set</H2></A>
<font color="blue">function hazard=vq_global_hazard_set(vq_data,hazard_set_file,centroids,TEST_volcano_preselection) </font>
 Create volcanoe hazard set
 MODULE
 eq_global
 NAME:
   vq_global_hazard_set
 PURPOSE:
   generate a volcano (VQ) hazard event set, starting from volcano data
   calculating ash thickness (distance and depth).

   previous step: see vq_volcano_list_read and vq_global_probabilistic
 CALLING SEQUENCE:
   hazard=vq_global_hazard_set(vq_data,hazard_set_file,centroids)
 EXAMPLE:
   hazard=vq_global_hazard_set(vq_volcano_list_read)
   hazard=vq_global_hazard_set(vq_volcano_list_read,'',[],1) % TEST
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   vq_data: a structure with volcano information, see vq_volcano_list_read
       &ampgt promted for if not given
   hazard_set_file: the name and path of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes
           Latitude(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a .mat-file which contains a centroids struct (saved by
       climada_centroids_read) or the filename of an Excel file (the original
       input to climada_centroids_read) which holds the centroids, in
       which case climada_centroids_read is called.
       &ampgt promted for .mat or .xls filename if not given
       NOTE: if you then select Cancel, a regular default grid is used
       (TEST mode), see hard-wired definition in code (a rectangular area in California)
   TEST_volcano_preselection: if =1, check and show centroids and volcano
       positions, if =2 STOP after check, Default=0, no check
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'EQ' for
       earthquake
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)

   simple check for hazard content: hist(full(hazard.intensity(find(hazard.intensity))))
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150302, initial
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/vq_global_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="vq_global_probabilistic">
<H2>vq_global_probabilistic</H2></A>
<font color="blue">function vq_data=vq_global_probabilistic(vq_data,ens_size,check_plot) </font>
 generate probabilistic hazard set
 MODULE:
   eq_global
 NAME:
   vq_global_probabilistic
 PURPOSE:
   Given a volcano (VQ) database, create a probabilistic version by
   wiggling duration, cloud height, wind direction and speed...

   First, add wind speed and direction (from climatolog) to historic
       eruptions. For those historic eruptions with no known month, add mean
       wind.
   Second, generate 11 times the events and add the 'missing' months winds
       For historic eruptions without wind, use January wind for historic
   Third, generate probabilistic eruptions

   previous step: see vq_volcano_list_read
   next step: see vq_global_hazard_set
 CALLING SEQUENCE:
   vq_data=vq_global_probabilistic(vq_volcano_list_read,ens_size,check_plot)
 EXAMPLE:
   vq_data=vq_global_probabilistic(vq_volcano_list_read,9,1)
 INPUTS:
   vq_data: an volcano (VQ) database, see vq_volcano_list_read
 OPTIONAL INPUT PARAMETERS:
   ens_size: ensemble size, the number of 'copies' of the original
       database we create, default=9 (means 10x as original data)
       if =0, the data is only enriched by wind climatology and no
       probabilistic eruptions are generated (for historic events with no
       month indicated, the annual mean wind is used).
       if =1, the data is 'replicated' 11 additional times, to reflect the
       wind climatology each month.
       if &ampgt1, it's really replicating other parameters, mainly Cloud_height_km
       parameters are sampled ens_size-1 times, the final event count is
       thus n_orig_events*12*(ens_size-1)
   check_plot: show a check plot (=1), or not (=0, default)
 OUTPUTS:
   vq_data, same as output of vq_volcano_list_read (see there), just for
       (many) more eruptions, plus U_vel_kmh an U_vel_rad added
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150307, initial
 David N. Bresch, david.bresch@gmail.com, 20160423, rand('seed',0) --&ampgt rng(0)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/vq_global_probabilistic.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="vq_tephra_field_cm">
<H2>vq_tephra_field_cm</H2></A>
<font color="blue">function T=vq_tephra_field_cm(centroids,lon,lat,H,U_vel,U_phi,tau,check_plot) </font>
 Create volcanoe hazard set
 MODULE
 eq_global
 NAME:
   vq_tephra_field_cm
 PURPOSE:
   Calculate the tephra (ash) field thickness for one eruption at
   centroids. The eroption is characterized by (obviously) the coordinate
   of the eruption center, the eruptive column height, the prevailing wind
   and the duration of the eruption.

   according to A. O. Gonzalez-Mellado and S. De la Cruz-Reyna, 2010: A
   simple semi-empirical approach to model thickness of ash-deposits for
   different eruption scenarios. Nat. Hazards Earth Syst. Sci., 10,
   2241?2257, 2010, direct:
   www.nat-hazards-earth-syst-sci.net/10/2241/2010/nhess-10-2241-2010.pdf

   Variable parameters are distance r between centroid(i) and eruption
   center and phi, angle between the wind direction and the vector from
   the ash emission center to centroid(i).

   Some PARAMETERS set in code, see below, also defaults

   previous step: see vq_global_hazard_set (usually colled from there)
 CALLING SEQUENCE:
   T=vq_tephra_field_cm(centroids,lon,lat,H,U_vel,U_phi,tau)
 EXAMPLE:
   lon=14.426;lat=40.821; % Vesuvius
   centroids.lon=lon-1:.01:lon+1;centroids.lat=centroids.lon*0+lat; % 1D cross-section
   T=vq_tephra_field_cm(centroids,lon,lat,15,50,0,1);
   plot((centroids.lon-lon)*100,T);hold on;plot([0 0],[0 max(T)],'-r');
   xlabel('approx km');ylabel('ash thickness [cm]')

   [X,Y]=meshgrid(lon-1:.01:lon+1,lat-1:.01:lat+1); % 2D grid
   centroids.lon=reshape(X,numel(X),1);centroids.lat=reshape(Y,numel(X),1); % 2D grid
   T=vq_tephra_field_cm(centroids,lon,lat,15,50,0,1,1); % last '1' for plot

   % As in Fig. 11 of cited paper: 30 June 1997 Popocatepetl eruption
   T=vq_tephra_field_cm(centroids,lon,lat,8,80,312/360*pi,0.58,1); % last '1' for plot

 INPUTS:
   centroids: a structure with lon(i) and lat(i) of all the points we'd
       like to obtain the tephra field thickness for
   lon: the longitude (scalar) of the eruption center
   lat: the latitude of the eruption center
 OPTIONAL INPUT PARAMETERS:
   H: eruptive column height in km
   U_vel: wind velocity in km/h, indicative 50-100 km/h most often.
   U_phi: direction of wind in radian (-pi..pi), counterclockwise from
       (dx=1,dy=0), i.e. from direction East, West=pi, North=pi/2
   tau: duration of the high-intensity phase of the eruption in hours
       (e.g. Pinatubo 1-5h) default=8h
   check_plot: =1, show check plot, =0 not (default)
 OUTPUTS:
   T: the height of the tephra field (in cm) at each centroid
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150302, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/vq_tephra_field_cm.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="vq_volcano_list_read">
<H2>vq_volcano_list_read</H2></A>
<font color="blue">function [vq_data,volcano_list_file_mat]=vq_volcano_list_read(volcano_list_file,check_plot) </font>
 read ISC-GEM earthquake catalogue
 EQ eq data read
 NAME:
   eq_GVP_volcano_list_read
 PURPOSE:
   Read volcano (VQ) database, either

   GVP_Volcano_List.xls from http://www.volcano.si.edu
   (more volcanoes, but less information)

   or

   NGDC_SignificantVolcanicEvents.xls from
   http://www.ngdc.noaa.gov/nndc/struts/results?type_15=Like&ampquery_15=&ampop_30=eq
   &ampv_30=&ampge_23=&ample_23=&ampop_29=eq&ampv_29=&amptype_16=Like&ampquery_16=&ample_17=&ampge_18=
   &ample_18=&ampge_17=&ampop_20=eq&ampv_20=&ampge_7=&ample_7=&ampbt_24=&ampst_24=&amptype_25=EXACT
   &ampquery_25=None+Selected&ampbt_26=&ampst_26=&amptype_27=EXACT&ampquery_27=None+Selected
   &amptype_12=Exact&ampquery_12=&amptype_11=Exact&ampquery_11=&ampt=102557&amps=50&ampd=50
   (more information, but less volcanoes)

   next step: see vq_global_probabilistic
 CALLING SEQUENCE:
   [vq_data,vq_data_file_mat]=vq_volcano_list_read(volcano_list_file_mat,check_plot)
 EXAMPLE:
   [vq_data,vq_data_file_mat]=vq_volcano_list_read % returns NGDC...
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   volcano_list_file: the filename of the .xls file with the tab
       volacano_list with volcano information
       if empty, the code tries a default name, if it does not exist, it
       prompts the user to locate the file
       Two short options are possible, too: 'GVP' or 'NGDC', see above
       Default is 'NGDC', as this list contains more parameters
   check_plot: show a check plot (=1), or not (=0, default)
 OUTPUTS:
   vq_data, a structure with either (for
       NGDC_SignificantVolcanicEvents.xls)
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       lat(line_i): geographic latitude
       lon(line_i): geographic longitude
       elevation_m(line_i) : the elevation of the volcano
       mag(line_i) : magnitude (moment magnitude, mw)
       ...and other fields, same names as column headers in Excel
   or for GVP_Volcano_List.xls
       lat(i): geographic latitude
       lon(line_i): geographic longitude
       elevation_m(line_i) : the elevation of the volcano
       filename: the filename the data has been read from
       Volcano_Number(i)
       Volcano_Name{i}
       country_name{i}
       Primary_Volcano_Type{i}
       Activity_Evidence{i}
       Last_Known_Eruption{i}
       Region{i}
       Subregion{i}
       Dominant_Rock_Type{i}
       Tectonic_Setting{i}
       &ampgt also stored as .mat file. Please delete the .mat file manually in order
       to re-read from the original .xls file
   volcano_list_file_mat: the name of the .mat file vq_data is stored to
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150217, initial
 David N. Bresch, david.bresch@gmail.com, 20150223, some trimming
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/earthquake_volcano/code/vq_volcano_list_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_srtm_entity">
<H2>climada_srtm_entity</H2></A>
<font color="blue">function [entity,centroids,SRTM_info]=climada_srtm_entity(centroidsORcountryORshapes,check_plot) </font>
 climada template
 MODULE:
   elevation_models
 NAME:
   climada_srtm_entity
 PURPOSE:
   Starting grom SRTM digital elevation model (90m), construct a country
   entity an the corresponding centroids, save both with standard names,
   i.e. III_{country_name}_SRTM_{entity|centroids}, with III the 3-digit
   iso code and country_name with no spaces, e.g. UnitedStates.

   check using climada_entity_plot and climada_centroids_plot
   please note that you need to run climada_EDS_calc with
   force_re_encode=1 unless you re-generate the hazard with the controids
   as generated here. Even better, run climada_assets_encode and save the
   encoded entity (
 CALLING SEQUENCE:
   entity=climada_srtm_entity(centroidsORcountryORshapes,check_plot)
 EXAMPLE:
   entity=climada_srtm_entity('Tuvalu')
 INPUTS:
   centroidsORcountryORshapes:  can be a country_name 'El Salvador', or
       coordinates of the rectangle box to get topography within [lonmin lonmax latmin latmax]
       or centroids (as e.g. from climada_centroids_load)
       handed over to climada_srtm_get, see there
 OPTIONAL INPUT PARAMETERS:
   check_plot: show a check plot, if =1, (default=0)
       if negative, omit calculation of distance2coast_km (which easily
           takes a few minutes)
 OUTPUTS:
   entity: a climada entity structure, see climada_entity_read for format
       description
   centroids: a climada centroids structure, see climada_centroids_read
   SRTM_info: just handed over from climada_srtm_get, see there
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20160514, initial (Rotterdam)
 david.bresch@gmail.com, 20160516, full compatibility with eg centroids_generate_hazard_sets
 david.bresch@gmail.com, 20160529, Cancel pressed works
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/elevation_models/code/climada_srtm_entity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_srtm_get">
<H2>climada_srtm_get</H2></A>
<font color="blue">function [SRTM,srtm_info] = climada_srtm_get(centroidsORcountryORshapes,check_plot,save_tile,verbose) </font>
 climada
 MODULE:
   elevation_models
 NAME:
   climada_srtm_get
 PURPOSE:
   Read the digital elevation model data from the files in an existing
   srtm directory. Data can be downloaded from http://srtm.csi.cgiar.org/SELECTION/inputCoord.asp
   or http://srtm.csi.cgiar.org/index.asp

   The code tries to automatically get the tiles from
   http://droppr.org/srtm/v4.1/6_5x5_TIFs/ (see SRTM_URL in PARAMETERS in
   code). If this fails, the list of required tiles of the SRTM is printed
   to stdout for the suer to manually retrieve
 CALLING SEQUENCE:
   [SRTM,srtm_info] = climada_srtm_get(centroidsORcountryORshapes,check_plot,save_tile,verbose)
 EXAMPLE:
   [SRTM,srtm_info] = climada_srtm_get('Switzerland',1,1,1)

   SRTM = climada_srtm_get('El Salvador',1,0)
   SRTM = climada_srtm_get([-89.15 -89.1 13.695 13.73],1,0) % las canas area, San Salvador
   SRTM = climada_srtm_get([min_lon max_lon min_lat max_lat],1,0)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   centroidsORcountryORshapes:  can be a country_name 'El Salvador', or
       coordinates of the rectangle box to get topography within [lonmin lonmax latmin latmax]
       or centroids (as e.g. from climada_centroids_load)
   check_plot: show a check plot, if =1, (default=0)
   save_tile: =1: save the respective SRTM tiles, in order to speed up in
       subsequent calls. =0 (default): do not save anything
       Warning: the user is responsible for managing such tiles in the
       ../data/results folder
   verbose: =1 print info, =0 not (default)
 OUTPUTS:
   SRTM: a structure, with
       .x(i,j): the longitude coordinates
       .y(i,j): the latitude coordinates
       .h(i,j): the elevation [m, negative below sea level]
       sourcefile: the source file (e.g. .../srtm_18_10.tif)
   If save_tile=1, the tile as returned is also saved to
       ../data/results/etopo_*
 MODIFICATION HISTORY:
 muellele@gmail.com, 20150723, init based on climada_90m_DEM by Gilles Stassen and etopo_get by David Bresch
 david.bresch@gmail.com, 20160122, srtm folder moved, some fixes (removed hard-wired paths)
 david.bresch@gmail.com, 20160126, automatic retrieve implemented
 david.bresch@gmail.com, 20160126, single precision (half the memory need)
 david.bresch@gmail.com, 20160513, issue southern hemisphere solved
 david.bresch@gmail.com, 20160529, Cancel pressed works
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/elevation_models/code/climada_srtm_get.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="etopo_elevation_m">
<H2>etopo_elevation_m</H2></A>
<font color="blue">function elevation_m=etopo_elevation_m(lon,lat,check_plot) </font>
 climada elevation m etopo
 MODULE:
   etopo
 NAME:
   etopo_elevation_m
 PURPOSE:
   obtain elevation in m (based on ETOPO)

   See etopo_get for any further information about ETOPO. See
   http://www.ngdc.noaa.gov/mgg/global/global.html and the readme files in
   .../etopo/data. Since ETOPO1 is globally consistent, its use is highly
   recommended (use ETOPO2 only if e.g. running in memory issues).
 CALLING SEQUENCE:
   elevation_m=etopo_elevation_m(lon,lat,check_plot)
 EXAMPLE:
   elevation_m=etopo_elevation_m(lon,lat)
 INPUTS:
   lon: vector of longitues
   lat: vector of latitudes
 OPTIONAL INPUT PARAMETERS:
   check_plot: =1: show circle plot for check, only works for more than
       one point
       =0: no plot (default)
 OUTPUTS:
   elevation_m: elevation in m for each lat/lon (ocean depth for below sea
       level)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141226, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/elevation_models/code/etopo_elevation_m.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="etopo_get">
<H2>etopo_get</H2></A>
<font color="blue">function ETOPO=etopo_get(etopo_coords,check_plot,save_tile) </font>
 climada topography ETOPO bathymetry
 NAME:
   etopo_get
 PURPOSE:
   get a chunk (tile) of the global ETOPO elevation (and bathymetry) dataset.

   Test it calling etopo_get without any argument (you should get an area
   around Switzerland)

   There are two datasets, ETOPO1 in high-res and ETOPO2 in mid-res. See
   http://www.ngdc.noaa.gov/mgg/global/global.html and the readme files in
   .../etopo/data. Since ETOPO1 is globally consistent, it?s use is highly
   recommended (use ETOPO2 only if e.g. running in memory issues).

   If there is no data file, means no file .../etopo/data/ETOPO1.nc,
   proceed as follows:
   1. Download the file
      http://www.ngdc.noaa.gov/mgg/global/relief/ETOPO1/data/ice_surface/grid_registered/netcdf/ETOPO1_Ice_g_gmt4.grd.gz
   2. Move it to .../etopo/data/
   3. Unzip it (it might do so automatically, e.g. on a Mac)
   4. Rename it to ETOPO1.nc
   5. Test it using etopo_get without any argument (you should get an area
      around Switzerland)

 CALLING SEQUENCE:
   ETOPO=etopo_get(etopo_coords,check_plot,save_tile)
 EXAMPLE:
   ETOPO=etopo_get([4 14 43 53])
 INPUTS:
   etopo_coords: the rectangle to get topography within
       [lonmin lonmax latmin latmax]
       if empty (or not provided): TEST mode, you should get an area
       around Switzerland - and the elevation is plotted, too.
 OPTIONAL INPUT PARAMETERS:
   check_plot: show a check plot, if =1, (default=0)
   save_tile: =1: save the respective etopo tile, in order to speed up in
       subsequent calls. =0 (default): do not save anything
       Warning: the user is responsible for managing such tiles in the
       ../data/results folder
       The option has mainly been introduced to support use of etopo_get
       under Octave, which does not yert provide ncread. Please note that
       check_plot does not work on subsequent calls.
 OUTPUTS:
   ETOPO: a structure, with
       x(i,j): the longitude coordinates
       y(i,j): the latitude coordinates
       h(i,j): the elevation [m, negative below sea level]
       sourcefile: the source file (.../ETOPO1.nc)
   If save_tile=1, the tile as returned is also saved to
       ../data/results/etopo_*
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140422
 David N. Bresch, david.bresch@gmail.com, 20141022, small fix if requested area ourside limits (just a FIX, not a nice one, see below)
 David N. Bresch, david.bresch@gmail.com, 20150101, save_tile
 David N. Bresch, david.bresch@gmail.com, 20160526, better error messaging for ETOPO issues
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/elevation_models/code/etopo_get.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hdr_read">
<H2>climada_hdr_read</H2></A>
<font color="blue">function min_max_lon_lat = climada_hdr_read(tif_filename) </font>
 climada
 MODULE:
   etopo
 NAME:
   climada_hdr_read
 PURPOSE:
   Read hdr files that go together with tif files and get coordinates
   information (upper left, lower left, upper right, lower right)
 CALLING SEQUENCE:
    min_max_lon_lat = climada_hdr_read(tif_filename)
 EXAMPLE:
   min_max_lon_lat = climada_hdr_read('...\etopo\data\srtm_19_10.tif')
 INPUTS:
   tif_filename: a char or a cell with one or multiple tif-filenames (e.g.
   ...etopo\data\srtm_19_10.tif)
 OUTPUTS:
   min_max_lon_lat: a 1x4 matrix with [min_lon max_lon min_lat max_lat] data
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150723, init based on climada_90m_DEM by Gilles Stassen
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/elevation_models/code/helper_functions/climada_hdr_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_srtm_info">
<H2>climada_srtm_info</H2></A>
<font color="blue">function [srtm_info,is_mat] = climada_srtm_info(centroidsORcountryORshapes,silent_mode) </font>
 climada
 MODULE:
   etopo
 NAME:
   climada_srtm_info
 PURPOSE:
   Get tile information for a specified country, centroids or a shape,
   i.e. which tiles to download from srtm directory.

   Data needs to be manually downloaded from from
   http://srtm.csi.cgiar.org/SELECTION/inputCoord.asp,
   (or possibly also ftp://srtm.csi.cgiar.org/SRTM_V41/SRTM_Data_GeoTiff/,
   http://droppr.org/srtm/v4.1/6_5x5_TIFs/)
   
   Next call: climada_srtm_get
 CALLING SEQUENCE:
   [srtm_info,is_mat] = climada_srtm_info(centroidsORcountryORshapes,silent_mode)
 EXAMPLE:
   srtm_info = climada_srtm_info
   srtm_info = climada_srtm_info('Netherlands')
   srtm_info = climada_srtm_info([min_lon max_lon min_lat max_lat])
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   centroidsORcountryORshapes:  centroids with lat/lon, country_name or
   shapes with lat/lon, it not specified prompted for a country_name
 OUTPUTS:
   srtm_tile: A struct with information which srtm_files to download from srtm
        http://srtm.csi.cgiar.org/SELECTION/inputCoord.asp
        .country_name:  country name of selected country, or region
        .n_tiles:  number of tiles that are required for the selected region/country
        .min_max_lon_lat: a 4x1 vector containing the srtm tile indices (e.g [18 19 10 10] for El Salvador)
        .srtm_filename: a cell with filenames to be downloaded from srtm
        .srtm_save_file: a char with the srtm filename (as .mat)
   is_mat: =1 if matfile exists, =0 if it does not exist (=1 usually only
       after climada_srtm_get has been called)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150720, init based on climada_90m_DEM by Gilles Stassen
 david.bresch@gmail.com, 20160122, srtm folder moved, some fixes (removed hard-wired paths)
 david.bresch@gmail.com, 20160126, file info to stdout improved
 david.bresch@gmail.com, 20160513, error in latitude selection for southern hemisphere fixed, prompting for country name if invalid
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/elevation_models/code/helper_functions/climada_srtm_info.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_encode_distance">
<H2>climada_hazard_encode_distance</H2></A>
<font color="blue">function hazard = climada_hazard_encode_distance(hazard,entityORassetsORcentroids,cutoff) </font>
 climada
 MODULE:
   flood
 NAME:
   climada_hazard_encode_distance
 PURPOSE:
   This is a function that is usually called from climada_ls_hazard_set.
   Convert landslide hazard intensity (landslide depth(m))
   into distance between an asset and the nearest centroid with nonzero
   intensity. Distance is transformed into intensity in the form of (y = mx+b), 
   which means increasing intensity with increasing damage, 
   intensity = 1 - 1/cutoff * distance_m
   Minimum distance is set to  1m, which translates into the maximum intensity 1.
   The lat/lon coordinates of the hazard are overwritten by the asset
   lat/lon coordinates
   A default distance cutoff, when it can be assumed that no asset is
   affected anymore is introduced at 1000 m.
 CALLING SEQUENCE:
   hazard = hazard_distance_convert(hazard,entity,cutoff)
 EXAMPLE:
   hazard = hazard_distance_convert(hazard,entity,250)
 INPUTS:
   hazard: landslide hazard structure, intensity given as meters soildepth
   entity: climada entity structure, with .assets.lon and .assets.lat
 OPTIONAL INPUT PARAMETERS:
   cutoff: default 1000m, can be set to other value
 OUTPUTS:
   hazard: a climada structure with lat/lon that equal the entity.assets.lat/lon
           and intensity as 1-1/cutoff*distance_m (-)
 MODIFICATION HISTORY:
 Jacob Anz, j.anz@gmx.net, 20150708, initial
 Lea Mueller, muellele@gmail.com, 20150713, intensity as 1-1/cutoff*distance_m instead of distance
 Gilles Stassen, gillesstassen@hotmail.com, 20150803, faster (~30x) alternative to knnsearch; argin entity -&ampgt entityORassetsORcentroids
 Gilles Stassen, 20150805, elevation cutoff. Entity points higher in elevation than land slide excluded
 Lea Mueller, muellele@gmail.com, 20150915, bugfix when calculate distance_m from intensity
 Lea Mueller, muellele@gmail.com, 20151106, move to flood
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_hazard_encode_distance.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_binary_plot">
<H2>climada_ls_hazard_binary_plot</H2></A>
<font color="blue">function fig = climada_ls_hazard_binary_plot(hazard) </font>
 climada plot ls binary hazard
 MODULE:
   flood
 NAME:
   climada_ls_hazard_binary_plot
 PURPOSE:
   This is a function that is usually called from climada_ls_hazard_set.
   Plot binary landslide hazard, all events on one map
 PREVIOUS STEP:
   hazard_binary = climada_ls_hazard_set_binary(centroids)
 NEXT STEP:
   hazard = climada_hazard_encode_distance(hazard,centroids,cutoff);
 CALLING SEQUENCE:
   fig = climada_ls_hazard_binary_plot(hazard)
 EXAMPLE:
   fig = climada_ls_hazard_binary_plot;
 INPUTS:
   hazard:  a climada hazard stucture with binary landslide
   information (.intensity is either 1 or 0)
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   fig: handle of map with landslide events
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151124, init
 -
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('hazard', 'var'), hazard = []; end
f isempty(hazard), hazard = climada_hazard_load; end   
        
 visualize binary ls hazard on a map
 ------------------------------
 delete nans if there are any
azard.intensity(isnan(hazard.intensity)) = 0;
xlim = [min(hazard.lon) max(hazard.lon) min(hazard.lat) max(hazard.lat)];
_events = hazard.event_count;
_colors = jet(n_events);
 show a maximum number of events
vent_step = 1;
ax_events_to_show = 100;
f n_events&ampgtmax_events_to_show, event_step = round(n_events/max_events_to_show);end
ig = climada_figuresize(0.5,0.7);
 plot(entity.assets.lon, entity.assets.lat,'.','linewidth',0.2,'markersize',0.8,'color',[255 64 64 ]/255);
old on
egendstr = []; h = []; counter = 0;
or e_i = 1:event_step:n_events
   is_event = logical(hazard.intensity(e_i,:));
   if any(is_event)
       counter = counter+1;
       %hold on; plot3(hazard.lon(is_event), hazard.lat(is_event), ones(sum(is_event))*3000, 'dr','linewidth',2,'markersize',5,'color',[255 64 64 ]/255)
       h(counter) = plot(hazard.lon(is_event), hazard.lat(is_event),'dr','linewidth',2,'markersize',5,'color',n_colors(e_i,:));
       hold on; 
       %plot(polygon_canas.X, polygon_canas.Y, 'b-');
       legendstr{counter} = sprintf('Event %d',e_i);
   end
nd
itlestr = 'LS hazard binary';
ry titlestr = sprintf('%s hazard (%s), %d events, %d',hazard.peril_ID, hazard.units, n_events, hazard.reference_year);end
itle(titlestr); axis(axlim); box on; 
limada_figure_axis_limits_equal_for_lat_lon(axlim); climada_figure_scale_add('',1,1)
egend(h,legendstr,'location','eastoutside')
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_ls_hazard_binary_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_set">
<H2>climada_ls_hazard_set</H2></A>
<font color="blue">function [hazard, centroids, fig] = climada_ls_hazard_set(centroids,n_events,hazard_set_file,... </font>
                                       wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                       n_downstream_cells,focus_area,polygon_correction,random_trigger_condition,...
                                       check_plot)
 Generate a landslide hazard set
 MODULE:
   flood
 NAME:
   climada_ls_hazard_set
 PURPOSE:
   This is a all-in-one function to generate a landslide hazard set. The 
   landslide events are based solely on topographical information 
   (SRTM 90m digital elevation data) and calculates slope and 
    topographical wetness index. We create first a binary hazard,
   encode to distance and plot figures if required.
   invokes 
       - climada_ls_hazard_set_binary
       - climada_hazard_encode_distance
   and for plots
       - climada_ls_hazard_binary_plot
       - climada_map_plot
       - climada_hazard_stats
       - climada_hazard_stats_figure   
 PREVIOUS STEP:
   create centroids, select a rectangle box to create the landslide hazard
   centroids = climada_centroids_elevation_add;
 CALLING SEQUENCE:
   [hazard, centroids, fig] = climada_ls_hazard_set(centroids,n_events,hazard_set_file,...
                                         wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                         n_downstream_cells,focus_area,polygon_correction,random_trigger_condition,...
                                         check_plot)
 EXAMPLE:
   hazard = climada_ls_hazard_set(centroids)
   check_plot = 1;
   [hazard, centroids, fig]  = climada_ls_hazard_set([-89.145 -89.1 13.692 13.727],'','','','','','','','','','',check_plot)
 INPUTS:
   centroids:  a climada centroids stucture (ideally including topographical
   information) or a rectangle to define lon/lat box, if not given, the
   user can select a rectangle by first selecting a country and then drawing
   a rectangle on a map
 OPTIONAL INPUT PARAMETERS:
   n_events: number of events
   hazard_set_file: the name (and path, optional) of the hazard set file
       If no path provided, default path ../data/hazards is used (and name
       can be without extension .mat)
       &ampgt promted for if not given
   wiggle_factor_TWI:    an array, default is 0.35, to modify topographical
                         wetness factor, which is a number between 0 and 1.4
   condition_TWI:        an array, default is 0.95, to define a minimum
                         topographical wetness index, where a landslide occurs
   wiggle_factor_slope:  an array, default is 0.35, to modify the slope factor, 
                         which is a number between 0 and 1
   condition_slope:      an array, default is 0.45, to define a minimum slope
                         where a landslide occurs
   n_downstream_cells:   number of downstream cells where the landslide is extended
   focus_area:           a polygon to define the focus area (with focus_area.lon, focus_area.lat),
                         landslides only in the given area will be filtered 
                         and the other areas are cut out
   polygon_correction:   a polygon to define an area where less landlislides should occur
   random_trigger_condition: a number between 0 and 1, 1 prevents all landslide 
                         in the polygon_correction area, 0 does not inhibit any
                         landlides in the polygon_correction area
   check_plot:          set to 1 if you want to see maps (elevation, slope, hazard, etc)
 OUTPUTS:
   hazard: a climada hazard structure with binary landslide information
       .peril_ID: 'LS'
       .date: the creation date of the set
       .intensity(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i, binary, 1 indicates a landslide, 0 no landslide
       .frequency(event_i): the frequency of each event
       .matrix_density: the density of the sparse array hazard.intensity
       .filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
   centroids: a climada centroids structure with fields
       .lon
       .lat
       .elevation_m, elevation in meters
       .slope_deg, slope in degree
       .TWI, topographical wetness index
       .aspect_deg, spect in degree
   fig: handle of figures (maps with elevation, slope, landslide
        hazard,etc)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151124, init
 -
 init
azard = []; fig = [];
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('centroids', 'var'), centroids = []; end
f ~exist('n_events', 'var'), n_events = []; end
f ~exist('hazard_set_file', 'var'), hazard_set_file = []; end
f ~exist('wiggle_factor', 'var'), wiggle_factor_TWI = []; end
f ~exist('TWI_condition', 'var'), condition_TWI = []; end
f ~exist('wiggle_factor_slope', 'var'), wiggle_factor_slope = []; end
f ~exist('slope_condition', 'var'), condition_slope = []; end
f ~exist('n_downstream_cells', 'var'), n_downstream_cells = []; end
f ~exist('focus_area', 'var'), focus_area = []; end
f ~exist('polygon_correction', 'var'), polygon_correction = []; end
f ~exist('random_trigger_condition', 'var'), random_trigger_condition = []; end
f ~exist('check_plot', 'var'), check_plot = 0; end
 create binary landslide hazard
hazard_binary, centroids]  = climada_ls_hazard_set_binary(centroids,n_events,hazard_set_file,...
                                   wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                   n_downstream_cells,focus_area,polygon_correction,random_trigger_condition);
              
 encode binary hazard to distance, so that we have the distance to
 landslides as intensity
utoff = 1000;
azard = climada_hazard_encode_distance(hazard_binary,centroids,cutoff);
 save hazard
pathname, filename, ext] = fileparts(hazard.filename);
f ~exist(pathname,'dir')
   hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'LSXX_hazard.mat'];
   [filename, pathname] = uiputfile(hazard_set_file, 'Save LS hazard set as:');
   if isequal(filename,0) || isequal(pathname,0)
       return; % cancel
   else
       hazard_set_file = fullfile(pathname,filename);
   end
lse
   filename = [strrep(filename,'binary','') 'distance'];
   hazard_set_file = fullfile(pathname,filename);
nd
printf('Save landslide (LS) hazard set (encoded to distance) as %s\n',hazard_set_file);
ave(hazard_set_file,'hazard')
f check_plot   
   % create landslide binary event map
   fig = climada_ls_hazard_binary_plot(hazard_binary);
   
   % plot centroids with characteristics (elevation, slope, twi, etc)
   fieldname_to_plot = {'elevation_m' 'slope_deg' 'TWI' 'aspect_deg'};
   plot_method = 'plotclr';
   [~, fig_temp] = climada_map_plot(centroids,fieldname_to_plot,plot_method);
   
   % plot hazard statistics
   hazard.orig_years = 1000; % we set the number of years to 1000 to have nice images, but please check if this is suitable
   hazard.frequency = ones(size(hazard.event_ID))*(1./hazard.orig_years);
   
   return_periods = [10 25 50 100 150 200];
   hazard_stats = climada_hazard_stats(hazard,return_periods,0);
   fig_temp_2 = climada_hazard_stats_figure(hazard_stats,return_periods);
  
   % concatenate figure handles
   fig = [fig fig_temp fig_temp_2];
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_ls_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_set_binary">
<H2>climada_ls_hazard_set_binary</H2></A>
<font color="blue">function [hazard, centroids]  = climada_ls_hazard_set_binary(centroids,n_events,hazard_set_file,... </font>
                                   wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                   n_downstream_cells,focus_area,polygon_correction,random_trigger_condition)
 Generate a binary landslide hazard set
 MODULE:
   flood
 NAME:
   climada_ls_hazard_set_binary
 PURPOSE:
   This is a function that is usually called from climada_ls_hazard_set.
   Generate a binary landslide hazard set based solely on topographical
   information (slope and topographical wetness index)
 PREVIOUS STEP:
   centroids = climada_centroids_elevation_add;
 CALLING SEQUENCE:
   hazard = climada_ls_hazard_set_binary(centroids,n_events,hazard_set_file,...
                    wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                    n_downstream_cells,focus_area,polygon_correction,random_trigger_condition)
 EXAMPLE:
   hazard = climada_ls_hazard_set_binary(centroids)
   hazard = climada_ls_hazard_set_binary([-89.145 -89.1 13.692 13.727])
   hazard = climada_ls_hazard_set_binary
 INPUTS:
   centroids:  a climada centroids stucture (ideally including topographical
   information) or a rectangle to define lon/lat box, if not given, the
   user can select a rectangle by first selecting a country and then drawing
   a rectangle on a map
 OPTIONAL INPUT PARAMETERS:
   n_events: number of events
   hazard_set_file: the name (and path, optional) of the hazard set file
       If no path provided, default path ../data/hazards is used (and name
       can be without extension .mat)
       &ampgt promted for if not given
   wiggle_factor_TWI:    an array, default is 0.35, to modify topographical
                         wetness factor, which is a number between 0 and 1.4
   condition_TWI:        an array, default is 0.95, to define a minimum
                         topographical wetness index, where a landslide occurs
   wiggle_factor_slope:  an array, default is 0.35, to modify the slope factor, 
                         which is a number between 0 and 1
   condition_slope:      an array, default is 0.45, to define a minimum slope
                         where a landslide occurs
   n_downstream_cells:   number of downstream cells where the landslide is extended
   focus_area:           a polygon to define the focus area (with focus_area.lon, focus_area.lat),
                         landslides only in the given area will be filtered 
                         and the other areas are cut out
   polygon_correction:   a polygon to define an area where less landlislides should occur
   random_trigger_condition: a number between 0 and 1, 1 prevents all landslide 
                         in the polygon_correction area, 0 does not inhibit any
                         landlides in the polygon_correction area
 OUTPUTS:
   hazard: a climada hazard structure with binary landslide information
       .peril_ID: 'LS'
       .date: the creation date of the set
       .intensity(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i, binary, 1 indicates a landslide, 0 no landslide
       .frequency(event_i): the frequency of each event
       .matrix_density: the density of the sparse array hazard.intensity
       .filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150911, init
 Lea Mueller, muellele@gmail.com, 20150920, add polygon_correction with a random trigger condition, to reduce landslides in a given polygon
 Lea Mueller, muellele@gmail.com, 20151124, return centroids as output, use climada_hazard_focus_area
 Lea Mueller, muellele@gmail.com, 20151124, call from climada_ls_hazard_set
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_TWI_calc from centroids_TWI
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_hazard_crop from climada_hazard_focus_area
 -
azard = []; % init
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('centroids', 'var'), centroids = []; end
f ~exist('n_events', 'var'), n_events = []; end
f ~exist('hazard_set_file', 'var'), hazard_set_file = []; end
f ~exist('wiggle_factor', 'var'), wiggle_factor_TWI = []; end
f ~exist('TWI_condition', 'var'), condition_TWI = []; end
f ~exist('wiggle_factor_slope', 'var'), wiggle_factor_slope = []; end
f ~exist('slope_condition', 'var'), condition_slope = []; end
f ~exist('n_downstream_cells', 'var'), n_downstream_cells = []; end
f ~exist('focus_area', 'var'), focus_area = []; end
f ~exist('polygon_correction', 'var'), polygon_correction = []; end
f ~exist('random_trigger_condition', 'var'), random_trigger_condition = []; end
f isnumeric(centroids) &amp&amp numel(centroids) == 4
   % we have a box that defines where centroids should be created on 90m
   % resolution (given by SRTM)
   % return
   centroids = climada_centroids_elevation_add('',centroids);
nd
f isempty(centroids) 
   % create centroids by asking user for a country and to define a
   % rectangle region on the figure
   % return
   centroids = climada_centroids_elevation_add('','');
nd
 PARAMETERS
f isempty(n_events); n_events = 100; end
f isempty(wiggle_factor_TWI); wiggle_factor_TWI = 0.35; end
f isempty(condition_TWI); condition_TWI = 0.95; end
f isempty(wiggle_factor_slope); wiggle_factor_slope = 0.2; end
f isempty(condition_slope); condition_slope = 0.45; end
f isempty(n_downstream_cells); n_downstream_cells = 5; end
f isempty(random_trigger_condition); random_trigger_condition = 0; end
 prompt for hazard_set_file if not given
f isempty(hazard_set_file) % local GUI
   hazard_set_file      = [climada_global.data_dir filesep 'hazards' filesep 'LSXX_hazard_binary.mat'];
   [filename, pathname] = uiputfile(hazard_set_file, 'Save LS (binary) hazard set as:');
   if isequal(filename,0) || isequal(pathname,0)
       return; % cancel
   else
       hazard_set_file = fullfile(pathname,filename);
   end
nd
 complete path, if missing
fP,fN,fE] = fileparts(hazard_set_file);
f isempty(fP),hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep fN fE];end
% load template for hazard-structure
azard_example_file = [climada_global.data_dir filesep 'hazards' filesep 'TCNA_today_small.mat'];
f exist(hazard_example_file,'file')
   load(hazard_example_file)
lse
   fprintf('No hazard example found to be loaded. \n')
nd
azard_ex = hazard;
 overwrite template hazrd with actual information
azard.lon = centroids.lon;
azard.lat = centroids.lat;
azard.centroid_ID = 1:numel(hazard.lon);
azard.peril_ID         = 'LS';
azard.orig_years       = 10000;
azard.orig_event_count = n_events;
azard.event_count      = n_events;
azard.event_ID         = 1:n_events;
azard.orig_event_flag  = ones(1,n_events);
azard.yyyy             = ones(1,n_events);
azard.mm               = ones(1,n_events);
azard.dd               = ones(1,n_events);
azard.intensity        = sparse(n_events,numel(hazard.lon));
azard.name             = cell(1,n_events);
azard.frequency        = ones(1,n_events)/hazard.orig_years;
azard.comment          = centroids.comment;
azard.date             = datestr(now);
azard.units            = 'binary';
azard.orig_yearset     = [];
azard.filename         = hazard_set_file;
azard.matrix_density   =  0.01; % estimate
 n_centroids = length(centroids.centroid_ID);
f ~isfield(centroids,'slope_deg')
   fprintf('Add topographical characteristics to the centroids, based on elevation\n')
   centroids = climada_centroids_TWI_calc(centroids);
nd
 calculate slope_factor as cos(slope)/sin(slope)
lope_factor = 1./(cosd(centroids.slope_deg) ./ sind(centroids.slope_deg));
lope_factor(isinf(slope_factor)) = 0;
lope_factor(slope_factor&ampgt0.55) = 0.6;
f ~isfield(centroids,'slope_factor')
   centroids.slope_factor = slope_factor;
nd
 normalize TWI
f ~isfield(centroids,'TWI_norm')
   % TWI_norm = centroids.TWI/10;
   % TWI_norm(TWI_norm&ampgt0.85) = 0.85;
   TWI_norm = centroids.TWI/10;
   TWI_norm(isnan(TWI_norm)) = 0;
   centroids.TWI_norm = TWI_norm;
nd
 % slope factor
 titlestr = 'Slope factor (-)';
 miv = 0;
 mav = 0.6;
 fig = climada_figuresize(0.5,0.6);
 plotclr(centroids.lon, centroids.lat, centroids.slope_factor, marker,markersize,cbar_on,miv,mav);
 title(titlestr); axis(axlim); box on; climada_figure_scale_add('',7,1)
 pdf_filename = sprintf('LS_slope_factor.pdf');
 print(fig,'-dpdf',[ls_dir pdf_filename])
 
 % TWI norm
 titlestr = 'TWI normalised';
 miv = 0;
 mav = 1;
 fig = climada_figuresize(0.5,0.6);
 plotclr(centroids.lon, centroids.lat, centroids.TWI_norm, marker,markersize,cbar_on,miv,mav);
 title(titlestr); axis(axlim); box on; climada_figure_scale_add('',7,1)
 pdf_filename = sprintf('LS_TWI_normalised.pdf');
 print(fig,'-dpdf',[ls_dir pdf_filename])
f ~isempty(polygon_correction)
   lon_lat_polygon = climada_concatenate_lon_lat(polygon_correction.lon,polygon_correction.lat);
   lon_lat = climada_concatenate_lon_lat(centroids.lon,centroids.lat);
   needs_correction = inpoly(lon_lat,lon_lat_polygon);
   %sum(needs_correction)
   needs_correction = find(needs_correction);
nd
 create TWI wiggle as the sum of TWI_norm + TWI_delta
 create slope wiggle as the sum of slope_factor + slope_delta
 TWI_wiggle = zeros(size(hazard.intensity)); %init
 slope_wiggle = zeros(size(hazard.intensity)); %init
elta_TWI = rand(size(hazard.intensity)) * wiggle_factor_TWI;
elta_slope = rand(size(hazard.intensity)) * wiggle_factor_slope;
or e_i = 1:n_events
   wiggle_TWI = centroids.TWI_norm + delta_TWI(e_i,:);
   wiggle_slope = centroids.slope_factor + delta_slope(e_i,:);
       
   % check where landslides occur
   ls_occurence(e_i,:) = wiggle_TWI&ampgtcondition_TWI &amp wiggle_slope&ampgtcondition_slope ;
   
   if ~isempty(polygon_correction)
       random_trigger = rand(numel(needs_correction),1);
       random_trigger(random_trigger&ampgtrandom_trigger_condition) = 1;
       random_trigger(random_trigger&amplt=random_trigger_condition) = 0;
       not_triggered = needs_correction(~random_trigger);
       ls_occurence(e_i,not_triggered) = 0;
   end
   
nd
 expand landslides to following n_cells downstream
f n_downstream_cells&ampgt1
   if ~isfield(centroids,'sink_ID_10')
       centroids = climada_flow_find(centroids);
   end
   if n_downstream_cells&ampgt10
       n_downstream_cells = 10;
       fprintf('Maximum numbers of downstream cells is 10.\n')
   end
   
   msgstr   = sprintf('Expand landslide to %d downstream cells for %i events ... ',n_downstream_cells,n_events);
   mod_step = 10; % first time estimate after 10 assets, then every 100
   if climada_global.waitbar
       fprintf('%s (updating waitbar with estimation of time remaining every 50th event)\n',msgstr);
       h        = waitbar(0,msgstr);
       set(h,'Name','Expand landslide to ownstream cells');
   else
       fprintf('%s (waitbar suppressed)\n',msgstr);
       format_str='%s';
   end
   
   % loop over all events
   for e_i = 1:n_events
       is_event = ls_occurence(e_i,:);
       centroid_list = find(is_event);
       
       % loop over centroids, that are sliding
       for i = centroid_list
           selected_sinks = centroids.sink_ID_10(i,:);
           % take only a given number of downstream cells
           if numel(selected_sinks)&ampgtn_downstream_cells
                selected_sinks = selected_sinks(1:n_downstream_cells);
           end
           if ~isempty(selected_sinks)
               is_sink = []; %init
               for s_i = 1:numel(selected_sinks)
                   if selected_sinks(s_i)&ampgt0
                       is_sink(s_i) = find(selected_sinks(s_i) == centroids.centroid_ID);
                   end
               end
               %is_sink = ismember(centroids.centroid_ID,selected_sinks);
               ls_occurence(e_i,is_sink) = ones(1,numel(is_sink));
           end
       end
       
       % the progress management
       if mod(e_i,mod_step)==0
           mod_step          = 50;
           msgstr = sprintf('%i/%i events',e_i,n_events);
           if climada_global.waitbar
               waitbar(e_i/n_events,h,msgstr); % update waitbar
           else
               fprintf(format_str,msgstr); % write progress to stdout
               format_str=[repmat('\b',1,length(msgstr)) '%s']; % back to begin of line
           end
       end
   
   end
   ls_occurence = logical(ls_occurence);
nd
 create sparse matrix
azard.intensity = sparse(ls_occurence);
f climada_global.waitbar
   close(h) % dispose waitbar
lse
   fprintf(format_str,''); % move carriage to begin of line
nd
 restrict hazard landslides to a given focus area (delete locations outside this area, .lon, .lat, .intensity)
f ~isempty(focus_area)
   fprintf('Filter out landslides in the given focus area.\n')
   hazard = climada_hazard_crop(hazard, focus_area);
   
     if isfield(focus_area,'lon') &amp&amp isfield(focus_area,'lat')
         polygon = climada_concatenate_lon_lat(focus_area(1).lon, focus_area(1).lat);
         
     elseif isfield(focus_area,'X') &amp&amp isfield(focus_area,'Y')
         polygon = climada_concatenate_lon_lat(focus_area(1).X, focus_area(1).Y);
         
     elseif isnumeric(focus_area) % it is already formatted as a polygon
         [i, j] = size(focus_area);
         if j == 2 &amp&amp i&ampgt2
             polygon = focus_area;
         end
     else
         fprintf('Please check the input of the focus area.\n')
         return
     end
     hazard_lon_lat = climada_concatenate_lon_lat(hazard.lon, hazard.lat);
     is_inside = inpoly(hazard_lon_lat,polygon);
     if any(is_inside)
         hazard.lon = hazard.lon(is_inside);
         hazard.lat = hazard.lat(is_inside);
         hazard.centroid_ID = 1:numel(hazard.lon);
         hazard.intensity = hazard.intensity(:,is_inside);
     end
nd
printf('Save landslide (LS) hazard set (binary) as %s\n',hazard_set_file);
ave(hazard_set_file,'hazard')
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_ls_hazard_set_binary.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_TWI_calc">
<H2>climada_centroids_TWI_calc</H2></A>
<font color="blue">function centroids = climada_centroids_TWI_calc(centroids, check_plots) </font>
 Calculate flood scores and topographic wetness indices
 MODULE:
   flood
 NAME:
	climada_centroids_TWI_calc
 PURPOSE:
   Calculate flood scores and topographic wetness indices for given
   centroids, that are on a regular grid.
   climada_centroids_TWI_calc applies a multiple-flow-direction method which,
   in contrast to the simple D8 method, allows the runoff to flow to
   multiple neighbouring cells. The distribution of the flow is determined
   based on the respective gradients between the central cell and its
   neighbouring cells. Also, the algorithm controls dispersion effects
   using a method suggested by
       Freeman, T.G. (1991): Calculating catchment area with
       divergent flow based on a regular grid;
       doi:10.1016/0098-3004(91)90048-I
   The Topographic wetness index (TWI), which can be derived from the
   calculated flow accumulation, then provides a cost-efficient
   alternative to flood determination by conventional hydrodynamic models.
   For more information on TWI see
       Pourali, S.H. et al. (2014): Topography Wetness Index Application
       in Flood-Risk-Based Land Use Planning;
       doi:10.1007/s12061-014-9130-2
 CALLING SEQUENCE:
   centroids = climada_centroids_TWI_calc(centroids, check_plots)
 EXAMPLE:
   centroids = climada_centroids_TWI_calc(centroids,0)
 INPUTS:
   centroids: Climada centroids struct; the following fields are required:
         .lat:           Latitude
         .lon:           Longitude
         .centroid_ID:   centroid ID
         .admin0_name    Country name
 OPTIONAL INPUT PARAMETERS:
   check_plots: whether plots of topography (elevation), slope, aspect
   angle, and flood scores should be drawn (=1) or not (=0; default)
   force_recalc: if set to 1, flood scores are calculated even if they
   already exist (default is 0)
 OUTPUTS:
   centroids: centroids with additional fields:
       .FL_score:   assigns a number for flow accumulation to each centroid, and
       .TWI:        assigns a topographic wetness index to each centroid
       .slope_deg:  slope of every centroid, in degree
       .area_m2:    area of every centroid, in square meters
       .aspect_deg: aspect of every centroid, in degree
       .sink_ID:    sink of every centroid, links to centroid_ID
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150226, initial
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150311, added wetness index
 Gilles Stassen, gillesstassen@hotmail.com, 20150407, clean up
 Lea Mueller, muellele@gmail.com, 20150720, bugfix, quick+dirty workaround
              to create meshgrid and allocate FL_score, @Gilles: please check and correct
 Jacob Anz, 280715, fixed shift_matrix
 Lea Mueller, muellele@gmail.com, 20150925, add process management/waitbar
 Lea Mueller, muellele@gmail.com, 20151105, improve output documentation
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_TWI_calc from centroids_TWI
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/helper_functions/climada_centroids_TWI_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_flow_find">
<H2>climada_flow_find</H2></A>
<font color="blue">function centroids = climada_flow_find(centroids) </font>
 Find flow direction for every centroid 
 MODULE:
   flood
 NAME:
   climada_flow_find
 PURPOSE:
   Find flow direction for every centroid, find next 10 centroids, based
   on sink_ID
 PREVIOUS STEP:
   centroids = climada_centroids_TWI_calc(centroids)
 CALLING SEQUENCE:
   centroids = climada_flow_find(centroids)
 EXAMPLE:
   centroids = climada_flow_find(centroids)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   centroids: a climada centroids structure, including TWI properties,
   especially .sink_ID
 OUTPUTS:
   centorids: centroid with field .sink_ID_10 defining the 10 next centroids
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150920, init
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_TWI_calc from centroids_TWI
 -
lobal climada_global
f ~climada_init_vars, return; end
_centroids = numel(centroids.sink_ID);
_sinks = 10;
ink_ID = zeros(n_centroids,n_sinks); % init
sgstr   = sprintf('Find flow direction for %i centroids ... ',n_centroids);
od_step = 10; % first time estimate after 10 assets, then every 100
f climada_global.waitbar
   fprintf('%s (updating waitbar with estimation of time remaining every 100th centroid)\n',msgstr);
   h        = waitbar(0,msgstr);
   set(h,'Name','Find flow direction for centroids');
lse
   fprintf('%s (waitbar suppressed)\n',msgstr);
   format_str='%s';
nd
or c_i = 1:n_centroids
   next_sink_ID = centroids.sink_ID(c_i);
   
   for c_ii = 1:n_sinks
       if ~isempty(next_sink_ID) &amp ~isnan(next_sink_ID)         
           sink_ID(c_i,c_ii) = next_sink_ID;
           next_sink_ID = centroids.sink_ID(sink_ID(c_i,c_ii) == centroids.centroid_ID);
           
           %this_elevation = centroids.elevation_m(sink_ID(c_i,c_ii) == centroids.centroid_ID);
           %next_elevation = centroids.elevation_m(centroids.centroid_ID == next_sink_ID);
           
           % %local minimum, do not use
           % if this_elevation&ampltnext_elevation 
           %     % go back to last sink ID
           %     previous_sink_ID = sink_ID(c_i,c_ii-1);
           % 
           %     % find all IDs that flow into this local minimum
           %     have_similar_sink = centroids.sink_ID == sink_ID(c_i,c_ii);
           %     centroids.centroid_ID(have_similar_sink)
           % 
           %     have_similar_sink_2 = ismember(centroids.sink_ID,centroids.centroid_ID(have_similar_sink));
           %     centroids.centroid_ID(have_similar_sink_2)
           % end
       end
   end
   
   % the progress management
   if mod(c_i,mod_step)==0
       mod_step          = 100;
       msgstr = sprintf('%i/%i centroids',c_i,n_centroids);
       if climada_global.waitbar
           waitbar(c_i/n_centroids,h,msgstr); % update waitbar
       else
           fprintf(format_str,msgstr); % write progress to stdout
           format_str=[repmat('\b',1,length(msgstr)) '%s']; % back to begin of line
       end
   end
   
nd
   
entroids.sink_ID_10 = sink_ID;
f climada_global.waitbar
   close(h) % dispose waitbar
lse
   fprintf(format_str,''); % move carriage to begin of line
nd
 figure
 is_sink = ismember(centroids.centroid_ID,sink_ID(1,:));
 plot(centroids.lon(is_sink),centroids.lat(is_sink),'o-')
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/helper_functions/climada_flow_find.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_geo_distance_2">
<H2>climada_geo_distance_2</H2></A>
<font color="blue">function dist_m = climada_geo_distance_2(lonlat1,lonlat2) </font>
 calculate distance between to points in meters
 MODULE:
   flood
 NAME:
   climada_geo_distance_2
 PURPOSE:
   calculate distance between two points or a point and a series of
   points, with different input format than climada_geo_distance. lonlat1
   and lonlat2 are a matrices that contain both lon and lat information. 
 CALLING SEQUENCE:
   climada_geo_distance_2(lonlat1, lonlat2);
 EXAMPLE:
   climada_geo_distance_2([0.0 45.0], [1.0 45.0]); % two points
   climada_geo_distance_2([0.0 45.0], [1.0 45.0; 1.0 46.0]); % point and a series of points
 INPUTS:
   lonlat1: longitude and latitude of first point
   lonlat2: longitude and latitude of second point
       or, if vectors of the same length, series of points
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   dist_m: distance(s) between points in [m]
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150801, init based on climada_geo_distance
 Lea Mueller, muellele@gmail.com, 20151106, move to flood
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/helper_functions/climada_geo_distance_2.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="basin_identify">
<H2>basin_identify</H2></A>
<font color="blue">function basin_IDs = basin_identify(lon_pts,lat_pts,lon_polygons,lat_polygons,basin_names) </font>
 Identify basins in which a set of points are located
 MODULE:
   flood
 NAME:
   basin_identify
 PURPOSE: 
   Identify basins in which a given set of points is located
   For a set of longitude and latitude points (usually from centroids), 
   determine if they are located in a given set of polygons, and if so,
   assign a basin name (or ID) to them.
 CALLING SEQUENCE: 
   basin_IDs = basin_identify(lon_pts,lat_pts,lon_polygons,lat_polygons,basin_names)
 INPUTS:
   lon_pts [deg E]: longitude of input points [0,360)
   lat_pts [deg N]: latitude of input points [-90,90]
   lon_polygons [deg E]: cell array of longitude values of polygon vertices
       (must be ordered either clockwise or counterclockwise)    
   lat_polygons [deg N]: cell array of latitude values of polygon vertices
       (must be ordered either clockwise or counterclockwise)  
   basin_names: cell array of basin labels (one per cell in lon_polygons)
 OPTIONAL INPUTS:  

 OUTPUTS:
   basin_IDs: cell array of basin labels at input points; 0 if
       outside all input polygons

 NOTE 1: This function has been adapted from code written by
 Dan Chavas, CEE Dept, Princeton University
 See http://www.mathworks.com/matlabcentral/fileexchange/48360-basin-identify-m/content/basin_identify/basin_identify.m

 NOTE 2: The current implementation also allows for basin names that
 consist of strings (rather than integer basin IDs). However, since for
 the time being the function will be used mostly with basin numbers, 
 basin_IDs will be converted from cell to a numeric vector in the end,
 which is only possible if all contents of the cell array are of the same
 data type. Therefore, remove the last command (&quotcell2mat&quot) in case you'd 
 like to attach the basin names to the input centroids as a cell

 MODIFICATION HISTORY
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150306, initial
 initialize output
asin_IDs = cell(size(lon_pts));
 loop over basins and check which centroids belong to them
or basin_i=1:length(basin_names)
  
   basin_str = basin_names{basin_i};
   lon_polys_temp = lon_polygons{basin_i};
   lat_polys_temp = lat_polygons{basin_i};
   lon_polys_temp = [lon_polys_temp lon_polys_temp(1)];   %to wrap around
   lat_polys_temp = [lat_polys_temp lat_polys_temp(1)];
       
   i_basin = inpolygon(lon_pts,lat_pts,lon_polys_temp,lat_polys_temp);
   if(sum(i_basin)&ampgt0)
       basin_IDs(i_basin) = {basin_str};
   end
   clear i_basin
   
nd
asin_IDs(cellfun(@isempty,basin_IDs)) = {0};
 Convert the contents of the cell array basin_IDs into a single matrix.
asin_IDs = cell2mat(basin_IDs);
 if mapping toolbox is installed:
 if check_plot
     h_pt = geoshow(lat_pts,lon_pts,'DisplayType','Point');
     set(h_pt,'Marker','x','Color','g','MarkerSize',15)
     textm(lat_pts,lon_pts,basin_pts)
     title('Red X = test points')
     
     sprintf('Note: Lines on output plot do not align perfectly with meridians')
     sprintf('so it may look like there are points that are in the wrong place. They are not.')
     
     %% Save plot %%%%%%%%%%%%%%%%%%
     plot_filename = sprintf('basin_identify_example.pdf');
     saveas(gcf,sprintf('%s',plot_filename),'pdf')
     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
 end
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/basin_identify.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="centroids_BD">
<H2>centroids_BD</H2></A>
<font color="blue">function centroids=centroids_BD(centroids, check_plots) </font>
 Assign bulk density (BD) values to given centroids
 MODULE:
   flood
 NAME:
	centroids_BD
 PURPOSE:
   Determine bulk density (BD) for given centroids by
   reading a grayscale GeoTIFF of global annual mean BD.
   The global average annual BD GeoTIFF image derived from http://soilgrids.org/

   It needs to be placed in data/system of the climada module flood
   The code automatically reads the GeoTIFF from that URL if it does not
   exist in the data folder of the flood module (but this is VERY slow...).
   bulk density values are in m
 CALLING SEQUENCE:
   centroids = centroids_BD(centroids, check_plots)
 EXAMPLE:
   centroids = centroids_BD(centroids)
 INPUTS:
  centroids: Climada centroids struct; the following fields are required:
         .lat:           Latitude
         .lon:           Longitude
         .centroid_ID:   centroid ID
         .admin0_name    Country name
 OPTIONAL INPUT PARAMBDERS:
   check_plots: whether a plot should be drawn (=1) or not (=0; default)
   force_recalc: if set to 1, BD is calculated even if the centroids
   already have a field 'bulk density' (default is 0)
 OUTPUTS:
   centroids: The input centroids structure with an additional field
   'BD_kg_m3', which contains the annual mean bulk density
   (in mm/day) for each centroid
 NOTE:
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmaail.com, 20150414
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/centroids_BD.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="centroids_ET">
<H2>centroids_ET</H2></A>
<font color="blue">function centroids=centroids_ET(centroids, check_plots) </font>
 Assign Evapotranspiration (ET) values to given centroids
 MODULE:
   flood
 NAME:
	centroids_ET
 PURPOSE:
   Determine Evapotranspiration (ET) for given centroids by
   reading a grayscale GeoTIFF of global annual mean ET.
   The global average annual ET GeoTIFF image derived from 2010-2013 MODIS
   data can be downloaded here:
   ftp://ftp.ntsg.umt.edu/pub/MODIS/NTSG_Products/MOD16/MOD16A3.105_MERRAGMAO/Geotiff/MOD16A3_ET_2000_to_2013_mean.tif
   It needs to be placed in data/system of the climada module flood
   The code automatically reads the GeoTIFF from that URL if it does not
   exist in the data folder of the flood module (but this is VERY slow...).
   Evapotranspiration values are in mm/day.
 CALLING SEQUENCE:
   centroids = centroids_ET(centroids, check_plots)
 EXAMPLE:
   centroids = centroids_ET(centroids)
 INPUTS:
  centroids: Climada centroids struct; the following fields are required:
         .lat:           Latitude
         .lon:           Longitude
         .centroid_ID:   centroid ID
         .admin0_name    Country name
 OPTIONAL INPUT PARAMETERS:
   check_plots: whether a plot should be drawn (=1) or not (=0; default)
   force_recalc: if set to 1, ET is calculated even if the centroids
   already have a field 'evapotranspiration' (default is 0)
 OUTPUTS:
   centroids: The input centroids structure with an additional field
   'ET_mm_day', which contains the annual mean evapotranspiration
   (in mm/day) for each centroid
 NOTE:
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150320, initial
 Gilles Stassen, gillesstassen@hotmail.com, 20150407, cleanup, units mm/yr -&ampgt mm/day
 Gilles Stassen, gillesstassen@hotmaail.com, 20150414, speedup
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/centroids_ET.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="centroids_LAI">
<H2>centroids_LAI</H2></A>
<font color="blue">function centroids=centroids_LAI(centroids, check_plots) </font>
 Assign Leaf Area Indices (LAIs) to given centroids
 MODULE:
   flood
 NAME:
	centroids_LAI_assign
 PURPOSE:
   Determine Leaf Area Indices (LAIs) for given centroids by
   reading a grayscale picture of global annual mean LAIs.
   Leaf area index (LAI) is a dimensionless quantity that characterizes
   plant canopies. It is defined as the one-sided green leaf area per unit
   ground surface area (LAI = leaf area / ground area, m^2/m^2).
   For more information on the LAI see
       http://en.wikipedia.org/wiki/Leaf_area_index
   The Moderate Resolution Imaging Spectroradiometer (MODIS) aboard NASA's
   Terra and Aqua satellites collects global LAI data on a daily basis.
   Values range from 0 to 7 square meters of leaf area per square meter of
   land surface.
   Global monthly mean LAI images in grayscale can be downloaded here:
       http://neo.sci.gsfc.nasa.gov/view.php?datasetId=MOD15A2_M_LAI
 NOTE: Since only monthly mean data are provided under the link above, a
 grayscale picture of the annual mean LAI needs to be produced manually by
 adding monthly pictures and taking the average.

 CALLING SEQUENCE:
   centroids = centroids_LAI(centroids,check_plots)
 EXAMPLE:
   centroids = centroids_LAI(centroids)
 INPUTS:
  centroids: Climada centroids struct; the following fields are required:
         .lat:           Latitude
         .lon:           Longitude
         .centroid_ID:   centroid ID
         .admin0_name    Country name
 OPTIONAL INPUT PARAMETERS:
   LAI_img_filename: File name of the global mean LAI image. If empty, a
   default image is used, and if it does not exists, the function prompts
   for the image filename.
   check_plots: whether a plot should be drawn (=1), for each month (=2) or not at all (=0; default) 
                   [about 3x slower when using check_plots = 2]
 OUTPUTS:
   centroids: The input centroids structure with an additional field
   'leaf_area_index', which contains the Leaf Area Index for each centroid
 NOTE:
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150318, initial
 Gilles Stassen, gillesstassen@hotmail.com, 20150407, monthly data; auto
                   file finder/downloader; interp2 to determine values at centroids; plotter
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/centroids_LAI.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="centroids_SD">
<H2>centroids_SD</H2></A>
<font color="blue">function centroids=centroids_SD(centroids, check_plots) </font>
 Assign soil depth (SD) values to given centroids
 MODULE:
   flood
 NAME:
	centroids_SD
 PURPOSE:
   Determine soil depth (SD) for given centroids by
   reading a grayscale GeoTIFF of global annual mean SD.
   The global average annual SD GeoTIFF image derived from http://soilgrids.org/
   
   It needs to be placed in data/system of the climada module flood
   The code automatically reads the GeoTIFF from that URL if it does not
   exist in the data folder of the flood module (but this is VERY slow...).
   soil depth values are in m
 CALLING SEQUENCE:
   centroids = centroids_SD(centroids, check_plots)
 EXAMPLE:
   centroids = centroids_SD(centroids)
 INPUTS:
  centroids: Climada centroids struct; the following fields are required:
         .lat:           Latitude
         .lon:           Longitude
         .centroid_ID:   centroid ID
         .admin0_name    Country name
 OPTIONAL INPUT PARAMSDERS:
   check_plots: whether a plot should be drawn (=1) or not (=0; default)
   force_recalc: if set to 1, SD is calculated even if the centroids
   already have a field 'soil depth' (default is 0)
 OUTPUTS:
   centroids: The input centroids structure with an additional field
   'SD_m' containing info about soil depth to bedrock in m
 NOTE:
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150414
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/centroids_SD.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="centroids_SWI">
<H2>centroids_SWI</H2></A>
<font color="blue">function centroids=centroids_SWI(centroids, check_plots) </font>
 Assign soil water indices (SWIs) to given centroids
 MODULE:
   flood
 NAME:
	centroids_SWI_assign
 PURPOSE:
   Determine soil water indices (SWIs) for given centroids by
   reading a grayscale image of global annual mean SWI.
   SWI describes the amount of soil moisture present out of how much could
   potentially exist in the soil; i.e., the current water storage divided
   by the available water storage. SWI ranges from 0 to 100% and is given
   by:
   SWI = (soil_moisture-wilting_point)/(field_capacity-wilting_point)
   SWI therefore equals 0 at the wilting point and 1 at the field capacity
   For more information on SWI see e.g. this paper by the Global Soil
   Wetness Project:
       https://www.jstage.jst.go.jp/article/jmsj1965/77/1B/77_1B_305/_pdf
   Daily global SWI images derived can be downloaded here:
   http://land.copernicus.eu/global/products/swi
   The image needs to be placed in data/system of the climada module flood

   NOTE: Since only daily data are provided under the link above, a
       grayscale picture of the annual mean SWI needs to be produced
       manually adding monthly pictures and taking the average.
 CALLING SEQUENCE:
   centroids = centroids_SWI_assign(centroids, check_plots)
 EXAMPLE:
   centroids = centroids_SWI_assign(centroids)
 INPUTS:
  centroids: Climada centroids struct; the following fields are required:
         .lat:           Latitude
         .lon:           Longitude
         .centroid_ID:   centroid ID
         .admin0_name    Country name
 OPTIONAL INPUT PARAMETERS:
   check_plots: whether a plot should be drawn (=1) or not (=0; default)
   force_recalc: if set to 1, SWI is calculated even if the centroids
   already have a field 'soil_water_index' (default is 0)
 OUTPUTS:
   centroids: The input centroids structure with an additional field
   'SWI' (soil water index), which contains the annual mean soil water index
   (in %) for each centroid
 NOTE:
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150325, initial
 import/setup global variables
lobal climada_global
f ~climada_init_vars,return;end;
 check arguments
f ~exist('centroids','var') || isempty(centroids),climada_centroids_load;      end
f ~exist('check_plots', 'var') || isempty(check_plots), check_plots = 0;       end
 locate the module's data folder
odule_data_dir=[fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
 PARAMETERS

 the file with the SWI data
WI_file=[module_data_dir filesep 'system' filesep 'SWI_global_mean_2013.png'];


 Missing data value, to be found in the documentation here:
 http://land.copernicus.eu/global/products/swi
issing_data_value = 255;

 north south extension of the SWI image (longitude is covered in the full
 range from -180 to 180)
in_lat=-90; % degree
ax_lat= 90;

 prepare bounding box (for speedup; we only want to look at a section of
 the global SWI map)
 bbox=[minlon minlat maxlon maxlat]
box = [min(centroids.lon)-1, min(centroids.lat)-1,max(centroids.lon)+1, max(centroids.lat)+1];
fP,fN,~] = fileparts(SWI_file);
WI_file_mat = [fP filesep fN '.mat'];
f climada_check_matfile(SWI_file,SWI_file_mat)
   % .mat file exists, we just have to load it
   load(SWI_file_mat);
lseif exist(SWI_file,'file')
   % GeoTIFF file exists; read it
   fprintf('reading soil water indices from %s\n',SWI_file)
   full_SWI_img = imread(SWI_file);
   save(SWI_file_mat,'full_SWI_img');
lse
   % Error message
   cprintf([206 50 50]/255,['ERROR: missing image %s.\nCan''t proceed.\n'],SWI_file);
   return
nd
 [fP,fN,~] = fileparts(SWI_file);
 SWI_file_mat = [fP filesep fN '.mat'];
 if exist(SWI_file_mat,'file') 
     % .mat file exists, we just have to load it
     load(SWI_file_mat);
 elseif exist(ET_file,'file')
     % GeoTIFF file exists; read it
     fprintf('reading soil water data from %s\n',SWI_file)
     full_SWI_img = imread(SWI_file);
     fprintf('saving as .mat file...')
     save(SWI_file_mat,'full_SWI_img');
     fprintf('done \n')
 else
     % Read the GeoTIFF file from the web
     fprintf('reading soil water data from web:%s\n',SWI_file_URL)
     full_SWI_img = imread(SWI_file_URL);
     fprintf('saving as .mat file...')
     save(SWI_file_mat,'full_SWI_img');
     fprintf('done \n')
 end
ull_SWI_img=full_SWI_img(end:-1:1,:); % switch for correct order in latitude (images are saved 'upside down')
 Crop the image to the centroids' bounding box (for speedup)
on         = 360*(1:size(full_SWI_img,2))/size(full_SWI_img,2)+(-180); % -180..180
at         = (max_lat-min_lat)*(1:size(full_SWI_img,1))/size(full_SWI_img,1)+min_lat;
on_crop_ndx= lon&ampgt=bbox(1) &amp lon&amplt=bbox(3);
at_crop_ndx= lat&ampgt=bbox(2) &amp lat&amplt=bbox(4);
mg         = full_SWI_img(lat_crop_ndx,lon_crop_ndx);
on         = lon(lon_crop_ndx);
at         = lat(lat_crop_ndx);
LON,LAT]	= meshgrid(lon,lat); % construct regular grid
 Set the missing data to zero
mg(img==missing_data_value) = 0;
printf('assigning evapotranspiration values to centroids... ')
entroids.ET_mm_day= interp2(LON,LAT,double(img),centroids.lon,centroids.lat,'cubic');
 convert range of greyscale values into actual soil water indices
 ranging from 0 to 100
entroids.SWI = centroids.SWI./255*100;
printf(' done\n');
f check_plots
   % convert to double
   soil_wetis=double(img);
   % plot the image (kind of 'georeferenced')
   pcolor(X,Y,soil_wetis./255*100); colorbar
   shading flat
   if isfield(centroids,'admin0_name')
       title_string = sprintf('Soil water index (%), %s', ...
           centroids.admin0_name);
   else title_string = 'Soil water index (%)';
   end
   title(title_string)
   hold on
   set(gcf,'Color',[1 1 1]) % white figure background
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/centroids_SWI.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="centroids_WHC">
<H2>centroids_WHC</H2></A>
<font color="blue">function centroids=centroids_WHC(centroids, check_plots) </font>
 Assign available water holding capacity (WHC) values to given centroids
 MODULE:
   flood
 NAME:
	centroids_WHC
 PURPOSE:
   Determine water holding capacity (WHC) for given centroids by
   reading a grayscale GeoTIFF of global annual mean WHC.
   The available water-holding capacity describes the amount of water
   available for evapotranspiration after drainage and is defined as the
   field capacity minus the permanent wilting point.
   The global mean annual FC GeoTIFF image is part of the Global Gridded
   Surfaces of Selected Soil Characteristics data set, which was developed
   by the Global Soil Data Task of the International Geosphere-Biosphere
   Programme. It can be downloaded here:
   http://webmap.ornl.gov/wcsdown/wcsdown.jsp?dg_id=569_3
   The image needs to be placed in data/system of the climada module
   flood.
   WHC values are in mm.
   For more information on the Global Soil Data Task, see
   https://daac.ornl.gov/SOILS/guides/igbp-surfaces.html
 CALLING SEQUENCE:
   centroids = centroids_WHC(centroids, check_plots, force_recalc)
 EXAMPLE:
   centroids = centroids_WHC(centroids)
 INPUTS:
  centroids: Climada centroids struct; the following fields are required:
         .lat:           Latitude
         .lon:           Longitude
         .centroid_ID:   centroid ID
         .admin0_name    Country name
 OPTIONAL INPUT PARAMETERS:
   check_plots: whether a plot should be drawn (=1) or not (=0; default)
   force_recalc: if set to 1, FC is calculated even if the centroids
   already have a field 'water_holding_capacity' (default is 0)
 OUTPUTS:
   centroids: The input centroids structure with an additional field
   'WHC_mm' (water holding capacity), which contains the annual mean available
   water holding capacity
   (in mm) of each centroid
 NOTE:
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150325, initial
 Gilles Stassen, gillesstassen@hotmail.com, 20150423, cleanup
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/centroids_WHC.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="centroids_basin_ID">
<H2>centroids_basin_ID</H2></A>
<font color="blue">function [centroids, shapes] = centroids_basin_ID(centroids, res, check_plots) </font>
 assign basin ID to centroids
 MODULE:
   tbd
 NAME:
	country_basin_ID
 PURPOSE:
   Assign basin IDs to centroids based on HydroSHEDS basin outline
   shapefiles For more information and a technical documentation see
   http://hydrosheds.org/page/hydrobasins
 CALLING SEQUENCE:
   centroids_basin_ID = centroids_basin_ID(basin_shapefile,centroids, check_plots)
 EXAMPLE:
   centroids_basin_ID = centroids_basin_ID('',centroids,0)
 INPUTS:
   centroids: Climada centroids struct; the following fields are required:
         .lat:           Latitude
         .lon:           Longitude
         .centroid_ID:   centroid ID
         .admin0_name    Country name
 OPTIONAL INPUT PARAMETERS:
   basin_shapefile: name (including full path) of the basin shapefile to
   be used. If left empty, the code constructs default names corresponding
   to the shapefile names as provided by HydroSHEDS. The basin shapefiles
   need to be located in the data/system folder of the CLIMADA flood
   module.
   res: resolution of shape file - the HydroSHEDS basin outline files are
   provided in 15 arcsecond (res==15; default) and 30 arcsecond (res==30)
   resolution.
   check_plots: whether a plot of the centroids should be generated (=1),
   or not (=0; default)
   force_recalc: if set to 1, basin IDs are recalculated even if they
   already exist (default is 0)
 OUTPUTS:
   centroids: centroids with an additional field 'basin_ID' denoting the
   river basin a centroid has been assigned to

 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150301, initial
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150314, add basin identification based on continents
 Gilles Stassen, gillesstassen@hotmail.com, 20150315, added use of subdir
 Gilles Stassen, gillesstassen@hotmail.com, 20150327, automatic download functionality
 Gilles Stassen, 20150408, clean up, the file finding piece in particular
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/centroids_basin_ID.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="centroids_river_network">
<H2>centroids_river_network</H2></A>
<font color="blue">function centroids = centroids_river_network(centroids,check_plots) </font>
 identify river network in centroids
 MODULE:
   flood
 NAME:
	centroids_river_network
 PURPOSE:
   Add rivers to centroids based on HydroSHEDS river network outline
   shapefiles For more information and a technical documentation see
   http://hydrosheds.org/page/hydrobasins,

 CALLING SEQUENCE:
   centroids = centroids_river_network(river_shapes,centroids, check_plots)
 EXAMPLE:
   centroids = centroids_river_network('',centroids,0)
 INPUTS:
   centroids: Climada centroids struct; the following fields are required:
         .lat:           Latitude
         .lon:           Longitude
         .centroid_ID:   centroid ID
         .admin0_NAME    Country name
 OPTIONAL INPUT PARAMETERS:
   river_shapes:   name (including full path) of the river network shapefile
                   to be used. If set for 'DL', climada will
                   automatically download the relevant files given the
                   spatial extent of the centroids.
   res:            resolution of shape file - the HydroSHEDS files are
                   provided in 15 arcsecond (res==15; default) and 30
                   arcsecond (res==30) resolution.
   check_plots:    whether a plot of the centroids should be generated (=1),
                   or not (=0; default)
 OUTPUTS:
   centroids:      centroids with an additional field 'river' defining the
                   river network as logicals.
 MODIFICATION HISTORY:
   Gilles Stassen, gillesstassen@hotmail.com, 20150318
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/centroids_river_network.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_90m_DEM">
<H2>climada_90m_DEM</H2></A>
<font color="blue">function [centroids, DEM] = climada_90m_DEM(centroidsORcountryORshapes, srtm_dir, DEM_save_file, smooth, check_plot) </font>
 climada
 MODULE:
   flood
 NAME:
   climada_read_srtm_DEM
 PURPOSE:
   Read the digital elevation model data from the files in an existing
   srtm directory. Data can be downloaded from http://srtm.csi.cgiar.org/SELECTION/inputCoord.asp
 CALLING SEQUENCE:
   [centroids,DEM] = climada_90m_DEM(centroids, srtm_dir, DEM_save_file, smooth, check_plot)
 EXAMPLE:
   [centroids,DEM] = climada_90m_DEM('Netherlands',[],[],[],1)
   [~,DEM] = climada_90m_DEM
   [centroids,DEM] = climada_90m_DEM([min_lon max_lon min_lat max_lat],srtm_dir,DEM_save_file, 4,1)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   centroids:  If centroids are provided as an input, the DEM will contain
               elevation data sampled at the location of centroids, and
               hence will have an extra field .centroid_ID. The extra
               field is required for tc_surge_hazard_create if you wish to
               provide your own topography data (e.g. srtm).
               If this input is left empty , a
               centroids struct will be generated at the same resolution
               as the DEM.
               If set to a 4-element vector (centroids_rect), these 4
               points will define the area of interest, which is
               subsequently cropped out of the DEM.
               NOTE:   It is only sensible to provide a centroids struct
               as input if its resolution is significantly lower than that
               of the DEM, otherwise, it is much faster to generate
               centroids directly from the DEM.
   srtm_dir:   The directory of an srtm data tile folder, containing at
               least a .hdr and a .tif file. Can also be set to 'DL' 
               (default) which will initiate automatic download from SRTM 
               website according to the centroidsORcountry given as input.
   smooth:     Can either be set to an integer N (smooth by default filter
               specified by a matrix size NxN with values 1/N^2) or a
               smoothing filter. Default = [] (no smoothing).
   check plot: Specify whether to plot a relief of the DEM, default = 0
 OUTPUTS:
   DEM:        Struct containing information of the digital elevation
               model at full 90m resolution, with fields:
               .elevation_m:   Elevation data
               .lat:           Latitude
               .lon:           Longitude
               .centroid_ID:   Only if centroids provided as input or if
                               centroids input set to 1.
   centroids:  Climada centroids struct with fields:
               .elevation_m:   Elevation data
               .lat:           Latitude
               .lon:           Longitude
               .centroid_ID:   Only if centroids provided as input or if
                               centroids input set to 1.
               .onLand:        Set to 0 if .elevation_m &amplt0, 1 otherwise
               .admin0_name    Country name
               .admin0_ISO3    ISO 3 country code
 MODIFICATION HISTORY:
 Gilles Stassen 20150107
 Gilles Stassen 20150224     fixed some bugs in the plotting routines
                               and added messages to warn of DEM edges
 Gilles Stassen 20150225     cleanup and added automatic download and
                               unzip feature
 Gilles Stassen 20150707     renamed climada_read_srtm_DEM-&ampgtclimada_90m_DEM
                               usage of climada_grid2array replaced with
                               reshape, some further bug fixes
 Lea Mueller, muellele@gmail.com, 20150720, @Gilles, please correct,
   code does not work, srtm_19_10 is a .tif.aux.xml, not a .tif, probably
   file was not copied from your drive to the shared drive
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_90m_DEM.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_DEM_plot">
<H2>climada_DEM_plot</H2></A>
<font color="blue">function [h,I,z]=climada_DEM_plot(x,y,z,varargin) </font>
DEM Shaded relief image plot

	DEM(X,Y,Z) plots the Digital Elevation Model defined by X and Y 
	coordinate vectors and elevation matrix Z, as a lighted image using
	specific &quotlandcolor&quot and &quotseacolor&quot colormaps. DEM uses IMAGESC 
	function which is much faster than SURFL when dealing with large 
	high-resolution DEM. It produces also high-quality and moderate-size 
	Postscript image adapted for publication.

	[H,I] = DEM(...); returns graphic handle H and illuminated image as I, 
	an MxNx3 matrix (if Z is MxN and DECIM is 1).

	DEM(X,Y,Z,'Param1',Value1,'Param2',Value2,...) specifies options or
	parameter/value couple (case insensitive):


	--- Lighting options ---

	'Azimuth',A
		Light azimuth in degrees clockwise relative to North. Default is
		A = -45 for	a natural northwestern illumination.

	'Contrast',C
		Light contrast, as the exponent of the gradient value:
			C = 1 for linear contrast (default),
			C = 0 to remove lighting,
			C = 0.5 for moderate lighting,
			C = 2 or more for strong contrast.

	'LCut',LC
		Lighting scale saturation cut with a median-style filter in % of 
	    elements, such as LC% of maximum gradient values are ignored:
			LC = 0.2 is default, 
			LC = 0 for full scale gradient.

	'km'
		Stands that X and Y coordinates are in km instead of m (default).
		This allows correct lighting. Ignored if LATLON option is used.


	--- Elevation colorscale options ---

	'ZLim',[ZMIN,ZMAX]
		Fixes min and max elevation values for colormap. Use NaN to keep 
		real min and/or max data values.

	'ZCut',ZC
		Median-style filter to cut extremes values of Z (in % of elements),
		such that ZC% of most min/max elevation values are ignored in the
		colormap application:
			ZC = 0.5 is default, 
			ZC = 0 for full scale.


	--- &quotNo Value&quot elevation options ---

	'NoValue',NOVALUE
		Defines the values that will be replaced by NaN. Note that values 
		equal to minimum of Z class are automatically detected as NaN 
		(e.g., -32768 for int16 class).

	'NaNColor',[R,G,B]
		Sets the RGB color for NaN/NoValue pixels (default is a dark gray).
		Note that your must specify a valid 3-scalar vector (between 0 and
		1);	color characters like 'w' or 'k' are not allowed, use [1,1,1]
		or [0,0,0] instead.

	'Interp'
		Interpolates linearly all NaN values (fills the gaps using linear 
		triangulation), using an optimized algorithm.


	--- Colormap options ---

	'LandColor',LMAP
		Uses LMAP colormap instead of default (landcolor, if exists or 
		jet) for Z &ampgt 0 elevations.

	'SeaColor',SMAP
		Sets the colormap used for Z &amplt= 0 elevations. Default is seacolor 
		(if exists) or single color [0.7,0.9,1] (a light cyan) to simulate
		sea color.

	'ColorMap',CMAP
		Uses CMAP colormap for full range of elevations, instead of default 
		land/sea. This option overwrites LANDCOLOR/SEACOLOR options.

	'Lake'
		Detects automaticaly flat areas different from sea level (non-zero 
		elevations) and colors them as lake surfaces.

	'Watermark',N
		Makes the whole image lighter by a factor of N.


	--- Basemap and scale options ---

	'Legend'
		Adds legends to the right of graph: elevation scale (colorbar)
		and a distance scale (in km).

	'Cartesian'
		Plots classic basemap-style axis, considering coordinates X and Y 
		as cartesian in meters. Use parameter &quotkm' for X/Y in km.

	'LatLon'
		Plots geographic basemap-style axis in deg/min/sec, considering 
		coordinates X as longitude and Y as latitude. Axis aspect ratio 
		will be adjusted to approximatively preserve distances (this is  
		not a real projection!). This overwrites ZRatio option.

	'AxisEqual', 'auto' (default) | 'manual' | 'off'
		When 'Cartesian' or 'LatLon' option is used, automatic axes scaling
		is applied to respect data aspect ratio. Default mode is 'auto' and
		uses AXIS EQUAL and DASPECT functions. The 'manual' mode modifies
		axes width or height with respect to the paper size in order to
		produce correct data scaling at print (but not necessarily at 
		screen). The 'off' mode disables any scaling.

	Additionnal options for basemap CARTESIAN or LATLON:

	'BorderWidth',BW
		Border width of the basemap axis, in % of axis height. Default is
		BW = 1%.

	'XTick',DX
	'YTick',DY
		X and Y Tick length (same unit as X and Y). Default is automatic.
		Tick labels are every 2 ticks.

	'FontSize',FS
		Font size for X and Y tick labels. Default is FS = 10.

	'FontBold'
		Font weight bold for tick labels.


	--- Decimation options ---

	For optimization purpose, DEM will automatically decimate data to limit
	to a total of 1500x1500 pixels images. To avoid this, use following
	options, but be aware that large grids may require huge computer 
	ressources or induce disk swap or memory errors.

	'Decim',N
		Decimates matrix Z at 1/N times of the original sampling.

	'NoDecim'
		Forces full resolution of Z, no decimation.



	--- Informations ---

	Colormaps are Mx3 RGB matrix so it is easy to modify saturation 
	(CMAP.^N), set darker (CMAP/N), lighter (1 - 1/N + CMAP/N), inverse
	it (flipud(CMAP)), etc...

	To get free worldwide topographic data (SRTM), see READHGT function.

	For backward compatibility, the former syntax is still accepted:
	DEM(X,Y,Z,OPT,CMAP,NOVALUE,SEACOLOR) where OPT = [A,C,LC,ZMIN,ZMAX,ZC],
	also option aliases DEC, DMS and SCALE, but there is no argument 
	checking. Please prefer the param/value syntax.

	Author: Franois Beauducel &ampltbeauducel@ipgp.fr&ampgt
	Created: 2007-05-17
	Updated: 2014-06-06
	History:
	[2014-06-06]
		- improve backward compatibility (adds strjoin subfunction)
	[2014-03-18]
		- adds new axisequal option
	[2013-03-11]
		- new options: 'km', 'watermark', 'fontsize', 'bordersize'
		- improve legend colorbar
		- all options now passed as param/value
	[2013-01-14]
		- improved light rendering (using surface normals instead of gradient)
		- improved 'lake' detection algorithm
		- new 'nancolor' option to set NaN color
		- adds a length scale with 'dec' option
		- minor code improvements
	[2013-01-07]
		- adds 'interp' option (fill the gaps)
		- adds 'seacolor' colormap for negative elevations (bathymetry)
	[2013-01-02]
		- adds a 'lake' option
		- minor bug correction
	[2012-09-26]
		- now accepts row/column vectors for X and/or Y.
	[2012-05-29]
		- adds basemap-style axis in decimal or lat/lon modes
		- adds elevation and distance scales
	[2012-05-18]
		- new landcolor.m colormap function
		- new arguments to control colormap scaling
		- median-style filters for light and colormap
	[2012-04-26]
		- Optimizations: adds a decimation for large DEM grids.

	Copyright (c) 2014, Franois Beauducel, covered by BSD License.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without 
	modification, are permitted provided that the following conditions are 
	met:

	   * Redistributions of source code must retain the above copyright 
	     notice, this list of conditions and the following disclaimer.
	   * Redistributions in binary form must reproduce the above copyright 
	     notice, this list of conditions and the following disclaimer in 
	     the documentation and/or other materials provided with the distribution
	                           
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quotAS IS&quot 
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
	CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
	INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
	POSSIBILITY OF SUCH DAMAGE.
f nargin &amplt 3
error('Not enough input arguments.');
nd
egkm = 6378*pi/180; % one latitude degree in km
ea_color = [.7,.9,1]; % default sea color (light cyan)
rey = 0.2*[1,1,1]; % a dark gray
 -------------------------------------------------------------------------
 --- Manage input arguments
 number of arguments param/value
args = 0;
f ~isnumeric(x) || ~isnumeric(y) || ~isnumeric(z)
error('X,Y and Z must be numeric.')
nd
f all(size(x) ~= 1) || all(size(y) ~= 1)
error('X and Y must be vectors, not matrix.')
nd
f length(x) ~= size(z,2) || length(y) ~= size(z,1)
error('If Z has a size of [M,N], X must have a length of N, and Y a length of M.')
nd
 OPTIONS and PARAM/VALUE arguments
		
 AZIMUTH param/value
s,az] = checkparam(varargin,'azimuth',@isscalar);
args = nargs + 2;
f s==0
az = -45; % default
nd
 ELEVATION param/value
s,el] = checkparam(varargin,'elevation',@isscalar);
args = nargs + 2;
f s==0
el = 0; % default
nd
 CONTRAST param/value
s,ct] = checkparam(varargin,'contrast',@isscalar);
args = nargs + 2;
f s
ct = abs(ct);
lse
ct = 1; % default
nd
 LCUT param/value
s,lcut] = checkparam(varargin,'lcut',@isperc);
args = nargs + 2;
f s==0
lcut = .2; % default
nd
 NOVALUE param/value
s,novalue] = checkparam(varargin,'novalue',@isscalar);
args = nargs + 2;
f s==0
% default: min value for integer class / NaN for float
S = whos('z');
if strfind(S.class,'int')
	novalue = intmin(S.class);
else
	novalue = NaN;
end
nd
 NANCOLOR param/value
s,novalue_color] = checkparam(varargin,'nancolor',@isrgb);
args = nargs + 2;
f s==0
novalue_color = grey; % default
nd
 LANDCOLOR param/value
s,cland] = checkparam(varargin,'landcolor',@isrgb);
args = nargs + 2;
f s==0
% default: landcolor or jet
if exist('landcolor','file')
	cland = landcolor.^1.3;
else
	cland = jet(256);
end
nd
 SEACOLOR param/value
s,csea] = checkparam(varargin,'seacolor',@isrgb);
args = nargs + 2;
f s==0
% default: seacolor or single color
if exist('seacolor','file')
	csea = seacolor;
else
	csea = sea_color;
end
nd
 COLORMAP param/value
s,cmap] = checkparam(varargin,'colormap',@isrgb);
args = nargs + 2;
f s
cland = [];
csea = [];
lse
% default
cmap = cland;
nd
 ZLIM param/value
s,zmm] = checkparam(varargin,'zlim',@isvec);
args = nargs + 2;
f s
zmin = min(zmm);
zmax = max(zmm);
lse
zmin = NaN; % default
zmax = NaN; % default
nd
 ZCUT param/value
s,zcut] = checkparam(varargin,'zcut',@isperc);
args = nargs + 2;
f s==0
zcut = .5; % default
nd
 ZRATIO param/value
s,zratio] = checkparam(varargin,'zratio',@isscalar);
args = nargs + 2;
f s==0
zratio = 1; % default
nd
 WATERMARK param/value
s,wmark] = checkparam(varargin,'watermark',@isscalar);
args = nargs + 2;
f s
wmark = abs(wmark);
lse
wmark = 0; % default
nd
 DECIM param/value and NODECIM option
s,decim] = checkparam(varargin,'decim',@isscalar);
f s
decim = round(decim);
nargs = nargs + 2;
lse
decim = any(strcmpi(varargin,'nodecim')); % default
nargs = nargs + 1;
nd
 FONTSIZE param/value
s,fs] = checkparam(varargin,'fontsize',@isscalar);
args = nargs + 2;
f s==0
fs = 10; % default
nd
 BORDERWIDTH param/value
s,bw] = checkparam(varargin,'borderwidth',@isperc);
args = nargs + 2;
f s==0
bw = 1; % default
nd
 XTICK param/value
s,ddx] = checkparam(varargin,'xtick',@isscalar);
args = nargs + 2;
f s==0
ddx = 0; % default (automatic)
nd
 YTICK param/value
s,ddy] = checkparam(varargin,'ytick',@isscalar);
args = nargs + 2;
f s==0
ddy = 0; % default (automatic)
nd
 AXISEQUAL param/value
s,axeq] = checkparam(varargin,'axisequal',@ischar,{'auto','manual','off'});
args = nargs + 2;
f s==0 || ~any(strcmpi(axeq,{'manual','off'}))
axeq = 'auto'; % default (automatic)
nd
 CROP param/value
s,crop] = checkparam(varargin,'crop',@isvec,4);
args = nargs + 2;
 options without argument value
m = any(strcmpi(varargin,'km'));
ec = any(strcmpi(varargin,'cartesian') | strcmpi(varargin,'dec'));
ms = any(strcmpi(varargin,'latlon') | strcmpi(varargin,'dms'));
cale = any(strcmpi(varargin,'legend') | strcmpi(varargin,'scale'));
nter = any(strcmpi(varargin,'interp'));
ake = any(strcmpi(varargin,'lake'));
bold = any(strcmpi(varargin,'fontbold'));
 for backward compatibility (former syntax)...
args = nargs + dec + dms + scale + lake + inter + km + fbold;
f (nargin - nargs) &ampgt 3 &amp&amp ~isempty(varargin{1})
opt = varargin{1};
if ~isnumeric(opt)
	error('OPT = [A,C,S,ZMIN,ZMAX,ZCUT] argument must be numeric.');
end
if ~isempty(opt)
	az = opt(1);
end
if length(opt) &ampgt 1
	ct = opt(2);
end
if length(opt) &ampgt 2
	lcut = opt(3);
end
if length(opt) &ampgt 4
	zmin = opt(4);
	zmax = opt(5);
end
if length(opt) &ampgt 5
	zcut = opt(6);
end
nd
f (nargin - nargs) &ampgt 4 &amp&amp ~isempty(varargin{2})
cmap = varargin{2};
csea = [];
nd
f (nargin - nargs) &ampgt 5 &amp&amp ~isempty(varargin{3})
novalue = varargin{3};
nd
f (nargin - nargs) &ampgt 6 &amp&amp ~isempty(varargin{4})
csea = varargin{4};
nd
 further test of input arguments
f dms &amp&amp any(abs(y) &ampgt 91)
error('With LATLON option Y must be in valid latitudes interval (decimal degrees).')
nd
f km
zratio = 1000;
nd
 -------------------------------------------------------------------------
 --- Pre-process DEM data
 crops data if needed
f numel(crop)==4
fprintf('DEM: crops original data from [%g,%g,%g,%g] to [%g,%g,%g,%g]...\n', ...
	min(x(:)),max(x(:)),min(y(:)),max(y(:)),crop);
kx = find(x &ampgt= crop(1) &amp x &amplt= crop(2));
ky = find(y &ampgt= crop(3) &amp y &amplt= crop(4));
x = x(kx);
y = y(ky);
z = z(ky,kx);
nd
 decimates data to avoid disk swap/out of memory...
max = 1500;
f decim
n = decim;
lse
n = ceil(sqrt(numel(z))/nmax);
nd
f n &ampgt 1
x = x(1:n:end);
y = y(1:n:end);
z = z(1:n:end,1:n:end);
fprintf('DEM: on the plot data has been decimated by a factor of %d...\n',n);
nd
 = double(z); % necessary for most of the following calculations...
(z==novalue) = NaN;
f inter
z = fillgap(x,y,z);
nd
f isempty(csea)
k = (z~=0 &amp ~isnan(z));
lse
k = ~isnan(z);
nd
f isnan(zmin)
zmin = nmedian(z(k),zcut/100);
nd
f isnan(zmax)
zmax = nmedian(z(k),1 - zcut/100);
nd
z = zmax - zmin;
 -------------------------------------------------------------------------
 --- Process lighting
f dz &ampgt 0
% builds the colormap: concatenates seacolor and landcolor around 0
if ~isempty(csea)
	l = size(csea,1);
	if zmin &amplt 0 &amp&amp zmax &ampgt 0
		r = size(cland,1)*abs(zmin)/zmax/l;
		cmap = cat(1,interp1(1:l,csea,linspace(1,l,ceil(l*r)),'*linear'),cland);
	elseif zmax &amplt=0
		cmap = csea;
	end
end

% normalisation of Z using CMAP and convertion to RGB
I = ind2rgb(uint16(round((z - zmin)*(size(cmap,1) - 1)/dz) + 1),cmap);

if ct &ampgt 0
	% computes lighting from elevation gradient
	%[fx,fy] = gradient(z,x,y);
	if dms
		ryz = degkm*1000;
		rxz = degkm*1000*cosd(mean(y));
	else
		rxz = zratio;
		ryz = zratio;
	end
	[xx,yy] = meshgrid(x*rxz,y*ryz);
	[fx,fy,fz] = surfnorm(xx,yy,z);
	[ux,uy,uz] = sph2cart((90-az)*pi/180,el*pi/180,1);
	fxy = fx*ux + fy*uy + fz*uz;
	clear xx yy fx fy fz	% free some memory...
	
	fxy(isnan(fxy)) = 0;
	% computes maximum absolute gradient (median-style), normalizes,
	% saturates and duplicates in 3-D matrix
	li = 1 - abs(sind(el)); % light amplitude (experimental)
	r = repmat(max(min(li*fxy/nmedian(abs(fxy),1 - lcut/100),1),-1),[1,1,3]);
	rp = (1 - abs(r)).^ct;

	% applies contrast using exponent
	I = I.*rp;

	% lighter for positive gradient
	I(r&ampgt0) = I(r&ampgt0) + (1 - rp(r&ampgt0));
			
end
% set novalues / NaN to nancolor
[i,j] = find(isnan(z));
if ~isempty(i)
	I(sub2ind(size(I),repmat(i,1,3),repmat(j,1,3),repmat(1:3,size(i,1),1))) = repmat(novalue_color,size(i,1),1);
end

% lake option
if lake
	klake = islake(z);
else
	klake = 0;
end

% set the seacolor for 0 values
if ~isempty(csea)
	[i,j] = find(z==0 | klake);
	if ~isempty(i)
		I(sub2ind(size(I),repmat(i,1,3),repmat(j,1,3),repmat(1:3,size(i,1),1))) = repmat(csea(end,:),size(i,1),1);
	end
end
if wmark
	I = watermark(I,wmark);
end

hh = imagesc(x,y,I);

lse

hh = imagesc(x,y,repmat(shiftdim(sea_color,-1),size(z)));
text(mean(x),mean(y),'SPLASH!','Color',sea_color/4, ...
	'FontWeight','bold','HorizontalAlignment','center')
cmap = repmat(sea_color,[256,1]);
if nargin &ampgt 1
	I = ones(size(z));
end
nd
rient tall; axis xy
f strcmpi(axeq,'auto')
axis equal
nd
xis tight
lim = [min(x),max(x)];
lim = [min(y),max(y)];
lim = [min([z(z(:) ~= novalue);zmin]),max([z(z(:) ~= novalue);zmax])];
f dms
% approximates X-Y aspect ratio for this latitude (&amplt 20-m precision for 1x1 grid)
xyr = cos(mean(y)*pi/180);
lse
xyr = 1;
nd
w0 = max(diff(xlim)*xyr,diff(ylim))/100;
wy = bw*bw0; % Y border width = 1%
wx = bwy/xyr; % border width (in degree of longitude)
 -------------------------------------------------------------------------
 --- Axis basemap style
f dec || dms
axis off
if strcmpi(axeq,'manual')
	ppos = get(gcf,'PaperPosition');
	apos = get(gca,'Position');
	xyf = (xyr*diff(xlim)/apos(3)/ppos(3))/(diff(ylim)/apos(4)/ppos(4));
	if xyf &ampgt= 1
		set(gca,'Position',[apos(1),apos(2),apos(3),apos(4)/xyf]);
	else
		set(gca,'Position',[apos(1),apos(2),apos(3)*xyf,apos(4)]);
	end
end
if strcmpi(axeq,'auto')
	if diff(xlim)*xyr &amplt= diff(ylim)
		set(gca,'DataAspectRatio',[1,xyr,1])
	else
		set(gca,'DataAspectRatio',[1/xyr,1,1])
	end
end
if bw &ampgt 0
	% transparent borders
	patch([xlim(1)-bwx,xlim(2)+bwx,xlim(2)+bwx,xlim(1)-bwx],ylim(1) - bwy*[0,0,1,1],'k','FaceColor','none','clipping','off')
	patch([xlim(1)-bwx,xlim(2)+bwx,xlim(2)+bwx,xlim(1)-bwx],ylim(2) + bwy*[0,0,1,1],'k','FaceColor','none','clipping','off')
	patch(xlim(1) - bwx*[0,0,1,1],[ylim(1)-bwy,ylim(2)+bwy,ylim(2)+bwy,ylim(1)-bwy],'k','FaceColor','none','clipping','off')
	patch(xlim(2) + bwx*[0,0,1,1],[ylim(1)-bwy,ylim(2)+bwy,ylim(2)+bwy,ylim(1)-bwy],'k','FaceColor','none','clipping','off')
end
dlon = {'E','W'};
dlat = {'N','S'};
if fbold
	fw = 'bold';
else
	fw = 'normal';
end

if ddx == 0
	ddx = dtick(diff(xlim),dms);
end
if ddy == 0
	ddy = dtick(diff(ylim),dms);
end
xtick = (ddx*ceil(xlim(1)/ddx)):ddx:xlim(2);
for xt = xtick(1:2:end)
	dt = ddx - max(0,xt + ddx - xlim(2));
	patch(repmat(xt + dt*[0,1,1,0]',[1,2]),[ylim(1) - bwy*[0,0,1,1];ylim(2) + bwy*[0,0,1,1]]','k','clipping','off')
	if fs &ampgt 0
		text(xt,ylim(1) - 1.2*bwy,deg2dms(xt,dlon,dec),'FontSize',fs,'FontWeight',fw, ...
			'HorizontalAlignment','center','VerticalAlignment','top');
	end
end
ytick = (ddy*ceil(ylim(1)/ddy)):ddy:ylim(2);
for yt = ytick(1:2:end)
	dt = ddy - max(0,yt + ddy - ylim(2));
	patch([xlim(1) - bwx*[0,0,1,1];xlim(2) + bwx*[0,0,1,1]]',repmat(yt + dt*[0,1,1,0]',[1,2]),'k','clipping','off')
	if fs &ampgt 0
		text(xlim(1) - 1.2*bwx,yt,deg2dms(yt,dlat,dec),'FontSize',fs,'FontWeight',fw, ...
			'HorizontalAlignment','center','VerticalAlignment','bottom','rotation',90);
	end
end
nd
 -------------------------------------------------------------------------
 --- Scales legend
f scale
%wsc = diff(xlim)*0.01;
wsc = bw0;
xsc = xlim(2) + wsc*2 + bwx;
if wmark
	cmap = watermark(cmap,wmark);
end
% -- elevation scale (colorbar)
zscale = linspace(zmin,zmax,length(cmap));
yscale = linspace(0,diff(ylim)/2,length(cmap));
ysc = ylim(1);
ddz = dtick(dz*max(0.5*xyr*diff(xlim)/yscale(end),1));
ztick = (ddz*ceil(zscale(1)/ddz)):ddz:zscale(end);
patch(xsc + repmat(wsc*[-1;1;1;-1],[1,length(cmap)]), ...
	ysc + [repmat(yscale,[2,1]);repmat(yscale + diff(yscale(1:2)),[2,1])], ...
	repmat(zscale,[4,1]), ...
	'EdgeColor','flat','LineWidth',.1,'FaceColor','flat','clipping','off')
colormap(cmap)
caxis([zmin,zmax]);
patch(xsc + wsc*[-1,1,1,-1],ysc + yscale(end)*[0,0,1,1],'k','FaceColor','none','Clipping','off')
text(xsc + 2*wsc + zeros(size(ztick)),ysc + (ztick - zscale(1))*0.5*diff(ylim)/diff(zscale([1,end])),num2str(ztick'), ...
	'HorizontalAlignment','left','VerticalAlignment','middle','FontSize',6)
% indicates min and max Z values
text(xsc,ysc - bwy/2,sprintf('%g m',roundsd(zlim(1),3)),'FontWeight','bold', ...
	'HorizontalAlignment','left','VerticalAlignment','top','FontSize',6)
text(xsc,ysc + .5*diff(ylim) + bwy/2,sprintf('%g m',roundsd(zlim(2),3)),'FontWeight','bold', ...
	'HorizontalAlignment','left','VerticalAlignment','bottom','FontSize',6)

% -- distance scale (in km)
if dms
	fsc = degkm;
else
	fsc = zratio/1e3;
end
dkm = dtick(diff(ylim)*fsc);
ysc = ylim(2) - 0.5*dkm/fsc;
patch(xsc + wsc*[-1,-1,0,0],ysc + dkm*0.5*[-1,1,1,-1]/fsc,'k','FaceColor',grey,'clipping','off')
if dkm &ampgt 1
	skm = sprintf('%g km',dkm);
else
	skm = sprintf('%g m',dkm*1000);
end
text(xsc,ysc,skm,'rotation',-90,'HorizontalAlignment','center','VerticalAlignment','bottom', ...
		'Color',grey,'FontWeight','bold','FontSize',6)
nd
f nargout &ampgt 0
h = hh;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function y = nmedian(x,n) </font>
NMEDIAN Generalized median filter
	NMEDIAN(X,N) sorts elemets of X and returns N-th value (N normalized).
	So:
	   N = 0 is minimum value
	   N = 0.5 is median value
	   N = 1 is maximum value
f nargin &amplt 2
n = 0.5;
nd
 = sort(x(:));
 = interp1(sort(y),n*(length(y)-1) + 1);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function dd = dtick(dlim,deg) </font>
DTICK Tick intervals
f nargin &amplt 2
deg = 0;
nd
f deg &amp&amp dlim &amplt= 2/60
% less than 2 minutes: base 36
m = 10^floor(log10(dlim*36))/36;
lseif deg &amp&amp dlim &amplt= 2
% less than 2 degrees: base 6
m = 10^floor(log10(dlim*6))/6;
lse
% more than few degrees or not degrees: decimal rules
m = 10^floor(log10(dlim));
nd
 = ceil(dlim/m);
f p &amplt= 1
dd = .1*m;
lseif p == 2
dd = .2*m;
lseif p &amplt= 5
dd = .5*m;
lse
dd = m;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function s = deg2dms(x,ll,dec) </font>
DEG2DMS Degree/minute/second display
f dec
s = sprintf('%7.7g',x);
lse
xa = abs(x) + 1/360000;
%sd = sprintf('%d%c',floor(xa),176);	% ASCII char 176 is the degree sign
sd = sprintf('%d',floor(xa));
sm = '';
ss = '';
if mod(x,1)
	sm = sprintf('%02d''',floor(mod(60*xa,60)));
	sa = floor(mod(3600*xa,60));
	if sa
		ss = sprintf('%02d&quot',sa);
	else
		if strcmp(sm,'00''')
			sm = '';
		end
	end
end
s = [sd,sm,ss,ll{1+int8(x&amplt0)}];
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function z = fillgap(x,y,z) </font>
 GRIDDATA is not efficient for large arrays, but has great advantage to be
 included in Matlab's core functions! To optimize interpolation, we
 reduce the amount of relevant data by building a mask of all surrounding
 pixels of novalue areas... playing with linear index!
z = size(z);
 = find(isnan(z));
(k == 1 | k == numel(z)) = []; % removes first and last index (if exist)
f ~isempty(k)
[xx,yy] = meshgrid(x,y);
mask = zeros(sz,'int8');
k2 = ind90(sz,k); % k2 is linear index in the row order
% sets to 1 every previous and next index, both in column and row order
mask([k-1;k+1;ind90(fliplr(sz),[k2-1;k2+1])]) = 1; 
mask(k) = 0; % removes the novalue index
kb = find(mask); % keeps only border values
z(k) = griddata(xx(kb),yy(kb),z(kb),xx(k),yy(k));
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function k2 = ind90(sz,k) </font>
i,j] = ind2sub(sz,k);
2 = sub2ind(fliplr(sz),j,i); % switched i and j: k2 is linear index in row order
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function k = islake(z) </font>
 ISLAKE mask of zero gradient on 3x3 tiles
 We use diff matrix in row and column directions, and shift it to build
 a single vectorized test of surrounding pixels. To do this we must
 concatenate unit vectors in different combinations...
x = diff(z,1,2);	% differences in X direction
y = diff(z,1,1);	% differences in Y direction
1 = ones(size(z,1),1);	% row unit vector 
2 = ones(1,size(z,2));	% column unit vector
2r = u2(2:end);
 index of the tiles center pixel
 = ( ...
[u2;dy] == 0 &amp [dy;u2] == 0 &amp ...
[u1,dx] == 0 &amp [dx,u1] == 0 &amp ...
[u1,[dx(2:end,:);u2r]] == 0 &amp [[dx(2:end,:);u2r],u1] == 0 &amp ...
[u1,[u2r;dx(1:end-1,:)]] == 0 &amp [[u2r;dx(1:end-1,:)],u1] == 0 ...
;
 now extends it to surrounding pixels
(1:end-1,:) = (k(1:end-1,:) | k(2:end,:));
(2:end,:) = (k(2:end,:) | k(1:end-1,:));
(:,1:end-1) = (k(:,1:end-1) | k(:,2:end));
(:,2:end) = (k(:,2:end) | k(:,1:end-1));
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function s = isrgb(x,n) </font>
f nargin &amplt 2
n = 0;
nd
f isnumeric(x) &amp&amp (n == 1 &amp&amp all(size(x) == [1,3]) || n == 0 &amp&amp size(x,2) == 3) ...
	&amp&amp all(x(:) &ampgt= 0 &amp x(:) &amplt= 1)
s = 1;
lse
s = 0;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function s = isperc(x) </font>
f isnumeric(x) &amp&amp isscalar(x) &amp&amp x &ampgt= 0 &amp&amp x &amplt= 100
s = 1;
lse
s = 0;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function s = isvec(x,n) </font>
f nargin &amplt 2
n = 2;
nd
f isnumeric(x) &amp&amp numel(x) == n
s = 1;
lse
s = 0;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function y=roundsd(x,n) </font>
g = 10.^(floor(log10(abs(x)) - n + 1));
 = round(x./og).*og;
(x==0) = 0;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function y = watermark(x,n) </font>
f nargin &amplt 2
n = 2;
nd
f n == 0
   y = x;
lse
   y = (x/n + 1 - 1/n);
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function [s,v] = checkparam(arg,nam,func,val) </font>
witch func2str(func)
case 'isscalar'
	num = 1;
	mes = 'scalar value';
case 'isperc'
	num = 1;
	mes = 'percentage scalar value';
case 'isvec'
	num = 1;
	if nargin &amplt 4
		val = 2;
	end
	mes = sprintf('%d-element vector',val);
case 'isrgb'
	num = 1;
	mes = '[R,G,B] vector with 0.0 to 1.0 values';
case 'ischar'
	num = 0;
	mes = 'string';
	if nargin &ampgt 3
		mes = sprintf('%s (%s)',mes,strjoin(val,' or '));
	end
otherwise
	num = 1;
	mes = 'value';
nd
 = 0;
 = [];
 = find(strcmpi(arg,nam));
f ~isempty(k)
if (k + 1) &amplt= length(arg) ...
		&amp&amp (~num || isnumeric(arg{k+1})) ...
		&amp&amp (nargin &amplt 4 &amp&amp func(arg{k+1}) ...
			|| (nargin &ampgt 3 &amp&amp (strcmp(func2str(func),'ischar') &amp&amp ismember(arg{k+1},val)) ...
				 || strcmp(func2str(func),'isvec') &amp&amp func(arg{k+1},val)))
	v = arg{k+1};
	s = 1;
else
	error('%s option must be followed by a valid %s.',upper(nam),mes)
end
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function s=strjoin(c,d) </font>
STRJOIN Join cell array of strings
(this is for Matlab versions &amplt 2013a backward compatibility)
f nargin &amplt 2
d = '';
nd
 = numel(c);
s = cell(2,n);
s(1,:) = reshape(c,1,n);
s(2,1:n-1) = {d};
 = [ss{:}];
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/climada_DEM_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_fl_centroids_prepare">
<H2>climada_fl_centroids_prepare</H2></A>
<font color="blue">function centroids = climada_fl_centroids_prepare(centroids, check_plots, force_recalc, save_file) </font>
 Equip centroids with all necessary hydrological information 
 MODULE:
   flood
 NAME:
	climada_fl_centroids_prepare
 PURPOSE:
   Equip centroids with flood scores, wetness indices, basin IDs, 
   evapotranspiration values, soil wetness indices, and values for the 
   available water-holding capacity of the soil, such that the centroids
   then contain all the information needed for the generation of 
   a flood hazard set. 
       In step 1, flood scores and topographic wetness indices are 
       calculated for the given centroids 
       (see function centroids_fl_score_calc for details)
       In step 2, basin IDs are assigned to the centroids (see function
       centroids_basinID_assign for details)
       In step 3, evapotranspiration (ET) is calculated for the centroids
       (see centroids_ET_assign for details)
       In step 4, soil wetness index (SWI) is calculated for the centroids 
       (see centroids_SWI_assign for details)
       In step 5, available water-holding capacity of the soil (WHC) is 
       calculated for the centroids (see centroids_WHC_assign for details)
 CALLING SEQUENCE:
   centroids = fl_centroids_prepare(centroids, res, basin_shapefile,...
       check_plots, force_recalc)
 EXAMPLE:
   centroids = fl_centroids_prepare(centroids,15,'',1)
 INPUTS:
   centroids: Climada centroids struct; the following fields are required:
         .lat:           Latitude
         .lon:           Longitude
         .centroid_ID:   centroid ID
         .admin0_name    Country name
 OPTIONAL INPUT PARAMETERS:
   basin_shapefile: name (including full path) of the basin shapefile to
   be used. If left empty, the code constructs default names corresponding
   to the shapefile names as provided by HydroSHEDS. The basin shapefiles
   need to be located in the data/system folder of the CLIMADA flood
   module. 
   res: resolution of shape file - the HydroSHEDS basin outline files are
   provided in 15 arcsecond (res==15) and 30 arcsecond (res==30; default)
   resolution.
   check_plots: whether a set of plots showing topography (elevation), 
   slope, aspect angle, flood scores and basins should be generated (=1),
   or not (=0; default)
   force_recalc: if set to 1, recalculate flood scores and basin IDs, even
   if they already exist (default is 0)
 OUTPUT:
   centroids: centroids with three additional fields: 
       centroids.flood_score: flow accumulation 
       centroids.topo_wetness_index: topographic wetness index 
       centroids.basin_ID: river basins 
       centroids.evapotranspiration: evapotranspiration (mm/yr)
       centroids.soil_wetness_index: soil wetness index (%)
       centroids.water_holding_capacity: available water-holding capacity
           of the soil (mm)
  
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150311, initial
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150319, added LAI
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150321, added ET
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150324, added FC
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150325, added SWI and WHC;
 Gilles Stassen, gillesstassen@hotmail.com, 20150414, cleanup
 Gilles Stassen, 20150416, added save functionality, added BD, SD
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_TWI_calc from centroids_TWI
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/climada_fl_centroids_prepare.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_fl_hazard_set">
<H2>climada_fl_hazard_set</H2></A>
<font color="blue">function hazard = climada_fl_hazard_set(centroids,hazard_rf,hazard_set_file, check_plots) </font>
 Generate flood hazard set from tr hazard set
 MODULE:
   flood
 NAME:
   climada_fl_hazard_set
 PURPOSE:
   Generate flood hazard set from tr hazard set by distributing rainfall
   volume according to flood scores (or wetness indices) of the centroids
 PREVIOUS STEP:
   centroids_fl_prepare
 CALLING SEQUENCE:
   hazard = climada_fl_hazard_set(hazard_tr,centroids,hazard_set_file, check_plots)
 EXAMPLE:
   hazard = climada_fl_hazard_set('',centroids,hazard_set_file)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   hazard_tr: a TR hazard event set, or a filename of a saved one
       &ampgt prompted for if not given
   hazard_set_file: the name of the hazard set file
       &ampgt prompted for if not given
   centroids: Climada centroids struct; the following fields are required:
         .lat:           Latitude
         .lon:           Longitude
         .centroid_ID:   centroid ID
         .admin0_name    Country name
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150310, initial
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150312, adjustments in rainfall distribution
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_TWI_calc from centroids_TWI
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/climada_fl_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_grid2array">
<H2>climada_grid2array</H2></A>
<font color="blue">function [data, x, y] = climada_grid2array(data_grid, x_vector, y_vector) </font>
 climada
 MODULE:
   flood
 NAME:
   climada_grid2array
 PURPOSE:
   Restructure gridded data into singleton arrays. For consistency with
   imagesc, the first index in data_grid corresponds to the x coords,
   while the second index corresponds to the y coords. Used in
   climada_read_srtm_DEM, read_APHRO_MA_V1101 and climada_rf_hazard_set
 CALLING SEQUENCE:
 EXAMPLE:
 INPUTS:
   data_grid:  Gridded data  
 OPTIONAL INPUT PARAMETERS:
   x_vector:   Monotonically in/decreasing vector defining the x values of
               each of the columns of the data grid. If y_vector is left
               empty, x_vector can also be a vector of size 4, defining
               the corners of the grid as [min(x) max(x) min(y) max(y)]
   y_vector:   Monotonically in/decreasing vector defining the x values of
               each of the rows of the data grid.
 OUTPUTS:
   data:       The original data structured as a singleton array 
   x:          The x data structured as singleton array, same length as data array
   y:          The y data structured as singleton array, same length as data array
 MODIFICATION HISTORY:
 Gilles Stassen 20150107
 Gilles Stassen 20150224 major cleanup
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_grid2array.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_cell_failure">
<H2>climada_ls_cell_failure</H2></A>
<font color="blue">function factor_of_safety = climada_ls_cell_failure(centroids, soil_moisture,moist_mod,slope_mod) </font>
 compute the factor of safety
 MODULE:
   flood
 NAME:
   climada_ls_cell_failure
 PURPOSE:
   Compute the factor of safety, given an appropriately prepared set of
   centroids and a soil moisture matrix
 PREVIOUS STEP:
   climada_ls_cell_failure
 CALLING SEQUENCE:
   factor_of_safety = climada_ls_cell_failure(centroids,soil_moisture)
 EXAMPLE:
   factor_of_safety = climada_ls_cell_failure(centroids,soil_moisture)
 INPUTS:
   centroids:          centroids with the necessary fields (use
                       climada_fl_centroids_prepare)
   soil_moisutr:       matrix with soil moisture values for each event at
                       each centroid (in mm)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   factor_of_safety:   a 2d matrix the same size as the soil_moisture
                       input.
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150330 init
 Gilles Stassen, 20150710, soil moisture as 2d matrix with one time dimension
 Gilles Stassen, 20150806, moisture and slope modifiers
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/climada_ls_cell_failure.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_set_gilles">
<H2>climada_ls_hazard_set_gilles</H2></A>
<font color="blue">function [hazard, centroidsORhazard] = climada_ls_hazard_set_gilles(hazardORcentroids, hazard_set_file, focus_areas, check_plots, chrono_check, bool_hazard_check) </font>
 Generate ls hazard set from rainfall hazard set
 MODULE:
   flood
 NAME:
   climada_ls_hazard_set
 PURPOSE:
   Generate land slide hazard set from tr hazard set by distributing rainfall
   volume according to wetness indices of the centroids
 PREVIOUS STEP:
   centroids_fl_prepare
 CALLING SEQUENCE:
   hazard = climada_ls_hazard_set(hazard_rf,centroids,hazard_set_file, check_plots)
 EXAMPLE:
   hazard = climada_ls_hazard_set('',centroids,hazard_set_file)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   hazardORcentroids:  a TR hazard event set, or a filename of a saved
                       one. The centroids for the ls hazard set will be
                       constructed from the lat lons.
                    OR a centroids struct, which will also form the basis
                       for the rainfall hazard set.
                       &ampgt prompted for if not given
                       NOTE that for stable performance, centroids should
                       form a regular grid.
   focus_areas:        struct array containing shape files defining focus
                       areas of interest. Useful considering the
                       limitation imposed by the necessity for a regular
                       grid of centroids. Land slides will only be
                       calculated starting at centroids inside the regions
                       defined by these polygons. Can also be the pathname
                       of a .shp or .mat file.
   hazard_set_file: the name of the hazard set file
       &ampgt prompted for if not given
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
   centroidsORhazard:  if rainfall hazard set is provided as input arg,
                       then output is the centroids struct which is
                       constructed from this hazard set, and to which
                       topographic parameters have been assigned. If
                       centroids are given as input, then output is the
                       rainfall hazard set which has been calculated for
                       these centroids.
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150330
 Gilles Stassen, 20150708, renamed MS-&ampgtLS, time-dependent soil moisture, linear decay according to ET_mm_day, separate input args combined into hazardORcentroids
 Gilles Stassen, 20150710, factor of safety calculation vectorised over events
 Gilles Stassen, 20150713, focus_areas added as input
 Lea Mueller, muellele@gmail.com, 20150920, workaround if centroids.filename does not exist
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_generate from climada_generate_centroids
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_TWI_calc from centroids_TWI
 -
azard = []; centroidsORhazard = [];    % init
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('hazardORcentroids',  'var'),     hazardORcentroids   = [];   end
f ~exist('focus_areas',        'var'),     focus_areas         = [];   end
f ~exist('hazard_set_file',    'var'),     hazard_set_file     = [];   end
f ~exist('check_plots',        'var'),     check_plots         = 1;    end
f ~exist('chrono_check',       'var'),     chrono_check        = 1;    end
f ~exist('bool_hazard_check',  'var'),     bool_hazard_check   = 0;    end
odule_data_dir=[fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
f isempty(hazardORcentroids) || ~isstruct(hazardORcentroids)
   res = input('would you like to auto-generate a rainfall hazard set (a); or browse files (b)?\t','s');
   if strcmp(res,'a') 
       [admin_name, admin_shapes, ~, admin_shape_ndx,country_name] = climada_admin_name;
       % centroids = climada_centroids_generate([],0.09,0); % hard-wired 90m resolution for srtm DEM
       centroids = climada_90m_DEM(admin_shapes(admin_shape_ndx),'DL','NO_SAVE');
       
       [country_name, country_ISO3] = climada_country_name(country_name);
       centroids.country_name = repmat({country_name},size(centroids.centroid_ID));
       centroids.admin0_ISO3 = country_ISO3;   centroids.admin0_name = country_name;
       hazard_rf = climada_rf_hazard_set(centroids,[],'NO_SAVE',1);
   elseif strcmp(res,'b') 
       % prompt for RF hazard event set if not given
       hazard_rf_file=[module_data_dir filesep 'hazards' filesep '*.mat'];
       [filename, pathname] = uigetfile(hazard_rf_file,...
           'Select a rainfall hazard event set:');
       if isequal(filename,0) || isequal(pathname,0)
           return; % cancel
       else
           hazard_rf_file =fullfile(pathname,filename);
       end
       load(hazard_rf_file);
       hazard_rf = hazard; clear hazard
       % construct centroids from RF hazard
       centroids.lon = hazard_rf.lon;  
       centroids.lat = hazard_rf.lat;
       centroids.centroid_ID = hazard_rf.centroid_ID;
       centroids.comment = ['centroids created from: ' hazard_rf.comment];
   end
lseif isfield(hazardORcentroids,'intensity') &amp&amp isfield(hazardORcentroids,'peril_ID') % input is hazard set
   % input is 
   hazard_rf = hazardORcentroids; clear hazardORcentroids
   % construct centroids from RF hazard
   centroids.lon = hazard_rf.lon;  
   centroids.lat = hazard_rf.lat;
   centroids.centroid_ID = hazard_rf.centroid_ID;
   centroids.comment = ['centroids created from: ' hazard_rf.comment];
lse % input is centroids (probably) so auto-generate rainfall hazard
   centroids = hazardORcentroids; clear hazardORcentroids
   hazard_rf = climada_rf_hazard_set(centroids,[],'NO_SAVE',1);
   centroidsORhazard = hazard_rf;
nd
f ~isempty(focus_areas)
   if ischar(focus_areas) &amp&amp exist(focus_areas,'file') % pathname given as input
       [fP, fN, fE] = fileparts(focus_areas);
       if strcmp(fE,'.shp')
           focus_areas = climada_shaperead(focus_areas,1,0);
       elseif strcmp(fE,'.mat')
           tmp = load(focus_areas);
           focus_areas = tmp.(getelements(fieldnames(tmp),1));
           clear tmp
       else
           cprintf([1 0.5 0],'WARNING: invalid filetype %s - computation continues for all centroids\n',fE)
           focus_areas = [];
       end
   elseif ~(isstruct(focus_areas) &amp&amp isfield(focus_areas,'X') &amp&amp isfield(focus_areas,'Y'))
       cprintf([1 0.5 0],'WARNING: invalid input - focus areas must be a .shp or .mat file, and must have fields .X and .Y\n')
       cprintf([1 0.5 0],'\t\tcomputation continues for all centroids\n')
       focus_areas = [];
   end
nd     
 for testing purposes
 snapshot_year = [2004 2005]; % 2006 2007];
 hazard_rf = climada_hazard_extract_event(hazard_rf,hazard_rf.event_ID(ismember(hazard_rf.yyyy, snapshot_year)));
 hazard_rf = climada_hazard_extract_event(hazard_rf,-[1:10]);
azard                  =   hazard_rf;
azard.peril_ID         =   'LS';
azard.date             =   datestr(now);
azard.filename         =   hazard_set_file;
azard.matrix_density   =   0.01; % estimate
azard.comment          =   '';
 allocate the hazard array (sparse, to manage memory)
 hazard.intensity = spalloc(hazard_rf.event_count,length(hazard_rf.centroid_ID),...
     ceil(hazard.event_count*length(hazard.lon)*hazard.matrix_density));
azard.intensity        =   zeros(size(hazard_rf.intensity));
azard.units            =   'm';
azard.source           =   zeros(size(hazard_rf.intensity));
azard.deposit          =   zeros(size(hazard_rf.intensity));
azard.slide_ID         =   zeros(size(hazard_rf.intensity));
f isfield(hazard,'rainfield_comment')
   hazard = rmfield(hazard, 'rainfield_comment');
nd
entroids_n_flds = length(fieldnames(centroids));
 Step 1: Compute centroid elevation fro
f ~isfield(centroids,'elevation_m')
   centroids = climada_90m_DEM(centroids,'DL',[],[],0);
   hazard.elevation_m = centroids.elevation_m;
nd
 Step 2: Calculate topographic wetness index (TWI) 
f ~isfield(centroids,'TWI')
   centroids = climada_centroids_TWI_calc(centroids, 0);
nd
 Step 3: Delineate basins
f ~isfield(centroids,'basin_ID')
   if isfield(climada_global,'climada_global_ori')
       ori = climada_global;
       climada_global = climada_global.climada_global_ori;
   end
   centroids = centroids_basin_ID(centroids, 15, 0);
   if exist('ori','var'), climada_global = ori; end
nd
 Step 3: Compute daily evapotranspiration (ET)
f ~isfield(centroids,'ET_mm_day')
   centroids = centroids_ET(centroids, 0);
nd
 % Step 4: Assign soil wetness index (SWI)
 if ~isfield(centroids,'SWI') || force_recalc
     centroids = centroids_SWI(centroids, check_plots);
 end
 Step 5: Assign available water-holding capacity of the soil (WHC)
f ~isfield(centroids,'WHC_mm')
   centroids = centroids_WHC(centroids, 0);
nd
 Step 6: Assign soil bulk density values (BD)
f ~isfield(centroids, 'BD_kg_m3')
   centroids = centroids_BD(centroids,0);
nd
 Step 7: add soil depth
f ~isfield(centroids, 'SD_m')
   centroids = centroids_SD(centroids,0);
nd
 Step 8: add leaf area index
f ~isfield(centroids, 'LAI')
   centroids = centroids_LAI(centroids,0);
nd
 if ~isfield(centroids, 'EC_Pa')
   % centroids.EC_Pa  =   6400 * ones(size(centroids.centroid_ID)); %1900 * mean(centroids.LAI,1); %proxy
   centroids.EC_Pa  =   7250 * ones(size(centroids.centroid_ID));
 end
 auto save if updated (i.e. new fields added)
 if isfield(centroids,'filename') &amp&amp length(fieldnames(centroids)) &ampgt centroids_n_flds
     fprintf('autosaving centroids with additional fields to %s \n',centroids.filename)
     save(centroids.filename,'centroids')
 end
lear centroids_n_flds
asin_IDs           =   unique(centroids.basin_ID);
_basins            =   length(basin_IDs);
_events            =   hazard_rf.event_count;
_centroids         =   length(centroids.centroid_ID);
f ~isfield(centroids,'onLand')
   if exist(climada_global.coastline_file,'file')
       fprintf('determining on land centroids... ')
       load(climada_global.coastline_file)
       onLand_ndx = inpolygon(centroids.lon,centroids.lat,shapes.X,shapes.Y);
       centroids.onLand( onLand_ndx)   = 1;
       centroids.onLand(~onLand_ndx)   = 0;
       fprintf('done \n')
   elseif exist(climada_global.map_border_file,'file')
       fprintf('determining on land centroids... ')
       load(climada_global.map_border_file)
       onLand_ndx = inpolygon(centroids.lon,centroids.lat,shapes.X,shapes.Y);
       centroids.onLand( onLand_ndx)   = 1;
       centroids.onLand(~onLand_ndx)   = 0;
       fprintf('done \n')
   else
       centroids.onLand                = 1;
       centroids.onLand(centroids.elevation_m &amplt 0) = 0;
   end
nd
 init for plotting data
or event_i = 1: n_events
   slide_data(event_i).X = [];
   slide_data(event_i).Y = [];
   slide_data(event_i).Z = [];
   slide_data(event_i).C = [];
nd
 for progress mgmt
ormat_str	= '%s';
0          = clock;
od_step    = 1;
 introduce time dependence into soil moisture calculation if hazard_rf
 allows it (i.e. events are in chronological order and real)
f all(unique(hazard_rf.datenum) == hazard_rf.datenum) &amp&amp chrono_check
   chrono = 1;
lse
   chrono = 0;
nd
 soil moisture
oil_moisture = NaN(size(hazard_rf.intensity)); % init
T_mm_day     = ones(size(centroids.centroid_ID)).*2;% ET_mm_day(isnan(ET_mm_day)) = min(ET_mm_day(~isnan(ET_mm_day)))/2; % proxy
or basin_i = 1: n_basins
   
   % index of centroids belonging to basin_i
   c_ndx       =   (centroids.basin_ID == basin_IDs(basin_i)) &amp (centroids.onLand==1);
   
   % fl_score_sum                =   sum(centroids.flood_score(c_ndx));
   wet_index_sum               =   sum(centroids.TWI(c_ndx &amp ~isnan(centroids.TWI)));
   
   for event_i = 1 : n_events
       
       if event_i&ampgt1 &amp&amp chrono % since soil moisture has been initialised to zero for first event
           dt = hazard_rf.datenum(event_i) - hazard_rf.datenum(event_i-1);
           soil_moisture(event_i,c_ndx) = nanmax(soil_moisture(event_i-1,c_ndx) - ET_mm_day(c_ndx) .* dt,zeros(1,sum(c_ndx)));
       end
       
       % progress mgmt
       if mod(event_i,mod_step) ==0
           mod_step        = 100;
           t_elapsed       = etime(clock,t0)/((basin_i-1)*n_events+event_i);
           n_remaining     = (n_basins-basin_i+1)*n_events-event_i;
           t_projected_sec = t_elapsed*n_remaining;
           if t_projected_sec&amplt60
               msgstr = sprintf('computing soil moisture, est. %3.0f sec left (%i/%i basins): (%i/%i events)',t_projected_sec, basin_i, n_basins,event_i,n_events);
           else
               msgstr = sprintf('computing soil moisture, est. %3.1f min left (%i/%i basins): (%i/%i events)',t_projected_sec/60, basin_i, n_basins,event_i,n_events);
           end
           fprintf(format_str,msgstr);
           format_str = [repmat('\b',1,length(msgstr)) '%s'];
       end
       
       % index of rained-on centroids
       r_ndx   = hazard_rf.intensity(event_i,:) &ampgt 0;
       
       if ~any(r_ndx &amp c_ndx)
           continue
       end
       
       % index of potentially moist centroids, i.e. centroids lower in
       % elevation than highest r_ndx centroid
       ls_ndx    =     c_ndx &amp (centroids.elevation_m &amplt= max(centroids.elevation_m(r_ndx &amp c_ndx)));
       ls_ndx    =     ls_ndx &amp ~isnan(centroids.TWI);
       
       rain_sum  =   sum(hazard_rf.intensity(event_i,r_ndx &amp c_ndx),2);
       
       % calculate incoming rainfall per centroid according to TWI
       Q_in = zeros(1,n_centroids); %init
       if wet_index_sum ~=0
           Q_in(ls_ndx) = rain_sum .*(centroids.TWI(ls_ndx) ./ wet_index_sum);
       else
           Q_in(ls_ndx) = rain_sum / sum(ls_ndx);
       end
       
       if chrono
           % add soil moisture to sm_init, cap at water holding capacity
           soil_moisture(event_i,c_ndx) = min(soil_moisture(event_i,c_ndx)+Q_in(c_ndx),centroids.WHC_mm(c_ndx));
       else
           % subtract evapotranspiration (assume events of length 1 day), cap at water holding capacity
           soil_moisture(event_i,c_ndx) = max(min(soil_moisture(event_i,c_ndx)-ET_mm_day(c_ndx),centroids.WHC_mm(c_ndx)),zeros(1,sum(c_ndx)));
       end
   end
nd
printf(format_str,...
   sprintf('processing soil moisture at %i centroids for %i rainfall events took %i minutes\n',...
   n_centroids, n_events,round(etime(clock,t0)/60)));
 sort by elevation (work down the mountain)
~,elev_ndx] = sort(centroids.elevation_m,'descend');
f ~isempty(focus_areas)
   % filter for centroids in focus area
   in = zeros(size(centroids.centroid_ID)); %init
   for a_i = 1:length(focus_areas)
       in = in | inpolygon(centroids.lon,centroids.lat,focus_areas(a_i).X,focus_areas(a_i).Y);
   end
   elev_ndx = elev_ndx(ismember(elev_ndx,find(in))); % only loop over desired centroids
   hazard.focus_areas      = zeros(size(centroids.centroid_ID));
   hazard.focus_areas(in)  = 1; % for identification later
nd
 calculate factor of safety for each event
printf('calculating factor of safety for all events... ')
ry % vectorised first, since faster, but takes a lot of memory for many centroids
   hazard.factor_of_safety = climada_ls_cell_failure(centroids, soil_moisture);
atch % so loop over events if matlab unable to handle
   for event_i =1:n_events
       hazard.factor_of_safety(event_i,:) = climada_ls_cell_failure(centroids,soil_moisture(event_i,:));
   end
nd
printf('done\n')
 land slides
azard.intensity        =   zeros(size(hazard_rf.intensity)); %init
 for progress mgmt
0          = clock;
od_step    = 1;
ormat_str  = '%s';
or event_i = 1 : n_events
   tmp_factor_of_safety = hazard.factor_of_safety(event_i,:);
   if ~any(tmp_factor_of_safety(~isnan(tmp_factor_of_safety)) &amplt 1),  continue;   end
   % tmp_factor_of_safety(tmp_factor_of_safety &amplt 1) = 0.0;
   
   % progress mgmt
   if mod(event_i,mod_step) ==0
       mod_step        = 10;
       t_elapsed       = etime(clock,t0)/event_i;
       n_remaining     = n_events-event_i;
       t_projected_sec = t_elapsed*n_remaining;
       if t_projected_sec&amplt60
           msgstr = sprintf('generating land slides, est. %3.0f sec left (%i/%i events)',t_projected_sec, event_i,n_events);
       else
           msgstr = sprintf('generating land slides, est. %3.1f min left (%i/%i events)',t_projected_sec/60, event_i,n_events);
       end
       fprintf(format_str,msgstr);
       format_str = [repmat('\b',1,length(msgstr)) '%s'];
   end
   
   for centroid_i = elev_ndx
       % if factor of safety is less than rand, failure occurs at
       % centroid_i
       if tmp_factor_of_safety(1,centroid_i) &amplt rand
           
           % set specific temp FoS to 1, to avoid recheck for other
           % clusters
           tmp_factor_of_safety(1,centroid_i) = 1;
           
           % index for centroids at lower elevation
           r = climada_geo_distance(centroids.lon(centroid_i),centroids.lat(centroid_i),...
               centroids.lon,centroids.lat);
           [~, r_ndx]  = sort(r,'ascend');
           min_r       = r(r_ndx(2));
           
           % initialise
           cluster_ndx  = zeros(size(centroids.centroid_ID));
           cluster_size = 0; cluster_ndx(centroid_i) = 1; i =0;
           sink_ndx     = centroids.centroid_ID == centroids.centroid_ID(centroid_i);
           
           while sum(cluster_ndx) &ampgt cluster_size % loop until cluster stops growing
               
               cluster_size    = sum(cluster_ndx);
               
               sink_ndx        = centroids.centroid_ID == centroids.sink_ID(sink_ndx);
               % cluster_ndx     = cluster_ndx |(sink_ndx &amp (tmp_factor_of_safety(event_i,:)./cluster_size) &amplt rand);
               cluster_ndx     = cluster_ndx |(sink_ndx &amp (tmp_factor_of_safety(1,:) &amplt rand));
               
               % set specific temp FoS to 1, to avoid recheck for other
               % clusters
               tmp_factor_of_safety(1,cluster_ndx) = 1;
               
           end % loop until cluster stops growing
           
           % index of last cluster cell for start of deposit
           cluster_end_ndx = sink_ndx;
           
           % ************************************************************
           % insist that at least 2 neighbouring cells must fail for a
           % land slide to occur
             if cluster_size &amplt 2
                 continue;
             end
           % ************************************************************
           
           % deposition of slide
           slide_ndx       = false(size(centroids.centroid_ID));
           slope           = centroids.slope_deg(centroid_i); %init
           sink_ndx        = centroids.centroid_ID == centroids.centroid_ID(centroid_i);
           i = 0;
           while slope &ampgt 2 ...                                     % slope is steep enough
                   &amp&amp ~isempty(centroids.sink_ID(sink_ndx))...     % there exists a sink to deposit into
                   &amp&amp ~isnan(centroids.sink_ID(sink_ndx)) ...      % the sink is defined
                   &amp&amp i &amplt (2*sum(cluster_ndx)) ...                 % limit deposition length to twice the source length
                   &amp&amp slide_ndx(centroids.sink_ID(sink_ndx)) ==0   % there must not already be a land slide at the next sink
               
               % loop counter
               i = i+1;
               sink_ndx     = (centroids.centroid_ID == centroids.sink_ID(sink_ndx));  % find next sink
               slope        = centroids.slope_deg(sink_ndx);                           
               slide_ndx    = slide_ndx | sink_ndx;    % add sink to slide
                 if     ~isempty(centroids.sink_ID(sink_ndx))...     % there exists a sink to deposit into
                     &amp&amp ~isnan(centroids.sink_ID(sink_ndx)) ...      % the sink is defined
                     &amp&amp i &amplt (2*sum(cluster_ndx)) ...                 % limit deposition length to twice the source length
                     &amp&amp slide_ndx(centroids.sink_ID(sink_ndx)) ==0   % there must not already be a land slide at the next sink
                     break;
                 end
               
               % p = scatter(centroids.lon(deposit_ndx),centroids.lat(deposit_ndx),'filled');
               % set(p,'markerFaceColor','g','markerEdgeColor','g')
           end
           
           % set temp FoS to 1 for entire slide, to avoid recalculation
           tmp_factor_of_safety(1,cluster_ndx) = 1;
           
           if any(isnan(centroids.area_m2(slide_ndx)))
               centroids.area_m2(isnan(centroids.area_m2) &amp slide_ndx) = nanmean(centroids.area_m2(slide_ndx));
           end
           
           % for testing purposes
           deposit_ndx = slide_ndx &amp ~cluster_ndx;
           
           hazard.source (event_i,cluster_ndx) = centroids.area_m2(cluster_ndx) .* centroids.SD_m(cluster_ndx);
           hazard.deposit(event_i,deposit_ndx) = sum(hazard.intensity(event_i,cluster_ndx)) / sum(deposit_ndx);
           hazard.slide_ID(event_i,slide_ndx)  = str2num(sprintf('%i%i%i',basin_i,event_i,centroid_i));
           
           hazard.intensity(event_i,cluster_ndx) = - centroids.SD_m(cluster_ndx);
           
           % for better overview of the code
           lon = centroids.lon;
           lat = centroids.lat;
           
           % distances from end of cluster
           dep_dist_m = climada_geo_distance(lon(cluster_end_ndx),lat(cluster_end_ndx),...
               lon(deposit_ndx),lat(deposit_ndx));
           
           % deposit intensity factor depends on distance from end of cluster
           int_factor = 2.* (1- dep_dist_m./max(dep_dist_m));
           int_factor = 1; % or not..
           
           hazard.intensity(event_i,deposit_ndx) = int_factor .* ...
           (sum(hazard.source(event_i,cluster_ndx))/sum(centroids.area_m2(deposit_ndx)));
           
           X  = centroids.lon(slide_ndx);
           Y  = centroids.lat(slide_ndx);
           Z  = centroids.elevation_m(slide_ndx);
           C  = hazard.intensity(event_i,slide_ndx);
           
           % attempt to smooth out the land slides - doesn't work so
           % well...
           smooth_factor = 1;
           if smooth_factor &ampgt1
               X_ = []; Y_ = []; Z_ = []; C_ = []; S = 0; Sq =[];
               % parameterise length along slide
               for s_i = 2:sum(slide_ndx)
                   S(end+1) = S(end) + sqrt((X(s_i)-X(s_i-1))^2 + (Y(s_i) - Y(s_i-1))^2 + (Z(s_i) - Z(s_i-1))^2);
               end
               for s_i = 1:length(S)-1
                   Sq(end+1:end+smooth_factor) = linspace(S(s_i),S(s_i+1),smooth_factor);
               end
               X_ = interp1(S,X,Sq,'spline');
               Y_ = interp1(S,Y,Sq,'spline');
               Z_ = interp1(S,Z,Sq,'spline');
               C_ = interp1(S,C,Sq,'spline');
               
               X = X_; Y = Y_; Z = Z_; C = C_;clear X_ Y_ Z_ C_
           end
       
           % vectors for easy plotting
           slide_data(event_i).X = [slide_data(event_i).X NaN X];
           slide_data(event_i).Y = [slide_data(event_i).Y NaN Y];
           slide_data(event_i).Z = [slide_data(event_i).Z NaN Z];
           slide_data(event_i).C = [slide_data(event_i).C NaN C];
       end
   end
nd
azard.intensity         = sparse(hazard.intensity);
azard.matrix_density    = nnz(hazard.intensity)/numel(hazard.intensity);
printf(format_str,...
   sprintf('generating land slides at %i centroids for %i rainfall events took %i minutes\n',...
   n_centroids, n_events,round(etime(clock,t0)/60)));
f bool_hazard_check % only ones (land slide) and zeroes (no land slide)
   hazard.intensity(hazard.intensity ~=0) = 1;
   hazard.unit = '';
nd
 filter out all-zero events
z_events_ndx = find(sum(abs(hazard.intensity),2) ~= 0);
f length(nz_events_ndx) &amplt hazard.event_count
   fprintf('filtering hazard set for %i non-zero events... ',length(nz_events_ndx))
   hazard      = climada_hazard_extract_event(hazard,nz_events_ndx);
   slide_data  = slide_data(nz_events_ndx);
   fprintf('done\n')
nd
azard.frequency = ones(size(hazard.event_ID))./hazard.event_count;
f ~isfield(centroids,'filename'); centroids.filename = ''; end
~, centroids_name, ~] = fileparts(centroids.filename);
f ~isfield(centroids,'admin0_name'), centroids.admin0_name = ''; end
azard.comment = sprintf('LS hazard set %s, centroids: %s, created on: %s',centroids.admin0_name, centroids_name,datestr(now,'HH:MM ddmmyyyy'));
f exist('res','var') &amp&amp nargout == 2
   % neither centroids nor RF hazard were provided as input, so return both
   % in cell array
   centroidsORhazard = {centroids; hazard_rf};
lseif isfield(centroids,'comment') &amp&amp ...
       strcmp(centroids.comment,['centroids created from: ' hazard_rf.comment])
   % centroids created from hazard input
   centroidsORhazard = centroids;
nd
 prompt for ls_hazard_save_file if not given
f isempty(hazard_set_file) % local GUI
   hazard_set_file=[module_data_dir filesep 'hazards' filesep 'LS_hazard.mat'];
   [filename, pathname] = uiputfile(hazard_set_file, 'Save new land slide hazard event set as:');
   if isequal(filename,0) || isequal(pathname,0)
       hazard_set_file = 'NO_SAVE'; % cancel
       cprintf([0 0 1],'NOTE: hazard not saved\n')
   else
       hazard_set_file=fullfile(pathname,filename);
   end
nd
f ~isempty(hazard_set_file) &amp&amp ~strcmp(hazard_set_file,'NO_SAVE')
   fprintf('saving LS hazard set as %s\n',hazard_set_file);
   hazard.filename         =   hazard_set_file;
   try
       save(hazard_set_file,'hazard')
   end
   file_dir = dir(hazard_set_file);
   if isempty(file_dir) || file_dir.datenum &amplt now -1 % one day
       fprintf('attempting to save using ''-v7.3'' switch... ')
       try
           save(hazard_set_file,'hazard','-v7.3')
       end
       if ~isempty(file_dir) &amp&amp ~(file_dir.datenum &amplt now -1)
           fprintf('success\n')
       else
           fprintf('failed\n')
       end
   end
nd
 Plots
f check_plots 
   figure('Name', 'LS hazard set (largest event)','color', 'w')
   
   % get largest event
   event_sum       =   sum(abs(hazard.intensity) &ampgt0,2);
   [~,sort_ndx]    =   sort(event_sum,'descend');
   max_event       =   sort_ndx(1);
   hazard_intensity=   full(hazard.intensity(max_event,:));
   
   % also plot DEM for land slide hazard
   % construct regular grid
   [x, y]  = meshgrid(unique(hazard.lon),unique(hazard.lat));
   z       = griddata(hazard.lon,hazard.lat,centroids.elevation_m,x,y,'linear');
   xy(:,:,1) = x;  xy(:,:,2) = y; lonlat(:,1) = hazard.lon; lonlat(:,2) = hazard.lat;
   for y_i = 1:size(y,1); 
       nanpts(y_i,:) = ~ismember(squeeze(xy(y_i,:,:)),lonlat,'rows');
   end
   z(nanpts) = NaN;
   [C,h]   = contourf(unique(hazard.lon),unique(hazard.lat),z,10);
   l_h     = clabel(C,h);
   for i=1:length(l_h)
       s = get(l_h(i),'String');
       s = str2num(s);
       s = sprintf('%4.1f',s);
       set(l_h(i),'String',s);
   end
   colormap(flipud(bone(50)))
   freezeColors
   hold on
   
   if isfield(centroids,'rivers')
       plot3(centroids.rivers.X,centroids.rivers.Y,ones(size(centroids.rivers.X)).*5,'b')
   end
   freezeColors
   
   % use surface plot to show varying colour along landslide
   x_ = slide_data(max_event).X;
   y_ = slide_data(max_event).Y;
   c_ = slide_data(max_event).C; % (slide_data(max_event).C + min(slide_data(max_event).C(~isnan(slide_data(max_event).C))))./max(slide_data(max_event).C(~isnan(slide_data(max_event).C)));
   z_ = ones(size(x_));
   s  = surface([x_;x_],[y_;y_],[z_;z_],[c_;c_],'edgecol','interp','linew',5, 'marker','o','markersize',1);
   colormap(climada_colormap('MS'))
   %colormap(hot)
   caxis([min(hazard_intensity) max(hazard_intensity)])
   cb = colorbar;
   ylabel(cb,sprintf('landslide depth [%s]',hazard.units))
   
  	title_str=sprintf('%s event %i on %s',hazard.peril_ID,max_event,datestr(hazard.datenum(max_event),'dddd dd mmmm yyyy'));
   title(title_str)
   xlabel('Longitude')
   ylabel('Latitude')
   hold off
   
   figure('Name', 'LS hazard set (largest event) 3D','color', 'w')
   surf(unique(hazard.lon),unique(hazard.lat),z./(111.12 * 1000));
   %colormap(landcolor)
   colormap(flipud(bone(50)))
   shading interp
   freezeColors
   hold on
   
   % use surface plot to show varying colour along landslide
   x_ = slide_data(max_event).X;
   y_ = slide_data(max_event).Y;
   z_ = slide_data(max_event).Z ./(111.12 * 1000); % convert to degrees to use equal axis
   c_ = slide_data(max_event).C;
   s  = surface([x_;x_],[y_;y_],[z_;z_],[c_;c_],'edgecol','interp','linew',5, 'marker','o','markersize',1);
   colormap(climada_colormap('MS'))
   %colormap(flipud(hot))
   caxis([min(hazard_intensity) max(hazard_intensity)])
   cb = colorbar;
   ylabel(cb,sprintf('landslide depth [%s]',hazard.units))
   
  	title_str=sprintf('%s event %i on %s',hazard.peril_ID,max_event,datestr(hazard.datenum(max_event),'dddd dd mmmm yyyy'));
   title(title_str)
   xlabel('Longitude')
   ylabel('Latitude')
   
   set(gca,'ztick',[], 'zcolor', 'w');
   view(60,30)
   axis equal
   grid off
   box off
   
nd
eturn         
  
 Some Notes
 ==================
 *     Might be interesting to consider capping the number of landslides
       in a certain location to (centroid resolution/typical land slide
       width). This could also include some time dependence, i.e. land
       slide can only occur in the same place again after X years.
 ==================
 the following is an old method for calculating land slides which may have
 a width greater than the centroids resolution
 ==================
 % loop counter
 i = i+1;
 
 % ring of nearest, lower neighbours
 ring_ndx = (centroids.elevation_m &amplt centroids.elevation_m(centroid_i) ...
     &amp r &amplt i*(min_r*1.4) &amp r &ampgt i*(min_r*0.8));
 
 % aspect criterion
 aspect_diff = mod(centroids.aspect_deg - centroids.aspect_deg(centroid_i),360);
 aspect_ndx = cosd(aspect_diff) &ampgt 0;
 
 % grow cluster to include failing cells in ring
 cluster_ndx = cluster_ndx |(aspect_ndx &amp ring_ndx &amp hazard.factor_of_safety(event_i,:) &amplt rand);
 %cluster_ndx = logical(cluster_ndx);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/climada_ls_hazard_set_gilles.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_multi_layer_plot">
<H2>climada_ls_multi_layer_plot</H2></A>
<font color="blue">function climada_ls_multi_layer_plot(hazard,centroids,susc_check) </font>
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_TWI_calc from centroids_TWI
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/climada_ls_multi_layer_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_rf_hazard_set">
<H2>climada_rf_hazard_set</H2></A>
<font color="blue">function hazard = climada_rf_hazard_set(centroids, precip_file, hazard_set_file,x_fraction, ens_size, ens_amp, check_plots) </font>
 climada RF hazard event set
 NAME:
   climada_RF_hazard_set
 PURPOSE:
   Construct hazard set structure from global historical daily precipitation data
   found here: ftp://ftp.cgd.ucar.edu/archive/PRECIP/GPCP_1DD_v1.2_199610-201407.nc.gz
               http://www.esrl.noaa.gov/psd/data/gridded/data.gpcc.html
   The ens_size probabilistic events are generated by taking the x_fraction most
   extreme events from the original data, and adjusting their intensity.
   The extent of the wiggle is determined by generating a random wiggle
   paramater from a normal distribution with standard deviation ens_amp.
 CALLING SEQUENCE:
   hazard = climada_rf_hazard_set(centroids, precip_file, x_fraction, ens_size, ens_amp, hazard_set_file, check_plots)
 EXAMPLE:
   hazard = climada_rf_hazard_set(centroids, '', 0.2, 9, 0.1, 'NO_SAVE', 1)
   hazard = climada_rf_hazard_set(centroids, '', 0.7, 1)
   hazard = climada_rf_hazard_set
 INPUTS:
   hazard_set_file: the name of the newly created rainfall (RF) hazard
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   x_fraction:     The fraction of most extreme events to take from input.
                   e.g. if x_fraction = 0.05 =&ampgt take 5% most extreme
                   events (default)
   ens_size:       Number of probabilistic events to be generated for each
                   extreme event. Default is set to depend on x_fraction,
                   such that if x_fraction = 0.1, then ens_size = 9, so
                   that the total number of events (historical &amp
                   probabilistic) is the same as number of days of input
                   data.
   ens_amp:        The standard deviation of the normal distribution from
                   which the random &quotwiggle_matrix&quot is constructed. For each
                   event, the wiggle matrix alters the intensity at each
                   centroid point to create the probabilistic events. See
                   help randn.
   check_plots:    Whether to show plots (default = 1)
 OUTPUTS:
   hazard:         a hazard event set, see core climada doc
                   also written to a .mat file (see hazard_set_file)
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150316
 Gilles Stassen, 20150406 overhaul to daily precipitation data, including 
                          auto download functionality, and probabilistic set of extreme events
 Gilles Stassen, 20150627 buffer size 0.5 -&ampgt precip data resolution
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/climada_rf_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="dem">
<H2>dem</H2></A>
<font color="blue">function [h,I,z]=dem(x,y,z,varargin) </font>
DEM Shaded relief image plot

	DEM(X,Y,Z) plots the Digital Elevation Model defined by X and Y 
	coordinate vectors and elevation matrix Z, as a lighted image using
	specific &quotlandcolor&quot and &quotseacolor&quot colormaps. DEM uses IMAGESC 
	function which is much faster than SURFL when dealing with large 
	high-resolution DEM. It produces also high-quality and moderate-size 
	Postscript image adapted for publication.

	[H,I] = DEM(...); returns graphic handle H and illuminated image as I, 
	an MxNx3 matrix (if Z is MxN and DECIM is 1).

	DEM(X,Y,Z,'Param1',Value1,'Param2',Value2,...) specifies options or
	parameter/value couple (case insensitive):


	--- Lighting options ---

	'Azimuth',A
		Light azimuth in degrees clockwise relative to North. Default is
		A = -45 for	a natural northwestern illumination.

	'Contrast',C
		Light contrast, as the exponent of the gradient value:
			C = 1 for linear contrast (default),
			C = 0 to remove lighting,
			C = 0.5 for moderate lighting,
			C = 2 or more for strong contrast.

	'LCut',LC
		Lighting scale saturation cut with a median-style filter in % of 
	    elements, such as LC% of maximum gradient values are ignored:
			LC = 0.2 is default, 
			LC = 0 for full scale gradient.

	'km'
		Stands that X and Y coordinates are in km instead of m (default).
		This allows correct lighting. Ignored if LATLON option is used.


	--- Elevation colorscale options ---

	'ZLim',[ZMIN,ZMAX]
		Fixes min and max elevation values for colormap. Use NaN to keep 
		real min and/or max data values.

	'ZCut',ZC
		Median-style filter to cut extremes values of Z (in % of elements),
		such that ZC% of most min/max elevation values are ignored in the
		colormap application:
			ZC = 0.5 is default, 
			ZC = 0 for full scale.


	--- &quotNo Value&quot elevation options ---

	'NoValue',NOVALUE
		Defines the values that will be replaced by NaN. Note that values 
		equal to minimum of Z class are automatically detected as NaN 
		(e.g., -32768 for int16 class).

	'NaNColor',[R,G,B]
		Sets the RGB color for NaN/NoValue pixels (default is a dark gray).
		Note that your must specify a valid 3-scalar vector (between 0 and
		1);	color characters like 'w' or 'k' are not allowed, use [1,1,1]
		or [0,0,0] instead.

	'Interp'
		Interpolates linearly all NaN values (fills the gaps using linear 
		triangulation), using an optimized algorithm.


	--- Colormap options ---

	'LandColor',LMAP
		Uses LMAP colormap instead of default (landcolor, if exists or 
		jet) for Z &ampgt 0 elevations.

	'SeaColor',SMAP
		Sets the colormap used for Z &amplt= 0 elevations. Default is seacolor 
		(if exists) or single color [0.7,0.9,1] (a light cyan) to simulate
		sea color.

	'ColorMap',CMAP
		Uses CMAP colormap for full range of elevations, instead of default 
		land/sea. This option overwrites LANDCOLOR/SEACOLOR options.

	'Lake'
		Detects automaticaly flat areas different from sea level (non-zero 
		elevations) and colors them as lake surfaces.

	'Watermark',N
		Makes the whole image lighter by a factor of N.


	--- Basemap and scale options ---

	'Legend'
		Adds legends to the right of graph: elevation scale (colorbar)
		and a distance scale (in km).

	'Cartesian'
		Plots classic basemap-style axis, considering coordinates X and Y 
		as cartesian in meters. Use parameter &quotkm' for X/Y in km.

	'LatLon'
		Plots geographic basemap-style axis in deg/min/sec, considering 
		coordinates X as longitude and Y as latitude. Axis aspect ratio 
		will be adjusted to approximatively preserve distances (this is  
		not a real projection!). This overwrites ZRatio option.

	'AxisEqual', 'auto' (default) | 'manual' | 'off'
		When 'Cartesian' or 'LatLon' option is used, automatic axes scaling
		is applied to respect data aspect ratio. Default mode is 'auto' and
		uses AXIS EQUAL and DASPECT functions. The 'manual' mode modifies
		axes width or height with respect to the paper size in order to
		produce correct data scaling at print (but not necessarily at 
		screen). The 'off' mode disables any scaling.

	Additionnal options for basemap CARTESIAN or LATLON:

	'BorderWidth',BW
		Border width of the basemap axis, in % of axis height. Default is
		BW = 1%.

	'XTick',DX
	'YTick',DY
		X and Y Tick length (same unit as X and Y). Default is automatic.
		Tick labels are every 2 ticks.

	'FontSize',FS
		Font size for X and Y tick labels. Default is FS = 10.

	'FontBold'
		Font weight bold for tick labels.


	--- Decimation options ---

	For optimization purpose, DEM will automatically decimate data to limit
	to a total of 1500x1500 pixels images. To avoid this, use following
	options, but be aware that large grids may require huge computer 
	ressources or induce disk swap or memory errors.

	'Decim',N
		Decimates matrix Z at 1/N times of the original sampling.

	'NoDecim'
		Forces full resolution of Z, no decimation.



	--- Informations ---

	Colormaps are Mx3 RGB matrix so it is easy to modify saturation 
	(CMAP.^N), set darker (CMAP/N), lighter (1 - 1/N + CMAP/N), inverse
	it (flipud(CMAP)), etc...

	To get free worldwide topographic data (SRTM), see READHGT function.

	For backward compatibility, the former syntax is still accepted:
	DEM(X,Y,Z,OPT,CMAP,NOVALUE,SEACOLOR) where OPT = [A,C,LC,ZMIN,ZMAX,ZC],
	also option aliases DEC, DMS and SCALE, but there is no argument 
	checking. Please prefer the param/value syntax.

	Author: Franois Beauducel &ampltbeauducel@ipgp.fr&ampgt
	Created: 2007-05-17
	Updated: 2014-06-06
	History:
	[2014-06-06]
		- improve backward compatibility (adds strjoin subfunction)
	[2014-03-18]
		- adds new axisequal option
	[2013-03-11]
		- new options: 'km', 'watermark', 'fontsize', 'bordersize'
		- improve legend colorbar
		- all options now passed as param/value
	[2013-01-14]
		- improved light rendering (using surface normals instead of gradient)
		- improved 'lake' detection algorithm
		- new 'nancolor' option to set NaN color
		- adds a length scale with 'dec' option
		- minor code improvements
	[2013-01-07]
		- adds 'interp' option (fill the gaps)
		- adds 'seacolor' colormap for negative elevations (bathymetry)
	[2013-01-02]
		- adds a 'lake' option
		- minor bug correction
	[2012-09-26]
		- now accepts row/column vectors for X and/or Y.
	[2012-05-29]
		- adds basemap-style axis in decimal or lat/lon modes
		- adds elevation and distance scales
	[2012-05-18]
		- new landcolor.m colormap function
		- new arguments to control colormap scaling
		- median-style filters for light and colormap
	[2012-04-26]
		- Optimizations: adds a decimation for large DEM grids.

	Copyright (c) 2014, Franois Beauducel, covered by BSD License.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without 
	modification, are permitted provided that the following conditions are 
	met:

	   * Redistributions of source code must retain the above copyright 
	     notice, this list of conditions and the following disclaimer.
	   * Redistributions in binary form must reproduce the above copyright 
	     notice, this list of conditions and the following disclaimer in 
	     the documentation and/or other materials provided with the distribution
	                           
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quotAS IS&quot 
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
	CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
	INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
	POSSIBILITY OF SUCH DAMAGE.
f nargin &amplt 3
error('Not enough input arguments.');
nd
egkm = 6378*pi/180; % one latitude degree in km
ea_color = [.7,.9,1]; % default sea color (light cyan)
rey = 0.2*[1,1,1]; % a dark gray
 -------------------------------------------------------------------------
 --- Manage input arguments
 number of arguments param/value
args = 0;
f ~isnumeric(x) || ~isnumeric(y) || ~isnumeric(z)
error('X,Y and Z must be numeric.')
nd
f all(size(x) ~= 1) || all(size(y) ~= 1)
error('X and Y must be vectors, not matrix.')
nd
f length(x) ~= size(z,2) || length(y) ~= size(z,1)
error('If Z has a size of [M,N], X must have a length of N, and Y a length of M.')
nd
 OPTIONS and PARAM/VALUE arguments
		
 AZIMUTH param/value
s,az] = checkparam(varargin,'azimuth',@isscalar);
args = nargs + 2;
f s==0
az = -45; % default
nd
 ELEVATION param/value
s,el] = checkparam(varargin,'elevation',@isscalar);
args = nargs + 2;
f s==0
el = 0; % default
nd
 CONTRAST param/value
s,ct] = checkparam(varargin,'contrast',@isscalar);
args = nargs + 2;
f s
ct = abs(ct);
lse
ct = 1; % default
nd
 LCUT param/value
s,lcut] = checkparam(varargin,'lcut',@isperc);
args = nargs + 2;
f s==0
lcut = .2; % default
nd
 NOVALUE param/value
s,novalue] = checkparam(varargin,'novalue',@isscalar);
args = nargs + 2;
f s==0
% default: min value for integer class / NaN for float
S = whos('z');
if strfind(S.class,'int')
	novalue = intmin(S.class);
else
	novalue = NaN;
end
nd
 NANCOLOR param/value
s,novalue_color] = checkparam(varargin,'nancolor',@isrgb);
args = nargs + 2;
f s==0
novalue_color = grey; % default
nd
 LANDCOLOR param/value
s,cland] = checkparam(varargin,'landcolor',@isrgb);
args = nargs + 2;
f s==0
% default: landcolor or jet
if exist('landcolor','file')
	cland = landcolor.^1.3;
else
	cland = jet(256);
end
nd
 SEACOLOR param/value
s,csea] = checkparam(varargin,'seacolor',@isrgb);
args = nargs + 2;
f s==0
% default: seacolor or single color
if exist('seacolor','file')
	csea = seacolor;
else
	csea = sea_color;
end
nd
 COLORMAP param/value
s,cmap] = checkparam(varargin,'colormap',@isrgb);
args = nargs + 2;
f s
cland = [];
csea = [];
lse
% default
cmap = cland;
nd
 ZLIM param/value
s,zmm] = checkparam(varargin,'zlim',@isvec);
args = nargs + 2;
f s
zmin = min(zmm);
zmax = max(zmm);
lse
zmin = NaN; % default
zmax = NaN; % default
nd
 ZCUT param/value
s,zcut] = checkparam(varargin,'zcut',@isperc);
args = nargs + 2;
f s==0
zcut = .5; % default
nd
 ZRATIO param/value
s,zratio] = checkparam(varargin,'zratio',@isscalar);
args = nargs + 2;
f s==0
zratio = 1; % default
nd
 WATERMARK param/value
s,wmark] = checkparam(varargin,'watermark',@isscalar);
args = nargs + 2;
f s
wmark = abs(wmark);
lse
wmark = 0; % default
nd
 DECIM param/value and NODECIM option
s,decim] = checkparam(varargin,'decim',@isscalar);
f s
decim = round(decim);
nargs = nargs + 2;
lse
decim = any(strcmpi(varargin,'nodecim')); % default
nargs = nargs + 1;
nd
 FONTSIZE param/value
s,fs] = checkparam(varargin,'fontsize',@isscalar);
args = nargs + 2;
f s==0
fs = 10; % default
nd
 BORDERWIDTH param/value
s,bw] = checkparam(varargin,'borderwidth',@isperc);
args = nargs + 2;
f s==0
bw = 1; % default
nd
 XTICK param/value
s,ddx] = checkparam(varargin,'xtick',@isscalar);
args = nargs + 2;
f s==0
ddx = 0; % default (automatic)
nd
 YTICK param/value
s,ddy] = checkparam(varargin,'ytick',@isscalar);
args = nargs + 2;
f s==0
ddy = 0; % default (automatic)
nd
 AXISEQUAL param/value
s,axeq] = checkparam(varargin,'axisequal',@ischar,{'auto','manual','off'});
args = nargs + 2;
f s==0 || ~any(strcmpi(axeq,{'manual','off'}))
axeq = 'auto'; % default (automatic)
nd
 CROP param/value
s,crop] = checkparam(varargin,'crop',@isvec,4);
args = nargs + 2;
 options without argument value
m = any(strcmpi(varargin,'km'));
ec = any(strcmpi(varargin,'cartesian') | strcmpi(varargin,'dec'));
ms = any(strcmpi(varargin,'latlon') | strcmpi(varargin,'dms'));
cale = any(strcmpi(varargin,'legend') | strcmpi(varargin,'scale'));
nter = any(strcmpi(varargin,'interp'));
ake = any(strcmpi(varargin,'lake'));
bold = any(strcmpi(varargin,'fontbold'));
 for backward compatibility (former syntax)...
args = nargs + dec + dms + scale + lake + inter + km + fbold;
f (nargin - nargs) &ampgt 3 &amp&amp ~isempty(varargin{1})
opt = varargin{1};
if ~isnumeric(opt)
	error('OPT = [A,C,S,ZMIN,ZMAX,ZCUT] argument must be numeric.');
end
if ~isempty(opt)
	az = opt(1);
end
if length(opt) &ampgt 1
	ct = opt(2);
end
if length(opt) &ampgt 2
	lcut = opt(3);
end
if length(opt) &ampgt 4
	zmin = opt(4);
	zmax = opt(5);
end
if length(opt) &ampgt 5
	zcut = opt(6);
end
nd
f (nargin - nargs) &ampgt 4 &amp&amp ~isempty(varargin{2})
cmap = varargin{2};
csea = [];
nd
f (nargin - nargs) &ampgt 5 &amp&amp ~isempty(varargin{3})
novalue = varargin{3};
nd
f (nargin - nargs) &ampgt 6 &amp&amp ~isempty(varargin{4})
csea = varargin{4};
nd
 further test of input arguments
f dms &amp&amp any(abs(y) &ampgt 91)
error('With LATLON option Y must be in valid latitudes interval (decimal degrees).')
nd
f km
zratio = 1000;
nd
 -------------------------------------------------------------------------
 --- Pre-process DEM data
 crops data if needed
f numel(crop)==4
fprintf('DEM: crops original data from [%g,%g,%g,%g] to [%g,%g,%g,%g]...\n', ...
	min(x(:)),max(x(:)),min(y(:)),max(y(:)),crop);
kx = find(x &ampgt= crop(1) &amp x &amplt= crop(2));
ky = find(y &ampgt= crop(3) &amp y &amplt= crop(4));
x = x(kx);
y = y(ky);
z = z(ky,kx);
nd
 decimates data to avoid disk swap/out of memory...
max = 1500;
f decim
n = decim;
lse
n = ceil(sqrt(numel(z))/nmax);
nd
f n &ampgt 1
x = x(1:n:end);
y = y(1:n:end);
z = z(1:n:end,1:n:end);
fprintf('DEM: on the plot data has been decimated by a factor of %d...\n',n);
nd
 = double(z); % necessary for most of the following calculations...
(z==novalue) = NaN;
f inter
z = fillgap(x,y,z);
nd
f isempty(csea)
k = (z~=0 &amp ~isnan(z));
lse
k = ~isnan(z);
nd
f isnan(zmin)
zmin = nmedian(z(k),zcut/100);
nd
f isnan(zmax)
zmax = nmedian(z(k),1 - zcut/100);
nd
z = zmax - zmin;
 -------------------------------------------------------------------------
 --- Process lighting
f dz &ampgt 0
% builds the colormap: concatenates seacolor and landcolor around 0
if ~isempty(csea)
	l = size(csea,1);
	if zmin &amplt 0 &amp&amp zmax &ampgt 0
		r = size(cland,1)*abs(zmin)/zmax/l;
		cmap = cat(1,interp1(1:l,csea,linspace(1,l,ceil(l*r)),'*linear'),cland);
	elseif zmax &amplt=0
		cmap = csea;
	end
end

% normalisation of Z using CMAP and convertion to RGB
I = ind2rgb(uint16(round((z - zmin)*(size(cmap,1) - 1)/dz) + 1),cmap);

if ct &ampgt 0
	% computes lighting from elevation gradient
	%[fx,fy] = gradient(z,x,y);
	if dms
		ryz = degkm*1000;
		rxz = degkm*1000*cosd(mean(y));
	else
		rxz = zratio;
		ryz = zratio;
	end
	[xx,yy] = meshgrid(x*rxz,y*ryz);
	[fx,fy,fz] = surfnorm(xx,yy,z);
	[ux,uy,uz] = sph2cart((90-az)*pi/180,el*pi/180,1);
	fxy = fx*ux + fy*uy + fz*uz;
	clear xx yy fx fy fz	% free some memory...
	
	fxy(isnan(fxy)) = 0;
	% computes maximum absolute gradient (median-style), normalizes,
	% saturates and duplicates in 3-D matrix
	li = 1 - abs(sind(el)); % light amplitude (experimental)
	r = repmat(max(min(li*fxy/nmedian(abs(fxy),1 - lcut/100),1),-1),[1,1,3]);
	rp = (1 - abs(r)).^ct;

	% applies contrast using exponent
	I = I.*rp;

	% lighter for positive gradient
	I(r&ampgt0) = I(r&ampgt0) + (1 - rp(r&ampgt0));
			
end
% set novalues / NaN to nancolor
[i,j] = find(isnan(z));
if ~isempty(i)
	I(sub2ind(size(I),repmat(i,1,3),repmat(j,1,3),repmat(1:3,size(i,1),1))) = repmat(novalue_color,size(i,1),1);
end

% lake option
if lake
	klake = islake(z);
else
	klake = 0;
end

% set the seacolor for 0 values
if ~isempty(csea)
	[i,j] = find(z==0 | klake);
	if ~isempty(i)
		I(sub2ind(size(I),repmat(i,1,3),repmat(j,1,3),repmat(1:3,size(i,1),1))) = repmat(csea(end,:),size(i,1),1);
	end
end
if wmark
	I = watermark(I,wmark);
end

hh = imagesc(x,y,I);

lse

hh = imagesc(x,y,repmat(shiftdim(sea_color,-1),size(z)));
text(mean(x),mean(y),'SPLASH!','Color',sea_color/4, ...
	'FontWeight','bold','HorizontalAlignment','center')
cmap = repmat(sea_color,[256,1]);
if nargin &ampgt 1
	I = ones(size(z));
end
nd
rient tall; axis xy
f strcmpi(axeq,'auto')
axis equal
nd
xis tight
lim = [min(x),max(x)];
lim = [min(y),max(y)];
lim = [min([z(z(:) ~= novalue);zmin]),max([z(z(:) ~= novalue);zmax])];
f dms
% approximates X-Y aspect ratio for this latitude (&amplt 20-m precision for 1x1 grid)
xyr = cos(mean(y)*pi/180);
lse
xyr = 1;
nd
w0 = max(diff(xlim)*xyr,diff(ylim))/100;
wy = bw*bw0; % Y border width = 1%
wx = bwy/xyr; % border width (in degree of longitude)
 -------------------------------------------------------------------------
 --- Axis basemap style
f dec || dms
axis off
if strcmpi(axeq,'manual')
	ppos = get(gcf,'PaperPosition');
	apos = get(gca,'Position');
	xyf = (xyr*diff(xlim)/apos(3)/ppos(3))/(diff(ylim)/apos(4)/ppos(4));
	if xyf &ampgt= 1
		set(gca,'Position',[apos(1),apos(2),apos(3),apos(4)/xyf]);
	else
		set(gca,'Position',[apos(1),apos(2),apos(3)*xyf,apos(4)]);
	end
end
if strcmpi(axeq,'auto')
	if diff(xlim)*xyr &amplt= diff(ylim)
		set(gca,'DataAspectRatio',[1,xyr,1])
	else
		set(gca,'DataAspectRatio',[1/xyr,1,1])
	end
end
if bw &ampgt 0
	% transparent borders
	patch([xlim(1)-bwx,xlim(2)+bwx,xlim(2)+bwx,xlim(1)-bwx],ylim(1) - bwy*[0,0,1,1],'k','FaceColor','none','clipping','off')
	patch([xlim(1)-bwx,xlim(2)+bwx,xlim(2)+bwx,xlim(1)-bwx],ylim(2) + bwy*[0,0,1,1],'k','FaceColor','none','clipping','off')
	patch(xlim(1) - bwx*[0,0,1,1],[ylim(1)-bwy,ylim(2)+bwy,ylim(2)+bwy,ylim(1)-bwy],'k','FaceColor','none','clipping','off')
	patch(xlim(2) + bwx*[0,0,1,1],[ylim(1)-bwy,ylim(2)+bwy,ylim(2)+bwy,ylim(1)-bwy],'k','FaceColor','none','clipping','off')
end
dlon = {'E','W'};
dlat = {'N','S'};
if fbold
	fw = 'bold';
else
	fw = 'normal';
end

if ddx == 0
	ddx = dtick(diff(xlim),dms);
end
if ddy == 0
	ddy = dtick(diff(ylim),dms);
end
xtick = (ddx*ceil(xlim(1)/ddx)):ddx:xlim(2);
for xt = xtick(1:2:end)
	dt = ddx - max(0,xt + ddx - xlim(2));
	patch(repmat(xt + dt*[0,1,1,0]',[1,2]),[ylim(1) - bwy*[0,0,1,1];ylim(2) + bwy*[0,0,1,1]]','k','clipping','off')
	if fs &ampgt 0
		text(xt,ylim(1) - 1.2*bwy,deg2dms(xt,dlon,dec),'FontSize',fs,'FontWeight',fw, ...
			'HorizontalAlignment','center','VerticalAlignment','top');
	end
end
ytick = (ddy*ceil(ylim(1)/ddy)):ddy:ylim(2);
for yt = ytick(1:2:end)
	dt = ddy - max(0,yt + ddy - ylim(2));
	patch([xlim(1) - bwx*[0,0,1,1];xlim(2) + bwx*[0,0,1,1]]',repmat(yt + dt*[0,1,1,0]',[1,2]),'k','clipping','off')
	if fs &ampgt 0
		text(xlim(1) - 1.2*bwx,yt,deg2dms(yt,dlat,dec),'FontSize',fs,'FontWeight',fw, ...
			'HorizontalAlignment','center','VerticalAlignment','bottom','rotation',90);
	end
end
nd
 -------------------------------------------------------------------------
 --- Scales legend
f scale
%wsc = diff(xlim)*0.01;
wsc = bw0;
xsc = xlim(2) + wsc*2 + bwx;
if wmark
	cmap = watermark(cmap,wmark);
end
% -- elevation scale (colorbar)
zscale = linspace(zmin,zmax,length(cmap));
yscale = linspace(0,diff(ylim)/2,length(cmap));
ysc = ylim(1);
ddz = dtick(dz*max(0.5*xyr*diff(xlim)/yscale(end),1));
ztick = (ddz*ceil(zscale(1)/ddz)):ddz:zscale(end);
patch(xsc + repmat(wsc*[-1;1;1;-1],[1,length(cmap)]), ...
	ysc + [repmat(yscale,[2,1]);repmat(yscale + diff(yscale(1:2)),[2,1])], ...
	repmat(zscale,[4,1]), ...
	'EdgeColor','flat','LineWidth',.1,'FaceColor','flat','clipping','off')
colormap(cmap)
caxis([zmin,zmax]);
patch(xsc + wsc*[-1,1,1,-1],ysc + yscale(end)*[0,0,1,1],'k','FaceColor','none','Clipping','off')
text(xsc + 2*wsc + zeros(size(ztick)),ysc + (ztick - zscale(1))*0.5*diff(ylim)/diff(zscale([1,end])),num2str(ztick'), ...
	'HorizontalAlignment','left','VerticalAlignment','middle','FontSize',6)
% indicates min and max Z values
text(xsc,ysc - bwy/2,sprintf('%g m',roundsd(zlim(1),3)),'FontWeight','bold', ...
	'HorizontalAlignment','left','VerticalAlignment','top','FontSize',6)
text(xsc,ysc + .5*diff(ylim) + bwy/2,sprintf('%g m',roundsd(zlim(2),3)),'FontWeight','bold', ...
	'HorizontalAlignment','left','VerticalAlignment','bottom','FontSize',6)

% -- distance scale (in km)
if dms
	fsc = degkm;
else
	fsc = zratio/1e3;
end
dkm = dtick(diff(ylim)*fsc);
ysc = ylim(2) - 0.5*dkm/fsc;
patch(xsc + wsc*[-1,-1,0,0],ysc + dkm*0.5*[-1,1,1,-1]/fsc,'k','FaceColor',grey,'clipping','off')
if dkm &ampgt 1
	skm = sprintf('%g km',dkm);
else
	skm = sprintf('%g m',dkm*1000);
end
text(xsc,ysc,skm,'rotation',-90,'HorizontalAlignment','center','VerticalAlignment','bottom', ...
		'Color',grey,'FontWeight','bold','FontSize',6)
nd
f nargout &ampgt 0
h = hh;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function y = nmedian(x,n) </font>
NMEDIAN Generalized median filter
	NMEDIAN(X,N) sorts elemets of X and returns N-th value (N normalized).
	So:
	   N = 0 is minimum value
	   N = 0.5 is median value
	   N = 1 is maximum value
f nargin &amplt 2
n = 0.5;
nd
 = sort(x(:));
 = interp1(sort(y),n*(length(y)-1) + 1);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function dd = dtick(dlim,deg) </font>
DTICK Tick intervals
f nargin &amplt 2
deg = 0;
nd
f deg &amp&amp dlim &amplt= 2/60
% less than 2 minutes: base 36
m = 10^floor(log10(dlim*36))/36;
lseif deg &amp&amp dlim &amplt= 2
% less than 2 degrees: base 6
m = 10^floor(log10(dlim*6))/6;
lse
% more than few degrees or not degrees: decimal rules
m = 10^floor(log10(dlim));
nd
 = ceil(dlim/m);
f p &amplt= 1
dd = .1*m;
lseif p == 2
dd = .2*m;
lseif p &amplt= 5
dd = .5*m;
lse
dd = m;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function s = deg2dms(x,ll,dec) </font>
DEG2DMS Degree/minute/second display
f dec
s = sprintf('%7.7g',x);
lse
xa = abs(x) + 1/360000;
%sd = sprintf('%d%c',floor(xa),176);	% ASCII char 176 is the degree sign
sd = sprintf('%d',floor(xa));
sm = '';
ss = '';
if mod(x,1)
	sm = sprintf('%02d''',floor(mod(60*xa,60)));
	sa = floor(mod(3600*xa,60));
	if sa
		ss = sprintf('%02d&quot',sa);
	else
		if strcmp(sm,'00''')
			sm = '';
		end
	end
end
s = [sd,sm,ss,ll{1+int8(x&amplt0)}];
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function z = fillgap(x,y,z) </font>
 GRIDDATA is not efficient for large arrays, but has great advantage to be
 included in Matlab's core functions! To optimize interpolation, we
 reduce the amount of relevant data by building a mask of all surrounding
 pixels of novalue areas... playing with linear index!
z = size(z);
 = find(isnan(z));
(k == 1 | k == numel(z)) = []; % removes first and last index (if exist)
f ~isempty(k)
[xx,yy] = meshgrid(x,y);
mask = zeros(sz,'int8');
k2 = ind90(sz,k); % k2 is linear index in the row order
% sets to 1 every previous and next index, both in column and row order
mask([k-1;k+1;ind90(fliplr(sz),[k2-1;k2+1])]) = 1; 
mask(k) = 0; % removes the novalue index
kb = find(mask); % keeps only border values
z(k) = griddata(xx(kb),yy(kb),z(kb),xx(k),yy(k));
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function k2 = ind90(sz,k) </font>
i,j] = ind2sub(sz,k);
2 = sub2ind(fliplr(sz),j,i); % switched i and j: k2 is linear index in row order
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function k = islake(z) </font>
 ISLAKE mask of zero gradient on 3x3 tiles
 We use diff matrix in row and column directions, and shift it to build
 a single vectorized test of surrounding pixels. To do this we must
 concatenate unit vectors in different combinations...
x = diff(z,1,2);	% differences in X direction
y = diff(z,1,1);	% differences in Y direction
1 = ones(size(z,1),1);	% row unit vector 
2 = ones(1,size(z,2));	% column unit vector
2r = u2(2:end);
 index of the tiles center pixel
 = ( ...
[u2;dy] == 0 &amp [dy;u2] == 0 &amp ...
[u1,dx] == 0 &amp [dx,u1] == 0 &amp ...
[u1,[dx(2:end,:);u2r]] == 0 &amp [[dx(2:end,:);u2r],u1] == 0 &amp ...
[u1,[u2r;dx(1:end-1,:)]] == 0 &amp [[u2r;dx(1:end-1,:)],u1] == 0 ...
;
 now extends it to surrounding pixels
(1:end-1,:) = (k(1:end-1,:) | k(2:end,:));
(2:end,:) = (k(2:end,:) | k(1:end-1,:));
(:,1:end-1) = (k(:,1:end-1) | k(:,2:end));
(:,2:end) = (k(:,2:end) | k(:,1:end-1));
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function s = isrgb(x,n) </font>
f nargin &amplt 2
n = 0;
nd
f isnumeric(x) &amp&amp (n == 1 &amp&amp all(size(x) == [1,3]) || n == 0 &amp&amp size(x,2) == 3) ...
	&amp&amp all(x(:) &ampgt= 0 &amp x(:) &amplt= 1)
s = 1;
lse
s = 0;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function s = isperc(x) </font>
f isnumeric(x) &amp&amp isscalar(x) &amp&amp x &ampgt= 0 &amp&amp x &amplt= 100
s = 1;
lse
s = 0;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function s = isvec(x,n) </font>
f nargin &amplt 2
n = 2;
nd
f isnumeric(x) &amp&amp numel(x) == n
s = 1;
lse
s = 0;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function y=roundsd(x,n) </font>
g = 10.^(floor(log10(abs(x)) - n + 1));
 = round(x./og).*og;
(x==0) = 0;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function y = watermark(x,n) </font>
f nargin &amplt 2
n = 2;
nd
f n == 0
   y = x;
lse
   y = (x/n + 1 - 1/n);
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function [s,v] = checkparam(arg,nam,func,val) </font>
witch func2str(func)
case 'isscalar'
	num = 1;
	mes = 'scalar value';
case 'isperc'
	num = 1;
	mes = 'percentage scalar value';
case 'isvec'
	num = 1;
	if nargin &amplt 4
		val = 2;
	end
	mes = sprintf('%d-element vector',val);
case 'isrgb'
	num = 1;
	mes = '[R,G,B] vector with 0.0 to 1.0 values';
case 'ischar'
	num = 0;
	mes = 'string';
	if nargin &ampgt 3
		mes = sprintf('%s (%s)',mes,strjoin(val,' or '));
	end
otherwise
	num = 1;
	mes = 'value';
nd
 = 0;
 = [];
 = find(strcmpi(arg,nam));
f ~isempty(k)
if (k + 1) &amplt= length(arg) ...
		&amp&amp (~num || isnumeric(arg{k+1})) ...
		&amp&amp (nargin &amplt 4 &amp&amp func(arg{k+1}) ...
			|| (nargin &ampgt 3 &amp&amp (strcmp(func2str(func),'ischar') &amp&amp ismember(arg{k+1},val)) ...
				 || strcmp(func2str(func),'isvec') &amp&amp func(arg{k+1},val)))
	v = arg{k+1};
	s = 1;
else
	error('%s option must be followed by a valid %s.',upper(nam),mes)
end
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function s=strjoin(c,d) </font>
STRJOIN Join cell array of strings
(this is for Matlab versions &amplt 2013a backward compatibility)
f nargin &amplt 2
d = '';
nd
 = numel(c);
s = cell(2,n);
s(1,:) = reshape(c,1,n);
s(2,1:n-1) = {d};
 = [ss{:}];
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/dem.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="fl_Climada_Aqueduct_compare">
<H2>fl_Climada_Aqueduct_compare</H2></A>
<font color="blue">function fl_Climada_Aqueduct_compare(country_risk,report_filename) </font>
 Compare flood damages with target model 
 MODULE:
   flood
 NAME:
   fl_Climada_Aqueduct_compare
 PURPOSE:
   Compare flood damages calculated by Climada to the flood damage 
   estimates of the Aqueduct Global Flood Analyzer developed by the World 
   Resources Insitute (WRI), which can be accessed here:
       http://www.wri.org/resources/maps/aqueduct-global-flood-analyzer
 PREREQUISITES:
   Country data from the Aqueduct flood tool needs to be downloaded from 
   here: 
   http://www.wri.org/resources/data-sets/aqueduct-global-flood-risk-maps
   (Click on the yellow button reading &quot3 DOWNLOADS&quot, select &quotData by 
   Country&quot and place the unzipped files in
       climada_module_flood/data/system)
 PREVIOUS STEP:
   Generate a &quotcountry flood risk&quot struct that collects all the flood 
   damage data for a list of countries. You can create such a struct 
   using the script fl_countryrisk_generate
 CALLING SEQUENCE:
   fl_Climada_Aqueduct_compare(fl_country_risk,report_filename)
 EXAMPLE:
   fl_Climada_Aqueduct_compare(fl_country_risk);
 INPUTS:
   fl_country_risk: a structure with the results from 
   fl_countryrisk_generate
 OPTIONAL INPUT PARAMETERS:
   report_filename: the filename of the Excel file the comparison is 
       written to. Prompted for if not given 
 OUTPUTS: writes an excel sheet
 NOTE: This function will probably just serve for developing purposes,
   i.e. to get a guideline for the calibration of flood damages and/or
   intensities. Hence the function might be removed from the repositories
   once it has fulfilled its purpose.
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150326, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/fl_Climada_Aqueduct_compare.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="fl_hazard_plot_hr">
<H2>fl_hazard_plot_hr</H2></A>
<font color="blue">function fig = climada_hazard_plot_hr(hazard,event_i,label,caxis_range,plot_centroids,hist_check) </font>
 climada plot single hazard event footprint
 NAME:
   climada_hazard_plot_hr
 PURPOSE:
   plot hazard event as high resolution contour on a map, works for all perils

   See also the low-resolution version climada_hazard_plot
 CALLING SEQUENCE:
   climada_hazard_plot_hr(hazard,event_i,label,caxis_range,plot_centroids,hist_check)
 EXAMPLE:
   climada_hazard_plot_hr(hazard,1); % plot first event
   climada_hazard_plot_hr; % prompt for hazard event set, plot largest event
 INPUTS:
   hazard: hazard structure
       &ampgt prompted for if empty
   event_i: the i-th event in the hazard event set to be displayed
       if event_i=0, the maximum intensity at each centroid is shown
       if event_i=-i, the i-th 'largest' event (sum of intensities) is shown
           e.g. for event_i=-2, the second largest event is shown
       default=-1 (just to get something on the screen ;-)
 OPTIONAL INPUT PARAMETERS:
   label: a struct with a label to add on the plot (i.e. a place)
       longitude: the longitude (decimal)
       latitude: the latitude (decimal)
       name: the label itself, like 'gaga'
   caxis_range: [minval maxval], the range of the color axis, e.g. [20 40]
       to show colors for values brtween 20 and 40
   plot_centroids: =1, plot centroids, =0 no (default)
   hist_check: if =1, plot historic events only, =0 all (default)
 OUTPUTS:
   creates a figure and returns figure handle
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150206
 David N. Bresch, david.bresch@gmail.com, 20150313, synchronized with climada_hazard_plot
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/fl_hazard_plot_hr.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_countryrisk_generate">
<H2>flood_countryrisk_generate</H2></A>
 script go generade &quotcountry flood risks&quot
 How to use: Specify the countries you want to calculate the flood risks 
 for in &quotcountry_list&quot (in the PARAMETERS section just below). 
 The script will then calculate a struct &quotfl_country_risk&quot that contains 
 the flood risk for all these countries and can be given as an input to
 the function fl_Climada_Aqueduct_compare, which will write an excel
 spreadsheet that compares the flood damages for given return
 periods calculated by CLIMADA to the corresponding estimates by the
 Aqueduct Global Flood Analyzer (see fl_Climada_Aqueduct_compare for
 details)
 NOTE: This is a very stupid script that just assumes that all the 
 entities and centroids needed in the calculation are present in their
 respective default folders; no error checking is done!
 Modification history: 
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150331, initial
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/flood_countryrisk_generate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_damagefunction_entity_add">
<H2>flood_damagefunction_entity_add</H2></A>
 This script just replaces the damagefunctions of entities with the
 damagefunctions read from an entity template file. 
 In particular, it can be used to equip entities with the newly defined
 flood damagefunction in climada_module_flood\data\entity_template.xlsx
 path and filename of the entity template file to read the damagefunctions
 from
ntity_template = climada_xlsread('no','C:\Users\S5ZQSN\Desktop\climada_meta\climada_modules\climada_module_flood\data\entity_template.xlsx','damagefunctions');
 regexp expression that describes the files (entities) where the
 replacement should be done
ntity_file_regexp = 'C:\Users\S5ZQSN\Desktop\climada_meta\climada\data\entities\*_entity*';
 find the desired entity / entities
P = fileparts(entity_file_regexp);
_entity_mat = dir(entity_file_regexp);
 loop over entity files and replace damagefunctions
or file_i=1:length(D_entity_mat)
   
   entity_file_i = [fP filesep D_entity_mat(file_i).name];
   try
       load(entity_file_i)
       entity.damagefunctions = entity_template;
       fprintf('saving %s in %s (by %s)\n',D_entity_mat(file_i).name,fP,mfilename)
       save(entity_file_i,'entity')
       
   catch
       fprintf('skipped (invalid entity): %s\n',D_entity_mat(file_i).name);
       entity.assets=[]; % dummy
   end
   
nd 
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/flood_damagefunction_entity_add.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="landcolor">
<H2>landcolor</H2></A>
<font color="blue">function y = landcolor(n) </font>
LANDCOLOR Land colormap

	Author: Francois Beauducel &ampltbeauducel@ipgp.fr&ampgt
	$Revision: 1.0.0 $   $Date: 2012/05/17 11:22:44 $
 = [ ...
.095678 0.53427 0.21682 
.15785 0.5979 0.23274 
.21286 0.64673 0.2514 
.26411 0.68789 0.27268 
.32959 0.72416 0.31308 
.39794 0.75695 0.36038 
.46153 0.7871 0.40624 
.52108 0.81516 0.45135 
.57702 0.84152 0.49547 
.62973 0.86645 0.53891 
.67946 0.89016 0.58187 
.72647 0.91282 0.62427 
.77095 0.93455 0.66619 
.81306 0.95546 0.70772 
.85292 0.97563 0.7489 
.89066 0.99514 0.78976 
.88379 0.98595 0.77038 
.86389 0.96758 0.73236 
.84615 0.94972 0.69623 
.8303 0.93233 0.66186 
.81612 0.91536 0.6291 
.80341 0.8988 0.59784 
.79201 0.8826 0.56795 
.78191 0.86676 0.53946 
.7729 0.85123 0.51224 
.76479 0.83602 0.48615 
.75747 0.8211 0.46111 
.75084 0.80645 0.43704 
.74506 0.79206 0.41414 
.73981 0.77792 0.39211 
.73501 0.76401 0.37089 
.73068 0.75033 0.35052 
.72683 0.73685 0.33106 
.72042 0.72074 0.31228 
.71032 0.70085 0.29417 
.69761 0.67821 0.27694 
.68489 0.65558 0.26026 
.67235 0.63313 0.24418 
.65997 0.61082 0.22889 
.64775 0.58874 0.21406 
.63568 0.56689 0.19983 
.62376 0.54527 0.18622 
.61197 0.52391 0.17299 
.60033 0.50283 0.16046 
.58881 0.48203 0.14832 
.57742 0.46151 0.13667 
.56616 0.44133 0.12555 
.55502 0.4214 0.11472 
.54398 0.4019 0.10456 
.53306 0.38266 0.094633 
.52226 0.36382 0.085242 
.51155 0.3453 0.076179 
.50095 0.32714 0.067515 
.49045 0.30938 0.059259 
.48005 0.29193 0.051294 
.46973 0.27495 0.043796 
.45951 0.25823 0.0365 
.44938 0.24206 0.029715 
.43934 0.22609 0.023063 
.42938 0.21074 0.016949 
.41951 0.19556 0.010917 
.40971 0.18105 0.0054326 
.4 0.16667 0 
;
 = length(J);
f nargin &amplt 1
n = 256;
nd
 = interp1(1:l,J,linspace(1,l,n),'*linear');
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/tools_and_more/landcolor.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="seacolor">
<H2>seacolor</H2></A>
<font color="blue">function y = seacolor(n) </font>
SEACOLOR Sea colormap adapted from NGDC ETOPO1

	Author: Francois Beauducel &ampltbeauducel@ipgp.fr&ampgt
 = [ ...
   0.0392         0    0.4745
   0.1020         0    0.5373
   0.1020         0    0.5373
   0.1490         0    0.5961
   0.1490         0    0.5961
   0.1059    0.0118    0.6510
   0.1059    0.0118    0.6510
   0.0627    0.0235    0.7059
   0.0627    0.0235    0.7059
   0.0196    0.0353    0.7569
   0.0196    0.0353    0.7569
        0    0.0549    0.7961
        0    0.0549    0.7961
        0    0.0863    0.8235
        0    0.0863    0.8235
        0    0.1176    0.8471
        0    0.1176    0.8471
        0    0.1529    0.8745
        0    0.1529    0.8745
   0.0471    0.2667    0.9059
   0.0471    0.2667    0.9059
   0.1020    0.4000    0.9412
   0.1020    0.4000    0.9412
   0.0745    0.4588    0.9569
   0.0745    0.4588    0.9569
   0.0549    0.5216    0.9765
   0.0549    0.5216    0.9765
   0.0824    0.6196    0.9882
   0.0824    0.6196    0.9882
   0.1176    0.6980    1.0000
   0.1176    0.6980    1.0000
   0.1686    0.7294    1.0000
   0.1686    0.7294    1.0000
   0.2157    0.7569    1.0000
   0.2157    0.7569    1.0000
   0.2549    0.7843    1.0000
   0.2549    0.7843    1.0000
   0.3098    0.8235    1.0000
   0.3098    0.8235    1.0000
   0.3686    0.8745    1.0000
   0.3686    0.8745    1.0000
   0.5412    0.8902    1.0000
   0.5412    0.8902    1.0000
   0.7373    0.9020    1.0000
;
 = length(J);
f nargin &amplt 1
n = 256;
nd
 = interp1(1:l,J,linspace(1,l,n),'*linear');
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/seacolor.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="structfind">
<H2>structfind</H2></A>
<font color="blue">function index=structfind(a,field,value) </font>
 StructFind, Find the index of a certain string or value in a struct

       index=structfind(a,field,value)

  inputs,
       a : A Matlab struct, for example a(1).name='red', a(2).name='blue';
       field : The name of the field which is searched, for example 'name'
       value : The search value, for example 'blue'

  outputs,
       index : The Struct index which match the search

 Function is written by D.Kroon University of Twente (December 2010)
 We don't compare structs
f(isstruct(value)), 
   error('structfind:inputs','search value can not be a struct');
nd
 Stop if field doesn't exist
f(~isfield(a,field))
   index=find(arrayfun(@(x)(cmp(x,field,value)),a,'uniformoutput',true));
lse
   index=find(arrayfun(@(x)(cmp(x,field,value)),a,'uniformoutput',true));
nd
<font color="blue">function check=cmp(x,field,value) </font>
heck=false;
f(isfield(x,field))
   % Simple field like x.tag
   x=x.(field); 
lse
   % Complex field like x.tag.child.value
   in=find(field=='.');
   s=[1 in+1]; e=[in-1 length(field)];
   for i=1:length(s)
       fieldt=field(s(i):e(i));
       if(isfield(x,fieldt)), x=x.(fieldt);  else return; end
   end
nd
 We don't compare structs
f(isstruct(x)), return; end
 Values can only be equal, if they equal in length
f(length(x)==length(value)), 
   % This part compares the NaN values 
   if((~iscell(x))&amp&amp(~iscell(value))&amp&ampany(isnan(value))), 
       checkv=isnan(value); checkx=isnan(x);
       if(~all(checkx==checkv)), return; end
       x(checkx)=0; value(checkv)=0;
   end
   % This part compares for both string as numerical values 
   if(iscell(x)||iscell(value))
       check=all(strcmpi(x,value)); 
   else
       check=all(x==value); 
   end
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood/code/under_construction/structfind.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="DEM_rainfall">
<H2>DEM_rainfall</H2></A>
<font color="blue">function [WO_object,precip] = DEM_rainfall(centroids) </font>
UNTITLED2 Summary of this function goes here
average the rainfall dataset
%
 climada RF hazard event set
 NAME:
   climada_RF_hazard_set
 PURPOSE:
   Construct hazard set structure from global historical daily precipitation data
   found here: ftp://ftp.cgd.ucar.edu/archive/PRECIP/GPCP_1DD_v1.2_199610-201407.nc.gz
               http://www.esrl.noaa.gov/psd/data/gridded/data.gpcc.html
   The ens_size probabilistic events are generated by taking the x_fraction most
   extreme events from the original data, and adjusting their intensity.
   The extent of the wiggle is determined by generating a random wiggle
   paramater from a normal distribution with standard deviation ens_amp.
 CALLING SEQUENCE:
   hazard = climada_rf_hazard_set(centroids, precip_file, x_fraction, ens_size, ens_amp, hazard_set_file, check_plots)
 EXAMPLE:
   hazard = climada_rf_hazard_set(centroids, '', 0.2, 9, 0.1, 'NO_SAVE', 1)
   hazard = climada_rf_hazard_set(centroids, '', 0.7, 1)
   hazard = climada_rf_hazard_set
 INPUTS:
   hazard_set_file: the name of the newly created rainfall (RF) hazard
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   check_plots: whether to show plots (default = 1)
 OUTPUTS:
   hazard:     a hazard event set, see core climada doc
               also written to a .mat file (see hazard_set_file)
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150316
 Gilles Stassen, gillesstassen@hotmail.com, 20150406 overhaul to daily
                   precipitation data, including auto download functionality, and
                   probabilistic set of extreme events
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/DEM_rainfall.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_90m_DEM">
<H2>climada_90m_DEM</H2></A>
<font color="blue">function [centroids, DEM] = climada_90m_DEM(centroidsORcountryORshapes, srtm_dir, DEM_save_file, smooth, check_plot) </font>
 climada
 MODULE:
   flood
 NAME:
   climada_read_srtm_DEM
 PURPOSE:
   Read the digital elevation model data from the files in an existing
   srtm directory. Data can be downloaded from http://srtm.csi.cgiar.org/SELECTION/inputCoord.asp
 CALLING SEQUENCE:
   [centroids,DEM] = climada_90m_DEM(centroids, srtm_dir, DEM_save_file, smooth, check_plot)
 EXAMPLE:
   [centroids,DEM] = climada_90m_DEM('Netherlands',[],[],[],1)
   [~,DEM] = climada_90m_DEM
   [centroids,DEM] = climada_90m_DEM([min_lon max_lon min_lat max_lat],srtm_dir,DEM_save_file, 4,1)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   centroids:  If centroids are provided as an input, the DEM will contain
               elevation data sampled at the location of centroids, and
               hence will have an extra field .centroid_ID. The extra
               field is required for tc_surge_hazard_create if you wish to
               provide your own topography data (e.g. srtm).
               If this input is left empty , a
               centroids struct will be generated at the same resolution
               as the DEM.
               If set to a 4-element vector (centroids_rect), these 4
               points will define the area of interest, which is
               subsequently cropped out of the DEM.
               NOTE:   It is only sensible to provide a centroids struct
               as input if its resolution is significantly lower than that
               of the DEM, otherwise, it is much faster to generate
               centroids directly from the DEM.
   srtm_dir:   The directory of an srtm data tile folder, containing at
               least a .hdr and a .tif file. Can also be set to 'DL' 
               (default) which will initiate automatic download from SRTM 
               website according to the centroidsORcountry given as input.
   smooth:     Can either be set to an integer N (smooth by default filter
               specified by a matrix size NxN with values 1/N^2) or a
               smoothing filter. Default = [] (no smoothing).
   check plot: Specify whether to plot a relief of the DEM, default = 0
 OUTPUTS:
   DEM:        Struct containing information of the digital elevation
               model at full 90m resolution, with fields:
               .elevation_m:   Elevation data
               .lat:           Latitude
               .lon:           Longitude
               .centroid_ID:   Only if centroids provided as input or if
                               centroids input set to 1.
   centroids:  Climada centroids struct with fields:
               .elevation_m:   Elevation data
               .lat:           Latitude
               .lon:           Longitude
               .centroid_ID:   Only if centroids provided as input or if
                               centroids input set to 1.
               .onLand:        Set to 0 if .elevation_m &amplt0, 1 otherwise
               .admin0_name    Country name
               .admin0_ISO3    ISO 3 country code
 MODIFICATION HISTORY:
   Gilles Stassen 20150107
   Gilles Stassen 20150224     fixed some bugs in the plotting routines
                               and added messages to warn of DEM edges
   Gilles Stassen 20150225     cleanup and added automatic download and
                               unzip feature
   Gilles Stassen 20150707     renamed climada_read_srtm_DEM-&ampgtclimada_90m_DEM
                               usage of climada_grid2array replaced with
                               reshape, some further bug fixes
   Lea Mueller, muellele@gmail.com, 20150720, @Gilles, please correct,
   code does not work, srtm_19_10 is a .tif.aux.xml, not a .tif, probably
   file was not copied from your drive to the shared drive
EM =[];
lobal climada_global
f ~climada_init_vars,return;end % init/import global variables
f exist(climada_global.map_border_file, 'file')
   load(climada_global.map_border_file)
nd
odule_data_dir=[fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
f ~exist('centroidsORcountryORshapes', 'var'),     centroidsORcountryORshapes  = [];   end
f ~exist('srtm_dir',           'var'),     srtm_dir            = 'DL'; end
f ~exist('DEM_save_file',      'var'),     DEM_save_file       = [];   end
f ~exist('smooth',             'var'),     smooth              = [];   end
f ~exist('check_plot',         'var'),     check_plot          = 0;    end
f ~isempty(centroidsORcountryORshapes)
   if isstruct(centroidsORcountryORshapes) &amp&amp isfield(centroidsORcountryORshapes,'centroid_ID')
       % input is centroids
       centroids   = centroidsORcountryORshapes; clear centroidsORcountryORshapes
       if isfield(centroids,'countryname')
           country_name    =   centroids.country_name;
           [country_name, ~, occurrence]=unique(country_name);
           country_name    =   country_name(mode(occurrence));
           country_name    =   country_name{1};
       else
           country_name = [];
       end
       rect        = [min(centroids.lon) max(centroids.lon) min(centroids.lat) max(centroids.lat)];
   elseif isstruct(centroidsORcountryORshapes) &amp&amp (isfield(centroidsORcountryORshapes,'X') || isfield(centroidsORcountryORshapes,'lon'))
       % input is probably shapes
       shapes = centroidsORcountryORshapes; clear centroidsORcountryORshapes
       if isfield(shapes,'lon'),   shapes.X  =shapes.lon; shapes.Y = shapes.lat; end
       bb          = [min([shapes(:).X]) min([shapes(:).Y])
                      max([shapes(:).X]) max([shapes(:).Y])];
       rect        = [bb(:,1)' bb(:,2)']; clear bb
   elseif isnumeric(centroidsORcountryORshapes) &amp&amp numel(centroidsORcountryORshapes) == 4
       % input is centroids_rect
       centroids   = [];
       rect        = centroidsORcountryORshapes; clear centroidsORcountryORshapes
   elseif ischar(centroidsORcountryORshapes)
       % input is country name
       centroids   = [];
       country_name= centroidsORcountryORshapes; clear centroidsORcountryORshapes
       [country_name,country_ISO3,shape_index] = climada_country_name(country_name);
       if isempty(shape_index)
           cprintf([1 0 0],'ERROR: invalid country name \n')
           [country_name,country_ISO3,shape_index] = climada_country_name;
       end
       
       % bb          = shapes(shape_index).BoundingBox;    % countries with colonies pose problems here...
       bb          = [min(shapes(shape_index).X) min(shapes(shape_index).Y)
           max(shapes(shape_index).X) max(shapes(shape_index).Y)];
       rect        = [bb(:,1)' bb(:,2)']; clear bb
   end
lse
   centroids   = []; clear centroidsORcountry
   [country_name,country_ISO3,shape_index] = climada_country_name('Single');
   country_name = char(country_name);
   if isempty(country_name), return; end % error message already printed in climada_country_name
   % bb          = shapes(shape_index).BoundingBox;    % countries with colonies pose problems here...
   bb          = [min(shapes(shape_index).X) min(shapes(shape_index).Y)
       max(shapes(shape_index).X) max(shapes(shape_index).Y)];
   rect        = [bb(:,1)' bb(:,2)']; clear bb
nd
 country string for fprintf and fig title
f exist('country_name','var') &amp&amp ~isempty(country_name)
   cntry_str = sprintf(' for %s',country_name'); 
lse
   cntry_str = ''; 
nd
 conversion to srtm tile indices
ect_buffer      = 0.5;     % set buffer to avoid missing data due to imperfect conversions below
f rect(1) &amplt-179.9,rect(1) = rect(1)+359.9; end
rtm_min_lon_ndx = max(ceil(72 * (rect(1)-rect_buffer + 180)/(179.28+180.00)),1);
rtm_max_lon_ndx = min(ceil(72 * (rect(2)+rect_buffer + 180)/(179.28+180.00)),72);
rtm_min_lat_ndx = max(ceil(24 * (60 - rect(3)+rect_buffer) /( 60.00+ 57.83)),1);
rtm_max_lat_ndx = min(ceil(24 * (60 - rect(4)-rect_buffer) /( 60.00+ 57.83)),24);
I,J]   = meshgrid([srtm_min_lon_ndx: srtm_max_lon_ndx],[srtm_max_lat_ndx: srtm_min_lat_ndx]);
_tiles = (1+srtm_max_lon_ndx-srtm_min_lon_ndx)*(1+srtm_min_lat_ndx-srtm_max_lat_ndx);
 load srtm tile from internet and unzip
l_check = 0;
f strcmp(srtm_dir, 'DL')
   dl_check = 1;
   clear srtm_dir
   
   % construct filenames
   if n_tiles &ampgt 9 % is this the limit??
       warn_msg = sprintf('WARNING: Your specified region of interest requires %i DEM tiles. \n\t \t Computation may be slow and Matlab may crash. Are you sure you wish to continue? (y/n) ',n_tiles);
       response = input(warn_msg,'s');
       if ~strcmp(response,'y')
           fprintf('aborting\n')
           return
       end
   end
   
   t0 = clock;
   format_str = '%s';
   for tile_i = 1 : n_tiles
       srtm_fN{tile_i}     = strcat('srtm_',num2str(I(tile_i),'%02.0f'),'_',num2str(J(tile_i),'%02.0f'));
       srtm_dir{tile_i}    = [module_data_dir filesep 'system' filesep srtm_fN{tile_i}];
       srtm_URL{tile_i}    = ['ftp://srtm.csi.cgiar.org/SRTM_V41/SRTM_Data_GeoTiff/' srtm_fN{tile_i} '.zip'];
       
       if exist([srtm_dir{tile_i} filesep srtm_fN{tile_i} '.tif'],'file') &amp&amp ...
               exist([srtm_dir{tile_i} filesep srtm_fN{tile_i} '.hdr'],'file')
           substr = sprintf('%s already exists - skipping', srtm_fN{tile_i});
           skip_file = 1;
       else
           % delete existing folder to avoid any unzipping issues
           if exist(srtm_dir{tile_i},'dir'), rmdir(srtm_dir{tile_i},'s'); end
           substr = sprintf('downloading and unzipping %s', srtm_fN{tile_i});
           skip_file = 0;
       end
       
       % progress management
       t_elapsed_tile   = etime(clock,t0)/tile_i;
       tiles_remaining  = n_tiles-tile_i;
       t_projected_sec   = t_elapsed_tile*tiles_remaining;
       if t_projected_sec&amplt60
           msgstr = sprintf('%s, est. %3.0f sec left (%i/%i files)',substr, t_projected_sec, tile_i,n_tiles);
       else
           msgstr = sprintf('%s, est. %3.1f min left (%i/%i files)',substr, t_projected_sec/60,tile_i,n_tiles);
       end
       fprintf(format_str,msgstr); % write progress to stdout
       format_str=[repmat('\b',1,length(msgstr)) '%s']; % back to begin of line
       
       if ~skip_file
           try
               mkdir(srtm_dir{tile_i});
               unzip(srtm_URL{tile_i}, srtm_dir{tile_i});
           catch
               http_URL = ['http://droppr.org/srtm/v4.1/6_5x5_TIFs/' srtm_fN{tile_i} '.zip'];
               urlwrite(http_URL,[srtm_dir{tile_i} '.zip']);
               unzip([srtm_dir{tile_i} '.zip'],srtm_dir{tile_i});
           end
       else     
           pause(1)
       end
   end
lse
   tmp         = srtm_dir;     clear srtm_dir
   srtm_dir{1} = tmp;          clear tmp
nd
printf('\nreading and processing DEM%s... ',cntry_str)
 struct containing the lat/lon extremes of each tile (in any order)
xtremes.lon = [];
xtremes.lat = [];
or tile_i = 1 : n_tiles
   srtm_files = dir(srtm_dir{tile_i});
   
   for file_i = 1 : numel(srtm_files)
       [~, ~, fE] = fileparts(srtm_files(file_i).name);
       
       if strcmp(fE, '.hdr')
           fid = fopen([srtm_dir{tile_i} filesep srtm_files(file_i).name]);
           scale_check = 0;
           while ~feof(fid),
               line = fgetl(fid);
               
               if scale_check
                   scale = str2num(line);
                   dlon = scale(1); dlat = scale(2);
                   scale_check =0;
               end
               if strfind(line,'ModelPixelScaleTag')
                   scale_check = 1;
               end
               
               if strfind(line,'Upper Left')
                   loc_i = strfind(line, '(');
                   loc_f = strfind(line, ')');
                   UL = str2num(line(loc_i+1:loc_f-1));
               end
               if strfind(line,'Lower Left')
                   loc_i = strfind(line, '(');
                   loc_f = strfind(line, ')');
                   LL = str2num(line(loc_i+1:loc_f-1));
               end
               if strfind(line,'Upper Right')
                   loc_i = strfind(line, '(');
                   loc_f = strfind(line, ')');
                   UR = str2num(line(loc_i+1:loc_f-1));
               end
               if strfind(line,'Lower Right')
                   loc_i = strfind(line, '(');
                   loc_f = strfind(line, ')');
                   LR = str2num(line(loc_i+1:loc_f-1));
               end
           end
           fclose(fid);
           extremes.lon = [extremes.lon UL(1) UR(1)];
           extremes.lat = [extremes.lat UL(2) LL(2)];
           break;
       end
   end
   
   for file_i = 1 : numel(srtm_files)
       [~, ~, fE] = fileparts(srtm_files(file_i).name);
       
       if strcmp(fE, '.tif') || strcmp(fE, '.tif.aux.xml')
           raw(I(tile_i),J(tile_i)).grid = imread([srtm_dir{tile_i} filesep srtm_files(file_i).name]);
           break;
       end
   end
nd
EM_grid = [];
 Concatenate tiles
or i = srtm_min_lon_ndx: srtm_max_lon_ndx
   DEM_grid_j = [];
   for j = srtm_max_lat_ndx: srtm_min_lat_ndx
       DEM_grid_j = [DEM_grid_j ; raw(i,j).grid];
   end
   DEM_grid = [DEM_grid DEM_grid_j];
nd
lear raw DEM_grid_j
eference_box = [min(extremes.lon) max(extremes.lon) min(extremes.lat) max(extremes.lat)];
EM_grid(DEM_grid== min(min(DEM_grid))) = min(DEM_grid(DEM_grid~= min(min(DEM_grid))));
EM_grid = double(DEM_grid);
 smooth the DEM if desired
f ~isempty(smooth) &amp&amp any(smooth) &amp&amp ~isnan(smooth)
   if isscalar(smooth)
       smooth_matrix = (1/smooth^2) .* ones(smooth);
   elseif ismatrix(smooth)
       smooth_matrix = smooth;
   end
   DEM_grid = filter2(smooth_matrix,DEM_grid);
nd
 store as singleton arrays in DEM structure
 [elev, lon, lat] = climada_grid2array(DEM_grid', reference_box); % OLD
LON, LAT] = meshgrid(linspace(reference_box(1),reference_box(2),size(DEM_grid,1)),...
   linspace(reference_box(3),reference_box(4),size(DEM_grid,2)));
AT = flipud(LAT);
on = reshape(LON,numel(LON),1);
at = reshape(LAT,numel(LAT),1);
lev = reshape(DEM_grid,numel(DEM_grid),1);
printf('done \n')
f exist('centroids','var') &amp&amp isstruct(centroids)
   % crop to rect
   lon_crop_ndx    = rect(1) &amplt= lon &amp lon &amplt= rect(2);
   lat_crop_ndx    = rect(3) &amplt= lat &amp lat &amplt= rect(4);
   lon_crop        = lon(lon_crop_ndx &amp lat_crop_ndx);
   lat_crop        = lat(lon_crop_ndx &amp lat_crop_ndx);
   elev_crop       = elev(lon_crop_ndx &amp lat_crop_ndx);
   
   DEM.elevation_m     = elev_crop';
   DEM.lon             = lon_crop';
   DEM.lat             = lat_crop';
   
   n_centroids = numel(centroids.centroid_ID);
   fprintf('processing centroid elevation... ');
   t0 = clock;
   format_str = '%s';
   if n_tiles &ampgt 2
       for centroid_i = 1: n_centroids
           r_i = climada_geo_distance(centroids.lon(centroid_i),centroids.lat(centroid_i),lon_crop,lat_crop);
           %r_i = sqrt((centroids.lon(centroid_i)-lon_crop).^2 + (centroids.lat(centroid_i)-lat_crop).^2);
           [~,ndx] = min(r_i);
           DEM.centroid_ID(ndx) = centroid_i;
           centroids.elevation_m(centroid_i) = elev_crop(ndx)';
           % the progress management
           mod_step = 100;
           if mod(centroid_i,mod_step)==0
               t_elapsed_event   = etime(clock,t0)/centroid_i;
               events_remaining  = n_centroids-centroid_i;
               t_projected_sec   = t_elapsed_event*events_remaining;
               if t_projected_sec&amplt60
                   msgstr = sprintf('est. %3.0f sec left (%i/%i centroids)',t_projected_sec,   centroid_i,n_centroids);
               else
                   msgstr = sprintf('est. %3.1f min left (%i/%i centroids)',t_projected_sec/60,centroid_i,n_centroids);
               end
               fprintf(format_str,msgstr); % write progress to stdout
               format_str=[repmat('\b',1,length(msgstr)) '%s']; % back to begin of line
           end
       end
   else
       
       % F_DEM = scatteredInterpolant(DEM.lon',DEM.lat',DEM.elevation_m');
       F_DEM = scatteredInterpolant(lon_crop,lat_crop,elev_crop);
       centroids.elevation_m = F_DEM(centroids.lon',centroids.lat')';
       fprintf('done \n')
   end
   fprintf(format_str,sprintf('processing centroid elevation%s took %3.0f seconds \n',cntry_str, etime(clock,t0)));
   
   if ~dl_check % only necessary when existing data is selected, avoid warning message due to imperfect cropping
       % deal with DEM edges if they do not reach extent of centroids
       if min(lon) &ampgt min(centroids.lon) || max(lon) &amplt max(centroids.lon)
           cprintf([1 0.25 0.25], ['WARNING: longitudinal extent of centroids exceeds '...
               'that of DEM \n \t \t Elevation not processed for some centroids \n'])
       end
       if min(lat) &ampgt min(centroids.lat) || max(lat) &amplt max(centroids.lat)
           cprintf([1 0.25 0.25], ['WARNING: latitudinal extent of centroids exceeds '...
               'that of DEM \n \t \t Elevation not processed for some centroids \n'])
       end
   end
   
   centroids.elevation_m(min(lon) &ampgt centroids.lon) = NaN;
   centroids.elevation_m(max(lon) &amplt centroids.lon) = NaN;
   centroids.elevation_m(min(lat) &ampgt centroids.lat) = NaN;
   centroids.elevation_m(max(lat) &amplt centroids.lat) = NaN;
   
   if ~exist('rect','var') || isempty(rect)
       rect = [min(DEM.lon) max(DEM.lon) min(DEM.lat) max(DEM.lat)];
   end
   
lseif ~isempty(rect)
   
   if min(lon) &ampgt rect(1) || max(lon) &amplt rect(2)
       cprintf([1 0.25 0.25], ['WARNING: DEM does not cover longitudinal extent'...
           'defined by centroids rect \n \t \t Spatial extent of centroids limited to DEM \n'])
   end
   
   if min(lat) &ampgt rect(3) || max(lat) &amplt rect(4)
       cprintf([1 0.25 0.25], ['WARNING: DEM does not cover latitudinal extent'...
           'defined by centroids rect \n \t \t Spatial extent of centroids limited to DEM \n'])
   end
   
   fprintf('generating centroids from DEM...');
   
   % crop to rect
   lon_crop_ndx    = rect(1) &amplt= lon &amp lon &amplt= rect(2);
   lat_crop_ndx    = rect(3) &amplt= lat &amp lat &amplt= rect(4);
   lon             = lon(lon_crop_ndx &amp lat_crop_ndx);
   lat             = lat(lon_crop_ndx &amp lat_crop_ndx);
   elev            = elev((lon_crop_ndx &amp lat_crop_ndx));
   
   DEM.elevation_m     = elev';
   DEM.lon             = lon';
   DEM.lat             = lat';
   
   % Generate centroids struct at same resolution as DEM if not provided
   centroids.lon           = lon';
   centroids.lat           = lat';
   centroids.elevation_m   = elev';
   n_centroids             = numel(centroids.lon);
   centroids.centroid_ID   = [1:n_centroids];
   DEM.centroid_ID         = [1:n_centroids];
   centroids.onLand        = ones(1,n_centroids);
   centroids.onLand(elev&amplt0)= 0; % May be inaccurate when there are land points below sea level, but much faster than using inpolygon
   
   if exist('shapes','var')
       n_centroids = numel(centroids.lon);
       % accomodate for both climada global shp files, as well as shp
       % files downloaded from http://www.diva-gis.org/gdata
       if isfield(shapes,'NAME')  &amp&amp length(shapes) == 1
           for i = 1 : n_centroids
               centroids.country_name{i} = shapes.NAME;
           end
           centroids.admin0_name = shapes.NAME;
       elseif exist('country_name','var')
           for i = 1 : n_centroids
               centroids.country_name{i} = country_name;
           end
           centroids.admin0_name = country_name;
       end
       if isfield(shapes,'ADM0_A3')  &amp&amp length(shapes) == 1
           centroids.admin0_ISO3 = shapes.ADM0_A3;
       elseif exist('country_name','var')
           for i = 1 : n_centroids
               centroids.country_name{i} = country_ISO3;
           end
           centroids.admin0_name = country_ISO3;
       end
   end
   fprintf(' done \n');
lse
   DEM.elevation_m = elev';
   DEM.lon         = lon';
   DEM.lat         = lat';
   rect            = reference_box;
nd
lear elev lon lat
f ~isempty(DEM_save_file) &amp&amp ~strcmp(DEM_save_file,'NO_SAVE')
   save(DEM_save_file,'DEM');
nd
f isfield(centroids, 'filename')
   save(centroids.filename,'centroids');
nd
f check_plot
   fprintf('plotting DEM (might take a while)... ')
   % relief plot
   figure('Name', '2D Relief Plot', 'color', 'w');
   hold on
   title(sprintf('Digital Elevation Model %s', cntry_str))
   
   if isempty(which('climada_DEM_plot'))
       fprintf('Download DEM plotting function from http://ch.mathworks.com/matlabcentral/fileexchange/36380-dem--shaded-relief-image-plot--digital-elevation-model-\n')
       fprintf('and rename dem -&ampgt climada_DEM_plot for awesome relief plot \n')
       fprintf('using imagesc instead\n')
       [s_x,s_y]   = size(DEM_grid);
       tmp_x       = linspace(reference_box(1),reference_box(2),s_x);
       tmp_y       = linspace(reference_box(3),reference_box(4),s_y);
       imagesc(tmp_x,tmp_y,DEM_grid)
   else
       [s_y,s_x]   = size(DEM_grid);
       tmp_x       = linspace(reference_box(1),reference_box(2),s_x);
       tmp_y       = linspace(reference_box(3),reference_box(4),s_y);
       if numel(DEM_grid) &amplt= (2 * 6001 * 6001)
           climada_DEM_plot(tmp_x,fliplr(tmp_y),DEM_grid, 'NoDecim')
       else
           climada_DEM_plot(tmp_x,fliplr(tmp_y),DEM_grid)
       end
   end
   xlabel('Longitude');
   ylabel('Latitude');
   axis equal
   axis(rect)
   set(gca,'Ydir','normal')
   
   shape_plotter(shapes,[],[],[],'linewidth',2,'color','r')
   
   hold off
   fprintf('done\n')
nd
eturn
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_90m_DEM.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_fl_encode">
<H2>climada_fl_encode</H2></A>
<font color="blue">function hazard_fl=climada_fl_encode(centroids,hazard_fl) </font>
lon_i lon_j] = size(centroids.lon);
 find unique lat lons
f lon_j == 1 % was lon_i
   [lon_lat,indx, indx2] = unique([centroids.lon centroids.lat],'rows');
lseif lon_i == 1 % was lon_j
   [lon_lat,indx, indx2] = unique([centroids.lon;centroids.lat]','rows');
lse
   fprintf('Please check the dimensions of centroids.lon and centroids.lat.\n')
   return
nd
 start encoding
_centroids             = length(indx);
 n_assets            = length(assets.Value);
entroids.centroid_index = centroids.lon*0; % init
or centroids_i=1:n_centroids
   centroids_i
  % if climada_global.waitbar,
  waitbar(centroids_i/n_centroids);
  %end
   
   dist_m                       = climada_geo_distance(centroids.lon(indx(centroids_i)),centroids.lat(indx(centroids_i)),hazard_fl.lon,hazard_fl.lat);
   [min_dist,min_dist_index]    = min(dist_m);
   
   % set closest centroids position to zero if centroids is too far away from hazard_fl (depends on peril ID)
     if min_dist&ampgtmax_distance_to_centroids
         min_dist_index = 0;
     end
   indx3                        = find(indx2 == centroids_i);
   centroids.centroid_index(indx3) = min_dist_index;
   hazard_fl.value=
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_fl_encode.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_fl_onland">
<H2>climada_fl_onland</H2></A>
<font color="blue">function  haz_temp=climada_fl_onland(haz_temp) </font>
 climada
 MODULE:
   flood
 NAME:
   climada_fl_onland
 PURPOSE:
   checking if evaluated centroids are onland, if not sets values to 0
 EXAMPLE:
   hazard(i)=climada_fl_onland(hazard(i));

   INPUTS:
   haz_temp:   A single event hazard 

 OUTPUTS:
  haz_temp:    The checked single event hazard

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

uses climada_tc_onland to evaluate if the centroids of the hazard are
onland 
or i=1:length(haz_temp)
   if ~isempty(haz_temp{1,i});
   evaluation=haz_temp{1,i};
   
   evaluation=climada_tc_on_land(evaluation);
   
   
   %evaluation.lat(evaluation.onLand==0)=[];
   %evaluation.lon(evaluation.onLand==0)=[];
   evaluation.value(evaluation.onLand==0)=0;
   haz_temp{1,i}=evaluation;
   clear evaluation
   display(sprintf('checked return period %d from %d',i,length(haz_temp)))
   else
   display(sprintf('skipped return period %d from %d',i,length(haz_temp)))   
   end
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_fl_onland.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_flood_module">
<H2>climada_flood_module</H2></A>
%function [hazard,S,DEMf]=climada_flood_module
 climada
 MODULE:
   flood
 NAME:
   climada_module_flood
 PURPOSE:
   Calculates a flood hazard including return periods from 1 to 500 years.
   Runs the entire flood module set
 EXAMPLE:
   hazard=climada_module_flood
   INPUTS:
   none, as the country name is asked for in a popup windows

 OUTPUTS:
   hazard:      A hazard struct, containing lon, lat, frequency (1/return
                period) and intensity
   S:           The stream structure. Visualize using plot(S)
   DEMf:        The smoothened DEM layer
 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

______________________________
initial parameters and settings:
 Empty variables
ax_ind_rp=[];
 Smoothing
arameter.smot='on';%[off];
centroids cleanup
arameter.remote_centroid_cleanup='off';
river network
arameter.accum_th=30000;
 Crosssection parameters
arameter.crosssect_width=0.1;
arameter.crossect_dy_dist=0.001;
arameter.smoothing_dist=0.005;
___________________________________
 1. choose a country
%centroids=climada_centroids_generate('',1,1,'NO_SAVE');
entroids = climada_centroids_generate([7 8 46 46.5]); % CHE Valais
Create the DEM layer for the country, retrieve the SRTM file if not loaded already
 next returns DEM.lon,lat and elevation_m as vectors
DEM]=climada_read_srtm_DEM('DL',centroids);
 next returns DEM.x,y and h as matrices
[DEM,srtm_info]=climada_srtm_get(centroids,0,0,1); % climada function
2. prepare the necessary input files
 2.1.1 interpolate the rainfall on the DEM resolution
 eleven return periods based on the available rainfall data are calculated
and stored in a weigthobject
long calculation time
the SRTM rainfall is loaded
WO_object,precip]=DEM_rainfall(DEM);
the return periods are interpolated based on the current (approx. 40 y) data
WO_obj]=rain_statistics(precip,DEM);
 2.1.2 Create an equal cellsized rainfall grid from colum
option: convert lat lon to UTM, parameters can be set in [meters] instead of degree lat/lon
convert lat lon to x y (takes a long time)
[DEM.x,DEM.y,DEM.utmzone] = deg2utm(DEM.lat,DEM.lon);
obtain a grid from the DEM vector
DEM] =vec2grid(DEM);
 3 Convert DEM into matlab objects
EM_2=GRIDobj(DEM.lon_vec,DEM.lat_vec,DEM.grid);
 4 preprepare the DEM; layer is smoothened and sinks are filled,
if DEM is good quality, no preprocessing like this is needed
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_flood_module.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_flood_module_ANZ">
<H2>climada_flood_module_ANZ</H2></A>
%function [hazard,S,DEMf]=climada_module_flood
 climada
 MODULE:
   flood
 NAME:
   climada_module_flood
 PURPOSE:
   Calculates a flood hazard including return periods from 1 to 500 years.
   Runs the entire flood module set
 EXAMPLE:
   hazard=climada_module_flood
   INPUTS:
   none, as the country name is asked for in a popup windows

 OUTPUTS:
   hazard:      A hazard struct, containing lon, lat, frequency (1/return
                period) and intensity
   S:           The stream structure. Visualize using plot(S)
   DEMf:        The smoothened DEM layer
 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

______________________________
initial parameters and settings:
 Empty variables
   max_ind_rp=[];
 Smoothing
   parameter.smot='on';%[off];
   
centroids cleanup   
   parameter.remote_centroid_cleanup='off';
   
river network
   parameter.accum_th=30000;
   
 Crosssection parameters
   parameter.crosssect_width=0.1;
   parameter.crossect_dy_dist=0.001;
   parameter.smoothing_dist=0.005;
___________________________________
 1. choose a country
entroids=climada_centroids_generate('',1,1,'NO_SAVE');
Create the DEM layer for the country, retrieve the SRTM file if not loaded already
DEM]=climada_read_srtm_DEM('DL',centroids);
2. prepare the necessary input files
 2.1.1 interpolate the rainfall on the DEM resolution
 eleven return periods based on the available rainfall data are calculated
and stored in a weigthobject
long calculation time
the SRTM rainfall is loaded
WO_object,precip]=DEM_rainfall(DEM);
the return periods are interpolated based on the current (approx. 40 y) data
WO_obj]=rain_statistics(precip,DEM);
 2.1.2 Create an equal cellsized rainfall grid from colum 
   %option: convert lat lon to UTM, parameters can be set in [meters] instead of degree lat/lon 
   %convert lat lon to x y (takes a long time)
   %[DEM.x,DEM.y,DEM.utmzone] = deg2utm(DEM.lat,DEM.lon);
obtain a grid from the DEM vector
DEM] =vec2grid(DEM);
 3 Convert DEM into matlab objects
EM_2=GRIDobj(DEM.lon_vec,DEM.lat_vec,DEM.grid);
 4 preprepare the DEM; layer is smoothened and sinks are filled,
if DEM is good quality, no preprocessing like this is needed
       %-&ampgtrequires image processsing toolbox
EMf=fillsinks(DEM_2); 
 5 Calculate the flow accumulation from the smoothened DEM
       %-&ampgtrequires image processsing toolbox
D=FLOWobj(DEMf);
=flowacc(FD);
 extract a river network by selecting only cells with an accumulation above a certain treshold (here 30000)
=A&ampgtparameter.accum_th;
   
 Create the stream object and plot the rivernetwork
 = STREAMobj(FD,W);
       %-&ampgtrequires image processsing toolbox
lot(S);
 The average rainfall situation as reference
_normal=flowacc(FD,WO_obj.grid(:,:,length(WO_obj.returnp)));
         
get the streamorder
st,hs,MS]=streamorder(S);
 5.1 Create the orthogonal crosssection profiles with the parameters specified in the beginning
         %0.01  degree =&ampgt 1.113km
         %0.001 degree =&ampgt 113m [ca.DEM resolution] 
         if strcmp(parameter.smot,'on')
             try
               SW = SWATHobj(DEMf,S,'width',parameter.crosssect_width,'dy',parameter.crossect_dy_dist,'keepnodes',true,'smooth', parameter.smoothing_dist); %,'smoothlongest',true); 
             catch
               SW = SWATHobj(DEMf,S,'width',parameter.crosssect_width,'dy',parameter.crossect_dy_dist,'keepnodes',true);  
             end
         else
             SW = SWATHobj(DEMf,S,'width',parameter.crosssect_width,'dy',parameter.crossect_dy_dist,'keepnodes',true);
         end
         
 5.2 Clean overlapping points  
ry
         %SW=tidyswath(SW);
atch
         sprintf('more memory required by matlab to clean overlapping points, check by typing &quotmemory&quot ')
nd
 5.3 correct for exceeding stream elevation values          
SW,SW_original]=stream_elevation_correct(SW);       
         
6. Calculate the hazard maps for different event return periods
loops over all different return periods for precipitation events
waitbar
 = waitbar(0,'Please wait...');s = clock;
or i=1:length(WO_obj.returnp)
   A_event=flowacc(FD,WO_obj.grid(:,:,i));
   
   pause(0.1)
   % 6.1 Accumulation matrix for each event
   A_quot=A_event;
   A_quot.Z=A_event.Z./A_normal.Z;
   
   % 6.2 Create the event accumultation for each cross section point
         %Create Weightobject with structure of Swathobject, SW_WO is the spatial variation of A_quot1 in the river structure
         %it gives the multiplicator at each point, how much the accumulation exceeds the normal accumulation
         %0.001 equals 111.32 m
         if strcmp(parameter.smot,'on')
             fprintf('creating cross sections...')
             try
                 SW_WO = SWATHobj(A_quot,S,'width',parameter.crosssect_width,'dy',parameter.crossect_dy_dist,'keepnodes',true,'smooth',parameter.smoothing_dist); %,'smoothlongest',true); 
                 if i==1;SW_WO_off = SWATHobj(A_quot,S,'width',parameter.crosssect_width,'dy',parameter.crossect_dy_dist,'keepnodes',true);end
             catch
                 SW_WO_off = SWATHobj(A_quot,S,'width',parameter.crosssect_width,'dy',parameter.crossect_dy_dist,'keepnodes',true);
                 SW_WO=SW_WO_off;
             end
        else
             SW_WO_off = SWATHobj(A_quot,S,'width',parameter.crosssect_width,'dy',parameter.crossect_dy_dist,'keepnodes',true);
             SW_WO=SW_WO_off;
             fprintf('done')
        end
         
  %6.3 clean overlapping centroids
  try
         %SW_WO=tidyswath(SW_WO); 
         %SW_WO_off=tidyswath(SW_WO_off);
  catch
      sprintf('not enough memory to clean overlapping cross section, to check, type &quotmemory&quot ');
  end
  
  %6.4 get the strahler streamorder at the crosssection center points
         if i==1;SO=streamorder2swathobj(MS,SW_WO_off);end
           
  %6.5 data generation for calibration- not yet implemented
          max_ind_rp=flood_calibrate(SW_WO,max_ind_rp,i);
          
  %6.6 calculate the difference between elevation SW.Z at the river crosssection section points and the elvation at the middle of the river SW.xyz
   %hence: flood_vec is + if river is lower than sourrounding which is usually the case
   %Speed:fast, can leave it in the loop
           for p=1:length(SW.xyz)
                   for j=1:numel(SW.xyz{1,p})
                        flood_vec_dif{p}(:,j)=SW.Z{1,p}(:,j)-SW.xyz{1,p}(j);                 
                   end
                       %option to disable negative flood_vec values
                      flood_vec_dif{p}(flood_vec_dif{p}&amplt0)=0;                  
           end
           flood_vec=flood_vec_dif; clear flood_vec_dif
           
           %[rrr,xr,yr] = GRIDobj2mat(A_quot);        
   %6.7 calculate the flood heigth at each cross section point SP
   
   %SW_WO.xyz: The elevation at the swath point crosssection centers, in the middle of the river
   %SO.strod: The strahler stream order at the swath points
   %flood_vec: The terrain heigth in comparison to middle of the river
   
   %rating curve returns the flood heigth in the river based on the rating curve parameters, the weightobject SW_WO which links to an inundation event,
   %the strahler stream order SO at that specific point and the elevation at the crosssection points (flood_vec)
   
   for t=1:length(flood_vec)
       for j=1:length(flood_vec{1,t}(1,:))
           for n=1:length(flood_vec{1,t}(:,1))
               %call rating curves specific to streamorder SO.strod{t}(j)(calibration step)
               SP.value{t}(n,j)= rating_curve(SW_WO.xyz{1,t}(j),SO.strod{t}(j))-flood_vec{1,t}(n,j);
           end
       end
       display(sprintf('stream %d of %d is calculated',t,length(flood_vec)))
   end                
   %lat,lon
   SP.lon=SW.X;SP.lat=SW.Y;
   clear A_event A_quot
     
   if strcmp(parameter.remote_centroid_cleanup,'on')
       SP=flood_remote_centroids_clean(SP,SW,1);
       display('remote centroid clean sucessful')
   end
   
   %6.8 create the hazard
   hazard{i}=flood_hazard_create_single(SP,100,0,0);
   display(sprintf('flood_hazard return period number %d successfully created out of %d return periods',i,length(hazard)))
   
   %6.9 clean all not onland centroids
   hazard(i)=climada_fl_onland(hazard(i));
   display('not onland centroids sucessfull cleaned')
   
   if i ==1;is = etime(clock,s);esttime = is*length(WO_obj.returnp);end
       if num2str(esttime-etime(clock,s)&amplt60)
           h = waitbar(i/length(WO_obj.returnp),h,['remaining time =',num2str(esttime-etime(clock,s),'%4.1f'),'sec']);
       else
           h = waitbar(i/length(WO_obj.returnp),h,['remaining time =',num2str(esttime-etime(clock,s)/60,'%4.0f'),'min']);
       end
       
nd
ry close(h);catch;end
fill the hazard struct, combine single event hazards
azard=flood_hazard_create(hazard,WO_obj);
%
 %plotting
single hazard plotting:
event=1;plotclr(hazard{1,event}.lon,hazard{1,event}.lat,hazard{1,event}.value,'',1,1)
  hold on
 for b=1:1%5%length(SW.lat)
     for m=1:length(SP.lat{1,b})
         plotclr(SP.lon{1,b}(:,m),SP.lat{1,b}(:,m),SP.value{1,b}(:,m),'','',1);
         %plotclr(SP.lat{1,b}(:,m),SP.lon{1,b}(:,m),flood_vec{1,b}(:,m),'','',1)
         %;axis ij
         event=10;plotclr(hazard{1,event}.lon,hazard{1,event}.lat,hazard{1,event}.value,'',1,1)
          m
     end
 b
 end 
%
swiss_rain
swiss_alps_precip
%plot
   %show the results
     imagesc(W)                                                                 
     imagesc(A)
     imagesc(A_normal)
     imagesc(A_max)
     imagesc(A_quot)
     imagesc(A_min)
     imagesc(A_event)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_flood_module_ANZ.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_flood_plot">
<H2>climada_flood_plot</H2></A>
climada_flood_plot
options to plot different floodmodel attributes
plot the DEM
plot the river network
lot(S)
plot the rivernetwork elevation profile
lotdz(S(1),DEM_2)
plot single river elevation profiles based on
igure(3);plot(SW.xyz{1,7})
plot single river original elevation profiles based on
igure(3);plot(SW.zd0{1,7}(:,1))
plot the strahler stream order
igure(3); 
plot single swathobj crosssection parts
=37;figure(2)
or  m=3150:3350 %m=3200:3300;
   plotclr(SP.lat{1,b}(:,m),SP.lon{1,b}(:,m),SP.value{1,b}(:,m),'',5,1);
   m
nd
xis ij
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_flood_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_grid2array">
<H2>climada_grid2array</H2></A>
<font color="blue">function [data, x, y] = climada_grid2array(data_grid, x_vector, y_vector) </font>
 climada
 MODULE:
   flood
 NAME:
   climada_grid2array
 PURPOSE:
   Restructure gridded data into singleton arrays. For consistency with
   imagesc, the first index in data_grid corresponds to the x coords,
   while the second index corresponds to the y coords. Used in
   climada_read_srtm_DEM, read_APHRO_MA_V1101 and climada_rf_hazard_set
 CALLING SEQUENCE:
 EXAMPLE:
 INPUTS:
   data_grid:  Gridded data  
 OPTIONAL INPUT PARAMETERS:
   x_vector:   Monotonically in/decreasing vector defining the x values of
               each of the columns of the data grid. If y_vector is left
               empty, x_vector can also be a vector of size 4, defining
               the corners of the grid as [min(x) max(x) min(y) max(y)]
   y_vector:   Monotonically in/decreasing vector defining the x values of
               each of the rows of the data grid.
 OUTPUTS:
   data:       The original data structured as a singleton array 
   x:          The x data structured as singleton array, same length as data array
   y:          The y data structured as singleton array, same length as data array
 MODIFICATION HISTORY:
 Gilles Stassen 20150107
 Gilles Stassen 20150224 major cleanup
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_grid2array.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_encode_distance">
<H2>climada_hazard_encode_distance</H2></A>
<font color="blue">function hazard = climada_hazard_encode_distance(hazard,entityORassetsORcentroids,cutoff) </font>
 climada
 MODULE:
   flood
 NAME:
   climada_hazard_encode_distance
 PURPOSE:
   This is a function that is usually called from climada_ls_hazard_set.
   Convert landslide hazard intensity (landslide depth(m))
   into distance between an asset and the nearest centroid with nonzero
   intensity. Distance is transformed into intensity in the form of (y = mx+b), 
   which means increasing intensity with increasing damage, 
   intensity = 1 - 1/cutoff * distance_m
   Minimum distance is set to  1m, which translates into the maximum intensity 1.
   The lat/lon coordinates of the hazard are overwritten by the asset
   lat/lon coordinates
   A default distance cutoff, when it can be assumed that no asset is
   affected anymore is introduced at 1000 m.
 CALLING SEQUENCE:
   hazard = hazard_distance_convert(hazard,entity,cutoff)
 EXAMPLE:
   hazard = hazard_distance_convert(hazard,entity,250)
 INPUTS:
   hazard: landslide hazard structure, intensity given as meters soildepth
   entity: climada entity structure, with .assets.lon and .assets.lat
 OPTIONAL INPUT PARAMETERS:
   cutoff: default 1000m, can be set to other value
 OUTPUTS:
   hazard: a climada structure with lat/lon that equal the entity.assets.lat/lon
           and intensity as 1-1/cutoff*distance_m (-)
 MODIFICATION HISTORY:
 Jacob Anz, j.anz@gmx.net, 20150708, initial
 Lea Mueller, muellele@gmail.com, 20150713, intensity as 1-1/cutoff*distance_m instead of distance
 Gilles Stassen, gillesstassen@hotmail.com, 20150803, faster (~30x) alternative to knnsearch; argin entity -&ampgt entityORassetsORcentroids
 Gilles Stassen, 20150805, elevation cutoff. Entity points higher in elevation than land slide excluded
 Lea Mueller, muellele@gmail.com, 20150915, bugfix when calculate distance_m from intensity
 Lea Mueller, muellele@gmail.com, 20151106, move to flood
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_hazard_encode_distance.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_binary_plot">
<H2>climada_ls_hazard_binary_plot</H2></A>
<font color="blue">function fig = climada_ls_hazard_binary_plot(hazard) </font>
 climada plot ls binary hazard
 MODULE:
   flood
 NAME:
   climada_ls_hazard_binary_plot
 PURPOSE:
   This is a function that is usually called from climada_ls_hazard_set.
   Plot binary landslide hazard, all events on one map
 PREVIOUS STEP:
   hazard_binary = climada_ls_hazard_set_binary(centroids)
 NEXT STEP:
   hazard = climada_hazard_encode_distance(hazard,centroids,cutoff);
 CALLING SEQUENCE:
   fig = climada_ls_hazard_binary_plot(hazard)
 EXAMPLE:
   fig = climada_ls_hazard_binary_plot;
 INPUTS:
   hazard:  a climada hazard stucture with binary landslide
   information (.intensity is either 1 or 0)
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   fig: handle of map with landslide events
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151124, init
 -
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('hazard', 'var'), hazard = []; end
f isempty(hazard), hazard = climada_hazard_load; end   
        
 visualize binary ls hazard on a map
 ------------------------------
 delete nans if there are any
azard.intensity(isnan(hazard.intensity)) = 0;
xlim = [min(hazard.lon) max(hazard.lon) min(hazard.lat) max(hazard.lat)];
_events = hazard.event_count;
_colors = jet(n_events);
 show a maximum number of events
vent_step = 1;
ax_events_to_show = 100;
f n_events&ampgtmax_events_to_show, event_step = round(n_events/max_events_to_show);end
ig = climada_figuresize(0.5,0.7);
 plot(entity.assets.lon, entity.assets.lat,'.','linewidth',0.2,'markersize',0.8,'color',[255 64 64 ]/255);
old on
egendstr = []; h = []; counter = 0;
or e_i = 1:event_step:n_events
   is_event = logical(hazard.intensity(e_i,:));
   if any(is_event)
       counter = counter+1;
       %hold on; plot3(hazard.lon(is_event), hazard.lat(is_event), ones(sum(is_event))*3000, 'dr','linewidth',2,'markersize',5,'color',[255 64 64 ]/255)
       h(counter) = plot(hazard.lon(is_event), hazard.lat(is_event),'dr','linewidth',2,'markersize',5,'color',n_colors(e_i,:));
       hold on; 
       %plot(polygon_canas.X, polygon_canas.Y, 'b-');
       legendstr{counter} = sprintf('Event %d',e_i);
   end
nd
itlestr = 'LS hazard binary';
ry titlestr = sprintf('%s hazard (%s), %d events, %d',hazard.peril_ID, hazard.units, n_events, hazard.reference_year);end
itle(titlestr); axis(axlim); box on; 
limada_figure_axis_limits_equal_for_lat_lon(axlim); climada_figure_scale_add('',1,1)
egend(h,legendstr,'location','eastoutside')
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_ls_hazard_binary_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_set">
<H2>climada_ls_hazard_set</H2></A>
<font color="blue">function [hazard, centroids, fig] = climada_ls_hazard_set(centroids,n_events,hazard_set_file,... </font>
                                       wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                       n_downstream_cells,focus_area,polygon_correction,random_trigger_condition,...
                                       check_plot)
 Generate a landslide hazard set
 MODULE:
   flood
 NAME:
   climada_ls_hazard_set
 PURPOSE:
   This is a all-in-one function to generate a landslide hazard set. The 
   landslide events are based solely on topographical information 
   (SRTM 90m digital elevation data) and calculates slope and 
    topographical wetness index. We create first a binary hazard,
   encode to distance and plot figures if required.
   invokes 
       - climada_ls_hazard_set_binary
       - climada_hazard_encode_distance
   and for plots
       - climada_ls_hazard_binary_plot
       - climada_map_plot
       - climada_hazard_stats
       - climada_hazard_stats_figure   
 PREVIOUS STEP:
   create centroids, select a rectangle box to create the landslide hazard
   centroids = climada_centroids_elevation_add;
 CALLING SEQUENCE:
   [hazard, centroids, fig] = climada_ls_hazard_set(centroids,n_events,hazard_set_file,...
                                         wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                         n_downstream_cells,focus_area,polygon_correction,random_trigger_condition,...
                                         check_plot)
 EXAMPLE:
   hazard = climada_ls_hazard_set(centroids)
   check_plot = 1;
   [hazard, centroids, fig]  = climada_ls_hazard_set([-89.145 -89.1 13.692 13.727],'','','','','','','','','','',check_plot)
 INPUTS:
   centroids:  a climada centroids stucture (ideally including topographical
   information) or a rectangle to define lon/lat box, if not given, the
   user can select a rectangle by first selecting a country and then drawing
   a rectangle on a map
 OPTIONAL INPUT PARAMETERS:
   n_events: number of events
   hazard_set_file: the name (and path, optional) of the hazard set file
       If no path provided, default path ../data/hazards is used (and name
       can be without extension .mat)
       &ampgt promted for if not given
   wiggle_factor_TWI:    an array, default is 0.35, to modify topographical
                         wetness factor, which is a number between 0 and 1.4
   condition_TWI:        an array, default is 0.95, to define a minimum
                         topographical wetness index, where a landslide occurs
   wiggle_factor_slope:  an array, default is 0.35, to modify the slope factor, 
                         which is a number between 0 and 1
   condition_slope:      an array, default is 0.45, to define a minimum slope
                         where a landslide occurs
   n_downstream_cells:   number of downstream cells where the landslide is extended
   focus_area:           a polygon to define the focus area (with focus_area.lon, focus_area.lat),
                         landslides only in the given area will be filtered 
                         and the other areas are cut out
   polygon_correction:   a polygon to define an area where less landlislides should occur
   random_trigger_condition: a number between 0 and 1, 1 prevents all landslide 
                         in the polygon_correction area, 0 does not inhibit any
                         landlides in the polygon_correction area
   check_plot:          set to 1 if you want to see maps (elevation, slope, hazard, etc)
 OUTPUTS:
   hazard: a climada hazard structure with binary landslide information
       .peril_ID: 'LS'
       .date: the creation date of the set
       .intensity(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i, binary, 1 indicates a landslide, 0 no landslide
       .frequency(event_i): the frequency of each event
       .matrix_density: the density of the sparse array hazard.intensity
       .filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
   centroids: a climada centroids structure with fields
       .lon
       .lat
       .elevation_m, elevation in meters
       .slope_deg, slope in degree
       .TWI, topographical wetness index
       .aspect_deg, spect in degree
   fig: handle of figures (maps with elevation, slope, landslide
        hazard,etc)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151124, init
 -
 init
azard = []; fig = [];
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('centroids', 'var'), centroids = []; end
f ~exist('n_events', 'var'), n_events = []; end
f ~exist('hazard_set_file', 'var'), hazard_set_file = []; end
f ~exist('wiggle_factor', 'var'), wiggle_factor_TWI = []; end
f ~exist('TWI_condition', 'var'), condition_TWI = []; end
f ~exist('wiggle_factor_slope', 'var'), wiggle_factor_slope = []; end
f ~exist('slope_condition', 'var'), condition_slope = []; end
f ~exist('n_downstream_cells', 'var'), n_downstream_cells = []; end
f ~exist('focus_area', 'var'), focus_area = []; end
f ~exist('polygon_correction', 'var'), polygon_correction = []; end
f ~exist('random_trigger_condition', 'var'), random_trigger_condition = []; end
f ~exist('check_plot', 'var'), check_plot = 0; end
 create binary landslide hazard
hazard_binary, centroids]  = climada_ls_hazard_set_binary(centroids,n_events,hazard_set_file,...
                                   wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                   n_downstream_cells,focus_area,polygon_correction,random_trigger_condition);
              
 encode binary hazard to distance, so that we have the distance to
 landslides as intensity
utoff = 1000;
azard = climada_hazard_encode_distance(hazard_binary,centroids,cutoff);
 save hazard
pathname, filename, ext] = fileparts(hazard.filename);
f ~exist(pathname,'dir')
   hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'LSXX_hazard.mat'];
   [filename, pathname] = uiputfile(hazard_set_file, 'Save LS hazard set as:');
   if isequal(filename,0) || isequal(pathname,0)
       return; % cancel
   else
       hazard_set_file = fullfile(pathname,filename);
   end
lse
   filename = [strrep(filename,'binary','') 'distance'];
   hazard_set_file = fullfile(pathname,filename);
nd
printf('Save landslide (LS) hazard set (encoded to distance) as %s\n',hazard_set_file);
ave(hazard_set_file,'hazard')
f check_plot   
   % create landslide binary event map
   fig = climada_ls_hazard_binary_plot(hazard_binary);
   
   % plot centroids with characteristics (elevation, slope, twi, etc)
   fieldname_to_plot = {'elevation_m' 'slope_deg' 'TWI' 'aspect_deg'};
   plot_method = 'plotclr';
   [~, fig_temp] = climada_map_plot(centroids,fieldname_to_plot,plot_method);
   
   % plot hazard statistics
   hazard.orig_years = 1000; % we set the number of years to 1000 to have nice images, but please check if this is suitable
   hazard.frequency = ones(size(hazard.event_ID))*(1./hazard.orig_years);
   
   return_periods = [10 25 50 100 150 200];
   hazard_stats = climada_hazard_stats(hazard,return_periods,0);
   fig_temp_2 = climada_hazard_stats_figure(hazard_stats,return_periods);
  
   % concatenate figure handles
   fig = [fig fig_temp fig_temp_2];
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_ls_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_set_binary">
<H2>climada_ls_hazard_set_binary</H2></A>
<font color="blue">function [hazard, centroids]  = climada_ls_hazard_set_binary(centroids,n_events,hazard_set_file,... </font>
                                   wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                   n_downstream_cells,focus_area,polygon_correction,random_trigger_condition)
 Generate a binary landslide hazard set
 MODULE:
   flood
 NAME:
   climada_ls_hazard_set_binary
 PURPOSE:
   This is a function that is usually called from climada_ls_hazard_set.
   Generate a binary landslide hazard set based solely on topographical
   information (slope and topographical wetness index)
 PREVIOUS STEP:
   centroids = climada_centroids_elevation_add;
 CALLING SEQUENCE:
   hazard = climada_ls_hazard_set_binary(centroids,n_events,hazard_set_file,...
                    wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                    n_downstream_cells,focus_area,polygon_correction,random_trigger_condition)
 EXAMPLE:
   hazard = climada_ls_hazard_set_binary(centroids)
   hazard = climada_ls_hazard_set_binary([-89.145 -89.1 13.692 13.727])
   hazard = climada_ls_hazard_set_binary
 INPUTS:
   centroids:  a climada centroids stucture (ideally including topographical
   information) or a rectangle to define lon/lat box, if not given, the
   user can select a rectangle by first selecting a country and then drawing
   a rectangle on a map
 OPTIONAL INPUT PARAMETERS:
   n_events: number of events
   hazard_set_file: the name (and path, optional) of the hazard set file
       If no path provided, default path ../data/hazards is used (and name
       can be without extension .mat)
       &ampgt promted for if not given
   wiggle_factor_TWI:    an array, default is 0.35, to modify topographical
                         wetness factor, which is a number between 0 and 1.4
   condition_TWI:        an array, default is 0.95, to define a minimum
                         topographical wetness index, where a landslide occurs
   wiggle_factor_slope:  an array, default is 0.35, to modify the slope factor, 
                         which is a number between 0 and 1
   condition_slope:      an array, default is 0.45, to define a minimum slope
                         where a landslide occurs
   n_downstream_cells:   number of downstream cells where the landslide is extended
   focus_area:           a polygon to define the focus area (with focus_area.lon, focus_area.lat),
                         landslides only in the given area will be filtered 
                         and the other areas are cut out
   polygon_correction:   a polygon to define an area where less landlislides should occur
   random_trigger_condition: a number between 0 and 1, 1 prevents all landslide 
                         in the polygon_correction area, 0 does not inhibit any
                         landlides in the polygon_correction area
 OUTPUTS:
   hazard: a climada hazard structure with binary landslide information
       .peril_ID: 'LS'
       .date: the creation date of the set
       .intensity(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i, binary, 1 indicates a landslide, 0 no landslide
       .frequency(event_i): the frequency of each event
       .matrix_density: the density of the sparse array hazard.intensity
       .filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150911, init
 Lea Mueller, muellele@gmail.com, 20150920, add polygon_correction with a random trigger condition, to reduce landslides in a given polygon
 Lea Mueller, muellele@gmail.com, 20151124, return centroids as output, use climada_hazard_focus_area
 Lea Mueller, muellele@gmail.com, 20151124, call from climada_ls_hazard_set
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_TWI_calc from centroids_TWI
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_hazard_crop from climada_hazard_focus_area
 -
azard = []; % init
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('centroids', 'var'), centroids = []; end
f ~exist('n_events', 'var'), n_events = []; end
f ~exist('hazard_set_file', 'var'), hazard_set_file = []; end
f ~exist('wiggle_factor', 'var'), wiggle_factor_TWI = []; end
f ~exist('TWI_condition', 'var'), condition_TWI = []; end
f ~exist('wiggle_factor_slope', 'var'), wiggle_factor_slope = []; end
f ~exist('slope_condition', 'var'), condition_slope = []; end
f ~exist('n_downstream_cells', 'var'), n_downstream_cells = []; end
f ~exist('focus_area', 'var'), focus_area = []; end
f ~exist('polygon_correction', 'var'), polygon_correction = []; end
f ~exist('random_trigger_condition', 'var'), random_trigger_condition = []; end
f isnumeric(centroids) &amp&amp numel(centroids) == 4
   % we have a box that defines where centroids should be created on 90m
   % resolution (given by SRTM)
   % return
   centroids = climada_centroids_elevation_add('',centroids);
nd
f isempty(centroids) 
   % create centroids by asking user for a country and to define a
   % rectangle region on the figure
   % return
   centroids = climada_centroids_elevation_add('','');
nd
 PARAMETERS
f isempty(n_events); n_events = 100; end
f isempty(wiggle_factor_TWI); wiggle_factor_TWI = 0.35; end
f isempty(condition_TWI); condition_TWI = 0.95; end
f isempty(wiggle_factor_slope); wiggle_factor_slope = 0.2; end
f isempty(condition_slope); condition_slope = 0.45; end
f isempty(n_downstream_cells); n_downstream_cells = 5; end
f isempty(random_trigger_condition); random_trigger_condition = 0; end
 prompt for hazard_set_file if not given
f isempty(hazard_set_file) % local GUI
   hazard_set_file      = [climada_global.data_dir filesep 'hazards' filesep 'LSXX_hazard_binary.mat'];
   [filename, pathname] = uiputfile(hazard_set_file, 'Save LS (binary) hazard set as:');
   if isequal(filename,0) || isequal(pathname,0)
       return; % cancel
   else
       hazard_set_file = fullfile(pathname,filename);
   end
nd
 complete path, if missing
fP,fN,fE] = fileparts(hazard_set_file);
f isempty(fP),hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep fN fE];end
% load template for hazard-structure
azard_example_file = [climada_global.data_dir filesep 'hazards' filesep 'TCNA_today_small.mat'];
f exist(hazard_example_file,'file')
   load(hazard_example_file)
lse
   fprintf('No hazard example found to be loaded. \n')
nd
azard_ex = hazard;
 overwrite template hazrd with actual information
azard.lon = centroids.lon;
azard.lat = centroids.lat;
azard.centroid_ID = 1:numel(hazard.lon);
azard.peril_ID         = 'LS';
azard.orig_years       = 10000;
azard.orig_event_count = n_events;
azard.event_count      = n_events;
azard.event_ID         = 1:n_events;
azard.orig_event_flag  = ones(1,n_events);
azard.yyyy             = ones(1,n_events);
azard.mm               = ones(1,n_events);
azard.dd               = ones(1,n_events);
azard.intensity        = sparse(n_events,numel(hazard.lon));
azard.name             = cell(1,n_events);
azard.frequency        = ones(1,n_events)/hazard.orig_years;
azard.comment          = centroids.comment;
azard.date             = datestr(now);
azard.units            = 'binary';
azard.orig_yearset     = [];
azard.filename         = hazard_set_file;
azard.matrix_density   =  0.01; % estimate
 n_centroids = length(centroids.centroid_ID);
f ~isfield(centroids,'slope_deg')
   fprintf('Add topographical characteristics to the centroids, based on elevation\n')
   centroids = climada_centroids_TWI_calc(centroids);
nd
 calculate slope_factor as cos(slope)/sin(slope)
lope_factor = 1./(cosd(centroids.slope_deg) ./ sind(centroids.slope_deg));
lope_factor(isinf(slope_factor)) = 0;
lope_factor(slope_factor&ampgt0.55) = 0.6;
f ~isfield(centroids,'slope_factor')
   centroids.slope_factor = slope_factor;
nd
 normalize TWI
f ~isfield(centroids,'TWI_norm')
   % TWI_norm = centroids.TWI/10;
   % TWI_norm(TWI_norm&ampgt0.85) = 0.85;
   TWI_norm = centroids.TWI/10;
   TWI_norm(isnan(TWI_norm)) = 0;
   centroids.TWI_norm = TWI_norm;
nd
 % slope factor
 titlestr = 'Slope factor (-)';
 miv = 0;
 mav = 0.6;
 fig = climada_figuresize(0.5,0.6);
 plotclr(centroids.lon, centroids.lat, centroids.slope_factor, marker,markersize,cbar_on,miv,mav);
 title(titlestr); axis(axlim); box on; climada_figure_scale_add('',7,1)
 pdf_filename = sprintf('LS_slope_factor.pdf');
 print(fig,'-dpdf',[ls_dir pdf_filename])
 
 % TWI norm
 titlestr = 'TWI normalised';
 miv = 0;
 mav = 1;
 fig = climada_figuresize(0.5,0.6);
 plotclr(centroids.lon, centroids.lat, centroids.TWI_norm, marker,markersize,cbar_on,miv,mav);
 title(titlestr); axis(axlim); box on; climada_figure_scale_add('',7,1)
 pdf_filename = sprintf('LS_TWI_normalised.pdf');
 print(fig,'-dpdf',[ls_dir pdf_filename])
f ~isempty(polygon_correction)
   lon_lat_polygon = climada_concatenate_lon_lat(polygon_correction.lon,polygon_correction.lat);
   lon_lat = climada_concatenate_lon_lat(centroids.lon,centroids.lat);
   needs_correction = inpoly(lon_lat,lon_lat_polygon);
   %sum(needs_correction)
   needs_correction = find(needs_correction);
nd
 create TWI wiggle as the sum of TWI_norm + TWI_delta
 create slope wiggle as the sum of slope_factor + slope_delta
 TWI_wiggle = zeros(size(hazard.intensity)); %init
 slope_wiggle = zeros(size(hazard.intensity)); %init
elta_TWI = rand(size(hazard.intensity)) * wiggle_factor_TWI;
elta_slope = rand(size(hazard.intensity)) * wiggle_factor_slope;
or e_i = 1:n_events
   wiggle_TWI = centroids.TWI_norm + delta_TWI(e_i,:);
   wiggle_slope = centroids.slope_factor + delta_slope(e_i,:);
       
   % check where landslides occur
   ls_occurence(e_i,:) = wiggle_TWI&ampgtcondition_TWI &amp wiggle_slope&ampgtcondition_slope ;
   
   if ~isempty(polygon_correction)
       random_trigger = rand(numel(needs_correction),1);
       random_trigger(random_trigger&ampgtrandom_trigger_condition) = 1;
       random_trigger(random_trigger&amplt=random_trigger_condition) = 0;
       not_triggered = needs_correction(~random_trigger);
       ls_occurence(e_i,not_triggered) = 0;
   end
   
nd
 expand landslides to following n_cells downstream
f n_downstream_cells&ampgt1
   if ~isfield(centroids,'sink_ID_10')
       centroids = climada_flow_find(centroids);
   end
   if n_downstream_cells&ampgt10
       n_downstream_cells = 10;
       fprintf('Maximum numbers of downstream cells is 10.\n')
   end
   
   msgstr   = sprintf('Expand landslide to %d downstream cells for %i events ... ',n_downstream_cells,n_events);
   mod_step = 10; % first time estimate after 10 assets, then every 100
   if climada_global.waitbar
       fprintf('%s (updating waitbar with estimation of time remaining every 50th event)\n',msgstr);
       h        = waitbar(0,msgstr);
       set(h,'Name','Expand landslide to ownstream cells');
   else
       fprintf('%s (waitbar suppressed)\n',msgstr);
       format_str='%s';
   end
   
   % loop over all events
   for e_i = 1:n_events
       is_event = ls_occurence(e_i,:);
       centroid_list = find(is_event);
       
       % loop over centroids, that are sliding
       for i = centroid_list
           selected_sinks = centroids.sink_ID_10(i,:);
           % take only a given number of downstream cells
           if numel(selected_sinks)&ampgtn_downstream_cells
                selected_sinks = selected_sinks(1:n_downstream_cells);
           end
           if ~isempty(selected_sinks)
               is_sink = []; %init
               for s_i = 1:numel(selected_sinks)
                   if selected_sinks(s_i)&ampgt0
                       is_sink(s_i) = find(selected_sinks(s_i) == centroids.centroid_ID);
                   end
               end
               %is_sink = ismember(centroids.centroid_ID,selected_sinks);
               ls_occurence(e_i,is_sink) = ones(1,numel(is_sink));
           end
       end
       
       % the progress management
       if mod(e_i,mod_step)==0
           mod_step          = 50;
           msgstr = sprintf('%i/%i events',e_i,n_events);
           if climada_global.waitbar
               waitbar(e_i/n_events,h,msgstr); % update waitbar
           else
               fprintf(format_str,msgstr); % write progress to stdout
               format_str=[repmat('\b',1,length(msgstr)) '%s']; % back to begin of line
           end
       end
   
   end
   ls_occurence = logical(ls_occurence);
nd
 create sparse matrix
azard.intensity = sparse(ls_occurence);
f climada_global.waitbar
   close(h) % dispose waitbar
lse
   fprintf(format_str,''); % move carriage to begin of line
nd
 restrict hazard landslides to a given focus area (delete locations outside this area, .lon, .lat, .intensity)
f ~isempty(focus_area)
   fprintf('Filter out landslides in the given focus area.\n')
   hazard = climada_hazard_crop(hazard, focus_area);
   
     if isfield(focus_area,'lon') &amp&amp isfield(focus_area,'lat')
         polygon = climada_concatenate_lon_lat(focus_area(1).lon, focus_area(1).lat);
         
     elseif isfield(focus_area,'X') &amp&amp isfield(focus_area,'Y')
         polygon = climada_concatenate_lon_lat(focus_area(1).X, focus_area(1).Y);
         
     elseif isnumeric(focus_area) % it is already formatted as a polygon
         [i, j] = size(focus_area);
         if j == 2 &amp&amp i&ampgt2
             polygon = focus_area;
         end
     else
         fprintf('Please check the input of the focus area.\n')
         return
     end
     hazard_lon_lat = climada_concatenate_lon_lat(hazard.lon, hazard.lat);
     is_inside = inpoly(hazard_lon_lat,polygon);
     if any(is_inside)
         hazard.lon = hazard.lon(is_inside);
         hazard.lat = hazard.lat(is_inside);
         hazard.centroid_ID = 1:numel(hazard.lon);
         hazard.intensity = hazard.intensity(:,is_inside);
     end
nd
printf('Save landslide (LS) hazard set (binary) as %s\n',hazard_set_file);
ave(hazard_set_file,'hazard')
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_ls_hazard_set_binary.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_read_srtm_DEM">
<H2>climada_read_srtm_DEM</H2></A>
<font color="blue">function [DEM, centroids] = climada_read_srtm_DEM(srtm_dir, centroidsORcountry, DEM_save_file, smooth, check_plot) </font>
 climada
 MODULE:
   barisal_demo
 NAME:
   climada_read_srtm_DEM
 PURPOSE:
   Read the digital elevation model data from the files in an existing
   srtm directory. Data can be downloaded from http://srtm.csi.cgiar.org/SELECTION/inputCoord.asp
 CALLING SEQUENCE:
   DEM = climada_read_srtm_DEM(srtm_dir, centroids, DEM_save_file, smooth, check_plot)
 EXAMPLE:
   DEM = climada_read_srtm_DEM(srtm_dir,[],[],[],1)
   DEM = climada_read_srtm_DEM
   [DEM, centroids] = climada_read_srtm_DEM(srtm_dir,[min_lon max_lon min_lat max_lat], DEM_save_file, 4,1)
 INPUTS:
   srtm_dir:   The directory of an srtm data tile folder, containing at
               least a .hdr and a .tif file. Can also be set to 'DL' which
               will initiate automatic download from SRTM website
               according to the centroid_rect given as input.
 OPTIONAL INPUT PARAMETERS:
   centroids:  If centroids are provided as an input, the DEM will contain
               elevation data sampled at the location of centroids, and
               hence will have an extra field .centroid_ID. The extra
               field is required for tc_surge_hazard_create if you wish to
               provide your own topography data (e.g. srtm).
               If this input is left empty , a
               centroids struct will be generated at the same resolution
               as the DEM.
               If set to a 4-element vector (centroids_rect), these 4
               points will define the area of interest, which is
               subsequently cropped out of the DEM.
               NOTE:   It is only sensible to provide a centroids struct
               as input if its resolution is significantly lower than that
               of the DEM, otherwise, it is much faster to generate
               centroids directly from the DEM.
   smooth:     Can either be set to an integer N (smooth by default filter
               specified by a matrix size NxN with values 1/N^2) or a
               smoothing filter. Default = [] (no smoothing).
   check plot: Specify whether to plot a relief of the DEM, default = 0
 OUTPUTS:
   DEM:        Struct containing information of the digital elevation
               model at full 90m resolution, with fields:
               .elevation_m:   Elevation data
               .lat:           Latitude
               .lon:           Longitude
               .centroid_ID:   Only if centroids provided as input or if
                               centroids input set to 1.
   centroids:  Climada centroids struct with fields:
               .elevation_m:   Elevation data
               .lat:           Latitude
               .lon:           Longitude
               .centroid_ID:   Only if centroids provided as input or if
                               centroids input set to 1.
               .onLand:        Set to 0 if .elevation_m &amplt0, 1 otherwise
               .admin0_name    Country name
               .admin0_ISO3    ISO 3 country code
 MODIFICATION HISTORY:
   Gilles Stassen 20150107
   Gilles Stassen 20150224     fixed some bugs in the plotting routines
                               and added messages to warn of DEM edges
   Gilles Stassen 20150225     cleanup and added automatic download and
                               unzip feature

   Jacob Anz      20150610     fixed the url DEM source

View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/climada_read_srtm_DEM.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="discharge_relation">
<H2>discharge_relation</H2></A>
discharge curves
variable declaration
   %h = river flood heigth for certain q values
   %h_norm= river base level heigth
   %Cr = factor
   %b = factor
   %base relation
   %bp_depth= breakpoint depth (specific to topography,landscape and human impact
   bp_depth=0.5;
          q=1:50;
          Cr=1;
          b=1;
          h=(Cr*log(q).^b);
          
case 5
; 
convert Accumulation object to vector [ttest,tX,tY] = GRIDobj2mat(A_quot2);
introduce rating curves
or i=1:length(flood_vec)
       flood_vec{p}(:,i) % ist die Differenz Hhe des DEM und DEM Hhe Fluss entlang der Querlinie
       %h(SW.acc(i))           Fluthhe, SW.acc(i) ist der Accum Factor auf dem Flusspunkt
       %value(i)=h(SW.acc(i))-bp_depth -flood_vec_dif{p}(:,i)          Hhe Fluss incl. Flut duch Acc - Hhe Terrain = Fluthhe
                                                    %Wenn negativ dann lsche es.
nd
create hazard struct 
or t=1:length(flood_vec)
   for j=1:length(flood_vec{1,t}(1,:))
       for i=1:length(flood_vec{1,t}(:,1))
           %function should be seperate
           value{t}(i,j)= Cr*log(SW2.xyz{1,t}(j)).^b-bp_depth -flood_vec{1,t}(i,j);
       end
   end
nd
plot new hazard struct
old on
or b=1:1%length(SW.X)
   for m=1:length(SW.X{1,b})
       plotclr(SW.X{1,b}(:,m),SW.Y{1,b}(:,m),value{1,b}(:,m));
   end

nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/discharge_relation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_calibrate">
<H2>flood_calibrate</H2></A>
<font color="blue">function max_ind_rp=flood_calibrate(SW_WO,max_ind_rp,i) </font>
floodmodel calibration code
find the maximum values acc values
or f=1:length(SW_WO.xyz); max_ind(f)=max(SW_WO.xyz{1,f});end
ax_ind_rp(i,1:length(max_ind))=max_ind;
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/flood_calibrate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_hazard_create">
<H2>flood_hazard_create</H2></A>
<font color="blue">function hazard=flood_hazard_create(hazard,WO_obj) </font>
 climada
 MODULE:
   flood
 NAME:
   flood_hazard_create
 PURPOSE:
   combining the single event(return period) hazards into one combined
   hazard
 EXAMPLE:
   hazard{i}=flood_hazard_create_single(SP,100,0,0);

   INPUTS:
   hazard:     A single event hazard struct, containing lon, lat and intensity 
   WO_obj:     A weigth object struct containing the return periods

 OUTPUTS:
   hazard:     A hazard struct, containing different frequencies
               according to the return periods

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

fill the hazard struct
azard_final.lon=hazard{1}.lon;
azard_final.lat=hazard{1}.lat;
azard_final.peril_ID='FL';
azard_final.date=datestr(now);
azard_final.event_count=length(hazard);
the frequency is set as 1/years return period
azard_final.frequency= 1./(WO_obj.returnp);
delet the control event, last entry
azard_final.frequency(length(WO_obj.returnp))=[];
combine the single return period hazards;
or i=1:length(hazard)-1
   intensity(i,:)=hazard{i}.value;
nd
azard_final.intensity=sparse(intensity);
   
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/flood_hazard_create.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_hazard_create_single">
<H2>flood_hazard_create_single</H2></A>
<font color="blue">function hazard=flood_hazard_create_single(SP,cutoff_top,cutoff_bottom,plot) </font>
 climada
 MODULE:
   flood
 NAME:
   flood_hazard_create_single
 PURPOSE:
   reshaping the crossection struct into a .lat, .lon, .value vector
 EXAMPLE:
   hazard{i}=flood_hazard_create_single(SP,100,0,0);

   INPUTS:
   SP:         A crossection struct
   cutoff_top: The maximum value to reach
   cutoff_bottom: The minimum value to reach
   plot:       Option to plot the hazard

 OUTPUTS:
   hazard:      A hazard struct, containing lon, lat and intensity 

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

f ~exist('plot','var'),plot=0;end
   
create an hazard vector
azard.lon=[];hazard.lat=[];hazard.value=[];
or i=1:length(SP.lon)
       vec.lon=reshape(SP.lon{1,i},1,[]);vec.lat=reshape(SP.lat{1,i},1,[]);vec.value=reshape(SP.value{1,i},1,[]);
       hazard.lon=[hazard.lon vec.lon];
       hazard.lat=[hazard.lat vec.lat];
       hazard.value=[hazard.value vec.value];
       clear vec
nd
hazard cutoff
low value cutoff
f exist('cutoff_bottom','var')
   cutoff=find(hazard.value&ampltcutoff_bottom);
   %hazard.lon(cutoff)=[];hazard.lat(cutoff)=[];
   hazard.value(cutoff)=0;
   clear cutoff
nd
high value cutoff
f exist('cutoff_top','var')
   cutoff=find(hazard.value&ampgtcutoff_top);
   hazard.lon(cutoff)=0;%hazard.lat(cutoff)=[];hazard.value(cutoff)=[];
   clear cutoff
nd
plot the hazard
f plot==1; 
   if length(hazard.lon)&ampgt1
   plotclr(hazard.lon,hazard.lat,hazard.value,'','',1)
   axis equal
   else
       display('hazard has no entries');
   end
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/flood_hazard_create_single.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_innund_estim">
<H2>flood_innund_estim</H2></A>
<font color="blue">function [ hazard ] = flood_innund_estim(pack,delta) </font>
UNTITLED2 Summary of this function goes here
   Detailed explanation goes here
delta=2;
lot=[];
varibale initialisation
   hazard_comb.vec_x=[];
   hazard_comb.vec_y=[];
   hazard_comb.vec_z=[];
   
   hazard.vec_x=[];
   hazard.vec_y=[];
   hazard.vec_z=[];
calculate the different tiles
or m=1:length(pack)
   SW=pack{m};   

   for p=1:length(SW.xyz)
            for i=1:numel(SW.xyz{1,p})
               flood_vec{p}(:,i)=(SW.xyz{1,p}(i)+delta)&ampgtSW.Z{1,p}(:,i);
            end
   end
   
     %run on heigth level difference, future implementation
     for p=1:length(SW.xyz)
              for i=1:numel(SW.xyz{1,p})
                 flood_vec_dif{p}(:,i)=SW.xyz{1,p}(i)-SW.Z{1,p}(:,i);
              end
     end
   
   %create a hazard vector/ matrix
   for j=1:length(SW.X)
       stream_vec_x=SW.X{1,j}(:,1);
       stream_vec_y=SW.Y{1,j}(:,1);
       stream_vec_z=flood_vec{1,j}(:,1);
       for i=2:length(SW.X{1,j}(1,:))
           stream_vec_x=[stream_vec_x;SW.X{1,j}(:,i)];
           stream_vec_y=[stream_vec_y;SW.Y{1,j}(:,i)];
           stream_vec_z=[stream_vec_z;flood_vec{1,j}(:,i)];
       end
      hazard.vec_x= [stream_vec_x;hazard.vec_x];
      hazard.vec_y= [stream_vec_y;hazard.vec_y];
      hazard.vec_z= [stream_vec_z;hazard.vec_z];
      clear stream_vec_x stream_vec_y stream_vec_z
   end
 
   %combine the hazard vectors
   hazard_comb.vec_x=[hazard_comb.vec_x;hazard.vec_x];
   hazard_comb.vec_y=[hazard_comb.vec_y;hazard.vec_y];
   hazard_comb.vec_z=[hazard_comb.vec_z;hazard.vec_z];
   
nd
f exist(plot)
    plotclr(hazard.vec_x,hazard.vec_y,hazard.vec_z);
nd
 
azard=hazard_comb;
   
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/flood_innund_estim.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_remote_centroids_clean">
<H2>flood_remote_centroids_clean</H2></A>
<font color="blue">function SP=flood_remote_centroids_clean(SP,SW,mode) </font>
 climada
 MODULE:
   flood
 NAME:
   flood_remote_centroids_clean
 PURPOSE:
  Applies vector geometrics to cut overlaying crosssections
 EXAMPLE:
   SP=flood_remote_centroids_clean(SP,SW,1);

   INPUTS:
   SP:         A crossection struct 
   SW:         A swathobject crosssetion struct
   mode:       Defines if the check is done profound (0) looking 
               at much earlier (25,50) so more distant crosssections 

 OUTPUTS:
   SP:         A cleaned SP crosssection struct

 Comment:      Still not satisfying results, some crosssection overlays are
               not recognized 

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

Clean the flood points, whose inner neighbour has no flooding anymore
Goal is, to delete flood points,which have a flood level, but lay behind a
damm or mountain etc.
f ~exist('mode','var');mode=0;end 
cleanup_level, is the value below which all outside centroids with a lower flood depth are st to 0.
leanup_level=0;
utoff_dist_length=31;
the crossection vector is always uneven
nner_river_line=((length(SP.lon{1,1}(:,1))-1)/2)+1;
nner_river_line_width=(length(SP.lon{1,1}(:,1))-1)/2;
or b=1:length(SP.value)
   for m=1:length(SP.value{1,b}(1,:))
       trigger_up=0;trigger_down=0;
       for l=1:inner_river_line_width
           %up 
           if SP.value{1,b}(inner_river_line+l,m)&amplt=cleanup_level;
               trigger_up=1;
           end
           if trigger_up==1;
               SP.value{1,b}(inner_river_line+l,m)=0;
           end            
           
           %down
           if SP.value{1,b}(inner_river_line-l,m)&amplt=cleanup_level;   
               trigger_down=1;
           end
           if trigger_down==1;                
               SP.value{1,b}(inner_river_line-l,m)=0;
           end
       end
   end
nd
f mode==1
   %overlay of crosssections:
   %get the points
   %go back 5, 25 and 50 crosssections
   %loop over all stream
    for i=1:length(SW.Y) 
        %i=37;
    %loop over all crosssections
    if cutoff_dist_length &amplt length(SW.Y{1,i}(1,:))
    for index=cutoff_dist_length:length(SW.Y{1,i}(1,:))
        %cutoff_dist_length=30;
           %index=3290;
           
        m2=index;
        m1=index-30;         
       %m1=3240;
       %m2=3290;
       %vector 1
       x1=SW.X{1,i}(1,m1);
       x2=SW.X{1,i}(end,m1);
       y1=SW.Y{1,i}(1,m1);
       y2=SW.Y{1,i}(end,m1);
       %vector 2
       x3=SW.X{1,i}(1,m2);
       x4=SW.X{1,i}(end,m2);
       y3=SW.Y{1,i}(1,m2);
       y4=SW.Y{1,i}(end,m2);
       %vector analysis and construction
       % xs=x1+s(x2-x1);ys=y1+s(y2-y1);
       % xt=x3+t(x4-x3);yt=y3+t(y4-y3);
       %DGL of from
       %((x3-x1)+t(x4-x3))/(x2-x1)=((y3-y1)+t(y4-y3))/(x2-x1);
       t=((x3-x1)/(x2-x1)+(y1-y3)/(y2-y1))/((y4-y3)/(y2-y1)+(x3-x4)/(x2-x1));
       x_cross=x3+t*(x4-x3);y_cross=y3+t*(y4-y3); %based on second line
       %for t_lim &amplt t delete entries in Swathobj crosssection
       %check the different option that can occure
       for j=1:length(SW.X{1,i}(:,1))
           %left side of crosssection
           if (t&ampgt0 &amp&amp t&amplt0.5) &amp&amp (x3&ampltSW.X{1,i}(j,m2) &amp&amp SW.X{1,i}(j,m2)&ampltx_cross) &amp&amp (SW.Y{1,i}(j,m2)&ampgty_cross &amp&amp SW.Y{1,i}(j,m2)&amplty3) 
               SP.value{1,i}(j,m2)=0;
           end
           
           %right side of crosssection
           if (t&ampgt0.5 &amp&amp t&amplt1) &amp&amp (x4&ampgtSW.X{1,i}(j,m2) &amp&amp SW.X{1,i}(j,m2)&ampgtx_cross) &amp&amp (SW.Y{1,i}(j,m2)&amplty_cross &amp&amp SW.Y{1,i}(j,m2)&ampgty4) 
               SP.value{1,i}(j,m2)=0;
           end
                       
       end
       x_cross=NaN;y_cross=NaN;  
    end
    end
    end
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/flood_remote_centroids_clean.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_shape_write">
<H2>flood_shape_write</H2></A>
flood_shape_write
MS] = SWATHobj2mapstruct(SW,'lines');
hapewrite(MS,['test_shape' '.shp'])
plot
igure, imageschs(DEM), hold on
apshow(MS)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/flood_shape_write.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="rain_statistics">
<H2>rain_statistics</H2></A>
<font color="blue">function [WO_obj]=rain_statistics(precip,DEM) </font>
 climada
 MODULE:
   flood
 NAME:
   rain_statistics
 PURPOSE:
   generating higher return periods from the existing rainfall data set
 EXAMPLE:
   [WO_obj]=rain_statistics(precip,DEM);

   INPUTS:
   precip:         A precipitation event set
   DEM:            The digital elevation model

 OUTPUTS:
   WO_obj:      A weight object struct containing, lon, lat, returnperiods
                and a grid matrix with the intensity

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

Derive the weightobject from rain statistics
Input: DEM,precip
get the max rainfall
daily rainfall values
set a maximum rainfall value for the region that extrapolation for higher
return periods (150,250, 500 etc. can exceed)
ax_rain_cap=500;
return periods
py_axis=[1,2,5,10,25,50,100,150,250,500];
isplay('calculating return periods:')
isplay(sprintf('%d\t',rpy_axis))
or i=1:length(precip.precip(:,1))
N,centers] = hist(precip.precip(i,:));
requ=N/length(precip.precip);
p=1./frequ;
py=rp/365;
old on
lot(rpy,centers,'*')
remove 0 respectively Inf values, as polyfit doesn't work otherwise
ndex=find(isinf(rpy));
py(index)=[];centers(index)=[];
 = polyfit(log10(rpy),centers,2);
1 = polyval(P,log10(rpy));
lot(rpy, Y1)

 for i=1:length(precip.precip(:,1))
     max_rain(i)=max(precip.precip(i,:));
 end
statistical rain analysis
timespan years
tspan=length(precip.precip)/365;
 bin_max=max(precip.precip(1,:));
 steps=10;
 step_size=bin_max/10;
 bin_steps(1)=0;
 for i=1:steps
     bin_steps(i+1)=bin_steps(i)+step_size;
 end

set the return periods to the existing one:
recip_rp(i,:) = polyval(P,log10(rpy_axis));                              %one offest due to standart event
   %cap at maximum rainfall:
   precip_rp(precip_rp&ampgtmax_rain_cap)=max_rain_cap;
lot(rpy_axis, precip_rp(i,1:10))
    %average event, special case
     if i==length(precip.precip(:,1));
 precip_rp(:,length(rpy_axis)+1)=mean(precip.precip')';
     end
nd
%
 
 %strongest event
 p_data.precip_event(:,2)=max(precip.precip')';
 
 %minimum event
 p_data.precip_event(:,3)=min(precip.precip')';
 
 %random event
 p_data.precip_event(:,4)=(precip.precip(:,100)')';
takes long but no alternative to scatteredintp is found
or i=1:length(precip_rp(1,:))
           F_p_x = scatteredInterpolant(precip.lon,precip.lat,precip_rp(:,i),'linear','nearest');
           WO_object.intensity(:,i)=F_p_x(DEM.lon,DEM.lat);
           if i&amplt=length(rpy_axis);display(sprintf('calculating %d year return period successful',rpy_axis(i)))
           else display(sprintf('calculating mean scenario successful'))
           end
nd
O_object.lon=DEM.lon;
O_object.lat=DEM.lat;
O_object.intensity=WO_object.intensity';
or i=1:length(WO_object.intensity(:,1))
   [WO_object] =vec2grid(WO_object,i);
   WO_obj.grid(:,:,i)=WO_object.grid;
nd
O_obj.lon=DEM.lon;
O_obj.lat=DEM.lat;
O_obj.returnp(1:length(rpy_axis))=rpy_axis;
O_obj.returnp(length(rpy_axis)+1)=0;                                      %the average rain event
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/rain_statistics.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="rating_curve">
<H2>rating_curve</H2></A>
<font color="blue">function output=rating_curve(input,SO) </font>
 climada
 MODULE:
   flood
 NAME:
   rating_curve
 PURPOSE:
   assigning a flood heigth value to each input value according to the rating curve
   function and its parameters
 EXAMPLE:
   output=rating_curve(input,SO)

   INPUTS:
   input:         An accumulation value, e.g. 50
   SO:           The stream order
 OUTPUTS:
   output:      A flood depth value (m)

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

function for the rating curves
The rating curves need to be calibrated for each region, country.
The sigmoid function (S Shape) represents the river bank flood the best,
but is very sensitive to the paratmeters given
parameters:
 Cr defines the maximum reachable water level,
 bd_depth represents the river channel depth
 b changes the inclination of the curve on its ascending part
 mid_input represents the input value, where the strongest inclination is
 reached
SO is the streamorder
unit: meters
f ~exist('SO','var') || SO&ampgt5; SO=1;end
id_input=25;
stream order (SO) dependant parameters
f SO==1;
       bp_depth=0;Cr=3;b=7;
lseif SO==2;
       bp_depth=0;Cr=2.8;b=7;
lseif SO==3;
       bp_depth=0;Cr=2.5;b=7;
lseif SO==4;
       bp_depth=0;Cr=2.3;b=7;
lseif SO==5;
       bp_depth=0;Cr=2;b=7;
nd
calibration value:
r=10;
different functions to choose from:
log function
output= (Cr*log(input+1).^b) - bp_depth;
sqrt function   
output= (Cr*sqrt(input).^b) - bp_depth;
sigmoid function (logistical S shape)
utput=Cr./(1+exp(-(input-mid_input)*1/b))- bp_depth;
set treshold, if flooding less than 0.1m, set to 0m.
f output&amplt0.1
   output=0;
nd
 %plot rating curve
 figure(2)
 hold on
 input=-50:100;
 % output= (Cr*log(input+1).^b); %- bp_depth;
 output= (Cr*sqrt(input+1).^b);
 plot(input,output);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/rating_curve.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="stream_elevation_correct">
<H2>stream_elevation_correct</H2></A>
<font color="blue">function [SW,SW_original]=stream_elevation_correct(SW) </font>
 climada
 MODULE:
   flood
 NAME:
   stream_elevation_correct
 PURPOSE:
   correction the continuos stream elevation for exceptional values:
   The stream elevation should always decrease downstream, so higher
   values of a following cell that are higher than the previous one, are
   set to the previous value.
 EXAMPLE:
   [SW,SW_original]=stream_elevation_correct(SW); 

   INPUTS:
   SW:         A swathobject crossection struct

 OUTPUTS:
   SW_original:      The original swathobject crosssection struct
   SW         :      The corrected swathobject crosssection struct

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init


Correct exceeding river elevation points
Reason: The elevation at the swathobj intersections is not standart
derived (contains more points than SW.zd0) and can exceed the base
elevation
savety copy
W_original=SW;
the entire stream network
or j=1:length(SW.xyz)
   %single rivers
   for i=2:length(SW.xyz{1,j})
       if SW.xyz{1,j}(i-1)&ampgtSW.xyz{1,j}(i)
           %reset value to value before: simple one step correction
           SW.xyz{1,j}(i-1)=SW.xyz{1,j}(i);
       end
       if i&ampgt3
           if SW.xyz{1,j}(i-2)&ampgtSW.xyz{1,j}(i)
               %reset value to value before: two step correction
               SW.xyz{1,j}(i-2)=SW.xyz{1,j}(i);
           end
       end       
   end
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/stream_elevation_correct.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="streamord">
<H2>streamord</H2></A>
streamorder assigning
get streamorder for each river point
create coord.vector with streamorder
[st,hs,MS]=streamorder(S);
o_vec.x=[];so_vec.y=[];so_vec.streamorder=[];
or i=1:length(MS)
   so_vec_temp.x=MS(i).X;
   so_vec_temp.y=MS(i).Y;
   so_vec_temp.streamorder(1:length(MS(i).X))=MS(i).streamorder;
   
   so_vec.x=[so_vec.x so_vec_temp.x];
   so_vec.y=[so_vec.x so_vec_temp.y];
   so_vec.streamorder=[so_vec.streamorder so_vec_temp.streamorder];
   clear so_vec_temp
nd
o_vec.xy(:,1)=so_vec.x;
o_vec.xy(:,2)=so_vec.y;
lear so_vec.x so_vec.y
or i=1:length(pack{1,1}.xy0)
   for j=1:length(pack{1,1}.xy0{1,i})
       [row,col]=find(pack{1,1}.xy0{1,i}(j,i)==so_vec.xy(:,1) &amp pack{1,1}.xy0{1,i}(j,2)==so_vec.xy(:,2));
       
       for k=1:length(row)
           temp_str_order(k)=so_vec.streamorder(row(k));
       end
       streamord{1,i}(j)=max(temp_str_order);
       clear row col temp_str_order
   end
nd
ack{1,1}.georef=streamord;
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/streamord.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="streamorder2swathobj">
<H2>streamorder2swathobj</H2></A>
<font color="blue">function SO=streamorder2swathobj(MS,SW_WO) </font>
 climada
 MODULE:
   flood
 NAME:
   streamorder2swathobj
 PURPOSE:
   adding to each crosssection point SW_WO a Strahler streamorder value (MS) in the
   same structure SO
 EXAMPLE:
   SO=streamorder2swathobj(MS,SW_WO)

   INPUTS:
   MS:         A strahler streamoder struct, similar to a shape file
   SW_WO:      A crosssection struct

 OUTPUTS:
   SO:         A crosssection struct with a Strahler streamoder value at
               each point

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

comments:leaves room for optimization to speedup
Streamorder specific
for every swath point find a rating curve value
SW.xy is the central line of SWATHobj
SW_WO.xyz -&ampgt SW_WO.xy point find the middle of the river point and a point in the MS streamorder struct.
ind=find(test_vec(:,1)==test_vec_MS(:,1)&amptest_vec(:,2)==test_vec_MS(:,2));
ind=find(MS_tot.X==SW_WO.xy{1,1}(:,1)&amp MS_tot.Y==SW_WO.xy{1,1}(:,2));
create one Streamorder vector
S_tot.X=[];MS_tot.Y=[];MS_tot.strod=[];
or i=1:length(MS)
MS_tot.X=[MS_tot.X MS(i).X];
MS_tot.Y=[MS_tot.Y MS(i).Y];
st_ord(1:length(MS(i).Y))=MS(i).streamorder;
MS_tot.strod=[MS_tot.strod st_ord];
clear st_ord
nd
find streamorder by using the middleline of the SWATHobj
or j=1:length(SW_WO.xy)
   for i=1:length(SW_WO.xy{1,j})
       index=find(SW_WO.xy{1,j}(i,1)==MS_tot.X &amp SW_WO.xy{1,j}(i,2)==MS_tot.Y);
       ind_str=MS_tot.strod(index);
       if length(ind_str)&ampgt1
           ind_temp=find(max(ind_str));                                   %Takes the maximum streamorder value, could also be set to min
           SO.x{j}(i)=MS_tot.X(index(ind_temp));
           SO.y{j}(i)=MS_tot.Y(index(ind_temp));
           SO.strod{j}(i)=ind_str(ind_temp);
           clear ind_temp index ind_str
       elseif length(ind_str==1)
           SO.x{j}(i)=MS_tot.X(index);
           SO.y{j}(i)=MS_tot.Y(index);        
           SO.strod{j}(i)=ind_str;
           clear ind_temp index ind_str
       else
           %Fill linepoints with no streamorder value with value from left neighbours (usually higher, right neighbour is lower)                     
           SO.x{j}(i)=SW_WO.xy{1,j}(i,1);
           SO.y{j}(i)=SW_WO.xy{1,j}(i,2); 
           %ind.strod{j}(i)=9999;
           SO.strod{j}(i)=SO.strod{j}(i-1);
       end
   end
   display(sprintf('preparing stream %d from %d for calculation',j,length(SW_WO.xy)))
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/streamorder2swathobj.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_TWI_calc">
<H2>climada_centroids_TWI_calc</H2></A>
<font color="blue">function centroids = climada_centroids_TWI_calc(centroids, check_plots) </font>
 Calculate flood scores and topographic wetness indices
 MODULE:
   flood
 NAME:
	climada_centroids_TWI_calc
 PURPOSE:
   Calculate flood scores and topographic wetness indices for given
   centroids, that are on a regular grid.
   climada_centroids_TWI_calc applies a multiple-flow-direction method which,
   in contrast to the simple D8 method, allows the runoff to flow to
   multiple neighbouring cells. The distribution of the flow is determined
   based on the respective gradients between the central cell and its
   neighbouring cells. Also, the algorithm controls dispersion effects
   using a method suggested by
       Freeman, T.G. (1991): Calculating catchment area with
       divergent flow based on a regular grid;
       doi:10.1016/0098-3004(91)90048-I
   The Topographic wetness index (TWI), which can be derived from the
   calculated flow accumulation, then provides a cost-efficient
   alternative to flood determination by conventional hydrodynamic models.
   For more information on TWI see
       Pourali, S.H. et al. (2014): Topography Wetness Index Application
       in Flood-Risk-Based Land Use Planning;
       doi:10.1007/s12061-014-9130-2
 CALLING SEQUENCE:
   centroids = climada_centroids_TWI_calc(centroids, check_plots)
 EXAMPLE:
   centroids = climada_centroids_TWI_calc(centroids,0)
 INPUTS:
   centroids: Climada centroids struct; the following fields are required:
         .lat:           Latitude
         .lon:           Longitude
         .centroid_ID:   centroid ID
         .admin0_name    Country name
 OPTIONAL INPUT PARAMETERS:
   check_plots: whether plots of topography (elevation), slope, aspect
   angle, and flood scores should be drawn (=1) or not (=0; default)
   force_recalc: if set to 1, flood scores are calculated even if they
   already exist (default is 0)
 OUTPUTS:
   centroids: centroids with additional fields:
       .FL_score:   assigns a number for flow accumulation to each centroid, and
       .TWI:        assigns a topographic wetness index to each centroid
       .slope_deg:  slope of every centroid, in degree
       .area_m2:    area of every centroid, in square meters
       .aspect_deg: aspect of every centroid, in degree
       .sink_ID:    sink of every centroid, links to centroid_ID
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150226, initial
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150311, added wetness index
 Gilles Stassen, gillesstassen@hotmail.com, 20150407, clean up
 Lea Mueller, muellele@gmail.com, 20150720, bugfix, quick+dirty workaround
              to create meshgrid and allocate FL_score, @Gilles: please check and correct
 Jacob Anz, 280715, fixed shift_matrix
 Lea Mueller, muellele@gmail.com, 20150925, add process management/waitbar
 Lea Mueller, muellele@gmail.com, 20151105, improve output documentation
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_TWI_calc from centroids_TWI
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/helper_functions/climada_centroids_TWI_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_flow_find">
<H2>climada_flow_find</H2></A>
<font color="blue">function centroids = climada_flow_find(centroids) </font>
 Find flow direction for every centroid 
 MODULE:
   flood
 NAME:
   climada_flow_find
 PURPOSE:
   Find flow direction for every centroid, find next 10 centroids, based
   on sink_ID
 PREVIOUS STEP:
   centroids = climada_centroids_TWI_calc(centroids)
 CALLING SEQUENCE:
   centroids = climada_flow_find(centroids)
 EXAMPLE:
   centroids = climada_flow_find(centroids)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   centroids: a climada centroids structure, including TWI properties,
   especially .sink_ID
 OUTPUTS:
   centorids: centroid with field .sink_ID_10 defining the 10 next centroids
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150920, init
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_TWI_calc from centroids_TWI
 -
lobal climada_global
f ~climada_init_vars, return; end
_centroids = numel(centroids.sink_ID);
_sinks = 10;
ink_ID = zeros(n_centroids,n_sinks); % init
sgstr   = sprintf('Find flow direction for %i centroids ... ',n_centroids);
od_step = 10; % first time estimate after 10 assets, then every 100
f climada_global.waitbar
   fprintf('%s (updating waitbar with estimation of time remaining every 100th centroid)\n',msgstr);
   h        = waitbar(0,msgstr);
   set(h,'Name','Find flow direction for centroids');
lse
   fprintf('%s (waitbar suppressed)\n',msgstr);
   format_str='%s';
nd
or c_i = 1:n_centroids
   next_sink_ID = centroids.sink_ID(c_i);
   
   for c_ii = 1:n_sinks
       if ~isempty(next_sink_ID) &amp ~isnan(next_sink_ID)         
           sink_ID(c_i,c_ii) = next_sink_ID;
           next_sink_ID = centroids.sink_ID(sink_ID(c_i,c_ii) == centroids.centroid_ID);
           
           %this_elevation = centroids.elevation_m(sink_ID(c_i,c_ii) == centroids.centroid_ID);
           %next_elevation = centroids.elevation_m(centroids.centroid_ID == next_sink_ID);
           
           % %local minimum, do not use
           % if this_elevation&ampltnext_elevation 
           %     % go back to last sink ID
           %     previous_sink_ID = sink_ID(c_i,c_ii-1);
           % 
           %     % find all IDs that flow into this local minimum
           %     have_similar_sink = centroids.sink_ID == sink_ID(c_i,c_ii);
           %     centroids.centroid_ID(have_similar_sink)
           % 
           %     have_similar_sink_2 = ismember(centroids.sink_ID,centroids.centroid_ID(have_similar_sink));
           %     centroids.centroid_ID(have_similar_sink_2)
           % end
       end
   end
   
   % the progress management
   if mod(c_i,mod_step)==0
       mod_step          = 100;
       msgstr = sprintf('%i/%i centroids',c_i,n_centroids);
       if climada_global.waitbar
           waitbar(c_i/n_centroids,h,msgstr); % update waitbar
       else
           fprintf(format_str,msgstr); % write progress to stdout
           format_str=[repmat('\b',1,length(msgstr)) '%s']; % back to begin of line
       end
   end
   
nd
   
entroids.sink_ID_10 = sink_ID;
f climada_global.waitbar
   close(h) % dispose waitbar
lse
   fprintf(format_str,''); % move carriage to begin of line
nd
 figure
 is_sink = ismember(centroids.centroid_ID,sink_ID(1,:));
 plot(centroids.lon(is_sink),centroids.lat(is_sink),'o-')
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/helper_functions/climada_flow_find.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_geo_distance_2">
<H2>climada_geo_distance_2</H2></A>
<font color="blue">function dist_m = climada_geo_distance_2(lonlat1,lonlat2) </font>
 calculate distance between to points in meters
 MODULE:
   flood
 NAME:
   climada_geo_distance_2
 PURPOSE:
   calculate distance between two points or a point and a series of
   points, with different input format than climada_geo_distance. lonlat1
   and lonlat2 are a matrices that contain both lon and lat information. 
 CALLING SEQUENCE:
   climada_geo_distance_2(lonlat1, lonlat2);
 EXAMPLE:
   climada_geo_distance_2([0.0 45.0], [1.0 45.0]); % two points
   climada_geo_distance_2([0.0 45.0], [1.0 45.0; 1.0 46.0]); % point and a series of points
 INPUTS:
   lonlat1: longitude and latitude of first point
   lonlat2: longitude and latitude of second point
       or, if vectors of the same length, series of points
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   dist_m: distance(s) between points in [m]
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150801, init based on climada_geo_distance
 Lea Mueller, muellele@gmail.com, 20151106, move to flood
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/helper_functions/climada_geo_distance_2.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="filtfilt">
<H2>filtfilt</H2></A>
<font color="blue">function y = filtfilt(b,a,x) </font>
FILTFILT Zero-phase forward and reverse digital filtering.
   Y = FILTFILT(B, A, X) filters the data in vector X with the filter described
   by vectors A and B to create the filtered data Y.  The filter is described 
   by the difference equation:

     y(n) = b(1)*x(n) + b(2)*x(n-1) + ... + b(nb+1)*x(n-nb)
                      - a(2)*y(n-1) - ... - a(na+1)*y(n-na)


   After filtering in the forward direction, the filtered sequence is then 
   reversed and run back through the filter; Y is the time reverse of the 
   output of the second filtering operation.  The result has precisely zero 
   phase distortion and magnitude modified by the square of the filter's 
   magnitude response.  Care is taken to minimize startup and ending 
   transients by matching initial conditions.

   The length of the input x must be more than three times
   the filter order, defined as max(length(b)-1,length(a)-1).

   Note that FILTFILT should not be used with differentiator and Hilbert FIR
   filters, since the operation of these filters depends heavily on their
   phase response.

   See also FILTER.
   Author(s): L. Shure, 5-17-88
   revised by T. Krauss, 1-21-94
   initial conditions: Fredrik Gustafsson
   error(nargchk(3,3,nargin))
   if (isempty(b)|isempty(a)|isempty(x))
       y = [];
       return
   end
   [m,n] = size(x);
   if (n&ampgt1)&amp(m&ampgt1)
       y = x;
       for i=1:n  % loop over columns
          y(:,i) = filtfilt(b,a,x(:,i));
       end
       return
       % error('Only works for vector input.')
   end
   if m==1
       x = x(:);   % convert row to column
   end
   len = size(x,1);   % length of input
   b = b(:).';
   a = a(:).';
   nb = length(b);
   na = length(a);
   nfilt = max(nb,na);
   nfact = 3*(nfilt-1);  % length of edge transients
   if (len&amplt=nfact),    % input data too short!
       error('Data must have length more than 3 times filter order.');
   end
 set up filter's initial conditions to remove dc offset problems at the 
 beginning and end of the sequence
   if nb &amplt nfilt, b(nfilt)=0; end   % zero-pad if necessary
   if na &amplt nfilt, a(nfilt)=0; end
 use sparse matrix to solve system of linear equations for initial conditions
 zi are the steady-state states of the filter b(z)/a(z) in the state-space 
 implementation of the 'filter' command.
   rows = [1:nfilt-1  2:nfilt-1  1:nfilt-2];
   cols = [ones(1,nfilt-1) 2:nfilt-1  2:nfilt-1];
   data = [1+a(2) a(3:nfilt) ones(1,nfilt-2)  -ones(1,nfilt-2)];
   sp = sparse(rows,cols,data);
   zi = sp \ ( b(2:nfilt).' - a(2:nfilt).'*b(1) );
 non-sparse:
 zi = ( eye(nfilt-1) - [-a(2:nfilt).' [eye(nfilt-2); zeros(1,nfilt-2)]] ) \ ...
      ( b(2:nfilt).' - a(2:nfilt).'*b(1) );
 Extrapolate beginning and end of data sequence using a &quotreflection
 method&quot.  Slopes of original and extrapolated sequences match at
 the end points.
 This reduces end effects.
   y = [2*x(1)-x((nfact+1):-1:2);x;2*x(len)-x((len-1):-1:len-nfact)];
 filter, reverse data, filter again, and reverse data again
   y = filter(b,a,y,[zi*y(1)]);
   y = y(length(y):-1:1);
   y = filter(b,a,y,[zi*y(1)]);
   y = y(length(y):-1:1);
 remove extrapolated pieces of y
   y([1:nfact len+nfact+(1:nfact)]) = [];
   if m == 1
       y = y.';   % convert back to row if necessary
   end
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/helper_functions/filtfilt.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="l_imerode">
<H2>l_imerode</H2></A>
<font color="blue">function B = imerode(A,se,varargin) %#codegen </font>
IMERODE Erode image.
   IM2 = IMERODE(IM,SE) erodes the grayscale, binary, or packed binary image
   IM, returning the eroded image, IM2.  SE is a structuring element
   object, or array of structuring element objects, returned by the
   STREL function.

   If IM is logical and the structuring element is flat, IMERODE
   performs binary erosion; otherwise it performs grayscale erosion.  If
   SE is an array of structuring element objects, IMERODE performs
   multiple erosions of the input image, using each structuring element
   in succession.

   IM2 = IMERODE(IM,NHOOD) erodes the image IM, where NHOOD is an array
   of 0s and 1s that specifies the structuring element.  This is
   equivalent to the syntax IMERODE(IM,STREL(NHOOD)).  IMERODE uses this
   calculation to determine the center element, or origin, of the
   neighborhood:  FLOOR((SIZE(NHOOD) + 1)/2).

   IM2 = IMERODE(IM,SE,PACKOPT,M) or IMERODE(IM,NHOOD,PACKOPT,M) specifies
   whether IM is a packed binary image and, if it is, provides the row
   dimension, M, of the original unpacked image.  PACKOPT can have
   either of these values:

       'ispacked'    IM is treated as a packed binary image as produced
                     by BWPACK.  IM must be a 2-D uint32 array and SE
                     must be a flat 2-D structuring element.  If the
                     value of PACKOPT is 'ispacked', SHAPE must be
                     'same'.

       'notpacked'   IM is treated as a normal array.  This is the
                     default value.

   If PACKOPT is 'ispacked', you must specify a value for M.

   IM2 = IMERODE(...,SHAPE) determines the size of the output image.  
   SHAPE can have either of these values:

       'same'        Make the output image the same size as the input
                     image.  This is the default value.  If the value of
                     PACKOPT is 'ispacked', SHAPE must be 'same'.

       'full'        Compute the full erosion.

   Class Support
   -------------
   IM can be numeric or logical and it can be of any dimension.  If IM is
   logical and the structuring element is flat, then output will be
   logical; otherwise the output will have the same class as the input.  If
   the input is packed binary, then the output is also packed binary. 

   Examples
   --------
   Erode the binary image in text.png with a vertical line:

       originalBW = imread('text.png');
       se = strel('line',11,90);
       erodedBW = imerode(originalBW,se);
       figure, imshow(originalBW)
       figure, imshow(erodedBW)

   Erode the grayscale image in cameraman.tif with a rolling ball:

       originalI = imread('cameraman.tif');
       se = strel('ball',5,5);
       erodedI = imerode(originalI,se);
       figure, imshow(originalI), figure, imshow(erodedI)

   See also BWHITMISS, BWPACK, BWUNPACK, CONV2, FILTER2, IMCLOSE, 
            IMDILATE, IMOPEN, STREL.
   Copyright 1993-2004 The MathWorks, Inc.
 Testing notes
 Syntaxes
 --------
 B = imerode(A,se)
 B = imerode(A,se,packopt)
 B = imerode(A,se,packopt,M)
 B = imerode(...,padopt)

 A:       numeric or logical, real, full, N-D array.  May be empty.
          May contain Infs.  May not contain NaNs.  Required.

 se:      A single STREL object, a STREL array, or a real, full, double,
          N-D array containing 0s and 1s.  If se is an empty array of
          strels, then B should be the same as A, unless the input is
          logical and not packed, in which case B should be
          uint8(A ~= 0).  If se contains no neighbors (e.g.,
          strel(zeros(3,3))), then B should be filled with the maximum
          value for its type.  Required.

 packopt: Either 'ispacked' or 'notpacked'.  May be abbreviated; case
          insensitive match.  Optional.  Defaults to 'notpacked' if not
          specified.

 M:       Integer specifying the unpacked row dimension of the input
          image.  Required if packopt is 'ispacked'; otherwise
          optional and not used.

 padopt:  Either 'same' or 'full'.  May be abbreviated; case insensitive
          match.  Optional.  Defaults to 'same' if not specified.

 B:       Array of the same size and class as A.  Exception: if A is
          logical and the strel is all flat and packopt is 'notpacked',
          then B is a logical array.

 Key logic branches:

 se:      flat or nonflat?
 se:      array or single strel?
 se:      decomposed or nondecomposed?
 se:      2-D or N-D?
 A:       logical or nonlogical?
 A:       uint8 or not?
 A:       uint32 or not?
 packopt: 'ispacked' or 'notpacked'?
 padopt:  'full' or 'same'?
arginchk(2,5);
 = images.internal.morphop(A,se,'erode',mfilename,varargin{:});
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/helper_functions/l_imerode.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="lineSegmentIntersect">
<H2>lineSegmentIntersect</H2></A>
<font color="blue">function out = lineSegmentIntersect(XY1,XY2) </font>
LINESEGMENTINTERSECT Intersections of line segments.
   OUT = LINESEGMENTINTERSECT(XY1,XY2) finds the 2D Cartesian Coordinates of
   intersection points between the set of line segments given in XY1 and XY2.

   XY1 and XY2 are N1x4 and N2x4 matrices. Rows correspond to line segments. 
   Each row is of the form [x1 y1 x2 y2] where (x1,y1) is the start point and 
   (x2,y2) is the end point of a line segment:

                  Line Segment
       o--------------------------------o
       ^                                ^
    (x1,y1)                          (x2,y2)

   OUT is a structure with fields:

   'intAdjacencyMatrix' : N1xN2 indicator matrix where the entry (i,j) is 1 if
       line segments XY1(i,:) and XY2(j,:) intersect.

   'intMatrixX' : N1xN2 matrix where the entry (i,j) is the X coordinate of the
       intersection point between line segments XY1(i,:) and XY2(j,:).

   'intMatrixY' : N1xN2 matrix where the entry (i,j) is the Y coordinate of the
       intersection point between line segments XY1(i,:) and XY2(j,:).

   'intNormalizedDistance1To2' : N1xN2 matrix where the (i,j) entry is the
       normalized distance from the start point of line segment XY1(i,:) to the
       intersection point with XY2(j,:).

   'intNormalizedDistance2To1' : N1xN2 matrix where the (i,j) entry is the
       normalized distance from the start point of line segment XY1(j,:) to the
       intersection point with XY2(i,:).

   'parAdjacencyMatrix' : N1xN2 indicator matrix where the (i,j) entry is 1 if
       line segments XY1(i,:) and XY2(j,:) are parallel.

   'coincAdjacencyMatrix' : N1xN2 indicator matrix where the (i,j) entry is 1 
       if line segments XY1(i,:) and XY2(j,:) are coincident.
 Version: 1.00, April 03, 2010
 Version: 1.10, April 10, 2010
 Author:  U. Murat Erdem
 CHANGELOG:

 Ver. 1.00: 
   -Initial release.
 
 Ver. 1.10:
   - Changed the input parameters. Now the function accepts two sets of line
   segments. The intersection analysis is done between these sets and not in
   the same set.
   - Changed and added fields of the output. Now the analysis provides more
   information about the intersections and line segments.
   - Performance tweaks.
 I opted not to call this 'curve intersect' because it would be misleading
 unless you accept that curves are pairwise linear constructs.
 I tried to put emphasis on speed by vectorizing the code as much as possible.
 There should still be enough room to optimize the code but I left those out
 for the sake of clarity.
 The math behind is given in:
   http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/
 If you really are interested in squeezing as much horse power as possible out
 of this code I would advise to remove the argument checks and tweak the
 creation of the OUT a little bit.
%% Argument check.
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/helper_functions/lineSegmentIntersect.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="vec2grid">
<H2>vec2grid</H2></A>
<font color="blue">function [ WO_object ] =vec2grid(WO_object,event,plot) </font>
 climada
 MODULE:
   flood
 NAME:
   vec2grid
 PURPOSE:
   converting a lat, lon, intensity vector into a grid and adding this to
   the original struct
 EXAMPLE:
   [DEM] =vec2grid(DEM);

   INPUTS:
   DEM:        A digital elevation model struct containing lat, lon,
               elevation or intensity
   event:      a number for an event in the WO_object matrix
   plot:       The option to plor the result
 OUTPUTS:
   WO_object:     Same like input with an additional grid matrix derived
                  from the lat, lon vectors

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

f ~exist('event','var'); event=1; end
f ~exist('plot','var'); plot=0; end
get matrix dimension, than reshape
est=diff(WO_object.lon);
=find(test&amplt0);
if_lon=r(1);
if_lat=length(r)+1;
f  isfield(WO_object,'intensity')
   matrix=reshape(WO_object.intensity(event,:),dif_lon,dif_lat);
lseif isfield(WO_object,'elevation_m')
   matrix=reshape(WO_object.elevation_m,dif_lon,dif_lat);    
nd
lon &amp lat vector
   minlon=min(WO_object.lon);
   maxlon=max(WO_object.lon);
   minlat=min(WO_object.lat);
   maxlat=max(WO_object.lat);
   lon_size=maxlon-minlon;
   lat_size=maxlat-minlat;
   diff_lon=lon_size/(dif_lon-1);
   diff_lat=lat_size/(dif_lat-1);
   
  %resolution in x and y direction is not the same, extend maxlon;
  % to have the same gridsize is important to fill intensity values
    if diff_lon~=diff_lat
      diff_lon=diff_lat;
       
      for i=1:dif_lon
   WO_object.lon_vec(i)=minlon+i*diff_lon;   
      end
      
      %check max_lon offset
      offset=maxlon-max(WO_object.lon_vec);
      WO_object.lat_vec=minlat:diff_lat:maxlat;
    else
        
   WO_object.lon_vec=minlon:diff_lon:maxlon;
   WO_object.lat_vec=minlat:diff_lat:maxlat;
    end
WO_object.grid=rot90(fliplr(matrix));
O_object.grid=flipud(rot90(fliplr(matrix)));                                   % CC: test if orientation correct now
matrix=rot90(matrix);
O_object.offset=offset;
optional x/y instead of lat/lon conversion
f isfield(WO_object,'x')
   
lon &amp lat vector
   minlon=min(WO_object.x);
   maxlon=max(WO_object.x);
   minlat=min(WO_object.y);
   maxlat=max(WO_object.y);
   lon_size=maxlon-minlon;
   lat_size=maxlat-minlat;
   diff_lon=lon_size/(dif_lon-1);
   diff_lat=lat_size/(dif_lat-1);
   
  %resolution in x and y direction is not the same, extend maxlon;
  % to have the same gridsize is important to fill intensity values
    if diff_lon~=diff_lat
      diff_lon=diff_lat;
       
      for i=1:dif_lon
   WO_object.lon_vec_x(i)=minlon+i*diff_lon;   
      end
      
      %check max_lon offset
      offset=maxlon-max(WO_object.lon_vec_x);
      WO_object.lat_vec_y=minlat:diff_lat:maxlat;
    else
        
   WO_object.lon_vec_x=minlon:diff_lon:maxlon;
   WO_object.lat_vec_y=minlat:diff_lat:maxlat;
    end
nd
plot the grid
f plot==1
   imagesc(WO_object.grid)
nd
 %create grid
     minlon=min(WO_object.lon);
     maxlon=max(WO_object.lon);
     minlat=min(WO_object.lat);
     maxlat=max(WO_object.lat);
 
     diff_lat=diff(WO_object.lat);
     diff_lat=abs(diff_lat(diff_lat~=0));
     diff_lon=diff(WO_object.lon);
 
 
     lon_vec=minlon:diff_lon(1):maxlon;
     lat_vec=minlat:diff_lat(1):maxlat;
     WO_object.grid(length(lon_vec),length(lat_vec))=0;
 
     %round the values
     lon_vec=round(lon_vec*10000)/10000;
     lat_vec=round(lat_vec*10000)/10000;
     WO_object.lat=round(WO_object.lat*10000)/10000;
     WO_object.lon=round(WO_object.lon*10000)/10000;
     %fill with WO_object values
 
 
 %    h = waitbar(0,'Please wait...');
     for i=1:length(WO_object.lat)
         t_lat=find(WO_object.lat(i)==lat_vec);
         t_lon=find(WO_object.lon(i)==lon_vec);
         WO_object.grid(t_lon,t_lat)=WO_object.intensity(1,i);
 %        waitbar(i / length(WO_object.lat))
     end    
 
 %close(h)
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/helper_functions/vec2grid.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="chiplot">
<H2>chiplot</H2></A>
<font color="blue">function OUT = chiplot(S,DEM,A,varargin) </font>
 CHI plot for bedrock river analysis

 Syntax

     C = chiplot(S,DEM,A)
     C = chiplot(S,DEM,A,pn,pv,...)

 Description

     CHI plots are an alternative to slope-area plots for bedrock river
     analysis. CHI plots are based on a transformation of the horizontal
     coordinate that converts a steady-state river profile into a straight
     line with a slope that is related to the ratio of the uplift rate to
     the erodibility (Perron and Royden 2012).

 Input arguments

     S     instance of STREAMobj. The stream network must consist of only 
           one connected component (only one outlet may exist!)
     DEM   digital elevation model (GRIDobj)
     A     flow accumulation as calculated by flowacc (GRIDobj)

     Parameter name/value pairs {default}

     'a0': {1e6}
     reference area in m^2

     'mn':  {[]}, scalar      
     mn is the ratio of m and n in the stream power equation. The value
     ranges usually for bedrock rivers between 0.1 and 0.5. If empty, it
     is automatically found by a least squares approach.
     
     'trunkstream': {[]}, STREAMobj
     instance of STREAMobj that must be a subset of S, e.g. the main river
     in the network S. The main trunk is highlighted in the plot and can
     be used to fit the mn ratio (see pn/pv pair 'fitto').

     'fitto': {'all'},'ts', 
     choose which data should be used for fitting the mn ratio.
     'all' fits mn to all streams in S
     'ts' fits mn only to the trunkstream which must be provided with the
     pn-pv pair trunkstream.

     'plot': {true}, false
     plot the CHIplot.

     'mnplot': {false}, true
     plot data for various values of mn [.1:.1:.9]

 Output arguments

     C     structure array that contains
     .mn       ratio of m and n
     .beta     slope of the best fit line
     .betase   standard error of beta
     .a0       reference area
     .ks       channel steepness index
     .chi      CHI values 
     .elev     elevation
     .elevbl   elevation above baselevel
     .distance distance from outlet
     .pred     predicted elevation
     .res      residual elevation


 Example



 See also: flowpathapp, STREAMobj, FLOWobj/flowacc, STREAMobj/trunk,
           STREAMobj/modify  


 References:
     
     Perron, J. &amp Royden, L. (2013): An integral approach to bedrock river 
     profile analysis. Earth Surface Processes and Landforms, 38, 570-576.
     [DOI: 10.1002/esp.3302]
     

 Author: Wolfgang Schwanghart (w.schwanghart[at]geo.uni-potsdam.de)
 Date: 13. May, 2013
 Parse Inputs
 = inputParser;         
.FunctionName = 'chiplot';
ddRequired(p,'S',@(x) isa(x,'STREAMobj'));
ddRequired(p,'DEM', @(x) isa(x,'GRIDobj'));
ddRequired(p,'A', @(x) isa(x,'GRIDobj'));
ddParamValue(p,'mn',[],@(x) isscalar(x) || isempty(x));
ddParamValue(p,'trunkstream',[],@(x) isa(x,'STREAMobj') || isempty(x));
ddParamValue(p,'plot',true,@(x) isscalar(x));
ddParamValue(p,'mnplot',false,@(x) isscalar(x));
ddParamValue(p,'fitto','all');
ddParamValue(p,'a0',1e6,@(x) isscalar(x) &amp&amp isnumeric(x));
ddParamValue(p,'betamethod','ls',@(x) ischar(validatestring(x,{'ls','lad'})));
ddParamValue(p,'mnmethod','ls',@(x) ischar(validatestring(x,{'ls','lad'})));
arse(p,S,DEM,A,varargin{:});
     = p.Results.S;
EM   = p.Results.DEM;
     = p.Results.A;
itto = p.Results.fitto;
etamethod = validatestring(p.Results.betamethod,{'ls','lad'});
nmethod   = validatestring(p.Results.mnmethod,{'ls','lad'});
 to which stream should the data be fitted? Trunkstream or all streams?
f ischar(fitto)
   fitto = validatestring(fitto,{'all','ts'});    
   if strcmpi(fitto,'ts') &amp&amp isempty(p.Results.trunkstream);
       error('TopoToolbox:wronginput',...
            ['You must supply a trunkstream, if you use the parameter \n'...
             'fitto together with the option ts']);
   end
nd
 nr of nodes in the entire stream network
rc = numel(S.x);
   = sparse(double(S.ix),double(S.ixc),true,nrc,nrc);
 find outlet
utlet = sum(M,2) == 0 &amp sum(M,1)'~=0;
f nnz(outlet)&ampgt1
   % there must not be more than one outlet (constraint could be removed
   % in the future).
   error('TopoToolbox:chiplot',...
       'The stream network must not have more than one outlet');
nd
 reference drainage area
0   = p.Results.a0; % m^2
 elevation values at nodes
x   = double(DEM.Z(S.IXgrid));
 elevation at outlet
b   = double(DEM.Z(S.IXgrid(outlet)));
 a is the term inside the brackets of equation 6b 
    = double(a0./(A.Z(S.IXgrid)*(A.cellsize.^2)));
 x is the cumulative horizontal distance in upstream direction
    = S.distance;
 use trunkstream for fitting and display
witch fitto;
   case 'all'
       SFIT = S;
       Lib = true(size(x));
   case 'ts'
       SFIT = p.Results.trunkstream;
       [Lia,Lib] = ismember(SFIT.IXgrid,S.IXgrid);
       if any(~Lia);
           error('TopoToolbox:chiplot',...
               ['The main trunk stream must be a subset of the stream network.\n'...
                'Map a trunk stream with flowpathtool and use the STREAMobj as \n'...
                '3rd input argument ( flowpathtool(FD,DEM,S) ).']) ;
       end
nd
 find values of the ratio of m and n that generate a linear Chi plot
 uses fminsearch
f isempty( p.Results.mn );
   mn0  = 0.5; % initial value
   mn   = fminsearch(@mnfit,mn0);
lse
   % or use predefined mn ratio.
   mn   = p.Results.mn;
nd
 plot different values of mn
f p.Results.mnplot
   mntest = .1:.1:.9;
   cvec = jet(numel(mntest));
   figure('DefaultAxesColorOrder',cvec);
   chitest = zeros(numel(Lib),numel(mntest));
   
   for r = 1:numel(mntest);
       chitest(:,r) = netcumtrapz(x(Lib),a(Lib).^mntest(r),SFIT.ix,SFIT.ixc);
   end
   plot(chitest,zx(Lib)-zb,'x');
   xlabel('\chi [m]')
   ylabel('elevation [m]');
   title('\chi plots for different values of mn')
   legnames = cellfun(@(x) num2str(x),num2cell(mntest),'uniformoutput',false);
   legend(legnames);
nd
 calculate chi
hi = netcumtrapz(x,a.^mn,S.ix,S.ixc); %*ab.^mn
 now use chi to fit beta
witch betamethod
   case 'ls'
       % least squares
       beta = chi(Lib)\(zx(Lib)-zb);
   case 'lad'
       % least absolute deviations
       beta = fminsearch(@(b) sum(abs(b*chi(Lib) - (zx(Lib)-zb))),0.0334);
nd
    = nnz(Lib);
SE  = sum((chi(Lib)*beta - (zx(Lib)-zb)).^2);
SZ  = sum((zx(Lib)-mean(zx(Lib))).^2);
2   = 1-(SSE/SSZ);
etase = sqrt((SSE/(n-2))./(sum((chi(Lib)-mean(chi(Lib))).^2)));
f p.Results.plot;
   figure
   % plot results
   order = S.orderednanlist;
   I     = ~isnan(order);
   c     = nan(size(order));
   c(I)  = chi(order(I));
   zz    = nan(size(order));
   zz(I) = zx(order(I))-zb;
   
   plot(c,zz,'-','color',[.5 .5 .5]);
   hold on
   if ~isempty( p.Results.trunkstream )
       switch p.Results.fitto
           case 'all'
               % check trunkstream
       
               ST    = p.Results.trunkstream;
               [Lia,Lib] = ismember(ST.IXgrid,S.IXgrid);
       
               if any(~Lia);
                   error('TopoToolbox:chiplot',...
                       ['The main trunk stream must be a subset of the stream network.\n'...
                       'Map a trunk stream with flowpathtool and use the STREAMobj as \n'...
                       '3rd input argument ( flowpathtool(FD,DEM,S) ).']) ;
               end
           case 'ts'
                ST = SFIT;
       end
       
       order = ST.orderednanlist; 
       I     = ~isnan(order);
       c     = nan(size(order));
       chifit = chi(Lib);
       zxfit  = zx(Lib);
       c(I)  = chifit(order(I));
       zz    = nan(size(order));
       zz(I) = zxfit(order(I))-zb;
       plot(c,zz,'k-','LineWidth',2);
   end
   
   refline(beta,0);
   hold off
   xlabel('\chi [m]')
   ylabel('elevation [m]');
nd
 write to output array
f nargout == 1;
   
   OUT.mn   = mn;
   OUT.beta = beta;
   OUT.betase = betase;
   OUT.a0   = a0;
   OUT.ks   = beta*a0^mn;
   OUT.R2   = R2;
   
   [OUT.x,...
    OUT.y,...
    OUT.chi,...
    OUT.elev,...
    OUT.elevbl,...
    OUT.distance,...
    OUT.pred,...
    OUT.area] = STREAMobj2XY(S,chi,DEM,zx-zb,S.distance,beta*chi,A.*(A.cellsize^2));
    OUT.res   = OUT.elevbl-OUT.pred;
nd
   
% fitting function
<font color="blue">function sqres = mnfit(mn) </font>
 calculate chi with a given mn ratio
 and integrate in upstream direction
HI = netcumtrapz(x(Lib),a(Lib).^mn,SFIT.ix,SFIT.ixc);%*ab.^mn
 normalize both variables
HI = CHI ./ max(CHI);
   = zx(Lib)-zb;
   = z./max(z);
 calculate the residuals and minimize their squared sums
witch mnmethod
   case 'ls'
       sqres = sum((CHI - z).^2);
   case 'lad'
       sqres = sum(sqrt(abs(CHI-z)));
nd
nd
nd
<font color="blue">function z = netcumtrapz(x,y,ix,ixc) </font>
 cumtrapz along upward direction in a directed tree network
 = zeros(size(x));
or lp = numel(ix):-1:1;
   z(ix(lp)) = z(ixc(lp)) + (y(ixc(lp))+(y(ix(lp))-y(ixc(lp)))/2) *(abs(x(ixc(lp))-x(ix(lp))));
nd
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/chiplot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="compilemexfiles">
<H2>compilemexfiles</H2></A>
<font color="blue">function compilemexfiles </font>
 compile mex-functions that come with TopoToolbox 2

 Syntax 

     compilemexfiles

 Description

     TopoToolbox 2 comes with a few mex-functions that have been
     written in C and that must be compiled prior to usage. While all
     functions have been written in plain m-code, the usage of
     mex-functions enhances the speed at which some functions are
     evaluated. compilemexfiles compiles all these files to run on your
     system. Prior to running compilemexfiles run

     mex -setup

     and locate a compiler on your system.

 Available mex-functions

     All mex-functions are located in private directories

     @FLOWobj/private
     dependencemap_mex.c
     drainagebasins_mex.c
     flowacc_mex.c
     steepestneighbor_mex.c
     tsort_mex.c

 Author: Wolfgang Schwanghart (w.schwanghart[at]geo.uni-potsdam.de)
 Date: 30. January, 2013
ocation = which('compilemexfiles');
pathstr,~,~] = fileparts(location);
ewFolder = [pathstr filesep '@FLOWobj' filesep 'private']; 
ldFolder = cd(newFolder);
iles = dir('*.c');
ry
   for r = 1:numel(files)
       funname = files(r).name;
       mex('-largeArrayDims',funname)
   end
atch err
   cd(oldFolder);
   rethrow(err)
nd
d(oldFolder);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/compilemexfiles.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="coord2ind">
<H2>coord2ind</H2></A>
<font color="blue">function [IX,ixcoord,res] = coord2ind(X,Y,x,y) </font>
 convert xy coordinates to linear index

 Syntax

     IX = coord2ind(X,Y,x,y)

 Description

     coord2ind converts xy coordinates to a linear index. 

 Input

     X,Y       coordinate matrices. X and Y must be plaid and
               monotonically increasing as produced by meshgrid
     x,y       point coordinates

 Output

     IX        vector with linear indices of the point coordinates in
               X and Y
     ixcoord   linear index such that 
               IX = coord2ind(X,Y,x(ixcoord),y(ixcoord))
     res       distance between original x y data and clipped data 

 Example

     [X,Y] = meshgrid(0:0.01:1,0:0.01:1);
     x = rand(100,1);
     y = rand(100,1);
     Z = false(size(X));
     [IX,ix,res] = coord2ind(X,Y,x,y);
     Z(IX) = true;
     imagesc(X(1,:),Y(:,2),Z); axis image; axis xy
     hold on
     scatter(x,y,'y') 

 See also: SUB2IND, IND2SUB, MESHGRID

 Author: Wolfgang Schwanghart (w.schwanghart[at]unibas.ch)
 Date: 15. March, 2009
f nargin == 0;
   % get X and Y
   h = findobj(gcf,'type','image');
   M = size(get(h,'CData'), 1);
   N = size(get(h,'CData'), 2);
   
   X = get(h,'XData');
   Y = get(h,'YData');
   
   if numel(X) == 2 &amp&amp numel(Y) == 2
       if isa(X,'cell') &amp&amp isa(X,'cell') 
           X = X{2};
           Y = Y{2};
       else
           
           X = linspace(X(1),X(2),N);
           Y = linspace(Y(1),Y(2),M);
       end
   end
     [X,Y] = meshgrid(1:N,1:M);
   [x,y] = getpts;
lseif nargin == 2;
   [x,y] = getpts;
nd
 force column vectors
 = x(:);
 = y(:);
f isvector(X) &amp&amp isvector(Y);
   siz = [numel(Y) numel(X)];
   dx  = X(2)-X(1);
   dy  = Y(2)-Y(1);
lse
   siz = size(X);
   dx = X(1,2)-X(1);
   dy = Y(2)-Y(1);   
nd
X1 = (x-X(1))./dx + 1;
X2 = (y-Y(1))./dy + 1;
X1 = round(IX1);
X2 = round(IX2);
 = IX1&ampgtsiz(2) | IX1&amplt1 | IX2&ampgtsiz(1) | IX2&amplt1;
(I) = [];
(I) = [];
xcoord = find(~I);
f ~isempty(x)
   IX = sub2ind(siz,IX2,IX1);
   if nargout == 3
       if isvector(X) &amp&amp isvector(Y);
           res = hypot(X(IX1)-x,Y(IX2)-y);
       else            
           res = hypot(X(IX)-x,Y(IX)-y);
       end
   end
lse
   IX = [];
   ixcoord = [];
   res = [];
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/tools_and_more/coord2ind.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="demo_modifystreamnet">
<H2>demo_modifystreamnet</H2></A>
<font color="blue">function demo_modifystreamnet </font>
 demo on geometric modifications of stream networks

 Syntax

     demo_modifystreamnet

 Description

     This demo shows most of the available, automated tools to modify the 
     planform geometry of stream networks in TopoToolbox. The function
     requires no input and output arguments.

 See also: STREAMobj/modify, STREAMobj/trunk, STREAMobj/klargestconncomps
           STREAMobj/removeshortstreams

 Author: Wolfgang Schwanghart (w.schwanghart[at]geo.uni-potsdam.de)
 Date: 18. April, 2015
arginchk(0,0)
argoutchk(0,0)
oad exampledem
EM = GRIDobj(X,Y,dem);
D  = FLOWobj(DEM,'preprocess','carve');
   = STREAMobj(FD,'minarea',100);
1   = [.5 .5 .5];
2   = 'r';
w   = 1.5;
% klargestconncomps
ubplot(3,5,1);
lot(S,'color',c1);
old on
2 = klargestconncomps(S,1);
lot(S2,c2,'LineWidth',lw);
etaxisright
itle('klargestconncomps(S,1)');
old off
% removeshortstreams(S,1000)
ubplot(3,5,2);
lot(S,'color',c1);
old on
2 = removeshortstreams(S,1000);
lot(S2,c2,'LineWidth',lw);
etaxisright
itle('removeshortstreams(S,1000)');
old off
% trunk
ubplot(3,5,3);
lot(S,'color',c1);
old on
2 = trunk(S);
lot(S2,c2,'LineWidth',lw);
etaxisright
itle('trunk(S)');
old off
% modify(S,'distance',10000)
ubplot(3,5,4);
lot(S,'color',c1);
old on
2 = modify(S,'distance',10000);
lot(S2,c2,'LineWidth',lw);
etaxisright
itle('modify(S,''distance'',10000)');
old off
% modify(S,'distance',[5000 10000])
ubplot(3,5,5);
lot(S,'color',c1);
old on
2 = modify(S,'distance',[5000 10000]);
lot(S2,c2,'LineWidth',lw);
etaxisright
itle({'modify(S,''distance'',...';'[5000 10000])'});
old off
% modify(S,'streamorder',1)
ubplot(3,5,6);
lot(S,'color',c1);
old on
2 = modify(S,'streamorder',1);
lot(S2,c2,'LineWidth',lw);
etaxisright
itle('modify(S,''streamorder'',1)');
old off
% modify(S,'streamorder','&amplt=2')
ubplot(3,5,7);
lot(S,'color',c1);
old on
2 = modify(S,'streamorder','&amplt=2');
lot(S2,c2,'LineWidth',lw);
etaxisright
itle({'modify(S,''streamorder'',...';'''&amplt=2'')'});
old off
% modify(S,'upstreamto',DEM&ampgt=1600)
ubplot(3,5,8);
lot(S,'color',c1);
old on
2 = modify(S,'upstreamto',DEM&ampgt=1600);
lot(S2,c2,'LineWidth',lw);
etaxisright
itle({'modify(S,''upstreamto'',...';'DEM&ampgt=1600)'});
old off
% modify(S,'downstreamto',DEM&amplt=1600)
ubplot(3,5,9);
lot(S,'color',c1);
old on
2 = modify(S,'downstreamto',DEM&amplt=1600);
lot(S2,c2,'LineWidth',lw);
etaxisright
itle({'modify(S,''downstreamto'',...';'DEM&amplt=1600)'});
old off
% modify(S,'tributaryto',trunk(S))
ubplot(3,5,10);
lot(S,'color',c1);
old on
2 = modify(S,'tributaryto',trunk(S));
lot(S2,c2,'LineWidth',lw);
etaxisright
itle({'modify(S,''tributaryto'',...';'trunk(S))'});
old off
nd
<font color="blue">function setaxisright(ax) </font>
f nargin == 0;
   ax = gca;
nd
xis(ax,'image');
et(ax,'Xticklabel',[]);
et(ax,'Yticklabel',[]);
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/demo_modifystreamnet.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flowpathapp">
<H2>flowpathapp</H2></A>
<font color="blue">function flowpathtool(FD,DEM,S) </font>
 Map, visualize and export flowpaths that start at manually set channelheads

 Syntax
     
     flowpathtool(FD,DEM)
     flowpathtool(FD,DEM,S)

 Description

     flowpathtool provides an interactive tool to visualize and generate
     flow paths on a digital elevation model based on single flow direction
     (FLOWobj). If an instance of STREAMobj derived from FD is supplied as
     third argument, manually set points are automatically snapped to the
     existing stream network, so that a subset of the latter can be
     generated.

     The stream network constructed by manually setting
     channelheads can be exported to the workspace as new instance of
     STREAMobj. In addition, the stream network can be exported to Excel, 
     as text file or as shapefile (requires Mapping Toolbox).

     Tools are found in the menu bar of the main window. 


 Notes on export to .xls or .txt

     The mapped stream network can be exported as xls or txt file. Note
     that individual streams are listed in the order at which they were
     mapped. Streams that are tributary to a previously mapped stream
     terminate at the confluence of both so it may make sense to map
     higher order stream first before mapping their tributaries. The data
     is exported in a columnar format that include following fields:

                    ID    unique stream identifier.
                     X    x coordinates of the stream vertices
     	              Y    y coordinates
     upstream_distance   distance from the outlet
             elevation   elevation of the stream vertices
          upslope_area   drainage area of each stream vertice in map units 
                         (nr of upstream cells x cellsize^2)
                 slope   channel gradient in tangens [m/m]. Note that the
                         slope is calculated along the drainage network
                         and may differ from the slope returned by the
                         function gradient8. If the DEM was not
                         hydrologically conditioned, negative slope values
                         (upward directed) may occur. 


 Input arguments

     FD     FLOWobj
     DEM    Digital elevation model (GRIDobj)
     S      STREAMobj derived from FD

 

 Author: Wolfgang Schwanghart (w.schwanghart[at]geo.uni-potsdam.de)
 Date: 30. January, 2013
 Default line color
rops.linecolor = 'k';
 If you set fastindexing to true then downstream processing is much faster
 for tools that do computations along single flow paths such as
 flowpathextract
D.fastindexing = true;
 create figure
crsz = get(0,'ScreenSize');
 pos = [left, bottom, width, height]
Fig = figure('OuterPosition',[1/4*scrsz(3) 1/3*scrsz(4) 3/4*scrsz(3) 2/3*scrsz(4)],...
             'MenuBar','none',...
             'NumberTitle','off',...
             'Name','Main');
         
 create menu
MenuView    = uimenu(hFig,'Label','View'); 
ButtonMenuColor = uimenu(hMenuView,'Label','Line Color'); 
olors = 'kbgyr';
ButtonColors(1) = uimenu(hButtonMenuColor,'Label','black','Checked','on','Callback',@(src,event) changelinecolor(src,event)); 
ButtonColors(2) = uimenu(hButtonMenuColor,'Label','blue','Checked','off','Callback',@(src,event) changelinecolor(src,event));
ButtonColors(3) = uimenu(hButtonMenuColor,'Label','green','Checked','off','Callback',@(src,event) changelinecolor(src,event));
ButtonColors(4) = uimenu(hButtonMenuColor,'Label','yellow','Checked','off','Callback',@(src,event) changelinecolor(src,event));
ButtonColors(5) = uimenu(hButtonMenuColor,'Label','red','Checked','off','Callback',@(src,event) changelinecolor(src,event));
ButtonClear = uimenu(hMenuView,'Label','Clear','Callback',@(src,event) clearvectorplots);  
MenuExport  = uimenu(hFig,'Label','Export'); 
ButtonExport = uimenu(hMenuExport,'Label','Export STREAMobj to workspace','Callback',@(src,event) exporttoworkspace);    
ButtonExportXLS = uimenu(hMenuExport,'Label','Export streams to Excel','Callback',@(src,event) writetoexcel); 
ButtonExportTXT = uimenu(hMenuExport,'Label','Export streams to ASCII','Callback',@(src,event) writetotxtfile);
ButtonExportSHP = uimenu(hMenuExport,'Label','Export streams to Shapefile','Callback',@(src,event) writetoshape);
 calculate hillshade
GB  = imageschs(DEM,DEM);
 create empty axes in figure
 hAx = axes('parent',hFig);
Ax = imgca(hFig);
f nargin == 3;
   WW = false(DEM.size);
   WW(S.IXgrid) = true;
   
   RGB(repmat(WW,[1 1 3])) = 150;    
   [~,SNAPRASTER] = bwdist(WW,'q');
   
   FD.ixcix(~WW) = 0;
   snap = true;
lse
   snap = false;
nd
 show hillshade using imshow
Im = image(RGB,'parent',hAx);
 create an instance of imscrollpanel and use the API
Panel = imscrollpanel(hFig,hIm);
pi    = iptgetapi(hPanel);
 set to initial magnification
ag    = api.findFitMag();
pi.setMagnification(mag);
 create magnification box in another window
MagBox = immagbox(hFig,hIm);
os     = get(hMagBox,'Position');
et(hMagBox,'Position',[0 0 pos(3) pos(4)])
moverview(hIm)
 create figure for profiles
FigProfiles = figure('OuterPosition',[1/4*scrsz(3) 50 3/4*scrsz(3) 1/3*scrsz(4)-50],...
                     'NumberTitle','off',...
                     'Name','Profiles') ;
AxProfiles = axes('Parent',hFigProfiles,'Xscale','linear','Yscale','linear','box','on');
label(hAxProfiles,'distance from outlet');
label(hAxProfiles,'elevation');
% add callbacks
nterFcn = @(figHandle, currentPoint)...
      set(hFig, 'Pointer','crosshair');
ptSetPointerBehavior(hIm,enterFcn);
ptPointerManager(hFig);
lim = get(hIm,'XData');
lim = get(hIm,'YData');
 = 1:xlim(2);
 = 1:ylim(2);
et(hFig,'WindowButtonDownFcn',@PressLeftButton);
% Predefine variables
Xchannelhead = 0;
ounter = 0;
OGgrid = zeros(DEM.size,'uint16');
Xchannel = {};
istance  = {};
Plot = [];
PlotProfiles = [];
<font color="blue">    function PressLeftButton(src,evt) </font>
       
       % get the axis position
       p = get(hAx,'CurrentPoint');
       
       % check if current point is located inside axis
       p = p(1,1:2);
       
       pixelx = round(axes2pix(xlim(2), xlim, p(1)));
       pixely = round(axes2pix(ylim(2), ylim, p(2)));
       
       if pixelx &amplt xlim(1) || pixelx &ampgt xlim(2) ...
               || pixely &amplt ylim(1) || pixely &ampgt ylim(2)
           % do nothing
       else
           % call function
           IXchannelhead(:) = sub2ind(DEM.size,pixely,pixelx);
           counter = counter + 1;
           
           % snap to stream
           if snap
               IXchannelhead(:) = SNAPRASTER(IXchannelhead);
           end
           
           PlotProfiles
       end
       
       
   end
<font color="blue">    function PlotProfiles </font>
       % get coordinates of mouse click
       
       % get indices of flow path
       [IXchannel{counter},distance{counter}] = flowpathextract(FD,IXchannelhead);
       % set values in the ixcix raster (see FD.fastindexing) to zero
       % where the channel has been identified. This will ensure that
       % these locations are not visited again and thus for fast execution
       if LOGgrid(IXchannel{counter}(end)) == 0;
           LOGgrid(IXchannel{counter}) = counter;
           distance{counter} = distance{counter}(end) - distance{counter};
       else
           tribIX = LOGgrid(IXchannel{counter}(end));
           LOGgrid(IXchannel{counter}(1:end-1)) = counter;
           I = IXchannel{tribIX} == IXchannel{counter}(end);
           distance{counter} = distance{tribIX}(I)+(distance{counter}(end)-distance{counter});
       end
       
       FD.ixcix(IXchannel{counter}) = 0;
       % plot flow path
       hold(hAx,'on')
       [r,c] = ind2sub(DEM.size,IXchannel{counter});
       hPlot(counter) = plot(hAx,X(c),Y(r),props.linecolor,'LineWidth',2);
       hold(hAx,'off');
       drawnow
       
       hold(hAxProfiles,'on')
       hPlotProfiles(counter) = plot(hAxProfiles,distance{counter},DEM.Z(IXchannel{counter}),props.linecolor);
       hold(hAxProfiles,'off');
       drawnow
       
   end
<font color="blue">    function clearvectorplots </font>
       delete(hPlot);
       hPlot = [];
       delete(hPlotProfiles)
       hPlotProfiles = [];
       counter = 0;
       FD.fastindexing = true;
       
       if snap
           FD.ixcix(~WW) = 0;
       end
       
       LOGgrid = zeros(DEM.size,'uint16');
       IXchannel = {};
       distance  = {};
       
   end
<font color="blue">    function exporttoworkspace </font>
       W = DEM;
       W.Z = LOGgrid&ampgt0;
       
       if any(W.Z(:))
           S = STREAMobj(FD,W);
           
           prompt = {'Enter variable name:'};
           title = 'Export';
           lines = 1;
           def = {'S'};
           answer = inputdlg(prompt, title, lines, def);
           if ~isempty(answer) &amp&amp isvarname(answer{1})
               assignin('base',answer{1},S);
           else
               return
           end
       else
           warndlg('No streams available for export.');
       end
   end
<font color="blue">    function writetoexcel(src,event) </font>
       
       
       if isempty(IXchannel)
           warndlg('No streams available for export.');
       else
           [D,header] = makedataset(IXchannel,distance);
           D = [header; num2cell(D)];
           
           [FileName,PathName] = uiputfile({'*.xlsx';'*.xls'},'Write to Excel');
           
           if FileName == 0
               return
           end
           
           xlswrite([PathName FileName],D);
       
       end
   end
<font color="blue">    function writetotxtfile(src,event) </font>

       if isempty(IXchannel)
           warndlg('No streams available for export.');
          
       else
           [D,header] = makedataset(IXchannel,distance);            
           [FileName,PathName] = uiputfile({'*.txt'},'Write to text file');
           
           if FileName == 0
               return
           end
           
           fid = fopen([PathName FileName], 'w');
           
           for r = 1:numel(header);
               fprintf(fid, header{r});
               if r &amplt numel(header)
                   fprintf(fid, '\t');
               end 
           end
           fprintf(fid, '\n');
           for row=1:size(D,1);
               fprintf(fid, '%d\t%f\t%f\t%f\t%f\t%f\t%f\n', D(row,:));
           end
           fclose(fid);
       
       end
   end
<font color="blue">    function writetoshape(src,event) </font>
       if isempty(IXchannel)
           warndlg('No streams available for export.');
       elseif ~(exist('shapewrite','file')==2);
           warndlg('The function shapewrite is not available. Shapewrite is part of the Mapping Toolbox.');
       else
           
           
           for r = 1:numel(IXchannel);
               SHP(r).Geometry = 'Line';
               [SHP(r).X SHP(r).Y] = ind2coord(DEM,IXchannel{r}(:)); 
               SHP(r).X = SHP(r).X';
               SHP(r).Y = SHP(r).Y';
               SHP(r).ID = r;
               SHP(r).minZ = double(min(DEM.Z(IXchannel{r})));
               SHP(r).maxZ = double(max(DEM.Z(IXchannel{r})));
               SHP(r).length = double(max(distance{r})-min(distance{r}));
               SHP(r).tribtoID = double(LOGgrid(IXchannel{r}(end)));
               if SHP(r).tribtoID == SHP(r).ID;
                   SHP(r).tribtoID = 0;
               end
           end
           [FileName,PathName] = uiputfile('*.shp','Write to Shapefile');
           
           if FileName == 0
               return
           end
           
           shapewrite(SHP,[PathName FileName]);
       end
 
   end
<font color="blue">    function changelinecolor(src,event) </font>
       
       
       I = src == hButtonColors;
       props.linecolor = colors(I);
       
       h = findobj(hButtonColors,'Checked','on');
       set(h,'Checked','off');
       set(src,'Checked','on');
   end
 
<font color="blue">    function [D,header] = makedataset(IXchannel,distance) </font>
               
       A = flowacc(FD);
       G = FLOWobj2gradient(FD,DEM);
       D = cell(numel(IXchannel),1);
       for r = 1:numel(IXchannel);
           D{r}(1:numel(IXchannel{r}),1) = repmat(r,numel(IXchannel{r}),1);
           [D{r}(:,2) D{r}(:,3)] = ind2coord(DEM,IXchannel{r}(:));            
           D{r}(:,4) = distance{r}(:);
           D{r}(:,5) = DEM.Z(IXchannel{r}(:));
           D{r}(:,6) = A.Z(IXchannel{r}(:)).*(DEM.cellsize).^2;
           D{r}(:,7) = G.Z(IXchannel{r}(:));
       end
       
       D = cell2mat(D);
       header = {'ID' 'X' 'Y' 'upstream_distance' 'elevation' 'upslope_area' 'slope'};
  
   end
       
nd
       
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/flowpathapp.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="preprocessapp">
<H2>preprocessapp</H2></A>
<font color="blue">function preprocesstool(DEM) </font>
 interactive tool for hydrological conditioning

 Syntax

     preprocesstool(DEM)

 Description

     preprocesstool starts an interactive tool that enables the
     hydrological conditioning of a DEM using sink filling and carving. 

 Input arguments

     DEM    digital elevation model (class: GRIDobj)

 See also: FLOWobj/imposemin, GRIDobj/fillsinks


 Author: Wolfgang Schwanghart (w.schwanghart[at]geo.uni-potsdam.de)
 Date: 17. April, 2013
arginchk(1,1)
alidateattributes(DEM,{'GRIDobj'},{},'preprocesstool','DEM',1)
ui_preprocess(DEM);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/preprocessapp.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="showmethods">
<H2>showmethods</H2></A>
<font color="blue">function showmethods(classname) </font>
 displays class method names and H1 lines in the command line

 Syntax

     showmethods(classname)

 Description

     showmethods outputs a list of methods available for a specific class
     (e.g. GRIDobj) in the command window. Only the methods are listed
     that feature an H1 line, e.g., the first line of the help text block
     in a function.

 Input arguments

     classname     string with class name (e.g. GRIDobj, FLOWobj)

 Example

     showmethods('GRIDobj')

 See also: methods, properties, class
 
 Author: Wolfgang Schwanghart (w.schwanghart[at]geo.uni-potsdam.de)
 Date: 21. June, 2013
arginchk(1,1)
 = methods(classname);
 = cellfun(@(x) numel(x),m,'uniformoutput',true);
axmethcharacter = max(C);
or r = 1:numel(m)
   s = which([classname '/' m{r}]);
   fileID = fopen(s,'r');
   H1line = false;
   
   try
       while ~H1line &amp&amp ~feof(fileID)
           tline = fgetl(fileID);
           if isempty(tline)
               continue
           end
           if strcmp(tline(1),'%');
               H1line = true;
           end
       end
       
       if feof(fileID)
           fclose(fileID);
           continue
       end
       
       methodstr = m{r};
       if numel(methodstr)&amplt= maxmethcharacter;
           methodstr = [methodstr repmat(' ',1,maxmethcharacter - numel(methodstr))]; %#ok&ampltAGROW&ampgt
       end
       
       h1str = tline(3:end);
                       
       disp([ upper(methodstr) ' : ' h1str]);
       fclose(fileID);
       
   catch
       disp(m{r})
   end
   
   
nd
           
          
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/showmethods.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="slopearea">
<H2>slopearea</H2></A>
<font color="blue">function OUT = slopearea(S,DEM,A,varargin) </font>
 slope-area relation of a stream network

 Syntax

     SA = slopearea(S,DEM,A)
     SA = slopearea(S,DEM,A,pn,pv,...)
 
 Description

     The relation between upslope area and stream gradient usually follows 
     a power law. This function examines this relation using a stream 
     network, a DEM (from which stream gradient is derived), and upslope 
     area. The function aggregates gradient values into area bins and fits
     a power law. The data (binned values, statistical parameters and
     measures) are returned in the structure array SA.
     
 Input arguments

     S    stream network (class: STREAMobj)
     DEM  digital elevation model (class: GRIDobj)
     A    flow accumulation as derived from the function flowacc
          (class: GRIDobj). 
     
     parameter name/value pairs {default}

     'areabins'       number of bins used to aggragate upslope area {100}.
                      Note that the value supplied might differ from the
                      final number of bins, since only the bins are
                      returned that contain data.
     'areabinlocs'    determines the way, how the area values of the bin
                      centers are derived. Default is {'median'}, e.g.,
                      each bin center is ultimately derived by calculating
                      the median of the area values in each bin. 'mean' 
                      uses the average of all area values. 'center'
                      determines the location of the bin center by as the 
                      0.5*(edge(i)+edge(i+1)) where edge contains the area
                      values that limit each bin.
     'gradaggfun'     determines how slope values are aggragated in each
                      bin. Can be either {'mean'} or 'median'.
     'fitmethod'      by default, this function uses a nonlinear fitting
                      approach to avoid error bias introduced by taking
                      the logarithms of gradient and area. The nonlinear
                      regression lets you choose between least squares 
                      {'ls'}, and least absolute deviations 'lad'. If you
                      prefer a linear fit using least squares with 
                      logtransformed data, set this option to 'logtrls'.
     'theta'          by default []. Provide a positive value (e.g. 0.45)
                      to only fit the scale parameter keeping the exponent
                      at a fixed value.
     'hist2'          if the option 'plot' is true, setting hist2 to true
                      will result in a 2d density plot to visualize the
                      distribution of the point cloud of the entire data.
                      Default is {'false'}.
     'histbins'       two element vector with number of bins used for the 
                      2d histogram. Default ist [100 100], where the first
                      element refers to the number of bins used for area
                      and the second element refers to the number of bins
                      used for counting gradient values.
     'plot'           Plot it. Default is {true}.
     'mingradient'    Set minimum gradient {0.0001} since fitting does not
                      allow gradients &amplt= 0 
     'streamgradient' {'forward'} or 'robust'. See the parameter method of
                      the function STREAMobj/gradient for further
                      explanations.

 Output arguments

     SA   structure array with following fields

          .a       binned area values
          .g       aggregated gradients
          .ks      channel steepness index 
          .theta   channel concavity (note that this parameter is (against
                   convention reported as a negative value).
          .hHist   surface handle to the histogram, if plotted
          .hPoints line handle to the binned, empirical data, if plotted
          .hLine   line handle to the fitted line, if plotted

 Example

     DEM = GRIDobj('srtm_bigtujunga30m_utm11.tif');
     % This DEM is not well suited to show an application of slope area
     % plots. The DEM has various sinks located along streams resulting in
     % many zero gradients. 
     FD  = FLOWobj(DEM,'preprocess','c');
     A   = flowacc(FD);
     S   = STREAMobj(FD,A&ampgt1000);     
     SA  = slopearea(S,DEM,A);

 Remark

     In case you are unsatisfied by the line fitted to the data or in case
     you require confidence intervals of the parameters, please use the
     functions nlinfit or nlintool with following syntax. nlinfit will
     allow you several more options for fitting and robust analysis. Note
     that both functions require the statistics toolbox, however.

     [beta,R,J,CovB,MSE,ErrorModelInfo] = nlinfit(...
                SA.a,SA.g,@(b,x) b(1)*x.^b(2),[SA.ks SA.theta]);

     or 

     nlintool(SA.a,SA.g,@(b,x) b(1)*x.^b(2),[SA.ks SA.theta],0.05,...
                'area','gradient')

     


 See also: slopearea, chiplot

 Author: Wolfgang Schwanghart (w.schwanghart[at]geo.uni-potsdam.de)
 Date: 4. June, 2015
arginchk(3,inf)
 Parse Inputs
 = inputParser;         
.FunctionName = 'slopearea';
alidstreamgradient = {'forward' 'centered' 'robust'};
alidareabinlocs = {'center' 'median' 'mean'};
alidgradaggfun  = {'mean','median'};
alidfitmethods  = {'ls','lad','logtrls'};
ddParamValue(p,'streamgradient','forward',@(x) ischar(validatestring(x,validstreamgradient)));
ddParamValue(p,'drop',10,@(x) isscalar(x) &amp&amp x&ampgt0);
ddParamValue(p,'imposemin',true,@(x) isscalar(x));
ddParamValue(p,'areabins',100,@(x) isscalar(x) || isempty(x));
ddParamValue(p,'areabinlocs','median',@(x) ischar(validatestring(x,validareabinlocs)));
ddParamValue(p,'gradaggfun','mean',@(x) ischar(validatestring(x,validgradaggfun)));
ddParamValue(p,'fitmethod','ls',@(x) ischar(validatestring(x,validfitmethods)));
ddParamValue(p,'theta',[],@(x) isscalar(x) &amp&amp x&ampgt0);
ddParamValue(p,'hist2',false,@(x) isscalar(x));
ddParamValue(p,'plot',true,@(x) isscalar(x));
ddParamValue(p,'mingradient',0.0001, @(x) isscalar(x));
ddParamValue(p,'histbins',[100 100], @(x) ismember(numel(x),[1 2]) &amp&amp all(x&ampgt0));
arse(p,varargin{:});
radmeth    = validatestring(p.Results.streamgradient,validstreamgradient);
reabinlocs = validatestring(p.Results.areabinlocs,validareabinlocs);
radaggfun  = validatestring(p.Results.gradaggfun,validgradaggfun);
itmethod   = validatestring(p.Results.fitmethod,validfitmethods);
 validate alignment
alidatealignment(S,DEM)
alidatealignment(DEM,A);
 = gradient(S,DEM,'unit','tangent',...
                  'method',gradmeth,...
                  'drop',p.Results.drop,...
                  'imposemin',p.Results.imposemin);
 evaluate               
    = A.Z(S.IXgrid).*(A.cellsize).^2;
ina = min(a);
axa = max(a);
f p.Results.hist2;
   copya = a;
   copyg = g;
nd
 bin area values
f ~isempty(p.Results.areabins);
   
   edges = logspace(log10(mina-0.1),log10(maxa+1),p.Results.areabins+1);
   [~,ix] = histc(a,edges);
   
   switch areabinlocs
       case 'mean'
           a = accumarray(ix,a,[p.Results.areabins 1],@mean,nan);
       case 'median'
           a = accumarray(ix,a,[p.Results.areabins 1],@median,nan);
       case 'center'
           a = edges(1:end-1) + diff(edges)/2;
           if a(end) == maxa;
               a(end) = nan;
           end
           a = a(:);
   end
   
   switch gradaggfun
       case 'mean'
           g = accumarray(ix,g,[p.Results.areabins 1],@(x) mean(x(~isnan(x))),nan);
       case 'median'
           g = accumarray(ix,g,[p.Results.areabins 1],@(x) median(x(~isnan(x))),nan);
      
   end
   
   I = ~isnan(a) &amp ~isnan(g);
   a = a(I);
   g = g(I);
   
   
   
nd
(g&amplt=0) = p.Results.mingradient;
UT.a = a;
UT.g = g;
f p.Results.plot
   ax = gca;
nd
 2d Histogram
f p.Results.hist2 &amp&amp p.Results.plot;
   edgesa = logspace(floor(log10(mina)),ceil(log10(maxa)),p.Results.histbins(1));
   [~,ixa] = histc(copya,edgesa);
   
   ming = min(copyg);
   ming = max(ming,p.Results.mingradient);    
   maxg = max(copyg);
   edgesg = logspace(floor(log10(ming)),ceil(log10(maxg)),p.Results.histbins(2));
   
   [~,ixg] = histc(copyg,edgesg);
   
   N   = accumarray([max(ixg(:),1) ixa(:)],1,p.Results.histbins,@sum,0);
   OUT.hHist = pcolor(ax,edgesa,edgesg,N);
   
   colormap(flipud(gray));
   shading flat
   colorbar
   hold on
nd
   
 Plot dots
f p.Results.plot
   OUT.hPoints = plot(ax,a,g,'s');
   xlabel('area');
   ylabel('slope')
nd
% Fitting
 gradient 
 = max(g,p.Results.mingradient);
f isempty(p.Results.theta) 
   % Both parameters may vary
   
   % find starting values using a least squares fit on log transformed data
   beta0 = [ones(numel(a),1) log(a(:))]\log(g);
   beta0(1) = exp(beta0(1));
   
   % fit power law S = k*A^(-mn)
   switch fitmethod
       case 'logtrls'
           beta = beta0;
       case 'ls'
           beta = fminsearch(@(beta) sum((g - beta(1)*a.^beta(2)).^2),beta0);
       case 'lad'
           beta = fminsearch(@(beta) sum(abs(g - beta(1)*a.^beta(2))),beta0);
   end
   
   OUT.ks = beta(1);
   OUT.theta = beta(2);
lse
   % theta is fixed
   
   % slope residuals
   theta = -p.Results.theta;
   gres  = g./(a.^theta);
   
   % find starting values using a least squares fit on log transformed data
   beta0 = mean(gres);
   
   % fit power law S = k*A^(-mn)
   switch fitmethod
       case 'logtrls'
           beta = beta0;
       case 'ls'
           beta = fminsearch(@(beta) sum((g - beta*a.^theta).^2),beta0);
       case 'lad'
           beta = fminsearch(@(beta) sum(abs(g - beta*a.^theta)),beta0);
   end
   
   OUT.ks = beta(1);
   OUT.theta = theta;
nd
% Plot
f p.Results.plot
   hold on
   aeval = logspace(log10(min(a)),log10(max(a)),10);
   geval = OUT.ks(1)*aeval.^OUT.theta;
   OUT.hLine = plot(ax,aeval,geval,'k-','LineWidth',1.5);
   
   set(ax,'Xscale','log','Yscale','log');
   hold off
nd
        
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/slopearea.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="slopeareatool">
<H2>slopeareatool</H2></A>
<font color="blue">function slopeareatool(FD,DEM,varargin) </font>
 Interactively create slope area plots and fit power laws

 Syntax
     
     slopeareatool(FD,DEM)
     slopeareatool(FD,DEM,'pn','pv',...)

 Description

     slopeareatool is an interactive tool to map streams and flowpaths and
     simultaneously plot area vs. gradient. Mapping can be done using up
     to five different plot colors so that user-defined groups of streams
     can be created. A curve-fitting scheme allows to fit group-specific
     power laws (S = beta(1) A^(beta(2)) and thus enables to compare these
     groups based on the derived parameters beta.

 Input arguments

     FD    Flow direction (FLOWobj)
     DEM   digital elevation  model (GRIDobj)

     Parameter name/value pairs
  
     minarea        minimum upslope area for stream grid derivation in 
                    map units^2. If set, channelhead are snapped to the
                    streams.
     maxarea        maximum upslope area in map units^2. Must not be 
                    less than minarea (may be set if only interested in
                    tributary streams)
     nrbins         nr of bins ({500}) between minium and maximum of 
                    upslope grid. If minarea/maxarea are set, the bins are
                    distributed with logarithmic spacing between minarea 
                    and maxarea.
     mingradient    minimum gradient. Since negative or zero gradients
                    will not be displayed in loglog space, they will be
                    increased to minimum gradient ({0.0001})
     fitmethod      see help slopearea for description


 See also: slopearea, chiplot

 Author: Wolfgang Schwanghart (w.schwanghart[at]geo.uni-potsdam.de)
 Date: 19. June, 2013
 = inputParser;
.FunctionName = 'slopeareatool';
ddRequired(p,'FD',@(x) isa(x,'FLOWobj'));
ddRequired(p,'DEM',@(x) isa(x,'GRIDobj'));
alidfitmethods  = {'ls','lad'};
ddParamValue(p,'minarea',0,@(x) isscalar(x));
ddParamValue(p,'maxarea',inf,@(x) isscalar(x));
ddParamValue(p,'nrbins',50,@(x) isscalar(x));
ddParamValue(p,'mingradient',0.0001,@(x) isscalar(x) &amp&amp x&ampgt0);
ddParamValue(p,'fitmethod','ls');
arse(p,FD,DEM,varargin{:});
 required
D         = p.Results.FD;
EM        = p.Results.DEM;
inarea    = p.Results.minarea;
axarea    = p.Results.maxarea;
rbins     = p.Results.nrbins;
itmethod = validatestring(p.Results.fitmethod,validfitmethods);
 validate alignment of FD and DEM
alidatealignment(FD,DEM)
 If you set fastindexing to true then downstream processing is much faster
 for tools that do computations along single flow paths such as
 flowpathextract
D.fastindexing = true;
 create figure
crsz = get(0,'ScreenSize');
 pos = [left, bottom, width, height]
Fig = figure('OuterPosition',[1/8*scrsz(3) 1/3*scrsz(4) 2/4*scrsz(3) 2/3*scrsz(4)],...
             'MenuBar','none',...
             'NumberTitle','off',...
             'Name','Main');
         
         
 create menu
MenuView    = uimenu(hFig,'Label','Change color'); 
ButtonMenuColor = uimenu(hMenuView,'Label','Marker Color'); 
olors = 'kbgyr';
olornames = {'black' 'blue' 'green' 'yellow' 'red'};
 Default line color
rops.linecolor = 'k';
ButtonColors(1) = uimenu(hButtonMenuColor,'Label',colornames{1},'Checked','on','Callback',@(src,event) changelinecolor(src,event)); 
ButtonColors(2) = uimenu(hButtonMenuColor,'Label',colornames{2},'Checked','off','Callback',@(src,event) changelinecolor(src,event));
ButtonColors(3) = uimenu(hButtonMenuColor,'Label',colornames{3},'Checked','off','Callback',@(src,event) changelinecolor(src,event));
ButtonColors(4) = uimenu(hButtonMenuColor,'Label',colornames{4},'Checked','off','Callback',@(src,event) changelinecolor(src,event));
ButtonColors(5) = uimenu(hButtonMenuColor,'Label',colornames{5},'Checked','off','Callback',@(src,event) changelinecolor(src,event));
ButtonClear = uimenu(hMenuView,'Label','Clear','Callback',@(src,event) clearvectorplots);  
MenuFit =   uimenu(hFig,'Label','Curve fitting','Enable','off');
MenuExport  = uimenu(hFig,'Label','Export','Enable','off');
     
         
         
 calculate hillshade
GB  = imageschs(DEM,DEM);
 calculate terrain attributes
 Upslope area (we will use pixel units and switch to map units when plotting)
 = flowacc(FD);
 gradient
EM = imposemin(FD,DEM,0.0000001);
 = FLOWobj2gradient(FD,DEM);
 Set minarea and maxarea to pixel units
inarea = minarea/(A.cellsize^2);
axarea = maxarea/(A.cellsize^2);
% Maximum upslope area set?
f isinf(maxarea);
   maxarea = max(A);
lseif maxarea &amplt minarea
   error('TopoToolbox:slopeareatool','maxarea must be larger than minarea')
lse
   FD.ixcix(A.Z&ampgtmaxarea) = 0;  
nd    
% Snapping
f minarea &ampgt 0;
   % calculate stream grid
   if minarea &amplt 10;
       warning('TopoToolbox:slopeareatool','minimum area is quite small')
   end
   W = A.Z&ampgt(minarea) &amp A.Z&amplt(maxarea);
   
   RGB(repmat(W,[1 1 3])) = 150;    
   [~,SNAPRASTER] = bwdist(W,'q');
   snap = true;
lse
   minarea = 1;
   snap = false;
nd
   
% Plot hillshade and magnifying tool   
 create empty axes in figure
 hAx = axes('parent',hFig);
Ax = imgca(hFig);
 show hillshade using imshow
Im = image(RGB,'parent',hAx);
 create an instance of imscrollpanel and use the API
Panel = imscrollpanel(hFig,hIm);
pi    = iptgetapi(hPanel);
 set to initial magnification
ag    = api.findFitMag();
pi.setMagnification(mag);
 create magnification box in another window
MagBox = immagbox(hFig,hIm);
os     = get(hMagBox,'Position');
et(hMagBox,'Position',[0 0 pos(3) pos(4)])
FigOV = imoverview(hIm);
 create slope area figure
AxProfiles = createSlopeAreaFigure;
% distribute figures on screen
 distFig('Position','L','Only',[hFig],'Rows',1)
 distFig('Position','R','Only',[hFigOV hFigProfiles],'Rows',2)
% add callbacks
nterFcn = @(figHandle, currentPoint)...
      set(hFig, 'Pointer','crosshair');
ptSetPointerBehavior(hIm,enterFcn);
ptPointerManager(hFig);
lim = get(hIm,'XData');
lim = get(hIm,'YData');
 = 1:xlim(2);
 = 1:ylim(2);
et(hFig,'WindowButtonDownFcn',@PressLeftButton);
% Predefine variables
Xchannelhead = 0;
ounter = 0;
olor   = [];
Xchannel = {};
eta  = zeros(2,numel(colors));
Plot = [];
PlotProfiles = [];
PlotFit = inf(numel(colors),1);
LegendFit = [];
ButtonFit = [];
ButtonExport = [];
% Create bins
 binning
edges  = logspace(floor(log10(minarea-.01)),ceil(log10(maxarea+1)),nrbins+1)';
centers = aedges + [diff(aedges)/2;0];
   %% Subfunctions
<font color="blue">    function PressLeftButton(src,evt) </font>
       
       % get the axis position
       cp = get(hAx,'CurrentPoint');
       
       % get pixel locations
       cp = cp(1,1:2);
       pixelx = round(axes2pix(xlim(2), xlim, cp(1)));
       pixely = round(axes2pix(ylim(2), ylim, cp(2)));
       
       % check if current point is located inside axis
       if pixelx &amplt xlim(1) || pixelx &ampgt xlim(2) ...
               || pixely &amplt ylim(1) || pixely &ampgt ylim(2)
           
       else
           % call function
           IXchannelhead(:) = sub2ind(DEM.size,pixely,pixelx);
           counter = counter + 1;
           
           % snap to stream
           if snap
               IXchannelhead(:) = SNAPRASTER(IXchannelhead);
           end
           
           PlotProfiles
       end
       
   end
<font color="blue">    function PlotProfiles </font>
       % get coordinates of mouse click
       if A.Z(IXchannelhead) &ampgt maxarea;
           counter = counter-1;
           return
       elseif FD.ixcix(IXchannelhead) == 0
           counter = counter -1;
           return
       end
       
       % get indices of flow path
       IXchannel{counter} = flowpathextract(FD,IXchannelhead);
       FD.ixcix(IXchannel{counter}) = 0;
       
       % color
       color(counter) = strfind(colors,props.linecolor);
       
       if counter == 1;
           set(hMenuFit,'Enable','on')
           hButtonFit = uimenu(hMenuFit,'Label',['Fit to ' colornames{color(counter)} ' data'],'Callback',@(src,event) fitline(src,event,color(counter)));
           
           set(hMenuExport,'Enable','on')
           hButtonExport = uimenu(hMenuExport,'Label',['Export ' colornames{color(counter)} ' streams as STREAMobj to workspace'],'Callback',@(src,event) exporttoworkspace(src,event,color(counter))); 
       elseif ~ismember(color(end),color(1:end-1));
           hButtonFit(end+1) = uimenu(hMenuFit,'Label',['Fit to ' colornames{color(counter)} ' data'],'Callback',@(src,event) fitline(src,event,color(counter)));
           hButtonExport(end+1) = uimenu(hMenuExport,'Label',['Export ' colornames{color(counter)} ' streams as STREAMobj to workspace'],'Callback',@(src,event) exporttoworkspace(src,event,color(counter)));
       end
       
       % bin area values
       [~,ix]  = histc(A.Z(IXchannel{counter}),aedges);
       ix = ix(:);
       I  = ix&ampgt0;
       I(end) = false;
       IXchannel{counter}(~I) = [];
       
       try
           g  = accumarray(ix(I),double(G.Z(IXchannel{counter})),[numel(aedges) 1],@(x) mean(double(x)),nan);
       catch %#ok&ampltCTCH&ampgt
           counter = max(counter - 1,0);
           return
       end
       
       
       % plot flow path
       hold(hAx,'on')
       [r,c] = ind2sub(DEM.size,IXchannel{counter});
       % let the new flow path blink
       hPlot(counter) = plot(hAx,X(c),Y(r),props.linecolor,'LineWidth',2);
       pause(.1)
       set(hPlot(counter),'Color','w');
       pause(.2)
       set(hPlot(counter),'Color',props.linecolor);
       drawnow
       hold(hAx,'off');
       
       % Slope area plot
       if ~ishandle(hAxProfiles);
           hAxProfiles = createSlopeAreaFigure;
       end
       
       hold(hAxProfiles,'on')
       hPlotProfiles(counter) = loglog(hAxProfiles,acenters*(A.cellsize^2),g,'s',...
           'MarkerSize',8,...
           'MarkerEdgeColor',props.linecolor,...
           'MarkerFaceColor','none');%props.linecolor
       hold(hAxProfiles,'off');
       drawnow
       
       
   end
<font color="blue">    function changelinecolor(src,event) </font>
       
       I = src == hButtonColors;
       
       props.linecolor = colors(I);
       
       h = findobj(hButtonColors,'Checked','on');
       set(h,'Checked','off');
       set(src,'Checked','on');
       
   end
<font color="blue">    function fitline(src,event,colornum) </font>
       
       switch get(src,'Checked')
           case 'off'
               
               linecolor = colors(colornum);
               
               % fit line
               IXchannel = IXchannel(:);
               IX = cell2mat(IXchannel(color == colornum));
               IX = unique(IX);
               
               S  = convert2STREAMobj(FD,IX);
               SA = slopearea(S,DEM,A,...
                   'plot',false,...
                   'mingradient',p.Results.mingradient,...
                   'fitmethod',fitmethod,...
                   'streamgradient','forward',...
                   'gradaggfun','mean');
               
               beta(:,colornum) = [SA.ks SA.theta]'; 
               
               geval = beta(1,colornum)*((acenters*(A.cellsize^2)).^beta(2,colornum));
               
              
               hold(hAxProfiles,'on')
               hPlotFit(colornum) = plot(hAxProfiles ,acenters*(A.cellsize^2),geval,linecolor,'LineWidth',1.5);
               hold(hAxProfiles,'off')
               
              
               
               % redraw legend         
               if ~isempty(hLegendFit)
               else
                   delete(hLegendFit);
                   hLegendFit = [];
               end
                   
               legplothandle = [];
               M = {};
               for r = 1:numel(colors)
                   if ishandle(hPlotFit(r))
                       legplothandle(end+1) = hPlotFit(r);
                       M{end+1} = ['S = ' num2str(beta(1,r)) ' A^{' num2str(beta(2,r)) '}'];
                   end
               end
               if any(legplothandle)
                   hLegendFit = legend(legplothandle,M,'location','northeast');
               end
               
               
               set(src,'Checked','on');
               
               
           case 'on'
               set(src,'Checked','off');
               
               delete(hPlotFit(colornum))
               hPlotFit(colornum) = inf;
               
               % redraw legend         
               if ~isempty(hLegendFit)
               else
                   delete(hLegendFit);
                   hLegendFit = [];
               end
                   
               legplothandle = [];
               M = {};
               for r = 1:numel(colors)
                   if ishandle(hPlotFit(r))
                       legplothandle(end+1) = hPlotFit(r);
                       M{end+1} = ['S = ' num2str(beta(1,r)) ' A^{' num2str(beta(2,r)) '}'];
                   end
               end
               if any(legplothandle)
                   hLegendFit = legend(legplothandle,M,'location','northeast');
               end
               
       end
   end
<font color="blue">    function exporttoworkspace(src,event,colornum) </font>
       linecolor = colors(colornum);
       % fit line
       IXchannel = IXchannel(:);
       IX = cell2mat(IXchannel(color == colornum));
       IX = unique(IX);
       
       S  = convert2STREAMobj(FD,IX);
       
       prompt = {'Enter variable name:'};
       title = 'Export';
       lines = 1;
       def = {['S' linecolor]};
       answer = inputdlg(prompt, title, lines, def);
       if ~isempty(answer) &amp&amp isvarname(answer{1})
           assignin('base',answer{1},S);
       else
           return
       end
   end
       
       
<font color="blue">    function clearvectorplots </font>
       delete(hPlot);
       hPlot = [];
       if ishandle(hPlotProfiles)
           delete(hPlotProfiles)
       end
       hPlotProfiles = [];
       delete(hPlotFit(ishandle(hPlotFit)))
       hPlotFit = inf(numel(colors),1);
       counter = 0;
       color   = [];
       FD.fastindexing = true;
       
       if snap
           FD.ixcix(~W) = 0;
       end
       
       IXchannel = {};
       
       set(hMenuFit,'Enable','off');
       delete(hButtonFit);
       hButtonFit = [];
       
       set(hMenuExport,'Enable','off');
       delete(hButtonExport);
       hButtonExport = [];
       
       if ~isempty(hLegendFit)
           delete(hLegendFit);
           hLegendFit = [];
       end
   end
<font color="blue">    function S = convert2STREAMobj(FD,IX) </font>
       
       WW = DEM;
       WW.Z = false(DEM.size);
       WW.Z(IX) = true;
       
       S  = STREAMobj(FD,WW);
   end
       
<font color="blue">    function hAxProfiles = createSlopeAreaFigure </font>
       %% create figure for profiles
       hFigProfiles = figure('name','Slope-Area Plot'); 
       hAxProfiles = axes('Parent',hFigProfiles,'Xscale','log','Yscale','log','box','on');
       xlabel(hAxProfiles,'Area [m^2]')
       ylabel(hAxProfiles,'Gradient [mm^{-1}]')
   end
       
       
       
nd
       
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/slopeareatool.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="ttbenchmark">
<H2>ttbenchmark</H2></A>
<font color="blue">function C = ttbenchmark </font>
oad exampledem
EM = GRIDobj(X,Y,dem);
lear X Y dem
or r = 1:6;
   
   C{r+1,1} = DEM.size;
   C{r+1,2} = prod(C{r+1,1});
   
   C{1,3} = 'FLOWobj';
   F = @() FLOWobj(DEM,'PreProcess','Carve',...
                      'mex',false);    
   C{r+1,3} = timeit(F);
   
   C{1,4} = 'FLOWobj (mex)';
   F = @() FLOWobj(DEM,'PreProcess','Carve',...
                      'mex',true);    
   C{r+1,4} = timeit(F);
   
   C{1,5} = 'flowacc';
   FD = FLOWobj(DEM,'PreProcess','Carve',...
                      'mex',true); 
   F = @() flowacc(FD);
   C{r+1,5} = timeit(F);
   
   
   % resample dem
   
   DEM = resample(DEM,2);    
nd
oglog(cell2mat(C(2:end,2)),cell2mat(C(2:end,3)),'-sk')
old on
oglog(cell2mat(C(2:end,2)),cell2mat(C(2:end,4)),'-sr')
label('# of cells');
label('time [s]');
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/tools_and_more/ttbenchmark.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="usersguide_1_intro">
<H2>usersguide_1_intro</H2></A>
% User Guide to TopoToolbox - Introduction

 &amplt&ampltTopoToolbox.png&ampgt&ampgt

 TopoToolbox provides a set of Matlab functions that support the analysis
 of relief and flow pathways in digital elevation models. The major 
 aim of TopoToolbox is to offer helpful analytical GIS utilities in a 
 non-GIS environment in order to support the simultaneous application
 of GIS-specific and other quantitative methods. 

 TopoToolbox is written in the Matlab language and requires the Image
 Processing Toolbox for various functions.

% TopoToolbox 2

 TopoToolbox version 2 is a major update to the Toolbox. The main
 difference to previous versions are

 * the introduction of an Object Oriented Programming (OOP) approach and
 the implementation of new classes such as GRIDobj, FLOWobj and STREAMobj.
 All objects carry information (properties) on spatial referencing,
 information that was previously stored using coordinate matrices that
 required large memory space.
 * a new representation of flow direction. TopoToolbox 1 used the sparse
 flow direction matrix to store flow direction and compute flow related
 variables. The new representation allows for much faster function
 evaluation that usually requires much less overhead memory.
 * various GUIs mainly for geomorphological and geomorphometric
 applications which are intended to make various analyses easier and
 faster.
 * higher computational efficiency by coding various functions as C-MEX
 files. Note that these functions should be compiled on your system.
 However, TopoToolbox runs without compilation, yet, less fast.

% TopoToolbox 2: limitations
 
 Flow related algorithms in TopoToolbox 2 recently only support the single
 flow direction (D8) representation. If you are a user of TopoToolbox 1,
 you may see this as a major limitation. Our advice is to keep both the
 last version (1.6) and version 2 on the search path. It will be shown 
 in the next userguide how to use the multiple flow direction algorithm in
 version 2.

% About the User Guide

 This user guide is intended as a basic introduction to the TopoToolbox.
 It won't give a comprehensive overview on the functions available but 
 serves a documentation for a sample session. In addition, this user guide
 provides an account for the command-line based tools of TopoToolbox only. 
 It does not expand upon the use of the GUIs.

% Load a DEM into Matlab

 TopoToolbox 2 reads the ESRI ascii grid format and single band geotiffs 
 into an instance of GRIDobj. 

 *Note that, throughout the use of TopoToolbox, it is assumed that the DEM
 has a projected coordinate system (e.g. UTM WGS84) and that elevation and 
 horizontal coordinates are in meter units.*

EM = GRIDobj('srtm_bigtujunga30m_utm11.tif');
%
 DEM is now an instance of the class |GRIDobj|. DEM contains various
 properties that contain the gridded data and information on the spatial
 referencing of the grid.

EM
%
 The data is stored in the property |.Z|. You can access it using linear
 indexing, subscripts or logical indexing as you are used to do with
 standard Matlab matrices and arrays. E.g. the upper-left 5x5 pixel in the
 grid can be accessed by following command.

EM.Z(1:5,1:5)
%
 GRIDobj is associated with various methods. Some of these methods
 overwrite existing builtin functions (e.g. |plus|, |minus|, |isnan|) or
 functions that ship with previous versions of TopoToolbox (e.g.
 |gradient8|, |curvature|, |fillsinks|). Here is an overview of the
 methods (functions) associated with |GRIDobj|
ethods GRIDobj
% View the DEM

 Matlab provides numerous ways to display gridded data (images). Among
 these are |imagesc|, |surf|, |pcolor|, |imshow|, etc. 
 TopoToolbox overwrites only |imagesc| and |surf|
magesc(DEM)
%
 Note that the axes contain the x and y coordinates and that the axes are
 set to image (axis image).

 Another useful function is imageschs which displays an instance of
 |GRIDobj| and overlays it with the DEM. Here we display the slope (see
 function |gradient8|) overlayn with the hillshade calculated from DEM.
 For visualization purposes the color range is restricted to slopes less
 than 1 m/m.
mageschs(DEM,min(gradient8(DEM),1))
%
 If none of the available visualization functions are what you are looking
 for, you can simply convert your DEM to the standard representation using
 GRIDobj2mat. The function returns two coordinate vectors and a matrix
 with values. Here we crop our DEM to a smaller extent beforehand.
EMc = crop(DEM,sub2ind(DEM.size,[1 50],[1 50]));
Z,x,y] = GRIDobj2mat(DEMc);
urf(x,y,double(Z))
%
 Note: See the help of the function |crop| on other ways to clip your data
 to a desired extent.
% Topographic attributes
 Topographic attributes are derivatives obtained from a DEM such as slope,
 exposition or curvature. We assume that you are familiar with the meaning
 of these attributes and you will notice must of the functions by their
 function name such as

 * |gradient8| -&ampgt as opposed to the Matlab builtin gradient function,
 |gradient8| calculates the gradient in 8 possible directions for each
 cell.
 * |curvature| -&ampgt the second derivative of a DEM.
 * |roughness| -&ampgt allows you calculate various roughness indices related
 to intercell, topographic variability such as ruggedness etc.
 * |aspect| -&ampgt slope exposition
 * and many more

% Export an instance of GRIDobj to the disk

 TopoToolbox ships with two functions for writing instances of GRIDobj
 back the hard drive so that they can be read by standard GIS software
 such as ArcGIS etc.

RIDobj2ascii(DEMc,'test.txt');
RIDobj2geotiff(DEMc,'test.tif');
%
 Note that writing geotiffs is possible without having the mapping toolbox
 available, however, TopoToolbox will then write an image with a tfw-file
 (worldfile). See help |GRIDobj2geotiff| for details.
% Fill sinks

 Often DEMs feature erroneous topographic depressions that should be
 filled prior to flow path computation. You can fill sinks using the
 function |fillsinks|. Note that in some situations it is more appropriate
 to not fill sinks but to carve the DEM which will be shown below (see
 section on FLOWobj).
EMf = fillsinks(DEM);
% FLOWobj and flow related functions

 Users of previous versions of TopoToolbox will remember that flow
 direction was stored as a sparse matrix that contained the information of
 the directed acyclic graph of the flow network. TopoToolbox 2 uses a
 novel technique to store flow direction that allows for easy coding and
 fast performance. Flow direction is stored as a new object, |FLOWobj|, an
 instance of which is derived from an existing DEM (instance of
 |GRIDobj|).

 Here is a fast way to calculate flow accumulation based on the previously
 sink filled DEM. The flow accumulation grid is dilated a little bit, so
 that flow paths are more easily appreciated in the figure.
D = FLOWobj(DEMf);
  = flowacc(FD);
mageschs(DEM,dilate(sqrt(A),ones(5)),'colormap',flipud(copper));
%
 When creating an instance of |FLOWobj|, you can set numerous options that 
 are summarized in the help of |FLOWobj|. 
% Methods associated with FLOWobj

 Various methods exist that operate on instances of FLOWobj to obtain flow
 related variables such as drainage basin delineation, flow accumulation, 
 etc. Here is an overview

ethods FLOWobj
%
 Now, let's calculate the drainage basins of the DEM. This can be done
 using the function |drainagebasins|. You may want to shuffle the colors
 so that the drainage basins can be more easily distinguished in a plot
 (|shufflelabel|). As a small exercise, let's denote the area of each 
 basin in the map. 
B = drainagebasins(FD);
B = shufflelabel(DB);
%
 Easy until here. Now let's get the area and display
 it together with the drainage basins map. Display only
 numbers for drainage basins larger than 10 km^2.
rDB = numel(unique(DB.Z(:)))-1; % nr of drainage basins
TATS = regionprops(DB.Z,'PixelIdxList','Area','Centroid');
mageschs(DEM,DB);
old on
or run = 1:nrDB;
   if STATS(run).Area*DB.cellsize^2 &ampgt 10e6;
       [x,y] = ind2coord(DB,...
           sub2ind(DB.size,...
           round(STATS(run).Centroid(2)),...
           round(STATS(run).Centroid(1))));
       text(x,y,...
           num2str(round(STATS(run).Area * DB.cellsize^2/1e6)),...
           'BackgroundColor',[1 1 1]);
   end
nd
old off
itle('drainage basins (numbers refer to drainage basin area in km^2)')
%
 It may also be interesting to know the distance from each drainage basin
 outlet in upstream direction along the flow network.

 = flowdistance(FD);
mageschs(DEM,D);
%
 You can use the output of flowdistance to calculate the area function
 which is the distribution of flow distances to the outlet of a specific
 basin. Let's take the largest basin in our study site.
~,IX] = max([STATS.Area]);
ist(D.Z(DB.Z == IX),1000);
label('distance to outlet [m]');
label('# cells');
% STREAMobj - a class for stream networks

 While FLOWobj stores the information on the entire flow network on
 hillslopes and in channels, STREAMobj is a class that is used to analyze 
 the channelized part of the flow network only. The storage strategy is
 very similar to the one of the class FLOWobj.

 Again, various methods (functions) are associated with STREAMobj that
 allow for manipulating, plotting and retrieving information on the stream
 network geometry and patterns.

 There are various ways to extract the channelized flow network from DEMs.
 In this example we simply use an area threshold.
 calculate flow accumulation
 = flowacc(FD);
 Note that flowacc returns the number of cells draining
 in a cell. Here we choose a minimum drainage area of 10000 cells.
 = A&ampgt10000;
 create an instance of STREAMobj
 = STREAMobj(FD,W);
 and plot it
lot(S)
%
 STREAMobj stores various properties some of which you might use to
 directly access if you want to customize your code or build your own
 functions. Please check the help of STREAMobj.
%
 Now let's extract the largest subnetwork of the channel network. 
 = klargestconncomps(S,1);
lot(S)
%
 and let's plot flow distance along the stream network versus elevation.
lotdz(S,DEM)
%
 If you have a license of Matlab's Mapping Toolbox you can export the
 stream network to a shapefile to be read by other GIS software. First,
 you need to create a mapstruct, a structure array used by the mapping
 toolbox to store vector data. Then use shapewrite to write the mapstruct
 to a shapefile.
S = STREAMobj2mapstruct(S);
hapewrite(MS,'testshape.shp')
% Reference

 Schwanghart, W., Kuhn, N.J. (2010): TopoToolbox: a set of Matlab
 functions for topographic analysis. Environmental Modelling &amp Software,
 25, 770-781. [DOI: 10.1016/j.envsoft.2009.12.002]
% History

 This user guide was updated last: June 19, 2013.
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/usersguide_1_intro.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="usersguide_2_flats">
<H2>usersguide_2_flats</H2></A>
% User Guide to TopoToolbox - Processing flats

 Flat areas are challenging when calculating flow directions in a DEM
 since flow directions cannot be derived from a simple neighborhood
 search. Thus, different techniques exist to process flats and some of
 them are implemented in TopoToolbox.

 Note that you should have Matlab R2011b to run this demo.
% Identify flats
 
 Hydrological conditioning is usually applied to preprocessing a DEM. The
 most common technique is sink filling (|fillsinks|) to remove spurious
 pits. Sink filling, in turn creates flats.

 Let's first load the Baranja Hill model
oad baranja_hill
urf(X,Y,dem);
xaggerate(gca,1);
hading interp; camlight
 for zooming
xtent = {[6551884,6553799.03205128],[5072228.94341349,5074170.03032261]};
%
 The first step is to fill all sinks. We can calculate the fill depth by
 subtracting the filled DEM from the original DEM.
emf = fillsinks(dem);
Z   = demf-dem;
mageschs(X,Y,dem,DZ);
olorbar
itle('sink depth [m]')
%
 We can also create a mask that indicates flat pixels using the function
 |identifyflats|. You can see that there are various flat areas with 
 different extents. Some of them are single pixels only, others comprise 
 large contiguous areas. As long as flats are not regional minima, each
 flat should have one or several sills pixels, e.g. pixels adjacent to
 flats with a downward neighbor.
FLATS,SILLS]    = identifyflats(demf);
mageschs(X,Y,dem,FLATS+2*SILLS);
itle('flat areas (1) and sills (2)')
% Three methods to process flats

 There a three methods implemented in TopoToolbox to process flats.

 # |crossflats|
 # |routeflats|
 # |routegeodesic|

 All of them are called from within |flowdir| or |flowdir_single|.
% Crossflats

 |crossflats| is the most basic way to process flats. Basically, it
 doesn't even try to assign flow directions to flat pixels, but it just 
 establishes flow connectivity between pixels entering flats and sill
 pixels. 
c = flowdir(X,Y,demf,'routeflats','cross','type','single');
mageschs(X,Y,dem);
old on
plot(Mc,[X(:) Y(:)],'k');
old off
etextent(extent)
% 
 While this is a fast method to route through flats, it may not be suited
 for many applications and visualizations.
% Routeflats

 |routeflats| uses a recursive upstream processing to establish flow paths
 through flats. The algorithm starts at sill pixels and then finds its way
 upstream. The advantage of the algorithm is its speed. It is reasonably
 fast and would be even faster, if it was implemented as MEX-file.
 Its major disadantage is, that it doesn't process flats that are
 connected to the edge of the DEM.
r = flowdir(X,Y,demf,'routeflats','route','type','single');
mageschs(X,Y,dem);
old on
plot(Mr,[X(:) Y(:)],'k');
old off
etextent(extent)
% Routegeodesic

 The most elegant way to route through flats is implemented in
 |routegeodesic|. The algorithm uses an auxiliary topography in flats
 based on least cost paths where the costs are calculated from the
 complemented distance transform. This generates flow paths that run along
 the centerline of sinks and produces the best looking and probably most
 realistic flow path representation through flat areas.

g = flowdir(X,Y,demf,'routeflats','geodesic','type','single');
mageschs(X,Y,dem);
old on
plot(Mg,[X(:) Y(:)],'k');
old off
etextent(extent)
% Compare the three

 Now let's visually compare the three algorithms using flow accumulation.
c = flowacc(Mc,size(dem));
r = flowacc(Mr,size(dem));
g = flowacc(Mg,size(dem));
igure
urf(X,Y,dem,log(Ac));
xaggerate(gca,1);
hading interp; camlight
itle('crossflats')
igure
urf(X,Y,dem,log(Ar));
xaggerate(gca,1);
hading interp; camlight
itle('routeflats')
igure
urf(X,Y,dem,log(Ag));
xaggerate(gca,1);
hading interp; camlight
itle('routegeodesic')
%
lose all
% History

 This user guide was updated last: November 1, 2011.
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/usersguide_2_flats.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="usersguide_2_mfd">
<H2>usersguide_2_mfd</H2></A>
% TopoToolbox 2 - calculating the multiple flow direction

 &amplt&ampltTopoToolbox.png&ampgt&ampgt


 With the introduction of TopoToolbox 2, the new FLOWobj does only support
 the single (D8) flow direction algorithm. If you have been a user of
 TopoToolbox 1 and require the multiple flow direction (MFD) algorithm,
 please read these pages.
% Requirements

 If you want to use the MFD algorithm with TopoToolbox 2, you must have a 
 previous version (e.g. TopoToolbox 1.6) on your search path.
% Here is how to do it

 get the coordinate vectors and the DEM in the format required by the
 function flowdir
dem,X,Y] = GRIDobj2mat(fillsinks(DEM));
 use meshgrid to calculate coordinate matrices
X,Y] = meshgrid(X,Y);
 calculate the flow direction matrix M
 = flowdir(X,Y,double(dem));
%
 Now you should calculate the desired topographic attribute directly from
 M, e.g. flow accumulation
  = flowacc(M,size(dem));
%
 and convert the output back to a GRIDobj.
  = GRIDobj(X,Y,A);
 if there is projection information in the property .georef, you can copy
 it from the DEM.
.georef = DEM.georef;
 and plot it
mageschs(DEM,log(A));
%
 and this is it.
% Future developments
 The fact, that TT2 currently does not support the MFD algorithm is
 unsatisfactory. We are currently working on including MFD in
 future version of TT.
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/usersguide_2_mfd.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="usersguide_3_ksn">
<H2>usersguide_3_ksn</H2></A>
% User Guide to TopoToolbox - Plotting ksn-values

 &amplt&ampltTopoToolbox.png&ampgt&ampgt

% Background

 Stream profiles carry information on tectonic and/or climatic
 perturbations in the form of knickpoints migrating in upstream direction.
 Plotting ksn-values provides a means to quantify deviations from the
 logarithmic channel length profile and thus enables to detect and
 visualize these locations in the stream network.

 The basic assumption behind ksn-values is that the stream power model of
 sediment transport/incision applies, e.g., sediment transport or incision 
 are functions of the energy expenditure of water when moving downstream. 
 In a landscape evolution context, the stream power model is written in
 following (simplified) form

 $$\frac{dz}{dt} = U - k A^m \left( \frac{dz}{dx} \right)^n$$

 where $U$ refers to the uplift rate, $A$ is the upslope area, $dz/dx$ is
 the slope and $k$, $m$ and $n$ are coefficients. In steady state the
 processes uplift and incision are in equilibrium such that $dz/dt = 0$ at
 each point along the profile. Hence, the equation is rearranged

 $$\left( \frac{dz}{dx} \right)^n = \frac{U}{k A^m}$$

 $$\frac{dz}{dx} = \left( \frac{U}{k} \right)^{1/n} A^{-n/m}$$

 The terms are rewritten so that

 $$S = k_{sn} A^{-\theta}$$

 and

 $$k_{sn} = \frac{S}{A^{-\theta}}$$

 where $k_{sn}$ refers to the normalized channel steepness and $\theta$ to
 the channel concavity. $\theta$ ranges between 0.3 and 0.8 and often
 takes on the value 0.45. It can be determined either based on slope-area
 plots (see function slopearea) or $\chi$-plots (see function chiplot).

% Load and generate required data

EM = GRIDobj('srtm_bigtujunga30m_utm11.tif');
D  = FLOWobj(DEM,'preprocess','carve');
   = flowacc(FD);
%
 The quality of the DEM is relatively bad, so we correct it by imposing a
 downward minimum gradient.
EM = imposemin(FD,DEM,0.0001);
%
 Subsequently, we extract a stream network by thresholding flow
 accumulation. In this example, we simply assume that channels occupy
 cells that have a minimum upslope area of 1000 pixels.
  = STREAMobj(FD,'minarea',1000);
 = klargestconncomps(S,1);
% 
 We modify the stream network somewhat so that we avoid to include the
 alluvial areas in the most downstream portion of the profile. 
 = modify(S,'distance',10000);
%
 In order to remove small stream sections we again extract the largest
 connected component of the network
 = klargestconncomps(S,1);
mageschs(DEM);
old on
lot(S,'k')
old off
%
lotdz(S,DEM)
% Calculating the concavity index

 After extracting the channel network of interest, we calculate the
 concavity index $\theta$ using the slopearea function.
 *Note that* slopearea returns the concavity index $\theta$ including its 
 negative sign!
TATS = slopearea(S,DEM,A)
% Calculate and plot ksn values

 Subsequently, we calculate the ksn-values for the entire grid. While this
 won't make sense for hillslope sections, our aim is to generate a grid
 that we can later reference with the stream network (STREAMobj).
   = gradient8(DEM);
SN = G./(A.*(A.cellsize^2)).^STATS.theta;
x,y,ksn] = STREAMobj2XY(S,KSN);
catter(x,y,5,ksn,'filled')
axis([0 2000])
itle('ksn values')
ox on
olorbar
xis image
% Aggregate ksn values in stream segments

 Note that in the above figure each channel location in the grid is
 plotted. There are two problems arising from doing so. First, owing to
 the high point density in the xy plane some of the points and their color
 may not be visible due to overlapping. Second, owing to the poor quality
 of the DEM the ksn-values are strongly variable at short distances. Note 
 the large variability in the main river trunk! To avoid both problems,
 ksn values should be generalized along stream segments. This is achieved
 with the function STREAMobj2mapstruct. Here we use a stream segment
 length of 1 km (1000 m).
S = STREAMobj2mapstruct(S,'seglength',1000,'attributes',...
   {'ksn' KSN @mean ...
    'uparea' (A.*(A.cellsize^2)) @mean ...
    'gradient' G @mean});
% Plot stream segments

 MS is a mapstruct that you can plot using mapshow and makesymbolspec.
 Both functions are available with the mapping toolbox. We use a coloring
 based on percentiles of the data.
ymbolspec = makesymbolspec('line',...
   {'ksn' [min([MS.ksn]) max([MS.ksn])] 'color' jet(6)});
mageschs(DEM,DEM,'colormap',gray,'colorbar',false);
apshow(MS,'SymbolSpec',symbolspec);
% Export as shapefile

 Alternativly, you may want to choose another software to visualize the
 stream network together with ksn values. In order to do so, you will need
 the function shapewrite available with the mapping toolbox (in case you
 don't have access to the toolbox, check the Mathworks fileexchange for
 functions with same functionality). 

 shapewrite(MS,'ksn_testshape.shp');
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/flood_module_Anz/code/topotoolbox/usersguide_3_ksn.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_meteorite_hazard_set">
<H2>climada_meteorite_hazard_set</H2></A>
<font color="blue">function hazard=climada_meteorite_hazard_set </font>
 climada
 NAME:
   climada_meteorite_hazard_set
 PURPOSE:
   generate the meteorite hazard event set

   first, create a centroids file prior to calling this code:
   ...data/system/Meteorite_centroids.xls

   for 1'000'000 events:
       generation of 1000000 events took 0.107830 sec
       latitude/longitude conversion took 0.620342 sec
       diameter conversion took 1.090989 sec
       CalculationUnit interpolation took 13996.156000 sec (almost 4h)
       37272 (100.00%) CalculationUnits hit (by 1390444 events)
       matrix density 0.0037%
       storing as C:\Data\climada\climada_data\hazards\MEXX_B_Probabilistic_1e6.mat ...
       for the Test ptf: loss calculation took 10.275969 seconds, based
       upon 5000000 events @ 279 locations
 CALLING SEQUENCE:
   hazard=climada_meteorite_hazard_set
 EXAMPLE:
   hazard=climada_meteorite_hazard_set
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   hazard: a climada hazard set structure, stored automatically also 
       in ...data/hazards... struct fields are:
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one - here all=0
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY: 
 David N. Bresch, david.bresch@gmail.com, 20130317, based on work back in 20080801
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/meteorite/code/climada_meteorite_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measure_viewer">
<H2>climada_measure_viewer</H2></A>
<font color="blue">function varargout = climada_measure_viewer(varargin) </font>
 climada_measure_viewer MATLAB code for climada_measure_viewer.fig
      climada_measure_viewer, by itself, creates a new climada_measure_viewer or raises the existing
      singleton*.

      H = climada_measure_viewer returns the handle to a new climada_measure_viewer or the handle to
      the existing singleton*.

      climada_measure_viewer('CALLBACK',hObject,eventData,handles,...) calls the local
      function named CALLBACK in climada_measure_viewer.M with the given input arguments.

      climada_measure_viewer('Property','Value',...) creates a new climada_measure_viewer or raises the
      existing singleton*.  Starting from the left, property value pairs are
      applied to the GUI before climada_measure_viewer_OpeningFcn gets called.  An
      unrecognized property name or invalid value makes property application
      stop.  All inputs are passed to climada_measure_viewer_OpeningFcn via varargin.

      *See GUI Options on GUIDE's Tools menu.  Choose &quotGUI allows only one
      instance to run (singleton)&quot.

 See also: GUIDE, GUIDATA, GUIHANDLES
 MODULE:
   viewer
 NAME:
   climada_measure_viewer
 PURPOSE:
   plots entities, assets and damage
 CALLING SEQUENCE:
   climada_measure_viewer
EXAMPLE
   climada_measure_viewer
 INPUT:
   (all inputs are asked for by the GUI)
   entity: an entity structure, see e.g. climada_entity_load and climada_entity_read
   measures_impact: a measures_impact structure, e.g. produced by salvador_calc_measures
   type: must be specified from 'assets','benefits' and 'damage'
   unit: must be specified from 'USD' or 'people'
   timestamp: position in the measures_impact that is selected, e.g. can be specified from
                  1- current state
                  2- economic growth
                  3- moderate climate change
                  4- extreme climate change
    
  index_measures:  can be selected from a certain measure (see measure list in the measures_impactfile), default =1;
  categories:      Select a certain category from the list


 OUTPUTS:
   Graphical result
 OPTIONAL OUTPUTS:
   A .mat file with the current selection
   An excel with the curretn selection
   A .kmz file with the current selection
 MODIFICATION HISTORY:
 Jacob Anz, j.anz@gmx.net, 20151106 init
 Jacob Anz, j.anz@gmx.net, 20151203 set new structure, make ready to process San Salvador and Barisal results
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/climada_measure_viewer.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_value_sum">
<H2>climada_value_sum</H2></A>
<font color="blue">function selection= climada_value_sum(entity,measures_impact,type,unit,timestamp,index_measures,handles) </font>
 % MODULE:
   viewer
 NAME:
   climada_value_sum
 PURPOSE:
   Select all values for a specific output of one unit (USD/people) 
   like assets, benefit or damage
 CALLING SEQUENCE:
   selection= climada_value_sum(entity,measures_impact,type,unit,timestamp,index_measures,handles)
EXAMPLE
   selection= climada_value_sum(entity,measures_impact,'assets','USD',1);
 INPUT:
   entity: an entity structure, see e.g. climada_entity_load and
       climada_entity_read
   measures_impact: a measures_impact structure, e.g. produced by salvador_calc_measures
   type: must be specified from 'assets','benefits' and 'damage'
   unit: must be specified from 'USD' or 'people'
   timestamp: identifies the position of the chosen EDS in the measures
   impact struct, e.g. can be specified from
                  1- current state
                  2- economic growth
                  3- moderate climate change
                  4- extreme climate change
                    (default is 1)
  index_measures: can be selected from a certain measure (see measure list in the measures_impactfile), default =1;
  
                 
 OPTIONAL INPUT PARAMETERS:
   handles: only used if called from the GUI (measures_viewer)
 OUTPUTS:
   selection: structure with .lon (.point_lon), .lat (.point_lat) and .value (.point_value) variables from the
   current selected values.
 MODIFICATION HISTORY:
 Jacob Anz, j.anz@gmx.net, 20151106 init
 Jacob Anz, j.anz@gmx.net, 20151203 modified the input so that
 climada_assets_select can be called if categories are not numbers but
 names

f ~climada_init_vars,return;end % init/import global variables
initialize
topper=0; index_USD=[]; index_people=[];
derive list of measures
   for i=1:length(measures_impact(timestamp).EDS)
       index_measures_list{i,1}=measures_impact(timestamp).EDS(i).annotation_name;
   end
default values
f ~exist('unit','var'); unit='USD';end
f ~exist('timestamp','var'); timestamp=1;end
f ~exist('type','var'); type='assets';end
f ~exist('index_measures','var'); index_measures=1;end
detection of peril
f exist('measures_impact','var')
   rb_peril=measures_impact(timestamp).peril_ID;
   message1=sprintf('recognized %s peril',rb_peril);
   message2=sprintf('Measure %s selected',index_measures_list{index_measures,1});
   message=[message1 ' and ' message2];
   
   %interaction with GUI (measures_viewer)
   try 
       set(handles.text15,'String',message);
   catch
       msgbox(message);
   end
nd
ategories=unique(entity.assets.Category);
f iscell(categories)
   categories{length(categories)+1}='all categories';
lse
   categories(length(categories)+1)=length(categories)+1;
nd
automatical detection of position of value_unit: USD or people
or i=1:length(categories)-1
   if iscell(categories)   
       pos=find(strcmp(entity.assets.Category,categories(i)));
       posi=pos(1);
       position{i}=entity.assets.Value_unit{posi};
   else
       pos=(find(entity.assets.Category==categories(i)));
       posi=pos(1);
       position{i}=entity.assets.Value_unit{posi};
   end
nd
   position{length(position)+1}='all categories with same unit';
or i=1:length(categories)
   if iscell(categories)
       string_vec{i}=[categories{i} '-' position{i}];
   else
       string_vec{i}=[num2str(categories(i)) ' - ' position{i}];
   end
nd
or i=1:length(string_vec)-1
   if findstr(string_vec{i},'USD')&ampgt=1
       index_USD(i)=i;
   elseif findstr(string_vec{i},'people')&ampgt=1
       index_people(i)=i;
   end
nd
ndex_USD(index_USD==0)=[];index_people(index_people==0)=[];
ategory_list_usd=categories(index_USD)';category_list_people=categories(index_people)';
f strcmp(unit,'USD')
   temp_ind_cat=category_list_usd; 
lseif strcmp(unit,'people')
   temp_ind_cat=category_list_people;
nd
   t.coord_tot=[];t.value_tot=[];
   %main part, climada_assets_select is called
   if iscell(temp_ind_cat)
           for counter=1:length(temp_ind_cat)
         
               is_selected = climada_assets_select(entity,rb_peril,unit,temp_ind_cat(counter));
               if strcmp(type,'assets');
                   coord(:,1)=entity.assets.lon(is_selected);
                   coord(:,2)=entity.assets.lat(is_selected);
                   value=entity.assets.Value(is_selected);
               elseif strcmp(type,'damage');
                  coord(:,1)= measures_impact(timestamp).EDS(index_measures).assets.lon(is_selected);
                  coord(:,2)= measures_impact(timestamp).EDS(index_measures).assets.lat(is_selected);
                  value=measures_impact(1).EDS(1).ED_at_centroid(is_selected);
               elseif strcmp(type,'benefit');
                   stopper=stopper+1;
                   if stopper==1;
                       for i=1:length(measures_impact(1).EDS)
                           benefit{i}=measures_impact(1).EDS(length(measures_impact(1).EDS)).ED_at_centroid-measures_impact(1).EDS(i).ED_at_centroid;
                       end
                   end
                  coord(:,1)= measures_impact(timestamp).EDS(index_measures).assets.lon(is_selected);
                  coord(:,2)= measures_impact(timestamp).EDS(index_measures).assets.lat(is_selected);
                  value= benefit{1,index_measures}(is_selected);
               end
                  t.coord_tot=[t.coord_tot;coord];
                  t.value_tot=[t.value_tot;value];
                  clear is_selected coord value
           end
                      
    else
           for index_cat=temp_ind_cat
               is_selected = climada_assets_select(entity,rb_peril,unit,index_cat);
               if strcmp(type,'assets');
                   coord(:,1)=entity.assets.lon(is_selected);
                   coord(:,2)=entity.assets.lat(is_selected);
                   value=entity.assets.Value(is_selected);
               elseif strcmp(type,'damage');
                  coord(:,1)= measures_impact(timestamp).EDS(index_measures).assets.lon(is_selected);
                  coord(:,2)= measures_impact(timestamp).EDS(index_measures).assets.lat(is_selected);
                  value=measures_impact(1).EDS(1).ED_at_centroid(is_selected);
               elseif strcmp(type,'benefit');
                   stopper=stopper+1;
                   if stopper==1;
                       for i=1:length(measures_impact(1).EDS)
                           benefit{i}=measures_impact(1).EDS(length(measures_impact(1).EDS)).ED_at_centroid-measures_impact(1).EDS(i).ED_at_centroid;
                       end
                   end
                  coord(:,1)= measures_impact(timestamp).EDS(index_measures).assets.lon(is_selected);
                  coord(:,2)= measures_impact(timestamp).EDS(index_measures).assets.lat(is_selected);
                  value= benefit{1,index_measures}(is_selected);
               end
                  t.coord_tot=[t.coord_tot;coord];
                  t.value_tot=[t.value_tot;value];
                  clear is_selected coord value
           end
    end
      
   [~,~,idx]=unique(t.coord_tot,'rows','stable');
   t_max=max(idx);
   for j=1:t_max
       t_indx{j}=find(idx==j);
   end
   
   for j=1:length(t_indx)
           selection.point_value(j)=sum(t.value_tot(t_indx{j}));
           selection.point_lon(j)=unique(t.coord_tot(t_indx{j},1));
           selection.point_lat(j)=unique(t.coord_tot(t_indx{j},2));
   end
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/climada_value_sum.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_LS_screw">
<H2>salvador_LS_screw</H2></A>
<font color="blue">function [screw_mod, screw_ext] = salvador_LS_screw </font>
 create moderate and extreme climate change screw for LS San Salvador
 NAME:
   salvador_LS_screw
 PURPOSE:
   create moderate and extreme climate change screw for LS San Salvador
 CALLING SEQUENCE:
   [screw_mod, screw_ext] = salvador_LS_screw
 EXAMPLE:
   [screw_mod, screw_ext] = salvador_LS_screw
 INPUTS:
   none, input is hardwired in the code
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   screw_mod: a screw structure for moderate climate change, that fits
   as input for climada_hazard_climate_screw.m. A 1xN structure with fields:
       .hazard_fld     defines the hazard field to be changed
       .change         extent of the change at time horizon
       .year           time horizon
       .hazard_crit    hazard field to which criteria apply
       .criteria       criteria for events/locations to change
       .bsxfun_op      operation of change (e.g. @times,@plus) (function handle)
   screw_ext: a screw for extreme climate change
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Jacob Anz, 20150923, init
 Lea Mueller, muellele@gmail.com, 20150924, add documentation
 Lea Mueller, muellele@gmail.com, 20151022, increase frequency and use stable intensity for cc scenarios
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/salvador_LS_screw.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_TC_screw">
<H2>salvador_TC_screw</H2></A>
<font color="blue">function [screw_mod, screw_ext] = salvador_TC_screw </font>
 create moderate and extreme climate change screw for TC San Salvador
 NAME:
   salvador_TC_screw
 PURPOSE:
   create moderate and extreme climate change screw for TC San Salvador
 CALLING SEQUENCE:
   [screw_mod, screw_ext] = salvador_TC_screw
 EXAMPLE:
   [screw_mod, screw_ext] = salvador_TC_screw
 INPUTS:
   none, input is hardwired in the code
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   screw_mod: a screw structure for moderate climate change, that fits
   as input for climada_hazard_climate_screw.m. A 1xN structure with fields:
       .hazard_fld     defines the hazard field to be changed
       .change         extent of the change at time horizon
       .year           time horizon
       .hazard_crit    hazard field to which criteria apply
       .criteria       criteria for events/locations to change
       .bsxfun_op      operation of change (e.g. @times,@plus) (function handle)
   screw_ext: a screw for extreme climate change
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Jacob Anz, 20150923, init
 Lea Mueller, muellele@gmail.com, 20150924, add documentation
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/salvador_TC_screw.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_calc_measures">
<H2>salvador_calc_measures</H2></A>
<font color="blue">function salvador_calc_measures(nametag,assets_file,damfun_file,measures_file,results_dir,peril_ID,m_file) </font>
 calculate measures for salvador FL (for now)
 NAME:
   salvador_calc_measures
 PURPOSE:
   calc measures and save reports and figures in a newly created directory
   in results/...
 CALLING SEQUENCE:
   salvador_calc_measures(nametag,assets_file,damfun_file,measures_file,results_dir)
 EXAMPLE:
   salvador_calc_measures('FL_v2',assets_file,damfun_file,measures_file,'20150922_measures_FL_v2')
   salvador_calc_measures('FL',[],[],[], [],'FL','AB2');
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   reports and figures 
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150910, init
 Lea Mueller, muellele@gmail.com, 20150921, use new assets for FL
 Lea Mueller, muellele@gmail.com, 20150921, use new functions salvador_hazard_future_save, salvador_entity_files_set, 
              add diary file, add future scenarios (2040 eco. development, 2040 moderate cc, 2040 extreme cc)
 Lea Mueller, muellele@gmail.com, 20150925, add urban planning (set to nil for 2015), use different 
              hazard_intensity_impact_a for today, moderate and extreme cc
 Lea Mueller, muellele@gmail.com, 20150930, add adaptation_cost_curve for 2040, moderate cc
 Lea Mueller, muellele@gmail.com, 20150930, add special xlim for medidas 1 FL
 Lea Mueller, muellele@gmail.com, 20151020, add switch for peril_IDs (FL, TC, LS_las_canas, LS_acelhuate)
 Lea Mueller, muellele@gmail.com, 20151020, add special xlim for LS_las_canas people
 Lea Mueller, muellele@gmail.com, 20151020, add special xlim for LS_acelhuate people
 Jacob Anz,   j.anz@gmx.net     , 20151021, add input parameter m_file
 Jacob Anz,   j.anz@gmx.net     , 20151026, set xlim_value for TC and cleanup
 Jacob Anz,   j.anz@gmx.net     , 20151026, set special m_file limits only for peril FL
 Lea Mueller, muellele@gmail.com, 20151030, enable to select any entity/assets,damfun (uigetfile)
 Lea Mueller, muellele@gmail.com, 20151106, rename to climada_EDS_ED_per_category_report from salvador_EDS_ED_per_category_report
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_adaptation_bar_chart from climada_adaptation_bar_chart_v2
 Lea Mueller, muellele@gmail.com, 20151217, use climada_global.data_dir instead of project_dir, use climada_assets_read and climada_discount_read instead of climada_entity_read
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/salvador_calc_measures.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_calc_waterfall">
<H2>salvador_calc_waterfall</H2></A>
<font color="blue">function EDS = salvador_calc_waterfall(nametag,assets_file,damfun_file,results_dir, growth_rate_eco, growth_rate_people,peril_ID) </font>
 calculate waterfall graph 
   - for San Salvador 
   - salvador_calc_waterfall.m
   - calculate EDS for today, economic development,
     2040 moderate and 2040 extreme cc
   - for USD and for people
Example
 EDS=salvador_calc_waterfall_2('','','','','','','TC');
Input parameter
 peril_ID = 'LS','FL','TC' ;

 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150901, init
 Lea Mueller, muellele@gmail.com, 20150924, cleanup and add new functions (salvador_entity_files_set, salvador_entity_future_create, salvador_hazard_future_save) 
 Lea Mueller, muellele@gmail.com, 20150924, add diary_file
 Lea Mueller, muellele@gmail.com, 20150925, check damagefunctions
 Lea Mueller, muellele@gmail.com, 20150925, set max_encoding_distance_m to 10^6 if not FL
 Lea Mueller, muellele@gmail.com, 20151020, do not show legend in waterfall graph
 Lea Mueller, muellele@gmail.com, 20151030, enable to select any entity/assets,damfun (uigetfile)
 Lea Mueller, muellele@gmail.com, 20151106, rename to climada_EDS_ED_per_category_report from salvador_EDS_ED_per_category_report
 Lea Mueller, muellele@gmail.com, 20151217, use climada_global.data_dir instead of project_dir, use climada_assets_read and climada_discount_read instead of climada_entity_read
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/salvador_calc_waterfall.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_entity_files_set">
<H2>salvador_entity_files_set</H2></A>
<font color="blue">function [assets_file, damfun_file, measures_file, m_file] = salvador_entity_files_set(assets_file,damfun_file,measures_file,peril_ID,m_file) </font>
 set assets_file, damfun_file and measures_file for San Salvador, depending on peril_ID
 NAME:
   salvador_entity_files_set
 PURPOSE:
   set assets_file, damfun_file and measures_file for San Salvador, depending on peril_ID
 CALLING SEQUENCE:
   assets_file, damfun_file, measures_file] = salvador_entity_files_set(peril_ID,assets_file,damfun_file,measures_file)
 EXAMPLE:
   assets_file, damfun_file, measures_file] = salvador_entity_files_set('TC','','','')
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   assets_file: empty
   damfun_file: empty
   measures_file: empty
   peril_ID: default is 'TC'
   m_file: string, e.g. 'AB1', to tage the measures version in case of FL
 OUTPUTS:
   assets_file: filename of assets, e.g. '20150917_TC\entity_AMSS_WIND_NEW.xlsx' 
   damfun_file: filename of damagefunctions
   measures_file: filename of measures
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller,  muellele@gmail.com, 20150924, init
 Jacob Anz,    j.anz@gmx.net,      20151020, added input m_file and cleanup
 Lea Mueller, muellele@gmail.com, 20151022, add m_file option
 Lea Mueller, muellele@gmail.com, 20151022, default m_file is '', only for FL it is 'AB1'
 Lea Mueller, muellele@gmail.com, 20151030, enable to select any entity/assets,damfun (uigetfile)
 Lea Mueller, muellele@gmail.com, 20151217, rename default files that have been nicely put together, 
         containing assets, damagefunctions, measures, discount all in one excel
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/salvador_entity_files_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_entity_future_create">
<H2>salvador_entity_future_create</H2></A>
<font color="blue">function entity = salvador_entity_future_create(entity, growth_rate_eco, growth_rate_people, peril_ID) </font>
 create future entity for San Salvador
 NAME:
   salvador_entity_future_create
 PURPOSE:
   create and save future entity for San Salvador, based on a growth rate for USD
   values and a growth rate for people, for the timespan from
   climada_global.present_reference_year and climada_global.future_reference_year
 CALLING SEQUENCE:
   entity = salvador_entity_future_create(entity, growth_rate_eco, growth_rate_people, peril_ID)
 EXAMPLE:
   entity = salvador_entity_future_create
 INPUTS:
   none, input is hardwired in the code
 OPTIONAL INPUT PARAMETERS:
   entity: a climada entity structure
   growth_rate_eco: default is 0.04 (4% per year)
   growth_rate_people: default is 0.002 (0.2% per year)
   peril_ID: default is 'FL'
 OUTPUTS:
   entity, a climada entity structure with upscaled values (different for
   USD and people values) for climada_global.future_reference_year
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150924, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/salvador_entity_future_create.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_hazard_future_save">
<H2>salvador_hazard_future_save</H2></A>
<font color="blue">function salvador_hazard_future_save(peril_ID) </font>
 create future hazard for San Salvador (TC, LS_las_canas, LS_acelhuate)
 NAME:
   salvador_hazard_future_save
 PURPOSE:
   create and save future hazard for San Salvador, for TC, LS_las_canas,
   LS_acelhuate, based on climada_global.future_reference_year and
   salvador_LS_screw and salvador_TC_screw
 CALLING SEQUENCE:
   salvador_hazard_future_save(peril_ID)
 EXAMPLE:
   salvador_hazard_future_save
 INPUTS:
   none, input is hardwired in the code
 OPTIONAL INPUT PARAMETERS:
   peril_ID: default is 'TC'
 OUTPUTS:
   none, hazards are created and saved in climada_global.project_dir
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150923, init
 Lea Mueller, muellele@gmail.com, 20151030, hazards can be saved in project_dir or project_dir/hazards
 Lea Mueller, muellele@gmail.com, 20151217, add .scenario 
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/salvador_hazard_future_save.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_resolution_test_LS">
<H2>salvador_resolution_test_LS</H2></A>
 Resolution sensitivity analysis for climada applied to 
 landslides and tropical cyclones in San Salvador
 Lea Mueller, 20160219
 Perform sensitivity analysis for different resolutions for two cases, 
 1) landslides in Las Caas neighborhood in San Salvador and 
 2) tropical cyclones in the metropolitan area of San Salvador (AMSS). 
 Analyzed resolutions range from high resolution (~50 meter), mid 
 resolution (~1 km) to low resolution (~10 km).
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
% landslides
limada_global.max_encoding_distance_m = 10^6;
 load shps files
oad([climada_global.data_dir filesep 'results' filesep 'san_salvador_shps_adm2_rivers_salvador_polygon_LS.mat'])
 landslide hazard las canas
S_hazard_file = [climada_global.data_dir filesep 'hazards' filesep 'Salvador_hazard_LS_las_canas_2015.mat'];
azard = climada_hazard_load('Salvador_hazard_LS_las_canas_2015.mat');
azard = rmfield(hazard,'name');
limada_map_plot(hazard)
azard.intensity_all = sum(hazard.intensity,1);
igure; climada_map_plot(hazard,'intensity_all'); hold on; climada_shapeplotter(polygon_canas,'','lon','lat')
old on; plot(entity_mid_res.assets.lon, entity_mid_res.assets.lat,'x','markersize',12)
eturn_periods = [50 500 1000]; check_plot = 0;
azard_stats = climada_hazard_stats(hazard,return_periods,check_plot);
 high resolution assets
S_entity_file = [climada_global.data_dir filesep 'entities' filesep 'LS_entity_las_canas.xls'];
ntity = climada_entity_read(LS_entity_file,'NOENCODE');
limada_global.markersize = 3;
limada_figuresize(0.6,0.8); climada_map_plot(entity_high_res,'Value','',{'Cat. 31' 'Cat. 32' 'Cat. 33' 'Cat. 34' 'Cat. 35' 'Cat. 36'}); 
 hold on; climada_shapeplotter(polygon_canas,'','lon','lat')
limada_geo_distance(entity_high_res.assets.lon(1), entity_high_res.assets.lat(1), entity_high_res.assets.lon(2), entity_high_res.assets.lat(2))
 figure;climada_shapeplotter(polygon_ilopango,'','lon','lat')
 climada_shapeplotter(shape_rivers)
 rios_25k_shapes = climada_shaperead([salvador_data_dir filesep 'system' filesep 'rios_25k_polyline_WGS84.shp'],1);
 EDS high resolution
nnotation_name = 'high resolution assets';
DS = climada_EDS_calc(entity,hazard,annotation_name);
limada_figuresize(0.6,0.8); climada_map_plot(EDS,'ED_at_centroid','','',{'Cat. 31' 'Cat. 32' 'Cat. 33' 'Cat. 34' 'Cat. 35' 'Cat. 36'});
 adaptation measures high resolution
easures_impact_reference = 'no';
easures_impact_high_res = climada_measures_impact(entity,hazard,measures_impact_reference);
limada_figuresize(0.4,0.9); climada_adaptation_cost_curve(measures_impact_high_res)
 save
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'entity_high_res.mat'],'entity_high_res')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'measures_impact_high_res.mat'],'measures_impact_high_res')
% mid resolution (1km)
 mid resolution assets
dmin0_name = 'El Salvador'; admin1_name = 'San Salvador'; selections = 0; scale_Value = [0 1 0];
ntity_nightlight = climada_nightlight_entity(admin0_name,admin1_name,selections,0,scale_Value);
igure;climada_map_plot(entity_nightlight)
old on; climada_shapeplotter(polygon_canas,'','lon','lat')
limada_geo_distance(entity.assets.lon(1), entity.assets.lat(1), entity.assets.lon(2), entity.assets.lat(2))
limada_geo_distance(entity_mid_res.assets.lon(2), entity_mid_res.assets.lat(2), entity_mid_res.assets.lon(3), entity_mid_res.assets.lat(3))
 filter out 18 points within las caas
 is_inside = inpoly([entity_nightlight.assets.lon; entity_nightlight.assets.lat]', [shapes.lon; shapes.lat]');
s_inside = inpoly([entity_nightlight.assets.lon; entity_nightlight.assets.lat]', [polygon_canas.lon; polygon_canas.lat]');
 create mid_res assets (18 points)
ntity_nightlight.assets.Value_orig = entity_nightlight.assets.Value;
ntity_nightlight.assets.Value(~is_inside)= 0;
ntity_mid_res = entity_high_res;
ssets = entity_nightlight.assets;
ssets.lon = entity_nightlight.assets.lon(is_inside);
ssets.lat = entity_nightlight.assets.lat(is_inside);
ssets.Value = entity_nightlight.assets.Value(is_inside);
ssets.DamageFunID = entity_nightlight.assets.DamageFunID(is_inside);
ssets.DamageFunID = assets.DamageFunID*131;
ssets.Deductible = entity_nightlight.assets.Deductible(is_inside);
ssets.Cover = entity_nightlight.assets.Cover(is_inside);
ssets = rmfield(assets,'Value_orig');
cale_Value = [0 -1.0159e8 2.1351e7 sum(entity_high_res.assets.Value)];
ssets.Value = scale_Value(1) + scale_Value(2)*assets.Value + scale_Value(3)*assets.Value.^2;
ssets.comment=sprintf('%s: y = %2.2f + %2.2f*x^1 + %2.2f*x^2',mfilename,scale_Value(1:3));
f length(scale_Value)==4
   assets.Value = assets.Value/sum(assets.Value)*scale_Value(4); % normalize, multiply
   assets.comment=[assets.comment sprintf(', normalized, then *%2.2f',scale_Value(4))];
nd
ssets.Cover = assets.Value;
ntity_mid_res.assets = assets;
ntity_mid_res.measures = rmfield(entity_mid_res.measures,'regional_scope');
ntity_mid_res.measures.regional_scope = logical(ones(10,9));
limada_global.markersize = 65;
limada_figuresize(0.6,0.8);climada_map_plot(entity_mid_res)
old on; climada_shapeplotter(polygon_canas,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.145 -89.10 13.6895 13.727]); climada_figure_scale_add('',1,1)
 EDS mid resolution
nnotation_name = 'mid resolution assets';
DS(2) = climada_EDS_calc(entity_mid_res,hazard,annotation_name);
limada_global.markersize = 35;
limada_figuresize(0.6,0.8); climada_map_plot(EDS(2),'ED_at_centroid','','');
old on; climada_shapeplotter(polygon_canas,'','lon','lat')
 axis([-89.145 -89.095 13.6895 13.732])
limada_figure_axis_limits_equal_for_lat_lon([-89.145 -89.10 13.6895 13.727]); climada_figure_scale_add('',1,1)
 adaptation measures mid resolution
limada_global.font_scale = 1.4;
easures_impact_reference = 'no';
easures_impact_mid_res = climada_measures_impact(entity_mid_res,hazard,measures_impact_reference);
limada_figuresize(0.4,0.9); climada_adaptation_cost_curve(measures_impact_mid_res)
 save
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'entity_mid_res.mat'],'entity_mid_res')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'EDS.mat'],'EDS')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'measures_impact_mid_res.mat'],'measures_impact_mid_res')
% low resolution
 assets, just one point
ntity_low_res = entity_mid_res;
ntity_low_res.assets.lon = [mean(entity_mid_res.assets.lon) entity_mid_res.assets.lon(:)'];
ntity_low_res.assets.lat = [mean(entity_mid_res.assets.lat) entity_mid_res.assets.lat(:)'];
ntity_low_res.assets.Value = [sum(entity_mid_res.assets.Value) zeros(1,18)];
ntity_low_res.assets.Cover = entity_low_res.assets.Value;
ntity_low_res.assets.DamageFunID = [131 zeros(1,18)]; 
ntity_low_res.assets.Deductible = [0 zeros(1,18)]; 
limada_global.markersize = 120;
limada_figuresize(0.6,0.8);climada_map_plot(entity_low_res)
old on; climada_shapeplotter(polygon_canas,'','lon','lat')
 axis([-89.145 -89.095 13.6895 13.732])
limada_figure_axis_limits_equal_for_lat_lon([-89.145 -89.10 13.6895 13.727]); climada_figure_scale_add('',1,1)
 EDS low resolution
nnotation_name = 'low resolution assets';
DS(3) = climada_EDS_calc(entity_low_res,hazard,annotation_name);
limada_figuresize(0.6,0.8); climada_map_plot(EDS(3),'ED_at_centroid','','');
old on; climada_shapeplotter(polygon_canas,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.145 -89.10 13.6895 13.727]); climada_figure_scale_add('',1,1)
 adaptation measures low resolution
limada_global.font_scale = 1.4;
easures_impact_reference = 'no';
easures_impact_low_res = climada_measures_impact(entity_low_res,hazard,measures_impact_reference);
limada_figuresize(0.4,0.9); climada_adaptation_cost_curve(measures_impact_low_res)
 save
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'entity_low_res.mat'],'entity_low_res')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'EDS.mat'],'EDS')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'measures_impact_low_res.mat'],'measures_impact_low_res')
%
igure;climada_entity_plot(entity_nightlight)
S_entity_file = [climada_global.data_dir filesep 'entities' filesep 'LS_entity_las_canas.xls'];
ntity = climada_entity_read(LS_entity_file,'NOENCODE');
limada_global.markersize = 3;
limada_figuresize(0.6,0.8); climada_map_plot(entity,'Value','',{'Cat. 31' 'Cat. 32' 'Cat. 33' 'Cat. 34' 'Cat. 35' 'Cat. 36'});
limada_geo_distance(entity.assets.lon(1), entity.assets.lat(1), entity.assets.lon(2), entity.assets.lat(2))
 figure;climada_shapeplotter(polygon_LS,'','lon','lat')
 figure;climada_shapeplotter(polygon_ilopango,'','lon','lat')
 climada_shapeplotter(shape_rivers)
 rios_25k_shapes = climada_shaperead([salvador_data_dir filesep 'system' filesep 'rios_25k_polyline_WGS84.shp'],1);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/salvador_resolution_test_LS.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_resolution_test_TC">
<H2>salvador_resolution_test_TC</H2></A>
 Resolution sensitivity analysis for climada applied to 
 landslides and tropical cyclones in San Salvador
 Lea Mueller, 20160219
 Perform sensitivity analysis for different resolutions for two cases, 
 1) landslides in Las Caas neighborhood in San Salvador and 
 2) tropical cyclones in the metropolitan area of San Salvador (AMSS). 
 Analyzed resolutions range from high resolution (~50 meter), mid 
 resolution (~1 km) to low resolution (~10 km).
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
% Tropical cyclones wind
limada_global.font_scale = 1.4;
limada_global.max_encoding_distance_m = 10^6;
limada_global.markersize = 5;
 load shps files
oad([climada_global.data_dir filesep 'results' filesep 'san_salvador_shps_adm2_rivers_salvador_polygon_LS.mat'])
 TC hazard san salvador AMSS
C_hazard_file = [climada_global.data_dir filesep 'hazards' filesep 'Salvador_hazard_TC_2015.mat'];
azard = climada_hazard_load('Salvador_hazard_TC_2015.mat');
 hazard = rmfield(hazard,'name');
limada_map_plot(hazard)
azard.intensity_all = sum(hazard.intensity,1);
igure; climada_map_plot(hazard,'intensity_all'); hold on; climada_shapeplotter(polygon_LS,'','lon','lat')
 hold on; plot(entity_high_res.assets.lon, entity_high_res.assets.lat,'x','markersize',12)
 return_periods = [50 500 1000]; check_plot = 0;
 hazard_stats = climada_hazard_stats(hazard,return_periods,check_plot);
 high resolution assets
C_entity_file = [climada_global.data_dir filesep 'entities' filesep 'TC_entity_AMSS.xls'];
ntity_high_res = climada_entity_read(TC_entity_file,'NOENCODE');
ntity_high_res.assets.Value(entity_high_res.assets.Category==2) = 0;
limada_global.markersize = 6;
limada_figuresize(0.6,0.8); climada_map_plot(entity_high_res,'Value');
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.32 -89.03 13.629 13.84]); climada_figure_scale_add('',1,1)
 polygon_AMSS = climada_shape_selector(gcf,1);
 climada_geo_distance(entity_high_res.assets.lon(1), entity_high_res.assets.lat(1), entity_high_res.assets.lon(2), entity_high_res.assets.lat(2))
 
 climada_geo_distance(entity_high_res.assets.lon(2), entity_high_res.assets.lat(2), entity_high_res.assets.lon(3), entity_high_res.assets.lat(3))
 % figure;climada_shapeplotter(polygon_ilopango,'','lon','lat')
 % climada_shapeplotter(shape_rivers)
 % rios_25k_shapes = climada_shaperead([salvador_data_dir filesep 'system' filesep 'rios_25k_polyline_WGS84.shp'],1);
 EDS high resolution
nnotation_name = 'high resolution assets';
DS = climada_EDS_calc(entity_high_res,hazard,annotation_name);
limada_figuresize(0.6,0.8); climada_map_plot(EDS,'ED_at_centroid');
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.32 -89.03 13.629 13.84]); climada_figure_scale_add('',1,1)
 adaptation measures high resolution
easures_impact_reference = 'no';
easures_impact_high_res = climada_measures_impact(entity_high_res,hazard,measures_impact_reference);
limada_figuresize(0.4,0.9); climada_adaptation_cost_curve(measures_impact_high_res)
 save
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_entity_high_res.mat'],'entity_high_res')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_EDS.mat'],'EDS')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_measures_impact_high_res.mat'],'measures_impact_high_res')
% mid resolution (1km)
 mid resolution assets
dmin0_name = 'El Salvador'; admin1_name = 'San Salvador'; selections = 0; scale_Value = [0 1 0];
ntity_nightlight = climada_nightlight_entity(admin0_name,admin1_name,selections,0,scale_Value);
igure;climada_map_plot(entity_nightlight)
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
igure;climada_entity_plot(entity_nightlight)
ntity_nightlight_2 = climada_nightlight_entity(admin0_name,'La Libertad',selections,0,scale_Value);
igure;climada_map_plot(entity_nightlight_2)
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
 combine the two
ntity_nightlight.assets.Value = [entity_nightlight.assets.Value entity_nightlight_2.assets.Value];
ntity_nightlight.assets.lon = [entity_nightlight.assets.lon entity_nightlight_2.assets.lon];
ntity_nightlight.assets.lat = [entity_nightlight.assets.lat entity_nightlight_2.assets.lat];
 climada_geo_distance(entity.assets.lon(1), entity.assets.lat(1), entity.assets.lon(2), entity.assets.lat(2))
 climada_geo_distance(entity_mid_res.assets.lon(2), entity_mid_res.assets.lat(2), entity_mid_res.assets.lon(3), entity_mid_res.assets.lat(3))
 filter out points within AMSS polygon (648 points)
s_inside = inpoly([entity_nightlight.assets.lon; entity_nightlight.assets.lat]', [polygon_AMSS.lon; polygon_AMSS.lat]');
um(is_inside)
 create mid_res assets (18 points)
ntity_nightlight.assets.Value_orig = entity_nightlight.assets.Value;
ntity_nightlight.assets.Value(~is_inside)= 0;
ntity_mid_res = entity_high_res;
ssets = entity_nightlight.assets;
ssets.lon = entity_nightlight.assets.lon(is_inside);
ssets.lat = entity_nightlight.assets.lat(is_inside);
ssets.Value = entity_nightlight.assets.Value(is_inside);
ssets.DamageFunID = ones(size(assets.Value))*121;
ssets.Deductible = zeros(size(assets.Value));
ssets.Cover = zeros(size(assets.Value));
ssets = rmfield(assets,'Value_orig');
cale_Value = [0 -1.0159e8 2.1351e7 sum(entity_high_res.assets.Value)];
ssets.Value = scale_Value(1) + scale_Value(2)*assets.Value + scale_Value(3)*assets.Value.^2;
ssets.comment=sprintf('%s: y = %2.2f + %2.2f*x^1 + %2.2f*x^2',mfilename,scale_Value(1:3));
f length(scale_Value)==4
   assets.Value = assets.Value/sum(assets.Value)*scale_Value(4); % normalize, multiply
   assets.comment=[assets.comment sprintf(', normalized, then *%2.2f',scale_Value(4))];
nd
ssets.Cover = assets.Value;
ntity_mid_res.assets = assets;
ntity_mid_res.measures = rmfield(entity_mid_res.measures,'regional_scope');
ntity_mid_res.measures.regional_scope = logical(ones(10,9));
limada_global.markersize = 10;
limada_figuresize(0.6,0.8);climada_map_plot(entity_mid_res)
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.32 -89.03 13.629 13.84]); climada_figure_scale_add('',1,1)
 EDS mid resolution
nnotation_name = 'mid resolution assets';
DS(2) = climada_EDS_calc(entity_mid_res,hazard,annotation_name);
limada_figuresize(0.6,0.8); climada_map_plot(EDS(2),'ED_at_centroid','','');
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.32 -89.03 13.629 13.84]); climada_figure_scale_add('',1,1)
 adaptation measures mid resolution
easures_impact_reference = 'no';
easures_impact_mid_res = climada_measures_impact(entity_mid_res,hazard,measures_impact_reference);
limada_figuresize(0.4,0.9); climada_adaptation_cost_curve(measures_impact_mid_res)
 save
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_entity_mid_res.mat'],'entity_mid_res')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_EDS.mat'],'EDS')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_measures_impact_mid_res.mat'],'measures_impact_mid_res')
% low resolution (10 km)
dmin0_name = 'El Salvador'; admin1_name = 'San Salvador'; selections = 10; scale_Value = [0 1 0];
ntity_nightlight_10km = climada_nightlight_entity(admin0_name,admin1_name,selections,0,scale_Value);
igure;climada_map_plot(entity_nightlight_10km)
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
 figure;climada_entity_plot(entity_nightlight_10km)
ntity_nightlight_10km_2 = climada_nightlight_entity(admin0_name,'La Libertad',selections,0,scale_Value);
igure;climada_map_plot(entity_nightlight_10km_2)
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
 combine the two
ntity_nightlight_10km.assets.Value = [entity_nightlight_10km.assets.Value entity_nightlight_10km_2.assets.Value];
ntity_nightlight_10km.assets.lon = [entity_nightlight_10km.assets.lon entity_nightlight_10km_2.assets.lon];
ntity_nightlight_10km.assets.lat = [entity_nightlight_10km.assets.lat entity_nightlight_10km_2.assets.lat];
 filter out points within AMSS polygon (648 points)
olygon_AMSS_buffer = climada_shape_selector(gcf,1);
olygon_AMSS_buffer.lon = polygon_AMSS_buffer.X; polygon_AMSS_buffer.lat = polygon_AMSS_buffer.Y;
s_inside = inpoly([entity_nightlight_10km.assets.lon; entity_nightlight_10km.assets.lat]', [polygon_AMSS_buffer.lon; polygon_AMSS_buffer.lat]');
um(is_inside)
 figure
 plot(entity_nightlight_10km.assets.lon,entity_nightlight_10km.assets.lat,'x')
 hold on
 plot(entity_nightlight_10km.assets.lon(is_inside),entity_nightlight_10km.assets.lat(is_inside),'or')
 create low_res assets (9 points)
ntity_nightlight_10km.assets.Value_orig = entity_nightlight_10km.assets.Value;
ntity_nightlight_10km.assets.Value(~is_inside)= 0;
ntity_low_res = entity_high_res;
ssets = entity_nightlight_10km.assets;
ssets.lon = entity_nightlight_10km.assets.lon(is_inside);
ssets.lat = entity_nightlight_10km.assets.lat(is_inside);
ssets.Value = entity_nightlight_10km.assets.lat(is_inside);
ssets.lon = assets.lon(1:9);
ssets.lat = assets.lat(1:9);
ssets.Value = assets.lat(1:9);
ssets.DamageFunID = ones(size(assets.Value))*121;
ssets.Deductible = zeros(size(assets.Value));
ssets.Cover = zeros(size(assets.Value));
ssets = rmfield(assets,'Value_orig');
cale_Value = [0 -1.0159e8 2.1351e7 sum(entity_high_res.assets.Value)];
ssets.Value = scale_Value(1) + scale_Value(2)*assets.Value + scale_Value(3)*assets.Value.^2;
ssets.comment=sprintf('%s: y = %2.2f + %2.2f*x^1 + %2.2f*x^2',mfilename,scale_Value(1:3));
f length(scale_Value)==4
   assets.Value = assets.Value/sum(assets.Value)*scale_Value(4); % normalize, multiply
   assets.comment=[assets.comment sprintf(', normalized, then *%2.2f',scale_Value(4))];
nd
ssets.Cover = assets.Value;
ntity_low_res.assets = assets;
ntity_low_res.measures = rmfield(entity_mid_res.measures,'regional_scope');
ntity_low_res.measures.regional_scope = logical(ones(7,9));
limada_global.markersize = 60;
limada_figuresize(0.6,0.8);climada_map_plot(entity_low_res)
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.35 -89.03 13.629 13.84]); climada_figure_scale_add('',1,1)
 for i=1:9
     hold on
     text(assets.lon(i),assets.lat(i),sprintf('%d',i))
 end
 assets.Value = [20 50 65 10 27 64 45 15 40];
 EDS low resolution
nnotation_name = 'low resolution assets';
DS(3) = climada_EDS_calc(entity_low_res,hazard,annotation_name);
limada_figuresize(0.6,0.8); climada_map_plot(EDS(3),'ED_at_centroid','','');
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.35 -89.03 13.629 13.84]); climada_figure_scale_add('',1,1)
 adaptation measures low resolution
limada_global.font_scale = 1.4;
easures_impact_reference = 'no';
easures_impact_low_res = climada_measures_impact(entity_low_res,hazard,measures_impact_reference);
limada_figuresize(0.4,0.9); climada_adaptation_cost_curve(measures_impact_low_res)
 save
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_entity_low_res.mat'],'entity_low_res')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_EDS.mat'],'EDS')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_measures_impact_low_res.mat'],'measures_impact_low_res')
%
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/salvador_resolution_test_TC.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="Salvador_movie_tc">
<H2>Salvador_movie_tc</H2></A>
 create movie for salvador TC
 MODULE:
   salvador_demo
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150401, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/Salvador_movie_tc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_ECA_San_Salvador">
<H2>_ECA_San_Salvador</H2></A>
<font color="blue">function [hazard_sets,EDS,centroids,entity]=ECA_San_Salvador(admin_name,... </font>
   adm_lvl,force_centroids_recalc,force_entity_recalc,force_hazard_recalc, check_plots)
 climada
 MODULE:
 NAME:
   ECA_hazard_analysis
 PURPOSE:
   calculate hazard event sets for desired peril for any region of any
   country in the world...
 CALLING SEQUENCE:
   [hazard, EDS, centroids, entity] = ECA_hazard_analysis
 EXAMPLE:
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   adm_lvl: Specify the admin level of interest
       Default:set to level 2
   force_centroids_entity_recalc: Automatically set to 0. Set to 1 if you
       wish to recalculate the centroids and entity, despite the relevant
       files already existing - calculation will take longer.
   force_hazard_recalc: Automatically set to 0. Set to 1 if you
       wish to recalculate the hazards, despite the relevant
       files already existing - calculation will take longer.
 OUTPUTS:
   hazard_sets:    Struct with fields for each peril, e.g.
             .TS:    Storm surge hazard set (with usual fields)
             .TC:    Tropical cyclone hazard set
   EDS:            Struct with fields for each peril, e.g.
             .TS:    Storm surge event damage set
             .TC:    Tropical cyclone event damage set
   centroids:  High resolution centroids
   entity:     High resolution entity
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150508 init
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_generate from climada_generate_centroids
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/_ECA_San_Salvador.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_FL_hazard_correction">
<H2>_FL_hazard_correction</H2></A>
dj = 0;
nt_tmp = full(tmp_hazard.intensity);
nt_    = full(hazard.intensity);
ax_diff = []; %init
0 = clock;
hile etime(clock,t0)&amplt20
   for e_i=1:9
       int_tmp(e_i,:) = max(int_(e_i,:)-(centroids.elevation_m-2),0);
   end
   max_diff(end+1) = abs(max(max(int_ - int_tmp)));
   %fprintf('%2.2f \t',max_diff)
   adj = adj + 0.5;
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/_FL_hazard_correction.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_salvador_EDS_ED_per_category_report_summary">
<H2>_salvador_EDS_ED_per_category_report_summary</H2></A>
<font color="blue">function output_report = climada_EDS_ED_per_category_report(entity,EDS,xls_file,sheet,benefit_flag,percentage_flag,assets_flag) </font>
 climada_EDS_ED_per_category_report
 MODULE:
   salvador_demo
 NAME:
   climada_EDS_ED_per_category_report
 PURPOSE:
   Write out ED per category for one EDS structures into xls file
   previous call: climada_EDS_calc, or climada_EDS_ED_at_centroid_report_xls
 CALLING SEQUENCE:
   output_report = climada_EDS_ED_per_category_report(entity,EDS,xls_file,sheet)
 EXAMPLE:
   output_report = climada_EDS_ED_per_category_report(entity,climada_EDS_calc(entity,hazard))
 INPUTS:
   entity: climada entity structure, with fields entity.assets.Category and entity.assets.Unit
   EDS: either an event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       SPECIAL: we also accept a structure which contains an EDS, like
       measures_impact.EDS
       if EDS has the field annotation_name, the legend will show this
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   xls_file: filename (and path) to save the report to (as .xls), if
       empty, prompted for.Can be set to 'NO_xls_file' to omit creation of
       xls file instead only creates the cell &quotoutput_report&quot
   sheet: sheet name for xls file, if empty, default excel name is &quotSheet1&quot
 OUTPUTS:
   output_report: cell including header and ED values
   report file written as .xls
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150806, init
 Lea Mueller, muellele@gmail.com, 20150831, introduce benefit_flag to calculate benefit (difference AED with measure and AED without measure)
 Lea Mueller, muellele@gmail.com, 20150831, rename climada_assets_select from salvador_assets_select
 Lea Mueller, muellele@gmail.com, 20150831, enhance to cope with multiple EDS
 Lea Mueller, muellele@gmail.com, 20150910, enhance to cope with Category names (cell) instead of numbers
 Lea Mueller, muellele@gmail.com, 20150915, add assets_flag to write out sum of entity.assets.Value per category, as specified in EDS(EDS_i).assets.filename
 Lea Mueller, muellele@gmail.com, 20150922, add filenames (entity.assets, entity.damagefunctions, entity.discount, entity.measures and EDS.hazard)
 Lea Mueller, muellele@gmail.com, 20150924, set silent_mode for climada_assets_select
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/_salvador_EDS_ED_per_category_report_summary.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_salvador_all_in_one">
<H2>_salvador_all_in_one</H2></A>
Salvador calculate all results, graphs and final overview
set entities in
open salvador_entity_files_set
waterfall
DS =salvador_calc_waterfall('TC',[],[],[], [], [],'TC');
DS =salvador_calc_waterfall('FL',[],[],[], [], [],'FL');
DS =salvador_calc_waterfall('LS_canas',[],[],[], [], [],'LS_las_canas');
DS =salvador_calc_waterfall('LS_acelhuate',[],[],[], [], [],'LS_acelhuate');
cascade/measures calc
alvador_calc_measures('TC',[],[],[], [],'TC');
alvador_calc_measures('FL_AB1',[],[],[], [],'FL','AB1');
alvador_calc_measures('FL_AB2',[],[],[], [],'FL','AB2');
alvador_calc_measures('LS_canas',[],[],[], [],'LS_las_canas');
alvador_calc_measures('LS_acelhuate',[],[],[],[],'LS_acelhuate');
Summary of results from all perils in !up_to_date waterfall folder
iwait(msgbox('Please move all generated waterfall folders into the folder &quot!waterfall up to date&quot and than click ok'))
ilepath=salvador_results_overview;
inopen(filepath)
sgbox('After checking the sourcefile destinations, delete them and use the format painter,to bring the file in a nice format')
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/_salvador_all_in_one.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_salvador_entity_read">
<H2>_salvador_entity_read</H2></A>
 ----- not used anymore----------
 read UCA entity for Rio Acelhuate
ntity_dirname  = 'M:\BGCC\CHR\RK\RS\A_Sustainable_Development\Projects\ECA\SanSalvador\consultant_data\entity';
ntity_filename = ['20150720' filesep 'entity_AMSS.xls'];
ntity = climada_entity_read(0,[entity_dirname filesep entity_filename]);
igure
limada_damagefunctions_plot(entity)
% load admin shapes
oad([climada_global.data_dir filesep 'entities' filesep 'SLV_adm' filesep 'SLV_adm2.mat'])
ndx_salvador = find(strcmp({shapes.NAME_1},'San Salvador'));
alvador_module_dir = ['\\CHRB1065.CORP.GWPNET.COM\homes\X\S3BXXW\Documents\lea\climada_git\climada_modules\salvador_demo\data\system'];
hapes_river        = climada_shaperead([salvador_module_dir filesep 'rios_25k_polyline_WGS84.shp']);
limada_shapeplotter(shapes_river)
% create figures with asset maps for different categories
ategories_ = unique(entity.assets.Category);
ax_value   = max(entity.assets.Value);
in_value   = min(entity.assets.Value);
or c_i = 1:numel(categories_)+1
   if c_i&ampgtnumel(categories_)
       indx = logical(entity.assets.lon);
       titlestr = sprintf('All assets');
   else
       indx = entity.assets.Category == categories_(c_i);
       titlestr = sprintf('Category %d',categories_(c_i));
   end
   climada_figuresize(0.3,0.9);
   climada_shapeplotter(shapes_river,'','','','-','color',[0.6 0.6 0.6])
   hold on 
   plotclr(entity.assets.lon(indx),entity.assets.lat(indx),entity.assets.Value(indx),'s',3,1,min_value,max_value);
   title(titlestr)
   climada_shapeplotter(shapes(indx_salvador))
   %axis equal
   %axis([-89.3 -89.05 13.6 13.81])
   box on
   
   %set(gca, 'PlotBoxAspectRatio', [1.3 1 1]);
   axis([-89.26 -89.16 13.67 13.7])
nd
%
 read UCA entity for Rio Acelhuate
ntity_dirname  = 'M:\BGCC\CHR\RK\RS\A_Sustainable_Development\Projects\ECA\SanSalvador\consultant_data\entity';
ntity_filename = 'listado_viviendas01072015.xls';
ssets = climada_xlsread(0,[entity_dirname filesep entity_filename]);
 convert utm to lat/lon
assets.lon, assets.lat] = utm2ll_salvador(assets.coordX, assets.coordY);
 [entity,entity_save_file] = climada_entity_read([entity_dirname filesep entity_filename],'');
 plot in figure
igure
lotclr(assets.lon, assets.lat, assets.PRECIO_BIENES_NIV1,'s',4,1,[],[],cmap)
  [h h_points] = plotclr(x,y,v, marker, markersize, colorbar_on, miv, mav, map, zero_off, v_exp)
find unique asset values
alues_unique = unique(assets.PRECIO_BIENES_NIV1);
map          = climada_colormap('damage',numel(values_unique)+1);
ransp  = 0.85;
or i = 1:size(cmap,1)
   colorHex(i,:) = kml.color2kmlHex([cmap(i,:) transp]);
nd

 create google earth kmz
oogle_earth_save = [climada_global.data_dir filesep 'results' filesep 'SanSalvador' filesep 'Rio_Acelhuate_entity_UCA.kmz'];
 = kml(google_earth_save);
or i = 1:numel(values_unique)
   indx = assets.PRECIO_BIENES_NIV1 == values_unique(i);
   kk = k.newFolder(sprintf('Precio bienes nivel 1: %d USD',values_unique(i)));
   %kk.plot(assets.lon(indx), assets.lat(indx), 'lineColor','50B4B414');
   %kk.plot(assets.lon(indx), assets.lat(indx), 'lineColor',['FF' ge_color(cmap(i+1,:))]);
   
   kk.point(assets.lon(indx), assets.lat(indx), ones(1,sum(indx))*100, ...
           'description','test',...
           'iconURL','http://maps.google.com/mapfiles/kml/shapes/donut.png',...
           'iconScale',0.5,...
           'iconColor',colorHex(i,:));
nd
.run 
% prepare salvador, el garrobo entity
hazard type
azard_names = {'flood'}; 
uture_years = [2015];
 future_years = [2014 2030 2050];
   
% loop over hazards
or h_i = 1:length(hazard_names)
   % set some input files
   switch hazard_names{h_i}
       case 'flood'
           hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_FL_depth_monsoon_2014'];
           hazard_name = 'Floods';
           entity_filename = [climada_global.data_dir filesep 'entities' filesep 'entity_AMSS.xls'];
           
       %case 'cyclone_wind'
       %    hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_TC_2014'];
       %    hazard_name = 'Cyclones';
       %    % entity_filename = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Cyclones 040515.xls'];
       %    entity_filename = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Cyclones 060515.xls'];
   end
   load(hazard_set_file)
   %% read entities
   % entity floods 2014, 2030 and 2050
   % entity cyclones 2014, 2030 and 2050
   entity       = [];
   for i = 1:length(future_years)
       entity_temp = [];
       fprintf('\n---------------\n\t - Read entity %s %d\n',hazard_name,future_years(i))
       if future_years(i) == 2015
           entity_filename_mat = strrep(entity_filename,'.xls', '.mat');
           if exist(entity_filename_mat,'file')
               delete(entity_filename_mat)
           end
           [entity,entity_save_file] = climada_entity_read(entity_filename,hazard);
           %% convert local coordinates to lat lon and reencode
           %fprintf('\t- Convert to lat lon and reencode\n')
           %entity.assets.X = entity.assets.lon;
           %entity.assets.Y = entity.assets.lat;
           %[entity.assets.lon, entity.assets.lat] = utm2ll_shift(entity.assets.X, entity.assets.Y);
           %entity = climada_assets_encode(entity,hazard);
           % % pre-process entity in the special Barisal case (Ecorys formatting)
           %entity = barisal_entity_pre_process(entity);
       else
           %sheetname = sprintf('%s_%d',hazard_name,future_years(i));
           %entity_temp.assets = climada_spreadsheet_read('no',entity_filename,sheetname,1);
           %% convert local coordinates to lat lon and reencode
           %%fprintf('\t- Convert to lat lon and reencode\n')
           %%[entity_temp.assets.lon, entity_temp.assets.lat] = utm2ll_shift(entity_temp.assets.X, entity_temp.assets.Y);
           %if isfield(entity_temp.assets,'X')
           %    entity_temp.assets.Value       = nan(size(entity_temp.assets.X));
           %    entity_temp.assets.DamageFunID = nan(size(entity_temp.assets.X));
           %else
           %    entity_temp.assets.Value       = nan(size(entity_temp.assets.lon));
           %    entity_temp.assets.DamageFunID = nan(size(entity_temp.assets.lon));
           %end
           %%entity_temp = climada_assets_encode(entity_temp,hazard);
           %% pre-process entity in the special Barisal case (Ecorys formatting)
           %%entity_temp = barisal_entity_pre_process(entity_temp);
       end
       %switch future_years(i)
       %    case 2030
       %        entity.assets.Value_2030 = entity_temp.assets.Value;
       %    case 2050
       %        entity.assets.Value_2050 = entity_temp.assets.Value;
       %end 
   end
   
   % we use only the assets
   %assets = entity.assets;
   % to combine with damage functions, etc from previous ward entity file 
   %load(entity_template_filename)
   %entity.assets = assets;
   % save
   save(entity_save_file, 'entity')
   fprintf('\t -Entity %s saved\n--------------\n',hazard_name)
   
nd %h_i
eturn
% save specific entity files for flood depth, flood duration and cyclone wind speed
 hazard type
azard_names     = {'flood_depth' 'flood_duration' 'cyclone_wind'};     
   
 loop over hazards
or h_i = 1:length(hazard_names)
    
   switch hazard_names{h_i}
       case 'flood_depth'
           %entity_filename     = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Flooding 040515.mat'];
           entity_filename     = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Flooding 060515.mat'];
           entity_filename_new = strrep(entity_filename,'.mat', '_flood_depth.mat');
           comment             = 'Flood depth (m)';
       case 'flood_duration'
           %entity_filename     = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Flooding 040515.mat'];
           entity_filename     = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Flooding 060515.mat'];
           entity_filename_new = strrep(entity_filename,'.mat', '_flood_duration.mat');
           comment             = 'Flood duration (days)';
       case 'cyclone_wind'
           %entity_filename    = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Cyclones 040515.mat'];
           entity_filename    = [climada_global.data_dir filesep 'entities' filesep 'Spreadsheet 100x100 Assets at risk Cyclones 060515.mat'];
           entity_filename_new = strrep(entity_filename,'.mat', '_cyclone_windspeed.mat');
           comment             = 'Cyclone wind speed (m/s)';           
   end
   load(entity_filename)
   
   % find unique damage functions and their peril_ID (flood depth, flood duration, cyclone wind speed)
   [DamFunID indx_depth indx_duration indx_windspeed] = barisal_dmgfun_filter(entity);
   
   switch hazard_names{h_i}
       case 'flood_depth'
           non_valid_DamFun    = DamFunID(~indx_depth);
       case 'flood_duration'
           non_valid_DamFun    = DamFunID(~indx_duration);
       case 'cyclone_wind'
           non_valid_DamFun    = DamFunID(~indx_windspeed);
   end
   
   if strcmp(hazard_names{h_i},'cyclone_wind')
       % check that cyclone wind speed is in m/s
       valid_indx = ~ismember(entity.damagefunctions.DamageFunID,non_valid_DamFun);
       
       % transform from kilometers per hour (kph) to m/s
       if max(entity.damagefunctions.Intensity(valid_indx)) == 400
           entity.damagefunctions.Intensity_ori         = entity.damagefunctions.Intensity;
           entity.damagefunctions.Intensity(valid_indx) = entity.damagefunctions.Intensity_ori(valid_indx)/3.6;
           entity.damagefunctions.comment               = 'Transformed intensity to m/s from km/h';
       end
   end
   % set non_hazard_type asset values to zero
   non_valid_indx                           = ismember(entity.assets.DamageFunID, non_valid_DamFun);
   entity.assets.Value(non_valid_indx)      = 0;
   entity.assets.Value_2030(non_valid_indx) = 0;
   entity.assets.Value_2050(non_valid_indx) = 0;
   entity.assets.comment                    = comment;
   % save final entity for a specific hazard type
   save(entity_filename_new, 'entity')
   fprintf('\t- Save entity %s as \n\t%s\n\n', hazard_names{h_i},entity_filename_new)
nd
% see damage functions for different asset categories
 
 asset_cat = unique(entity.assets.Category(entity.assets.Value&ampgt0));
 for cat_i = 1:length(asset_cat)
     fprintf('-----------\n-----------\nAsset category: %s \n-----------\n',asset_cat{cat_i})
     indx = strcmp(entity.assets.Category, asset_cat{cat_i});
     indx(entity.assets.Value&amplt=0) = 0;
     
     DamageFunID = unique(entity.assets.DamageFunID(indx));
     
     for ii = 1:numel(DamageFunID)
         fprintf('Asset DamageFunID: %d \n',DamageFunID(ii))
         indxx = find(entity.damagefunctions.DamageFunID == DamageFunID(ii));
         indxx = indxx(end);
         fprintf('DamageFunID: %d, %s \n',entity.damagefunctions.DamageFunID(indxx), entity.damagefunctions.Description{indxx})
         fprintf('max intensity %2.1f, max MDD %2.1f, \n\n', entity.damagefunctions.Intensity(indxx), entity.damagefunctions.MDD(indxx))     
     end
 end
% 
 % flood depth
 % find all assets that do not correspond to the specific index (damage function unit)
 fprintf('\t- DamageFunctions for flood depth: %d\n', numel(DamFunID(indx_depth)))
 fprintf('%d, ', DamFunID(indx_depth))
 fprintf('\n')
 entity           = entity_ori;
 non_valid_DamFun = DamFunID(~indx_depth);
 non_valid_indx   = ismember(entity.assets.DamageFunID, non_valid_DamFun);
 entity.assets.Value(non_valid_indx)      = 0;
 entity.assets.Value_2030(non_valid_indx) = 0;
 entity.assets.Value_2050(non_valid_indx) = 0;
 entity.assets.comment = 'Flood depth (m)';
 entity_filename       = [climada_global.data_dir filesep 'entities' filesep '20150416_values_Barisal_flood_depth.mat'];
 save(entity_filename, 'entity')
 fprintf('\t- Save entity flood depth as \n\t%s\n\n', entity_filename)
 
 % flood duration
 % find all assets that do not correspond to the specific index (damage function unit)
 fprintf('\t- DamageFunctions for flood duration: %d\n', numel(DamFunID(indx_duration)))
 fprintf('%d, ', DamFunID(indx_duration))
 fprintf('\n')
 entity           = entity_ori;
 non_valid_DamFun = DamFunID(~indx_duration);
 non_valid_indx   = ismember(entity.assets.DamageFunID, non_valid_DamFun);
 entity.assets.Value(non_valid_indx)      = 0;
 entity.assets.Value_2030(non_valid_indx) = 0;
 entity.assets.Value_2050(non_valid_indx) = 0;
 entity.assets.comment = 'Flood duration (days)';
 entity_filename = [climada_global.data_dir filesep 'entities' filesep '20150416_values_Barisal_flood_duration.mat'];
 save(entity_filename, 'entity')
 fprintf('\t- Save entity flood duration as \n\t%s\n\n', entity_filename)
% hazard
 if flood == 1
     % hazard flood
     % asci_file = ;
     % hazard = climada_asci2hazard(asci_file);
     hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_FL_2014'];
     load(hazard_set_file)
     hazard_name = 'Floods';
 
 else    
     % hazard tc wind
     hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_TC_2014'];
     load(hazard_set_file)
     hazard_name = 'Cyclones';
 
     % wind centroids
     centroids_file  = [climada_global.data_dir filesep 'system' filesep 'Barisal_BCC_centroids'];
     load(centroids_file)
 end
% --------------------
  CYCLONE WIND
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/_salvador_entity_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_salvador_hazard_FL_prepare">
<H2>_salvador_hazard_FL_prepare</H2></A>
 -- not used anymore ------
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_hazard_crop from climada_hazard_focus_area
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
% LOAD INDUNDATION HAZARD AND CREATE FIGURES
% set directories  and load the data
oldername = 'M:\BGCC\CHR\RK\RS\A_Sustainable_Development\Projects\ECA\SanSalvador\consultant_data\hazards\inundation\20150723_rio_acelhuate_rio_garrobo_2D\';
 asci_file = [foldername 'TR50A0.asc'];
sci_file = [foldername 'flood_gar_2yr_10m.asc'];
 load relevant shapes (adm2, rivers, polygon_LS, polygon_rio_acelhuate)
oad([climada_global.project_dir filesep 'system' filesep 'san_salvador_shps_adm2_rivers_salvador_polygon_LS.mat'])
 load inundation hazard
oad([climada_global.project_dir filesep 'Salvador_hazard_FL_2015'])
% create figures
 climada_hazard_plot_hr(hazard,3);
ax_flood_m = 7;
arkersize  = 1;
or e_i = 1:6
   fig = climada_figuresize(0.4,0.8);
   plotclr(hazard.lon, hazard.lat, hazard.intensity(e_i,:),'s',markersize,1,0,max_flood_m,climada_colormap(hazard.peril_ID));
   hold on
   climada_shapeplotter(shape_rios(indx_rios_in_San_Salvador),'','X_ori','Y_ori','linewidth',1,'color',[135 206 235]/255) % grey % blue [58 95 205]/255
   box on
   axis([min(hazard.lon) max(hazard.lon) min(hazard.lat) max(hazard.lat)])
   title({['Flood Rio Acelhuate (m), ' sprintf('%d year return period',1./hazard.frequency(e_i))]; '1D from MARN, 2D from GFA, 10m resolution'})
   x_y_ratio = climada_geo_distance(-89,14,-89.001,14)/climada_geo_distance(-89,14,-89,14.001);
   x_ = max(hazard.lon)-min(hazard.lon);
   y_ = max(hazard.lat)-min(hazard.lat);
   set(gca, 'PlotBoxAspectRatio', [x_ y_*x_y_ratio 1]);
   climada_figure_scale_add(gca,5,1)
   foldername = sprintf('%sresults%sSanSalvador%sFlood_Rio_Acelhuate_%d_return_period_max_flood_%dm_%s.pdf', filesep,filesep,filesep,1./hazard.frequency(e_i),max_flood_m,datestr(now,'YYYYmmDD'));
   print(fig,'-dpdf',[climada_global.data_dir foldername])
   
nd
% difference in flood meter
ax_flood_m = 100;
in_flood_m = 0;
or e_i = 1:5
   
   value = (hazard.intensity(e_i+1,:)-hazard.intensity(e_i,:))./hazard.intensity(e_i,:)*100;
   value(isnan(value)) = 0;
   
   fig = climada_figuresize(0.3,0.8);
   plotclr(hazard.lon, hazard.lat, value,'s',1,1,min_flood_m,max_flood_m,climada_colormap(hazard.peril_ID));
   hold on
   climada_shapeplotter(shape_rios(indx_rios_in_San_Salvador),'','X_ori','Y_ori','linewidth',1,'color',[135 206 235]/255) % grey % blue [58 95 205]/255
   box on
   axis([min(hazard.lon) max(hazard.lon) min(hazard.lat) max(hazard.lat)])
   title({['Differnce in flood height (m), ' sprintf('%d - %d year return period',1./hazard.frequency(e_i),1./hazard.frequency(e_i+1))]; '1D from MARN, 2D from GFA, 10m resolution'})
   x_y_ratio = climada_geo_distance(-89,14,-89.001,14)/climada_geo_distance(-89,14,-89,14.001);
   x_ = max(hazard.lon)-min(hazard.lon);
   y_ = max(hazard.lat)-min(hazard.lat);
   set(gca, 'PlotBoxAspectRatio', [x_ y_*x_y_ratio 1]);
   climada_figure_scale_add(gca,5,1)
   foldername = sprintf('%sresults%sSanSalvador%sFlood_Rio_Acelhuate_%d_%d_return_period_diff_m_%s.pdf', filesep,filesep,filesep,1./hazard.frequency(e_i),1./hazard.frequency(e_i+1),datestr(now,'YYYYmmDD'));
   print(fig,'-dpdf',[climada_global.data_dir foldername])
   
nd
% read inunation hazard for San Salvador Rio Acelhuate and Rio Garrobo
(MARN data 1D and from Maxime/GFA put )
present, future moderate and future extreme
oldername = 'M:\BGCC\CHR\RK\RS\A_Sustainable_Development\Projects\ECA\SanSalvador\consultant_data\hazards\inundation';
ata_name{1}='Salvador_hazard_FL_2015';
ata_name{2}='Salvador_hazard_FL_2040_moderate_cc';
ata_name{3}='Salvador_hazard_FL_2040_extreme_cc';
or i=1:3
   % set directories
   if      i==1
       asci_file = [foldername filesep '20150723_rio_acelhuate_rio_garrobo_2D' filesep 'flood_gar_2yr_10m.asc'];
      
   elseif  i==2
      asci_file = [foldername filesep '201508_rio_acelhuate_rio_garrobo_2D_2040_moderate_cc' filesep '4%_2yr.txt'];

   elseif  i==3
       asci_file = [foldername filesep '201508_rio_acelhuate_rio_garrobo_2D_2040_extreme_cc' filesep '10%_2yr.txt'];
   
   end
   % load relevant shapes (adm2, rivers, polygon_LS, polygon_rio_acelhuate)
   load([climada_global.project_dir filesep 'system' filesep 'san_salvador_shps_adm2_rivers_salvador_polygon_LS.mat'])
   % read hazard
   hazard = climada_asci2hazard(asci_file, 6, 'salvador');
   % set ordering and frequencies
   order_indx       = [4 6 2 3 5 1];
   hazard.intensity = hazard.intensity(order_indx,:);
   hazard.name      = hazard.name(order_indx);
   hazard.frequency = 1./[2 5 10 25 50 100];
   hazard.orig_years= 100;
   hazard.comment   = '1D modelled by MARN, 2D modelled by GFA';
   hazard.peril_ID  = 'FL';
   hazard.units     = 'm';
   hazard.filename  = '';
   % cut out relevant area for rio acelhuate
   hazard = climada_hazard_crop(hazard,polygon_rio_acelhuate);
   % save flood hazard rio acelhuate
   save_name = [climada_global.project_dir filesep data_name{i}];
   hazard.filename  = save_name;
   save(save_name,'hazard')
   fprintf('Save hazard in %s\n',save_name)
nd
% prepare inundation hazard for San Salvador Rio Acelhuate (MARN data)
 salvador inundation hazard
 but MARN data is based on a 1D visualisation, so data is not useful for
 flood damage modelling
% read inundation grid (TR50A0_test.txt)
oldername = 'M:\BGCC\CHR\RK\RS\A_Sustainable_Development\Projects\ECA\SanSalvador\consultant_data\hazards\inundation\rio_acelhuate\';
 asci_file = [foldername 'TR50A0.asc'];
sci_file = [foldername 'TR50A0_test.asc'];
ow_count = 6;
ow_counter = 0;
id=fopen(asci_file,'r');
or i = 1:row_count
   line=fgetl(fid);
   if length(line)&ampgt0
      [token, remain] = strtok(line,' ');
      if ~isempty(remain)
          if strfind(token,'ncols'       ); ncols        = str2num(remain);end
          if strfind(token,'nrows'       ); nrows        = str2num(remain);end
          if strfind(token,'xllcorner'   ); xllcorner    = str2num(remain);end
          if strfind(token,'yllcorner'   ); yllcorner    = str2num(remain);end
          if strfind(token,'cellsize'    ); cellsize     = str2num(remain);end
          if strfind(token,'NODATA_value'); NODATA_value = str2num(remain);end
          row_counter = row_counter+1;
      end
   end
nd
close(fid);
 read asci-file
elimiter = '';
 delimiter = ' ';
 delimiter = '\t';
vent_grid = flipud(dlmread(asci_file,delimiter,row_count,0));
 set nodata values to 0
vent_grid(event_grid==NODATA_value) = nan;
vent_grid(event_grid==0) = nan;
 = linspace(xllcorner,xllcorner+cellsize*ncols,ncols);
 = linspace(yllcorner,yllcorner+cellsize*nrows,nrows);
% plot event inundation
igure
 hold on
ontour(x,y,event_grid,[550:10:850])
olorbar
igure
ontourf(x,y,event_grid,'edgecolor','none')
% create meshgrid event_grid 
X, Y ]  = meshgrid(x,y);
azard.X = reshape(X,1,numel(x)*numel(y));
azard.Y = reshape(Y,1,numel(x)*numel(y));  
azard.intensity      = zeros(size(hazard.X)); %init
azard.intensity_ori  = zeros(size(hazard.X)); %init
azard.intensity_masl = reshape(event_grid,1,numel(x)*numel(y));
 use only positive values
ndx_valid = ~isnan(hazard.intensity_masl);
 sum(indx_valid)
azard.X   = hazard.X(indx_valid);
azard.Y   = hazard.Y(indx_valid);
azard.intensity      = hazard.intensity(indx_valid);
azard.intensity_ori  = hazard.intensity_ori(indx_valid);
azard.intensity_masl = hazard.intensity_masl(indx_valid);
azard.dem = zeros(size(hazard.X));
azard.dem = zeros(size(hazard.X));
 transformation of UTM to lat lon coordinates
hazard.lon, hazard.lat] = utm2ll_salvador(hazard.X, hazard.Y);
% find nearest neighbour and this dem value
ndx       = knnsearch([dem.X' dem.Y'],[hazard.X' hazard.Y']);
azard.dem = dem.value(indx);
 calculate inuundation depht and normalize
azard.intensity_ori  = hazard.intensity_masl-hazard.dem;
 normalize
ax_depth = 4.5; % just a guess
azard.intensity = hazard.intensity_ori -min(hazard.intensity_ori);
azard.intensity = hazard.intensity/max(hazard.intensity)*max_depth;
 add hazard fields
azard.frequency = 1/50;
azard.peril_ID  = 'FL';
azard.datenum   = now;
azard.orig_event_flag = 1;
azard.event_ID  = 1;
azard.unit      = 'm';
azard.comment   = 'Modelled by MARN, 1D, 3m resolution, 50 year return period';
% save hazard
ave([climada_global.data_dir filesep 'hazards' filesep 'hazard_Acelhuate_50yr'],'hazard');
% plot indundation
ig = climada_figuresize(0.4,0.8);
lotclr(hazard.lon, hazard.lat, hazard.intensity,'','',1)
old on
ox on
itle({'Flood Rio Acelhuate'; '50 years return period, normalized to 0 and 4.5m '; '1D from MARN, 3m resolution'})
 plot(hazard.lon(end), hazard.lat(end), 'rx')
 hazard.intensity(end)
oldername = sprintf('%sresults%sSanSalvador%sFlood_Rio_Acelhuate_%d_return_period.pdf', filesep,filesep,filesep,1/hazard.frequency(1));
rint(fig,'-dpdf',[climada_global.data_dir foldername])
 climada_hazard_plot_hr(hazard,1,[],[],[],0)
ig = climada_figuresize(0.4,0.8);
lotclr(hazard.lon, hazard.lat, hazard.intensity_ori,'','',1)
old on
ox on
itle({'Flood Rio Acelhuate'; '50 years return period, not normalized '; '1D from MARN, 3m resolution'})
 plot(hazard.lon(end), hazard.lat(end), 'rx')
 hazard.intensity(end)
oldername = sprintf('%sresults%sSanSalvador%sFlood_Rio_Acelhuate_%d_return_period_not_normalized.pdf', filesep,filesep,filesep,1/hazard.frequency(1));
rint(fig,'-dpdf',[climada_global.data_dir foldername])
 % just to check for nearest neighbour
 plot(dem.lon(indx(end)), dem.lat(indx(end)), 'bo','markersize',10)
 plot(dem.lon(indx(end)-1), dem.lat(indx(end)-1), 'bo','markersize',10)
 plot(dem.lon(indx(end)+1), dem.lat(indx(end)+1), 'bo','markersize',10)
 plot(dem.lon, dem.lat, 'bo','markersize',2)
 
 figure
 plotclr(dem.lon, dem.lat, dem.value)
%
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/_salvador_hazard_FL_prepare.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_salvador_hazard_LS_distance_prepare">
<H2>_salvador_hazard_LS_distance_prepare</H2></A>
 -----NOT USED ANYMORE ---
 create hazard Landslide (distance intenstiy) 
  - based on hazard LS soil depth
% create test entity
 lon = linspace(min(hazard.lon),max(hazard.lon),20);
 lat = linspace(min(hazard.lat),max(hazard.lat),20);
on = linspace(-89.18,-89.08,30);
at = linspace(13.65,13.74,30);
lon lat] = meshgrid(lon,lat);
ntity.assets.lon = lon(:)';
ntity.assets.lat = lat(:)';
 set random asset values
ntity.assets.Value = rand(size(entity.assets.lon))*10;
% load Gilles basis landslide hazard
alvador_data_dir = ['\\CHRB1065.CORP.GWPNET.COM\homes\X\S3BXXW\Documents\lea\climada_git\climada_modules\salvador_demo\data'];
oad([salvador_data_dir filesep 'hazards' filesep 'MS_hazard_050715'])
 % hazard_ori = hazard;
 % 
 % hazard.intensity = abs(hazard_ori.intensity);
 % hazard.intensity = sum(hazard.intensity);
 n_events = 220;
 hazard.intensity   = hazard.intensity(1:n_events,:);
 hazard.orig_event_count = n_events;
 hazard.event_ID    = 1:n_events;
 hazard.event_count = n_events;
igure
limada_hazard_plot_hr(hazard,1,'',[-2 2]);
% transform basis hazard to distance hazard
 profile on
limada_global.waitbar = 0;
 transform basis hazard to distance hazard
utoff = 1000;
azard_distance = climada_hazard_encode_distance(hazard,entity,cutoff);
azard_distance.peril_ID = 'LS';
 profile report
 profile off
% create test figure, event 1
_i = 4800;
igure
limada_hazard_plot_hr(hazard_distance,e_i,'',[0 cutoff]);
old on
ndx = abs(full(hazard.intensity(e_i,:)))&ampgt0;
lot(hazard.lon(indx), hazard.lat(indx),'sk')
lot(entity.assets.lon, entity.assets.lat,'xb')
_i = 1;
igure
lotclr(hazard_distance.lon, hazard_distance.lat, hazard_distance.distance_m(e_i,:),'',20,1,'','',flipud(jet));
old on
ndx = abs(full(hazard.intensity(e_i,:)))&ampgt0;
lot(hazard.lon(indx), hazard.lat(indx),'sk')
 hazard stats
azard_stats = climada_hazard_stats(hazard_distance,5:5:15);
%
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/_salvador_hazard_LS_distance_prepare.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_salvador_land_use">
<H2>_salvador_land_use</H2></A>
<font color="blue">function centroids = salvador_land_use(centroids) </font>
odule_data_dir=[fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
oil_type_file = [module_data_dir filesep 'system' filesep 'vegetacion.shp'];
oil_type_shapes = climada_shaperead(soil_type_file,0);
0 = clock;
ormat_str = '%s';
od_step        = 10;
or shape_i = 1:length(soil_type_shapes)
   
   [soil_type_shapes(shape_i).X,soil_type_shapes(shape_i).Y] =...
       utm2ll(soil_type_shapes(shape_i).X,soil_type_shapes(shape_i).Y);
   
   % progress mgmt
   if mod(shape_i,mod_step) ==0
       
       t_elapsed       = etime(clock,t0)/shape_i;
       n_remaining     = length(soil_type_shapes)-shape_i;
       t_projected_sec = t_elapsed*n_remaining;
       if t_projected_sec&amplt60
           msgstr = sprintf('processing land use, est. %3.0f sec left (%i/%i shapes)',t_projected_sec, shape_i,length(soil_type_shapes));
       else
           msgstr = sprintf('processing land use, est. %3.1f min left (%i/%i shapes)',t_projected_sec/60, shape_i,length(soil_type_shapes));
       end
       fprintf(format_str,msgstr);
       format_str = [repmat('\b',1,length(msgstr)) '%s'];
   end
   
   
   [in] = inpolygon(centroids.lon,centroids.lat,...
       soil_type_shapes(shape_i).X,soil_type_shapes(shape_i).Y);
   centroids.LAI(in) = soil_type_shapes(shape_i).NO_CATEGOR;
nd
printf(format_str,sprintf('processing land use took %2.0f seconds\n',etime(clock,t0)))
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/_salvador_land_use.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_salvador_results_overview">
<H2>_salvador_results_overview</H2></A>
<font color="blue">function filepath=salvador_results_overview </font>
 NAME:
   salvador_results_overview
 PURPOSE:
   Create summary report of all hazards based on the saved EDS
 CALLING SEQUENCE:
   none
 EXAMPLE:
   salvador_results_overview
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   printed excel file
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Jacob Anz, j.anz@gmx.net,20150929, init
 Lea Mueller, muellele@gmail.com, 20151106, rename to climada_EDS_ED_per_category_report from salvador_EDS_ED_per_category_report
load the different EDS for the different perils
Code is preassigened for a maximum of 4 different EDS sets (perils/areas)
eril_container{1}='_FL';       peril_ID{1}='FL';
eril_container{2}='_TC';       peril_ID{2}='TC';
eril_container{3}='_LS_ace';   peril_ID{3}='LS';
eril_container{4}='_LS_can';   peril_ID{4}='LS';
ath='N:\RM\sustainability\SanSalvador\salvador_climada_data\!waterfall up to date';
esults_dir=path;
isting = dir(path);
or k=1:length(peril_container)
   for i=1:length(listing)
       if findstr(listing(i).name,peril_container{k})
           path_mat=[path filesep listing(i).name];
           listing_mat = dir(path_mat);
           for j=1:length(listing_mat)
               if findstr(listing_mat(j).name, '.mat')
                 path_mat_file{k}= [path_mat filesep listing_mat(j).name];   
               end
           end
       end    
   end
nd
ametag='summary';
enefit_flag = 0;
ssets_flag = 1;
utput_container{1}=[];output_container{2}=[];output_container{3}=[];output_container{4}=[];
or i=1:length(path_mat_file)
   load(path_mat_file{i})          %loads EDS
   load(EDS(1).assets.filename)    %loads original entity
   
   xls_file = [results_dir filesep 'ED_' peril_ID{i} '_2015_2040_' datestr(now,'YYYYmmdd') '_' nametag '.xlsx'];
   output_report = climada_EDS_ED_per_category_report_summary(entity, EDS, xls_file,'ED_per_category',benefit_flag,0,assets_flag);
   output_container{i}=output_report;
   clear output_report xls_file EDS entity
nd
utput_report=[output_container{1};output_container{2};output_container{3};output_container{4}];
write to excel
ls_file = [results_dir filesep 'ED_all_perils_2015_2040_' datestr(now,'YYYYmmdd') '_' nametag '.xlsx'];
heet='ED_per_category';
ry
       xlswrite(xls_file,output_report,sheet)
   catch
       % probably too large for old excel, try writing to .xlsx instead
       try
           xlsx_file = [xls_file 'x'];
           xlswrite(xlsx_file,output_report,sheet)
       catch
           % probably too large for new excel, write to textfile instead
           cprintf([1 0 0],'FAILED\n')
           fprintf('attempting to write to text file instead... ')
           txt_file = strrep(xlsx_file,'.xlsx','.txt');
           writetable(cell2table(output_report),txt_file)
           fclose all;
       end
nd
printf('done\n')
printf('report written to sheet %s of %s\n',sheet,xls_file);
ilepath=xls_file;
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/_salvador_results_overview.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_salvador_vegetation">
<H2>_salvador_vegetation</H2></A>
<font color="blue">function centroids = salvador_vegetation(centroids) </font>
odule_data_dir=[fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
oil_type_file = [module_data_dir filesep 'system' filesep 'vegetacion.shp'];
oil_type_shapes = climada_shaperead(soil_type_file,0);
entroids.LAI = zeros(size(centroids.centroid_ID));
0 = clock;
ormat_str = '%s';
od_step        = 10;
or shape_i = 1:length(soil_type_shapes)
   
   [soil_type_shapes(shape_i).X,soil_type_shapes(shape_i).Y] =...
       utm2ll(soil_type_shapes(shape_i).X,soil_type_shapes(shape_i).Y);
   
   % progress mgmt
   if mod(shape_i,mod_step) ==0
       
       t_elapsed       = etime(clock,t0)/shape_i;
       n_remaining     = length(soil_type_shapes)-shape_i;
       t_projected_sec = t_elapsed*n_remaining;
       if t_projected_sec&amplt60
           msgstr = sprintf('processing land use, est. %3.0f sec left (%i/%i shapes)',t_projected_sec, shape_i,length(soil_type_shapes));
       else
           msgstr = sprintf('processing land use, est. %3.1f min left (%i/%i shapes)',t_projected_sec/60, shape_i,length(soil_type_shapes));
       end
       fprintf(format_str,msgstr);
       format_str = [repmat('\b',1,length(msgstr)) '%s'];
   end
   
   
   [in] = inpolygon(centroids.lon,centroids.lat,...
       soil_type_shapes(shape_i).X,soil_type_shapes(shape_i).Y);
   centroids.LAI(in) = soil_type_shapes(shape_i).NO_CATEGOR;
nd
at_lookup = [      20	3	0.214285714
                   19	4	0.285714286
                   18	5	0.357142857
                   14	14	0.999999999
                   25	13	0.928571429
                   21	Inf	NaN
                   3	3	0.214285714
                   27	7	0.5
                   5	8	0.571428571
                   8	6	0.428571429
                   26	7	0.5
                   7	9	0.642857143
                   23	11	0.785714286
                   1	10	0.714285714 ];
or cat_i = 1:length(cat_lookup)
   centroids.LAI(centroids.LAI == cat_lookup(cat_i,1)) = cat_lookup(cat_i,3);
nd
printf(format_str,sprintf('processing land use took %2.0f seconds\n',etime(clock,t0)))
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/_salvador_vegetation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_map_plot_salvador">
<H2>climada_map_plot_salvador</H2></A>
<font color="blue">function fig = climada_map_plot_salvador(entity,EDS,fieldname_to_plot,peril_criterum,unit_criterium,category_criterium,print_figure) </font>
 create a map, for selected assets, plot either asset values or damage
 MODULE:
   salvador_demo
 NAME:
   salvador_map_plot
 PURPOSE:
   create a map, for selected assets, plot either asset values or damage,
   select a subset of assets depending on peril_ID ('FL', 'TC'), units 
   ('USD' or 'people') and or category (4 or 7)   
 CALLING SEQUENCE:
   salvador_map_plot(entity,EDS,fieldname_to_plot,peril_criterum,unit_criterium,category_criterium, print_figure)
 EXAMPLE:
   salvador_map_plot(entity,EDS,'damage','FL','USD')
   salvador_map_plot(entity,EDS,'damage','FL','USD',1)
   salvador_map_plot(entity,'','assets','FL','people')
 INPUTS:
   entity: an entity (see climada_entity_read)
       &ampgt promted for if not given
   EDS: an EDS struct, needed only for 'damage'
 OPTIONAL INPUT PARAMETERS:
   fieldname_to_plot : a string to specify the field to be plotted, 'assets', 'damage' or 'damage_relative'
   peril_criterum    : a string to select a peril_ID, e.g. 'FL', or empty, see salvador_assets_select
   unit_criterium    : a string to select a unit, e.g. 'USD', 'people' or empty
   category_criterium: a scalar to select a category, e.g. 1
   print_figure      : set to 1 to save as a pdf in [climada_global.project_dir filesep 'PLOTS']
 OUTPUTS:
   a figure 
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150731, init
 Lea Mueller, muellele@gmail.com, 20150801, return if invalid selection
 Lea Mueller, muellele@gmail.com, 20150804, differentiate axis_limits for TC and FL
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/climada_map_plot_salvador.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_dem_read">
<H2>salvador_dem_read</H2></A>
<font color="blue">function [dem, resolution_m] = salvador_dem_read(dem_filename, resolution_m, check_plot) </font>
 Read dem grid and create dem structure for a given resolution (m)
 MODULE:
   salvador_demo
 NAME:
   salvador_dem_read
 PURPOSE:
   Read dem grid and create dem structure for a given resolution (m)
 CALLING SEQUENCE:
   [dem, resolution_m] = salvador_dem_read(dem_filename, resolution_m, check_plot)
 EXAMPLE:
   dem = salvador_dem_read
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   dem_filename: dem filename (txt or asci), &ampgt prompted for if not given
   resolution_m: default is 50m, finest resolution is 10m
   check_plot:   set to 1 if figure wanted 
 OUTPUTS:
   dem: a struct, with the fields
       .lon: the longitude of each location
       .lat: the latitude of each location
       .value: the elevation in masl for each location
       .resolution_m: resolution value in m
       .unit: unit of dem values (default masl)
       .comment: a free comment, normally containing the time the hazard
           event set has been generated
       .date_created: time when the dem structure has been generated
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150729, init
 Lea Mueller, muellele@gmail.com, 20150729, cutoff last column and row, only if resolution is coarser than original resolution
 Lea Mueller, muellele@gmail.com, 20150914, transform grid to lat/lon and then create vectors lat and lon
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
 -
em          = []; % init
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('dem_filename' ,'var'), dem_filename = []; end
f ~exist('resolution_m' ,'var'), resolution_m = []; end
f ~exist('check_plot'   ,'var'), check_plot   = []; end
 set module data directory
 module_data_dir=[fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
 default dem_file on the shared drive
oldername = 'M:\BGCC\CHR\RK\RS\A_Sustainable_Development\Projects\ECA\SanSalvador\consultant_data\hazards\landslides\system\';
sci_file  = [foldername 'dem-municipios.txt'];
 asci_file = [foldername 'dem-municipiosll.txt'];
f isempty(dem_filename)
   dem_filename = asci_file;
nd
f isempty(resolution_m), resolution_m = 50; end
f isempty(check_plot  ), check_plot   =  0; end
 
% read DEM grid (dem-municipios.txt)
ow_count   = 6;
ow_counter = 0;
id = fopen(dem_filename,'r');
 file does not exist
f fid &amplt= 0
   fprintf('File does not exist. Please check that the default file still exists.\n')
   return
nd
or i = 1:row_count
   line=fgetl(fid);
   if length(line)&ampgt0
      [token, remain] = strtok(line,' ');
      if ~isempty(remain)
          if strfind(token,'ncols'       ); ncols        = str2num(remain);end
          if strfind(token,'nrows'       ); nrows        = str2num(remain);end
          if strfind(token,'xllcorner'   ); xllcorner    = str2num(remain);end
          if strfind(token,'yllcorner'   ); yllcorner    = str2num(remain);end
          if strfind(token,'cellsize'    ); cellsize     = str2num(remain);end
          if strfind(token,'NODATA_value'); NODATA_value = str2num(remain);end
          row_counter = row_counter+1;
      end
   end
nd
close(fid);
 set delimiter
elimiter = '';
 delimiter = ' ';
 delimiter = '\t';
em_grid_ori = flipud(dlmread(dem_filename,delimiter,row_count,0));
 check that dimension of grid corresponds to ncols and nrows
dem_i, dem_j ] = size(dem_grid_ori);
f dem_i ~= nrows
   fprintf('Dimension do not agree. Please check dimension of grid, e.g. parameter &quotrow_count&quot.\n')
   return
nd
f dem_j ~= ncols
   fprintf('Dimension do not agree. Please check dimension of grid, e.g. parameter &quotrow_count&quot.\n')
   return
nd  
% create DEM grid on required resolution
esolution_factor = ceil(resolution_m/cellsize);
em_grid          = dem_grid_ori(1:resolution_factor:end, 1:resolution_factor:end);
f resolution_factor&ampgt1 % cut off last row and last column
   dem_grid(end,:)   = [];
   dem_grid(:,end)   = [];
nd
em_grid(dem_grid == NODATA_value) = 0;
ellsize          = cellsize*resolution_factor;
dem_i, dem_j ]   = size(dem_grid);
dem_i_ori, dem_j_ori]   = size(dem_grid_ori);
% create dem struct (vectors lon, lat, value)
transform to lat/lon
lonllcorner, latllcorner] = utm2ll_salvador([xllcorner xllcorner+cellsize*dem_j],[yllcorner yllcorner+cellsize*dem_i]);
 create dem struct
on_dem = lonllcorner(1):diff(lonllcorner)/(dem_j-1):lonllcorner(2); %0.0000914066
at_dem = latllcorner(1):diff(latllcorner)/(dem_i-1):latllcorner(2); %0.0000914066
lon, lat ]   = meshgrid(lon_dem,lat_dem);
em.lon       = reshape(lon,1,numel(lon_dem)*numel(lat_dem));
em.lat       = reshape(lat,1,numel(lon_dem)*numel(lat_dem));  
em.value     = reshape(dem_grid,1,numel(lon_dem)*numel(lat_dem));
em.unit      = 'masl';
em.resolution_m   = resolution_m;
em.comment        = sprintf('DEM on %dm resolution, read from %s',resolution_m, dem_filename);
 figure
 plotclr(dem.lon, dem.lat, dem.value,'s',3.5,1,500,650)
 % axis(axlim); box on
 hold on
 plotclr(entity.assets.lon, entity.assets.lat, entity.assets.Value,marker,markersize,cbar_on,miv,mav);
 x_dem     = linspace(xllcorner, xllcorner+cellsize*dem_j, dem_j);
 y_dem     = linspace(yllcorner, yllcorner+cellsize*dem_i, dem_i);
 [X, Y ]   = meshgrid(x_dem,y_dem);
 dem.lon   = zeros(1,dem_j*dem_i); %init
 dem.lat   = zeros(1,dem_j*dem_i); %init
 dem.X     = reshape(X,1,numel(x_dem)*numel(y_dem));
 dem.Y     = reshape(Y,1,numel(x_dem)*numel(y_dem));  
 dem.value = reshape(dem_grid,1,numel(x_dem)*numel(y_dem));
 dem.unit  = 'masl';
 dem.resolution_m   = resolution_m;
 dem.comment        = sprintf('DEM on %dm resolution, read from %s',resolution_m, dem_filename);
 %transform to lat/lon
 [dem.lon, dem.lat] = utm2ll_salvador(dem.X, dem.Y);
% save dem
 both on shared drive as well as in project folder
ilename = sprintf('%s_%dm.mat',strrep(dem_filename,'.txt',''),resolution_m);
ave(filename,'dem');
 in project folder
f isfield(climada_global, 'project_dir')
   filename = [climada_global.project_dir filesep 'system' filesep 'Salvador_dem_' int2str(resolution_m) 'm_' datestr(now,'YYYYmmdd') '.mat'];
   save(filename,'dem');
   fprintf('dem struct saved in \n \t %s\n',filename)
nd
% plot dem
f check_plot
   climada_figuresize(0.4, 0.7);
   contourf(x_dem,y_dem,dem_grid,[550:10:850],'edgecolor','none')
   [lon_dem, ~] = utm2ll_salvador(x_dem, ones(size(x_dem))*y_dem(1));
   [~, lat_dem] = utm2ll_salvador(ones(size(y_dem))*x_dem(1), y_dem);
   %contourf(lon_dem,lat_dem,dem_grid,[550:10:850],'edgecolor','none')
   contourf(lon_dem,lat_dem,dem_grid,[400:10:1000],'edgecolor','none')
   cbar = colorbar;
   set(get(cbar,'ylabel'),'String', '(masl)','fontsize',12);
   titlestr = sprintf('Digital elevation model (%dm resolution)', resolution_m);
   title(titlestr,'fontsize',13)
   % caxis([579 818])
   grid on
   hold on
   climada_figure_scale_add('',1,1)
   
   
   shp_file = [climada_global.project_dir filesep 'system' filesep 'san_salvador_shps_adm2_rivers_salvador_polygon_LS.mat'];
   if exist(shp_file,'file')
       load(shp_file)
       climada_shapeplotter(shape_rivers(indx_rivers_in_San_Salvador),'','','','linewidth',1,'color',[135 206 235]/255) % grey % blue [58 95 205]/255
       climada_shapeplotter(polygon_LS,'','lon','lat')
   end
   
   %axis equal
   %axis([-89.35 -89.00 13.62 13.83])
nd
% shift in DEM
 shift_x = 473460.90240-473437.90240;
 shift_y = 283998.50000-283883.50000;
 
 % apply shift in x and y
 xllcorner = xllcorner+shift_x;
 yllcorner = yllcorner+shift_y; 
 % 473437.90240 + shift_x
 % 283883.50000 + shift_y
 % 456064.365625+shift_x
 % 267347.04962761+shift_y
 dem.X = dem.X+shift_x;
 dem.Y = dem.Y+shift_y;
% only use dem values that are close to the hazard
 indx_valid = dem.X&ampgt473800 &amp dem.X&amplt482600 &amp dem.Y&ampgt284400 &amp dem.Y&amplt286500;
 % sum(indx_valid)
 % figure
 % hold on
 % plot(dem.lon(indx_valid),dem.lat(indx_valid),'.')
 dem.X       = dem.X(indx_valid);
 dem.Y       = dem.Y(indx_valid);
 dem.value   = dem.value(indx_valid);
 
 % transformation of UTM to lat lon coordinates
 [dem.lon, dem.lat] = utm2ll_salvador(dem.X, dem.Y);
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/salvador_dem_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_hazard_FL_read">
<H2>salvador_hazard_FL_read</H2></A>
<font color="blue">function hazard = salvador_hazard_read </font>
 read FL hazard from GFA consultants/Maxime and create climada hazard structure
 MODULE:
   salvador_demo
 NAME:
   salvador_hazard_read
 PURPOSE:
   read FL hazard from GFA consultants/Maxime and create climada hazard 
   structure for today's Acelhuate flood hazard, moderate and extreme
   climate change
 CALLING SEQUENCE:
   hazard = salvador_hazard_read
 EXAMPLE:
   hazard = salvador_hazard_read
 INPUTS:
   none, directory is hardwired, please check
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   hazard: a climada hazard structure, containing FL acelhuate flood depth
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150801, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/salvador_hazard_FL_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_hazard_LS_create_acelhuate">
<H2>salvador_hazard_LS_create_acelhuate</H2></A>
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/salvador_hazard_LS_create_acelhuate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_hazard_LS_create_las_canas">
<H2>salvador_hazard_LS_create_las_canas</H2></A>
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/salvador_hazard_LS_create_las_canas.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_map_plot">
<H2>salvador_map_plot</H2></A>
<font color="blue">function fig = salvador_map_plot(entity,EDS,fieldname_to_plot,peril_criterum,unit_criterium,category_criterium,print_figure) </font>
 create a map, for selected assets, plot either asset values or damage
 MODULE:
   salvador_demo
 NAME:
   salvador_map_plot
 PURPOSE:
   create a map, for selected assets, plot either asset values or damage,
   select a subset of assets depending on peril_ID ('FL', 'TC'), units 
   ('USD' or 'people') and or category (4 or 7)   
 CALLING SEQUENCE:
   salvador_map_plot(entity,EDS,fieldname_to_plot,peril_criterum,unit_criterium,category_criterium, print_figure)
 EXAMPLE:
   salvador_map_plot(entity,EDS,'damage','FL','USD')
   salvador_map_plot(entity,EDS,'damage','FL','USD',1)
   salvador_map_plot(entity,'','assets','FL','people')
 INPUTS:
   entity: an entity (see climada_entity_read)
       &ampgt promted for if not given
   EDS: an EDS struct, needed only for 'damage'
 OPTIONAL INPUT PARAMETERS:
   fieldname_to_plot : a string to specify the field to be plotted, 'assets', 'damage' or 'damage_relative'
   peril_criterum    : a string to select a peril_ID, e.g. 'FL', or empty, see salvador_assets_select
   unit_criterium    : a string to select a unit, e.g. 'USD', 'people' or empty
   category_criterium: a scalar to select a category, e.g. 1
   print_figure      : set to 1 to save as a pdf in [climada_global.project_dir filesep 'PLOTS']
 OUTPUTS:
   a figure 
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150731, init
 Lea Mueller, muellele@gmail.com, 20150801, return if invalid selection
 Lea Mueller, muellele@gmail.com, 20150804, differentiate axis_limits for TC and FL
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/salvador_map_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_plot">
<H2>salvador_plot</H2></A>
<font color="blue">function salvador_plot </font>
 climada
 MODULE
   salvador_demo
 NAME:
   Salvador_plot
 PURPOSE:
   plot Salvador, el Garrobo map, including all relevant information (AMSS GIS, BCC wards 
   polygon and open data). Hardwired for San Salvador.
 CALLING SEQUENCE:
   Salvador_plot
 EXAMPLE:
   Salvador_plot
 INPUTS:
   none, all hardwired for Salvador
 OUTPUTS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150511
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/salvador_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_risk_calculations">
<H2>salvador_risk_calculations</H2></A>
 create waterfall and adapatation measures for San Salvadoro
 MODULE:
   salvador_demo
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150901, init
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/salvador_risk_calculations.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_shp_prepare">
<H2>salvador_shp_prepare</H2></A>
% LOAD THE FINAL PREPARED SHAREDFILES
 - shapes                   : adm2
 - shape_rios               : rivers in El Salvador
 - indx_rios_in_San_Salvador: indx to select rivers within San Salvador center
 - polygon_LS               : polygon that roughly defines San Salvador center, used for landslide susceptibility map
 - polygon_rio_acelhuate    : polygon that roughly defines the Rio Acelhuate, used for focus area for flood hazard
oad([climada_global.project_dir filesep 'system' filesep 'san_salvador_shps_adm2_rivers_salvador_polygon_LS.mat'])
 salvador_module_system_dir = ['\\CHRB1065.CORP.GWPNET.COM\homes\X\S3BXXW\Documents\lea\climada_git\climada_modules\salvador_demo\data\system'];
 load([salvador_module_system_dir filesep 'san_salvador_shps_adm2_rivers_salvador_polygon_LS.mat'])
 Lea Mueller, 20150815, update shp-file shift, based on finalized FL hazard and FL entity
 Lea Mueller, 20150815, enlarge polygon_rio_acelhuate, as it was too small before
% san salvador prepare shapefiles
% set data directories, load adm2, polygon_LS and rivers
alvador_data_dir          = climada_global.project_dir;
alvador_module_system_dir = [climada_global.project_dir filesep 'system'];
 load shp admin 2, polygon LS and centroids LS
oad([salvador_module_system_dir filesep 'san_salvador_shps_adm2_rivers_salvador_polygon_LS'])
onsultant_shp_dir = [fileparts(climada_global.project_dir) filesep 'consultant_data' filesep 'hazards' filesep 'landslides' filesep 'system'];
hape_rivers = climada_shaperead([consultant_shp_dir filesep 'rios_25k_polyline_WGS84.shp']);
hape_roads  = climada_shaperead([consultant_shp_dir filesep 'el_salvador_highway.shp']);
 load([climada_global.data_dir filesep 'entities' filesep 'SLV_adm' filesep 'SLV_adm2.mat'])
 salvador_data_dir          = [climada_global.data_dir filesep 'results' filesep 'SanSalvador' filesep 'LS' filesep];
 salvador_module_system_dir = ['\\CHRB1065.CORP.GWPNET.COM\homes\X\S3BXXW\Documents\lea\climada_git\climada_modules\salvador_demo\data\system'];
% prepare river shapefile (apply shift in lat/lon)
 find rivers that are in San Salvador center
ndx_rivers_in_San_Salvador = zeros(1,numel(shape_rivers));
or s_i = 1:numel(shape_rivers)
   shape_rivers(s_i).X(isnan(shape_rivers(s_i).X)) = [];
   shape_rivers(s_i).Y(isnan(shape_rivers(s_i).Y)) = [];
   inpoly_indx = inpoly([shape_rivers(s_i).X' shape_rivers(s_i).Y'],[polygon_LS.lon_shift polygon_LS.lat_shift]);
   if any(inpoly_indx)
       indx_rivers_in_San_Salvador(s_i) = 1;
   end
nd
ndx_rivers_in_San_Salvador = logical(indx_rivers_in_San_Salvador);
 find roads that are in San Salvador center
ndx_roads_in_San_Salvador = zeros(1,numel(shape_roads));
or s_i = 1:numel(shape_roads)
   shape_roads(s_i).X(isnan(shape_roads(s_i).X)) = [];
   shape_roads(s_i).Y(isnan(shape_roads(s_i).Y)) = [];
   inpoly_indx = inpoly([shape_roads(s_i).X' shape_roads(s_i).Y'],[polygon_LS.lon_shift polygon_LS.lat_shift]);
   if any(inpoly_indx)
       indx_roads_in_San_Salvador(s_i) = 1;
   end
nd
ndx_roads_in_San_Salvador = logical(indx_roads_in_San_Salvador);
% copy original values before shift
 save original values, rivers
or s_i = 1:numel(shape_rivers)
   shape_rivers(s_i).X_ori = shape_rivers(s_i).X;
   shape_rivers(s_i).Y_ori = shape_rivers(s_i).Y;
nd
 save original values, roads
or s_i = 1:numel(shape_roads)
   shape_roads(s_i).X_ori = shape_roads(s_i).X;
   shape_roads(s_i).Y_ori = shape_roads(s_i).Y;
nd
 save original values, adm 2
or s_i = 1:numel(shapes)
   shapes(s_i).X_ori = shapes(s_i).X;
   shapes(s_i).Y_ori = shapes(s_i).Y;
nd
% apply shift in lon/lat for rivers
 shift_lon = 0.02/4;
 shift_lat = -0.02/6;
hift_lon = -0.002/6;
hift_lat = -0.005/5;
or s_i = 1:numel(shape_rivers)
   % rivers
   shape_rivers(s_i).X = shape_rivers(s_i).X_ori + shift_lon;
   shape_rivers(s_i).Y = shape_rivers(s_i).Y_ori + shift_lat;
nd
or s_i = 1:numel(shape_roads)
   % roads
   shape_roads(s_i).X = shape_roads(s_i).X_ori + shift_lon;
   shape_roads(s_i).Y = shape_roads(s_i).Y_ori + shift_lat;
nd
or s_i = 1:numel(shapes)  
   % admin level 2
   shapes(s_i).X = shapes(s_i).X_ori - shift_lon;
   shapes(s_i).Y = shapes(s_i).Y_ori - shift_lat;
nd
% create polygon for rio acelhaute
 load inundation hazard
oldername = [fileparts(fileparts(consultant_shp_dir)) filesep 'inundation' filesep '20150723_rio_acelhuate_rio_garrobo_2D'];
 foldername = 'M:\BGCC\CHR\RK\RS\A_Sustainable_Development\Projects\ECA\SanSalvador\consultant_data\hazards\inundation\20150723_rio_acelhuate_rio_garrobo_2D';
sci_file = [foldername filesep 'flood_gar_2yr_10m.asc'];
oad(strrep(asci_file,'.asc','.mat'))
igure
lot(hazard.lon, hazard.lat,'x');
old on
ndx = hazard.intensity(end,:)&ampgt0;
lot(hazard.lon(indx), hazard.lat(indx),'ro');
poygon_rio_acelhuate.lon, poygon_rio_acelhuate.lat]= ginput;
lot(poygon_rio_acelhuate.lon, poygon_rio_acelhuate.lat,'-.c');
% save shp results
 save([salvador_module_system_dir filesep 'san_salvador_shps_adm2_rivers_salvador_polygon_LS.mat'],'shapes','shape_rios','indx_rios_in_San_Salvador','polygon_LS','polygon_rio_acelhuate')
ave([climada_global.project_dir filesep 'system' filesep 'san_salvador_shps_adm2_rivers_salvador_polygon_LS.mat'],...
   'shapes','shape_rivers','shape_roads','indx_rivers_in_San_Salvador', 'indx_roads_in_San_Salvador',...
   'polygon_LS','polygon_rio_acelhuate','polygon_ilopango','rectangle_canas','polygon_canas','polygon_acelhuate','polygon_correction')
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/salvador_shp_prepare.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_tc_hazard_prob">
<H2>salvador_tc_hazard_prob</H2></A>
 create probabilistic TC hazard 
 MODULE:
   salvador_demo
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150401, init
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/salvador_tc_hazard_prob.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="utm2ll_salvador">
<H2>utm2ll_salvador</H2></A>
<font color="blue">function [lon,lat] = utm2ll_salvador(x,y,datum,varargin) </font>
UTM2LL UTM to Lat/Lon coordinates precise conversion.
	[LON,LAT]=UTM2LL(X,Y,ZONE) converts BTM coordinates X,Y (in meters)
	defined in the UTM ZONE (integer) to longitude LON and latitude LAT
	(in degrees). Default datum is WGS84.

	X, Y and F can be scalars, vectors or matrix. Outputs LAT and LON will
	have the same size as inputs.

	For southern hemisphere points, use negative zone -ZONE.

	UTM2LL(X,Y,ZONE,DATUM) uses specific DATUM for conversion. DATUM can be
	a string in the following list:
		'wgs84': World Geodetic System 1984 (default)
		'nad27': North American Datum 1927
		'clk66': Clarke 1866
		'nad83': North American Datum 1983
		'grs80': Geodetic Reference System 1980
		'int24': International 1924 / Hayford 1909
	or DATUM can be a 2-element vector [A,F] where A is semimajor axis (in
	meters)	and F is flattening of the user-defined ellipsoid.

	Notice:
		- BTM2LL does not perform cross-datum conversion.
		- precision is near a millimeter.


	Reference:
		I.G.N., Projection cartographique Mercator Transverse: Algorithmes,
		   Notes Techniques NT/G 76, janvier 1995.

	Author: Francois Beauducel, &ampltbeauducel@ipgp.fr&ampgt
	Created: 2001-08-23
	Updated: 2015-01-29
   Changed to BTM: Ruud van der Ent, 2015-03-13
   Lea Mueller, muellele@gmail.com, 20150415, order change, first lon, then lat
	Copyright (c) 2001-2015, Franois Beauducel, covered by BSD License.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without 
	modification, are permitted provided that the following conditions are 
	met:

	   * Redistributions of source code must retain the above copyright 
	     notice, this list of conditions and the following disclaimer.
	   * Redistributions in binary form must reproduce the above copyright 
	     notice, this list of conditions and the following disclaimer in 
	     the documentation and/or other materials provided with the distribution
	                           
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quotAS IS&quot 
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
	CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
	INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
	POSSIBILITY OF SUCH DAMAGE.
 Available datums
atums = [ ...
{ 'wgs84', 6378137.0, 298.257223563 };
{ 'nad83', 6378137.0, 298.257222101 };
{ 'grs80', 6378137.0, 298.257222101 };
{ 'nad27', 6378206.4, 294.978698214 };
{ 'int24', 6378388.0, 297.000000000 };
{ 'clk66', 6378206.4, 294.978698214 };
   { 'eve30', 6377299.36, 300.8017 };
;
f nargin &amplt 2
error('Not enough input arguments.')
nd
f all([numel(x),numel(y)] &ampgt 1) &amp&amp any(size(x) ~= size(y))
error('X and Y must be the same size or scalars.')
nd
f ~exist('datum','var'), datum = ''; end
f isempty(datum), datum = 'wgs84'; end
f nargin &amplt 3
datum = 'wgs84';
nd
f ischar(datum)
if ~any(strcmpi(datum,datums(:,1)))
	error('Unkown DATUM name &quot%s&quot',datum);
end
k = find(strcmpi(datum,datums(:,1)));
A1 = datums{k,2};
F1 = datums{k,3};	
lse
if numel(datum) ~= 2
	error('User defined DATUM must be a vector [A,F].');
end
A1 = datum(1);
F1 = datum(2);
nd
 SHIFT
 = x+15;   y = y-105;
 constants
0 = 180/pi;	% conversion rad to deg
axiter = 100;	% maximum iteration for latitude computation
ps = 1e-11;	% minimum residue for latitude computation
0 = 1;%0.9996;				  % BTM scale factor
0 = 500000;				  % BTM false East (m)
0 = 295809.184;%-2000000;	  % BTM false North (m)
0 = 13.78429963/D0;%0;		  % BTM origin latitude (rad)
0 = -88.99998296/D0; %90/D0; % BTM origin longitude (rad)
1 = sqrt((A1^2 - (A1*(1 - 1/F1))^2)/A1^2);	% ellpsoid excentricity
 = K0*A1;
 computing parameters for Mercator Transverse projection
 = coef(E1,0);
S = Y0 - N*(C(1)*P0 + C(2)*sin(2*P0) + C(3)*sin(4*P0) + C(4)*sin(6*P0) + C(5)*sin(8*P0));
 = coef(E1,1);
t = complex((y - YS)/N/C(1),(x - X0)/N/C(1));
 = zt - C(2)*sin(2*zt) - C(3)*sin(4*zt) - C(4)*sin(6*zt) - C(5)*sin(8*zt);
 = real(z);
S = imag(z);
 = L0 + atan(sinh(LS)./cos(L));
 = asin(sin(L)./cosh(LS));
 = log(tan(pi/4 + p/2));
 calculates latitude from the isometric latitude
 = 2*atan(exp(L)) - pi/2;
0 = NaN;
 = 0;
hile any(isnan(p0) | abs(p - p0) &ampgt eps) &amp&amp n &amplt maxiter
p0 = p;
es = E1*sin(p0);
p = 2*atan(((1 + es)./(1 - es)).^(E1/2).*exp(L)) - pi/2;
n = n + 1;
nd
f nargout &amplt 2
lat = D0*[p(:),l(:)];
lse
lat = p*D0;
lon = l*D0;
nd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<font color="blue">function c = coef(e,m) </font>
COEF Projection coefficients
	COEF(E,M) returns a vector of 5 coefficients from:
		E = first ellipsoid excentricity
		M = 0 for transverse mercator
		M = 1 for transverse mercator reverse coefficients
		M = 2 for merdian arc
f nargin &amplt 2
m = 0;
nd
witch m
case 0
c0 = [-175/16384, 0,   -5/256, 0,  -3/64, 0, -1/4, 0, 1;
          -105/4096, 0, -45/1024, 0,  -3/32, 0, -3/8, 0, 0;
          525/16384, 0,  45/1024, 0, 15/256, 0,    0, 0, 0;
         -175/12288, 0, -35/3072, 0,      0, 0,    0, 0, 0;
         315/131072, 0,        0, 0,      0, 0,    0, 0, 0];
  
case 1
c0 = [-175/16384, 0,   -5/256, 0,  -3/64, 0, -1/4, 0, 1;
            1/61440, 0,   7/2048, 0,   1/48, 0,  1/8, 0, 0;
         559/368640, 0,   3/1280, 0,  1/768, 0,    0, 0, 0;
         283/430080, 0, 17/30720, 0,      0, 0,    0, 0, 0;
      4397/41287680, 0,        0, 0,      0, 0,    0, 0, 0];
case 2
c0 = [-175/16384, 0,   -5/256, 0,  -3/64, 0, -1/4, 0, 1;
        -901/184320, 0,  -9/1024, 0,  -1/96, 0,  1/8, 0, 0;
        -311/737280, 0,  17/5120, 0, 13/768, 0,    0, 0, 0;
         899/430080, 0, 61/15360, 0,      0, 0,    0, 0, 0;
     49561/41287680, 0,        0, 0,      0, 0,    0, 0, 0];
  
nd
 = zeros(size(c0,1),1);
or i = 1:size(c0,1)
   c(i) = polyval(c0(i,:),e);
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/salvador_demo/code/helper_functions/utm2ll_salvador.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="WS_intensity_correction">
<H2>WS_intensity_correction</H2></A>
<font color="blue">function WS_intensity_correction(save_files) </font>
 climada
 NAME:
   WS_intensity_correction
 PURPOSE:
   correct WS intenisty as documented in the paper:

   Schwierz, C., P. K?llner-Heck, E. Zenklusen Mutter, D. N. Bresch,
   P.-L.Vidale, M. Wild, C., and Sch?r, 2010: Modelling European winter
   wind storm losses in current and future climate. Climatic Change (2010)
   101:485?514, doi: 10.1007/s10584-009-9712-1.

   If applied a second time, the correction is reversed

   WARNING: a truly expert level code, to be used with utmost caution

   see also winterstorm_compare and winterstorm_compare_severity
 CALLING SEQUENCE:
   WS_intensity_correction(param1);
 EXAMPLE:
   WS_intensity_correction
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   save_files: whether files are saves(=1) or only inspected (=0, default)
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141129
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/storm_europe/code/WS_intensity_correction.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_TEST">
<H2>winterstorm_TEST</H2></A>
<font color="blue">function winterstorm_TEST(check_plots) </font>
 climada
 NAME:
   winterstorm_TEST
 PURPOSE:
   TEST European winter storm module
 CALLING SEQUENCE:
   winterstorm_TEST(check_plot);
 EXAMPLE:
   winterstorm_TEST(1);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   check_plots: if =1, show figures to check hazards etc.
       If =0, skip figures (default)
       If country_name is set to 'ALL', be careful to set check_plots=1
 OUTPUTS:
   to stdout and storing an encoded entity to data/entities
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141029
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/storm_europe/code/winterstorm_TEST.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_blend_hazard_event_sets">
<H2>winterstorm_blend_hazard_event_sets</H2></A>
<font color="blue">function hazard=winterstorm_blend_hazard_event_sets(hazard_save_file,frequency_screw,intensity_screw) </font>
 climada
 MODULE:
   ws_europe
 NAME:
   winterstorm_blend_hazard_event_sets
 PURPOSE:
   Blend the four WS hazard events sets into one, see PARAMETERS in code

   Hazard sets from:
   Schwierz, C., P. Koellner-Heck, E. Zenklusen Mutter, D. N. Bresch,
   P.-L.Vidale, M. Wild, C., and Sch?r, 2010: Modelling European winter
   wind storm losses in current and future climate. Climatic Change (2010)
   101:485?514, doi: 10.1007/s10584-009-9712-1.

   See also winterstorm_compare and winterstorm_compare_severity
 CALLING SEQUENCE:
   hazard=winterstorm_blend_hazard_event_sets(hazard_save_file,frequency_screw)
 EXAMPLE:
   hazard=winterstorm_blend_hazard_event_sets('WS_Europe_blend.mat',0.9)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   hazard_save_file: the filename (w/o path) of the blended output file
       It is always stored in the same folder as the files it is blended
       from, e.g. only a filename, such as 'WS_Europe_blend.mat'.
   frequency_screw: an EXPERIMENTAL multiplier for the frequency, just
       multiplies all single event frequencies. Default=1 (obviously)
       (Can be justified to adjust, due to the fact that we blend hazard
       sets, an adjustment accounts for especially smaller scale events) 
   intensity_screw: scale intensity with, default=1
 OUTPUTS:
   hazard: the blended hazard event set, usually named WS_Europe.mat, see
       optional input parameter hazard_save_file
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141201, initial
 David N. Bresch, david.bresch@gmail.com, 20141206, frequency_screw added
 David N. Bresch, david.bresch@gmail.com, 20141213, intensity_screw added
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/storm_europe/code/winterstorm_blend_hazard_event_sets.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_compare">
<H2>winterstorm_compare</H2></A>
<font color="blue">function EDS=winterstorm_compare(entity,compare_damage_functions,compare_hazard_sets,compare_scenarios) </font>
 climada
 NAME:
   winterstorm_compare
 PURPOSE:
   Run a winterstorm Europe analysis for a given entity with different
   damage functions and different hazard event sets.

   compare_damage_functions: those derived based upon DWD and EuroTempest gust
   data. The code tries to use the matching hazard event set (as as
   created by country_risk_calc). If not found, the code prompts for a WS
   hazard event set and re-encodes assets.

   compare_hazard_sets, hazard sets from:
   Schwierz, C., P. K?llner-Heck, E. Zenklusen Mutter, D. N. Bresch,
   P.-L.Vidale, M. Wild, C., and Sch?r, 2010: Modelling European winter
   wind storm losses in current and future climate. Climatic Change (2010)
   101:485?514, doi: 10.1007/s10584-009-9712-1.

   compare_scenarios: show the modeled scenario loss for the events as
   defined in the data/validation folder in Database_master_table.xls
   WARNING: does not make much sense, since the scenario hazard intensity
   is not calibrated with the hazard intensities in the hazard event sets
   based on Schwierz et al. Code just kept for reference.

   See also winterstorm_validate and winterstorm_compare_severity
   See also climada_DFC_compare in core climada
 CALLING SEQUENCE:
   EDS=winterstorm_compare(entity,compare_damage_functions,compare_hazard_sets,compare_scenarios)
 EXAMPLE:
   EDS=winterstorm_compare('',1,1) % run damage function and hazard set
       comparisons
 INPUTS:
   entity: an encoded entity, see climada_entity_read
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   compare_damage_functions: if =1, compare damage functions (default)
       run 4 times: damage function as in entity, 2 versions with explicit
       function and using the standard WS damage function, see
       damagefunctions_filename in PARAMETERS in code
       =0: omit this
   compare_hazard_sets: if =1, compare hazard sets using the standard
       damage function, see damagefunctions_filename in PARAMETERS in code
       =0: omit this (default)
       =2, use the damage function as in entity, not the standard one
       Note that for each damage calculation, the entity is re-encoded (to
       be on the safe side)
   compare_scenarios: if =1, show modeled scenario losses, using standard
       damage function, see damagefunctions_filename in PARAMETERS in code.
       See PARAMETERS to define the location and name of the
       Database_master_table. WARNING: results do not make much sense,
       since scenario hazard intensities are not calibrated.
       =0: omit (default)
       =2, use the damage function as in entity, not the standard one
       Note that for each damage calculation, the entity is re-encoded (to
       be on the safe side)
       Note further that compare_scenarios only does not make much sense,
       but is permitted, as one might want to overlay scenario results to
       an existing DFC plot.
 OUTPUTS:
   EDS: the event damage set(s), see climada_EDS_calc
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141121, ICE initial
 David N. Bresch, david.bresch@gmail.com, 20141128, compare_hazard_sets, compare_scenarios
 David N. Bresch, david.bresch@gmail.com, 20141201, WARNING for compare_scenarios added
 David N. Bresch, david.bresch@gmail.com, 20141223, LOCAL folders moved
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/storm_europe/code/winterstorm_compare.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_compare_severity">
<H2>winterstorm_compare_severity</H2></A>
<font color="blue">function severity=winterstorm_compare_severity(compare_scenarios,plot_linear) </font>
 climada
 NAME:
   winterstorm_compare_severity
 PURPOSE:
   Compare the hazard severity of different hazard sets

   See also winterstorm_compare
   See also climada_DFC_compare in core climada
 CALLING SEQUENCE:
   severity=winterstorm_compare_severity(compare_scenarios)
 EXAMPLE:
   severity=winterstorm_compare_severity
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   compare_scenarios: if =1, run the severity calculation for single
       scenarios, too, and add them to the severity comparison
       =0: omit (default)
       See HARD CHOICE, TO BE REVISED in code, too
 OUTPUTS:
   severity: the severity information for all
       hazard event sets is stored (inspect yourself)
       For speedup, the routine saves .mat files with each hazard set's
       results in {module_data_dir}/results
   plot_linear: if =1, plot linear (default), otherwise loglog (=0)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141128, initial
 David N. Bresch, david.bresch@gmail.com, 20141223, folders moved
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/storm_europe/code/winterstorm_compare_severity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_scenario_hazard">
<H2>winterstorm_scenario_hazard</H2></A>
<font color="blue">function hazard=winterstorm_scenario_hazard(storm_data_filename,plot_gust_field,save_hazard_flag) </font>
 climada
 NAME:
   winterstorm_scenario_hazard
 PURPOSE:
   read the single storm gust table and create a single storm hazard event

   see winterstorm_validate and winterstorm_compare
 CALLING SEQUENCE:
   hazard=winterstorm_scenario_hazard(storm_data_filename,save_hazard_flag)
 EXAMPLE:
   hazard=winterstorm_scenario_hazard(storm_data_filename,save_hazard_flag)
 INPUTS:
   storm_data_filename: the filename of a single storm (.csv). The file
   just contains n lines with grid number, gust. Hence we also read the
   grid table (see )
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   plot_gust_field: if =1, plot the gust field (default=0)
   save_hazard_flag: if =1, save as single hazard event set (default=0)
       on subsequent calls, the hazard is read from this file, rather than
       re-created (hence delete the .mat file to re-create from .csv).
       If =2, force re-creation of the .mat file, i.e. re-read from the
       .csv file and create the scenario hazard set again
 OUTPUTS:
   hazard: a single hazard event set
       if save_hazard_flag=1, stored as climada hazard event set (with
       just one event)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141128, initial
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/storm_europe/code/winterstorm_scenario_hazard.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_severity">
<H2>winterstorm_severity</H2></A>
<font color="blue">function severity=winterstorm_severity(hazard,check_plot) </font>
 climada
 NAME:
   winterstorm_severity
 PURPOSE:
   calculate the winterstorm severity, a measure for it's 'strength'

   in essence, calculate sum of v^3 over all centroids of a each event

   see winterstorm_compare_severity (to show severity exceedence curve etc)
 CALLING SEQUENCE:
   severity=winterstorm_severity(hazard)
 EXAMPLE:
   severity=winterstorm_severity(hazard)
 INPUTS:
   hazard: the filename of a hazard event set
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   check_plot: if =1, show check plot of selected centroids
       =0: no plot (default)
 OUTPUTS:
   severity: a structure with
       index= the storm severity index
       frequency: the event frequency
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141128, initial
 David N. Bresch, david.bresch@gmail.com, 20141212, compatible with new admin0.mat
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/storm_europe/code/winterstorm_severity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_climada_nonspheric_distance_m">
<H2>_climada_nonspheric_distance_m</H2></A>
<font color="blue">function [fDistance_km GridVect] = climada_nonspheric_distance_m(fLon1,fLat1,fLon2,fLat2,... </font>
                                                        CUID, inreach)      
 This function calculates the distance for each individual gridpoint from
 the TC center. Distance differences in x direction, depending on
 latitude, are normalized in the whole inreach-box with the value at the
 TC-Center

 --------------------------------------------------------------------------
 Modified Haversine Formula to normalize distance differences in y (longitudinal)
 direction at different latitudes
 --------------------------------------------------------------------------
 used in climada_tc_rainfield
 MODIFICATION HISTORY:
 Fabian Schoenenberger, 20110601
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/_climada_nonspheric_distance_m.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_scaleup_factor">
<H2>climada_EDS_scaleup_factor</H2></A>
<font color="blue">function ELS = climada_ELS_scaleup_factor(ELS, factor_) </font>
lobal climada_global
f ~climada_init_vars,return;end % init/import global variables
 poor man's version to check arguments
f ~exist('ELS'    ,'var'), ELS     = []; end
f ~exist('factor_','var'), factor_ = []; end
f isempty(ELS)
   ELS = climada_ELS_load;
nd
f isempty(factor_)
   fprintf('No scaleup factor given. Unable to proceed.\n')
   return
nd
 % scale up ELS with given factor
f ~isempty(ELS)
   ELS.loss        = factor_ * ELS.loss;
   ELS.loss_per_cu = factor_ * ELS.loss_per_cu;
   ELS.EL_per_cu   = factor_ * ELS.EL_per_cu;
   ELS.Value       = factor_ * ELS.Value;
   ELS.comment     = sprintf('Scaled up ELS with factor %2.2f, %s',...
                              factor_, ELS.comment);
   ELS.annotation_name = sprintf('Scaled up ELS with factor %2.2f, %s',...
                                  factor_, ELS.annotation_name);
   ELS.EL          = factor_ * ELS.EL;                           
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_EDS_scaleup_factor.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_RCLIPER">
<H2>climada_RCLIPER</H2></A>
<font color="blue">function [rainrate] = climada_RCLIPER(fmaxwind_kn,inreach,Radius_km)                                   </font>
 calculate rainrate based on RCLIPER in mm/h
 NAME:
   climada_RCLIPER
 PURPOSE:
   given the windspeed (kn) at a specific node calculate the rainrate at 
   all centroids according to RCLIPER (symmetric rainfield)

   usually called from: climada_tr_rainfield (see there)
 CALLING SEQUENCE:
   climada_RCLIPER(fmaxwind_kn, inreach, Radius_km)
 EXAMPLE:
   rainrate=climada_RCLIPER(tc_track.MaxSustainedWind(i),inreach,fRadius_km);      
 INPUTS:
   fmaxwind_kn: maximum sustained wind at specific node (array) 
   inreach:     logical vector of centroids length, containing 1 if centroid
                is within (3, see climada_tr_rainfield) deg of node, otherwise 0 
   Radius_km:   vector of centroids length, containing distance to node
                for every centroid
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   res.G: the rainrate [mm/h] at all centroids
       the single-character variables refer to the Pioneer offering circular
       that's why we kept these short names (so one can copy the OC for
       documentation)
   res.lat: the latitude of the centroids
   res.lon: the longitude of the centroids
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 201106038
 david.bresch@gmail.com, 20140804, GIT update
 david.bresch@gmail.com, 20160529, header edited
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_RCLIPER.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_admin_name">
<H2>climada_admin_name</H2></A>
<font color="blue">function [admin_name, admin_shapes, adm_lvl, shape_ndx, country_name, location] ... </font>
   = climada_admin_name(country_name,admin_name,adm_lvl,climada_global_border_file_check)
 climada_admin_name
 MODULE:
   climada core
 NAME:
   climada_admin_name
 PURPOSE:
   check for valid admin name on different levels (0: country, 1: states, 2: districts) 
   and download admin shape files, return all the arguments incl. shape files
   Same concept as climada_country_name, but for admin regions. The map
   border file in climada_global as used in climada_plot_world_borders
   may be replaced with the shape files for the desired admin level, but
   this may cause problems later
 CALLING SEQUENCE:
   [admin_name, admin_shapes, adm_lvl, shape_ndx, country_name, location] ...
     = climada_admin_name(country_name,admin_name,adm_lvl,climada_global_border_file_check)
 EXAMPLE:
   [admin_name, admin_shapes, adm_lvl, shape_ndx, country_name, location] ...
     = climada_admin_name('Netherlands','Utrecht',2,1)
 INPUTS: 
 OPTIONAL INPUT PARAMETERS:
   country_name:   country of interest,prompted from if not given
   admin_name:     set to 'SINGLE' (default) for single admin region
                   selection at the specified admin level
                   set to 'MULTIPLE' for multi-region select within one
                   admin level, e.g. admin level set to 2 =&ampgt select
                   country, select admin region at level 1, then choose
                   multiple regions at level 2
                   set to 'ALL' to return all admin regions at desired
                   admin level for entire country
   adm_lvl:        define admin level of interest (max admin level varies
                   per country)
   climada_global_border_file_check:   whether to set admin shapes as
                                       default climada global map border file.
 OUTPUTS:
   admin_name:     name of the selected admin region
   admin_shapes:   shapes struct array at admin level
   adm_lvl:        administrative region (0 = country)
   shape_ndx:      shape index of selected admin region in admin shapes
                   structure array
   country_name:   country name
   location:       struct with .lon .lat for centre of selected admin region
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150508 init
 Gilles Stassen, gillesstassen@hotmail.com, 20150615, documentation, hopefully all bugs are gone (they never are...)
 Lea Mueller, muellele@gmail.com, 20150615, climada_global.data dir instead of module_dir
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_admin_name.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_distance_to_coast">
<H2>climada_centroids_distance_to_coast</H2></A>
<font color="blue">function centroids = climada_centroids_distance_to_coast(centroids, coastline, check_figure) </font>
 calculate distance to coast in km for every centroid and add information
 in the field centroids.dist_to_coast
 NAME:
   climada_centroids_distance_to_coast
 PURPOSE:
   calculate distance to coast in km for every centroid and add information
   in the field centroids.dist_to_coast
   within: climada_hazard_distance_to_coast
 CALLING SEQUENCE:
   centroids = climada_centroids_distance_to_coast(centroids, coastline,
   check_figure)
 EXAMPLE:
   centroids = climada_centroids_distance_to_coast
 INPUTS:
   none, if coastline_file empty default file is loaded from 
 OPTIONAL INPUT PARAMETERS:
   check_figure to create figure
 OUTPUTS:
   centroids structure variable including field centroids.dist_to_coast
   with distance to coast in km
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_centroids_distance_to_coast.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_hazard_expand">
<H2>climada_centroids_hazard_expand</H2></A>
<font color="blue">function [centroids,hazard] = climada_centroids_hazard_expand(centroids_ori, hazard_ori, tc_track) </font>
 UNDOCUMENTED
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_centroids_hazard_expand.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_coastline_read">
<H2>climada_coastline_read</H2></A>
<font color="blue">function coastline = climada_coastline_read(coastline_file, check_plot) </font>
read the coastline file, data source NOAA
 http://www.ngdc.noaa.gov/mgg/coast/
 NAME:
   climada_coastline_read
 PURPOSE:
   read the coastline and have coastline as output
   within: climada_centroids_distance_to_coast
 CALLING SEQUENCE:
   coastline = climada_coastline_read(coastline_file)
 EXAMPLE:
   coastline = climada_coastline_read
 INPUTS:
   none, if coastline_file empty default file is loaded from globalGDP
   modul data folder
 OPTIONAL INPUT PARAMETERS:
   check_plot to create figure
 OUTPUTS:
   coastline
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_coastline_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_event_damage_animation_ge">
<H2>climada_event_damage_animation_ge</H2></A>
<font color="blue">function res=climada_event_damage_animation_ge(animation_data_file,google_earth_save,schematic_tag) </font>
 climada_event_damage_animation_ge
 MODULE:
   tc_hazard_advanced
 NAME:
   climada_event_damage_animation_ge
 PURPOSE:
   Animation of event damage in google earth
   This code write the kmz file for google earth, see e.g.
   climada_event_damage_data_tc to calculate all the data. As one often
   needs to play with visualization parameters, the process is split.

   An animation of the tropical cylclone track hitting the assets as
   defined in entity.

   The code determines the plot area based on entity (but since there can be
   more than one ocean basin's tracks hitting the centroids, the user has
   to select the track file).

   prior calls: climada_event_damage_data_tc or similar to prepare the
   event damage information
 CALLING SEQUENCE:
   res=climada_event_damage_animation_ge(animation_data_file,google_earth_save)
 EXAMPLE:
   res=climada_event_damage_animation_ge; % prompt for
 INPUTS:
   animation_data_file: the data file (.mat) with hazard set which
       includes event damage information, see e.g. climada_event_damage_data_tc
       &ampgt promted for if not given
   google_earth_save: the filename of the resulting .kmz google earth file
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   schematic_tag: set to 1 if schematic plot (no colorbar, indicative
   colorscale). if set to 0, e.g. tc wind color scale is yellow
   (20-30 m/s), orange (30-40 m/s), dark orange (40-50 m/s), etc...
 OUTPUTS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150130, initial
 Lea Mueller, muellele@gmail.com, 20150203, schematic tag
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_event_damage_animation_ge.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_clim_scen_IPCC">
<H2>climada_hazard_clim_scen_IPCC</H2></A>
<font color="blue">function hazard = climada_hazard_clim_scen_IPCC(hazard, tc_track, hazard_save_name, reference_year, screw) </font>
 NAME:
   climada_hazard_clim_scen
 PURPOSE:
   starting from a given hazard event set (hazard), construct the
   hazard event set (hazard_clim_file) for a climate change scenario, e.g.
   from IPCC SREX
 CALLING SEQUENCE:
   hazard = climada_tc_hazard_clim_scen(hazard, tc_track, reference_year, screw)
 EXAMPLE:
   hazard = climada_tc_hazard_clim_scen
 INPUTS:
   hazard  :         either a hazard set (struct) or a hazard set file (.mat with a struct)
                     &ampgt promted for if not given
   tc_track:         either a tc track set (struct) or a tc track set file (.mat with a struct)
                     &ampgt promted for if not given (important for storm
                     category)
 OPTIONAL INPUT PARAMETERS:
   reference_year:   the reference year for the give climate change scenario, 
                     e.g. 2017 (+5 years), and then frequency and or intensity 
                     changes are linearly interpolated from the projected time 
                     horizon (e.g. 2100 from IPCC SREX) to the requested
                     reference year.
   screw:            structure of one or multiple frequency or intensity 
                     changes given a certain projected time horizon, default
                     from IPCC SREX taken if not given
                     example:  
                        screw.variable_to_change = 'frequency';
                        screw.frequency          = 0.8;
                        screw.time_horizon       = 2100;
                        screw.cat                = [4 5];
   hazard_save_name: the filename of the new climate scenario hazard event set
                     &ampgt promted for if not given
 OUTPUTS:
   hazard  :        the hazard event set for the climate scenario, also
                     stored to hazard_save_name
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090920
 Lea Mueller, 20120816
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_clim_scen_IPCC.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_clim_scen_advanced">
<H2>climada_hazard_clim_scen_advanced</H2></A>
<font color="blue">function hazard = climada_hazard_clim_scen_advanced(hazard, tc_track, hazard_save_name, reference_year, screw) </font>
 NAME:
   climada_hazard_clim_scen_advanced
 PURPOSE:
   starting from a given hazard event set (hazard), construct the
   hazard event set (hazard_clim_file) for a climate change scenario, e.g.
   from IPCC SREX
   
   see also core climada code climada_hazard_clim_scen
 CALLING SEQUENCE:
   hazard = climada_tc_hazard_clim_scen(hazard, tc_track, reference_year, screw)
 EXAMPLE:
   hazard = climada_tc_hazard_clim_scen
 INPUTS:
   hazard  :         either a hazard set (struct) or a hazard set file (.mat with a struct)
                     &ampgt promted for if not given
   tc_track:         either a tc track set (struct) or a tc track set file (.mat with a struct)
                     &ampgt promted for if not given (important for storm
                     category)
 OPTIONAL INPUT PARAMETERS:
   reference_year:   the reference year for the give climate change scenario, 
                     e.g. 2017 (+5 years), and then frequency and or intensity 
                     changes are linearly interpolated from the projected time 
                     horizon (e.g. 2100 from IPCC SREX) to the requested
                     reference year.
   screw:            structure of one or multiple frequency or intensity 
                     changes given a certain projected time horizon, default
                     from IPCC SREX taken if not given
                     example:  
                        screw.variable_to_change = 'frequency';
                        screw.frequency          = 0.8;
                        screw.time_horizon       = 2100;
                        screw.cat                = [4 5];
   hazard_save_name: the filename of the new climate scenario hazard event set
                     &ampgt promted for if not given
 OUTPUTS:
   hazard  :        the hazard event set for the climate scenario, also
                     stored to hazard_save_name
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090920
 Lea Mueller, 20120816
 David N. Bresch, david.bresch@gmail.com, 20141103, named climada_hazard_clim_scen_advanced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_clim_scen_advanced.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_climate_screw">
<H2>climada_hazard_climate_screw</H2></A>
<font color="blue">function hazard = climada_hazard_climate_screw(hazard, hazard_set_file, reference_year, screw) </font>
 NAME:
 climada_hazard_climate_screw
 PURPOSE:
   Compute the future hazard set for a given climate change scenario from
   a hazard set defining the risk today.
 CALLING SEQUENCE:
   hazard = climada_hazard_climate_screw(hazard, hazard_set_file, reference_year, screw)
 EXAMPLE:
   hazard_cc = climada_hazard_climate_screw(hazard, '', 2040, screw)
   hazard_cc = climada_hazard_climate_screw(hazard, 'NO_SAVE')
   hazard_cc = climada_hazard_climate_screw
 INPUTS:
   hazard:     hazard set today (can be any peril which may be subject to
               climate change)
 OPTIONAL INPUT PARAMETERS:
   hazard_set_file:    file name defining where the new hazard should be
                       saved. If set to 'NO_SAVE', the hazard set will not 
                       be saved. Prompted for if left empty.
   reference_year:     time horizon for which one wishes to compute the
                       climate change hazard set. If left empty, the 
                       reference year in climada_global will be used.
   screw:      defines the climate change scenario. A 1xN structure with
               fields:
                   .hazard_fld     defines the hazard field to be changed
                   .change         extent of the change at time horizon
                   .year           time horizon
                   .hazard_crit    hazard field to which criteria apply
                   .criteria       criteria for events/locations to change
                   .bsxfun_op      operation of change (e.g. @times,@plus) (function handle)
               specifying N transformations to the original hazard set.
 OUTPUTS:
   hazard:     new hazard for a future reference year, given a climate
               change scenario specified by screw.
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150421 based on original
           function climada_hazard_clim_scen_advanced by David N. Bresch &amp Lea Mueller
 Lea Mueller, muellele@gmail.com, 20151021, do not change hazard if it corresponds already to the required year
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_climate_screw.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_distance_to_coast">
<H2>climada_hazard_distance_to_coast</H2></A>
<font color="blue">function hazard = climada_hazard_distance_to_coast(hazard, centroids, tc_track, check_figure) </font>
 Weakening of hazard, namely maximum sutained wind over land depending on
 distance to coast 
 NAME:
   climada_hazard_distance_to_coast
 PURPOSE:
   Weakening of hazard, namely maximum sutained wind over land depending
   on
   previous step:  climada_tc_hazard_set
   next step    :  climada_ELS_calc, or climada_hazard_clim_scen, diverse
 CALLING SEQUENCE:
   hazard = climada_hazard_distance_to_coast(hazard, centroids, tc_track)
 EXAMPLE:
   hazard = climada_hazard_distance_to_coast
 INPUTS:
   none, if hazard, centroids or tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   check_figure to create figure
 OUTPUTS:
   same hazard structure but hazard.intensity are lower values depending on
   distance to coast
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_distance_to_coast.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_distance_to_coast_USA">
<H2>climada_hazard_distance_to_coast_USA</H2></A>
<font color="blue">function hazard = climada_hazard_distance_to_coast_USA(hazard, centroids, tc_track, check_figure) </font>
 Weakening of hazard, namely maximum sutained wind over land depending on
 distance to coast 
 NAME:
   climada_hazard_distance_to_coast
 PURPOSE:
   Weakening of hazard, namely maximum sutained wind over land depending
   on
   previous step:  climada_tc_hazard_set
   next step    :  climada_ELS_calc, or climada_hazard_clim_scen, diverse
 CALLING SEQUENCE:
   hazard = climada_hazard_distance_to_coast(hazard, centroids, tc_track)
 EXAMPLE:
   hazard = climada_hazard_distance_to_coast
 INPUTS:
   none, if hazard, centroids or tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   check_figure to create figure
 OUTPUTS:
   same hazard structure but hazard.intensity are lower values depending on
   distance to coast
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_distance_to_coast_USA.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_distance_to_coast_australia">
<H2>climada_hazard_distance_to_coast_australia</H2></A>
<font color="blue">function hazard = climada_hazard_distance_to_coast_australia(hazard, centroids, tc_track, check_figure) </font>
 Weakening of hazard, namely maximum sutained wind over land depending on
 distance to coast 
 NAME:
   climada_hazard_distance_to_coast
 PURPOSE:
   Weakening of hazard, namely maximum sutained wind over land depending
   on
   previous step:  climada_tc_hazard_set
   next step    :  climada_ELS_calc, or climada_hazard_clim_scen, diverse
 CALLING SEQUENCE:
   hazard = climada_hazard_distance_to_coast(hazard, centroids, tc_track)
 EXAMPLE:
   hazard = climada_hazard_distance_to_coast
 INPUTS:
   none, if hazard, centroids or tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   check_figure to create figure
 OUTPUTS:
   same hazard structure but hazard.intensity are lower values depending on
   distance to coast
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_distance_to_coast_australia.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_distance_to_coast_china">
<H2>climada_hazard_distance_to_coast_china</H2></A>
<font color="blue">function hazard = climada_hazard_distance_to_coast_china(hazard, centroids, tc_track, check_figure) </font>
 Weakening of hazard, namely maximum sutained wind over land depending on
 distance to coast 
 NAME:
   climada_hazard_distance_to_coast
 PURPOSE:
   Weakening of hazard, namely maximum sutained wind over land depending
   on
   previous step:  climada_tc_hazard_set
   next step    :  climada_ELS_calc, or climada_hazard_clim_scen, diverse
 CALLING SEQUENCE:
   hazard = climada_hazard_distance_to_coast(hazard, centroids, tc_track)
 EXAMPLE:
   hazard = climada_hazard_distance_to_coast
 INPUTS:
   none, if hazard, centroids or tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   check_figure to create figure
 OUTPUTS:
   same hazard structure but hazard.intensity are lower values depending on
   distance to coast
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_distance_to_coast_china.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_distance_to_coast_japan">
<H2>climada_hazard_distance_to_coast_japan</H2></A>
<font color="blue">function hazard = climada_hazard_distance_to_coast_japan(hazard, centroids, tc_track, check_figure) </font>
 Weakening of hazard, namely maximum sutained wind over land depending on
 distance to coast 
 NAME:
   climada_hazard_distance_to_coast
 PURPOSE:
   Weakening of hazard, namely maximum sutained wind over land depending
   on
   previous step:  climada_tc_hazard_set
   next step    :  climada_ELS_calc, or climada_hazard_clim_scen, diverse
 CALLING SEQUENCE:
   hazard = climada_hazard_distance_to_coast(hazard, centroids, tc_track)
 EXAMPLE:
   hazard = climada_hazard_distance_to_coast
 INPUTS:
   none, if hazard, centroids or tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   check_figure to create figure
 OUTPUTS:
   same hazard structure but hazard.intensity are lower values depending on
   distance to coast
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_distance_to_coast_japan.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_extract_event">
<H2>climada_hazard_extract_event</H2></A>
<font color="blue">function event = climada_hazard_extract_event(hazard,event_i) </font>
 climada
 MODULE:
 NAME:
   climada_hazard_extract_event
 PURPOSE:
   easily extract one event from a hazard set for faster testing/debugging/developing
 CALLING SEQUENCE:
   event = climada_hazard_extract_event(hazard,event_i)
 EXAMPLE:
   event = climada_hazard_extract_event
   event = climada_hazard_extract_event(hazard,153)
 INPUTS:
   hazard:     standard climada hazard event set struct
   event_i:    event number of interest, can be a vector containing
               multiple event numbers
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   event:  struct of the same format as a hazard event set, but only
           containing the events specified by the event numbers in event_i
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150428
 Gilles Stassen, 20150706, multiple events, negative input for nth largest event
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_extract_event.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_footprint_plot">
<H2>climada_hazard_footprint_plot</H2></A>
<font color="blue">function climada_hazard_footprint_plot(hazard, event_no, nametag) </font>
 TC footprint figure
 NAME:
   climada_plot_tc_footprint
 PURPOSE:
 create footprint figure
 CALLING SEQUENCE:
   [contr t_handle] = climada_plot_tc_footprint(hazard, tc_track, track_no)
 EXAMPLE:
   climada_plot_tc_footprint
 INPUTS:
   hazard: hazard.intensity with intensities per centroid
   event_no: a number, event number of hazard to be shown
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   figure with footprint
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20121205
 Lea Mueller, muellele@gmail.com, 20150423
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_footprint_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_merge">
<H2>climada_hazard_merge</H2></A>
<font color="blue">function hazard = climada_hazard_merge(hazard1, hazard2) </font>
 hazard1 = hazard_wkn;
 hazard2 = hazard_ext;
f hazard1.reference_year ~= hazard2.reference_year   
   fprintf(['Warning: Reference years are not equal: ' int2str(hazard1.reference_year) ' and ' int2str(hazard2.reference_year) '\n']);
nd
f hazard1.peril_ID ~= hazard2.peril_ID   
   fprintf(['Warning: Peril IDs are not equal: ' hazard1.peril_ID ' and ' hazard2.peril_ID '\n']);
nd
f hazard1.orig_years ~= hazard2.orig_years   
   fprintf(['Warning: orig years are not equal: ' int2str(hazard1.orig_years) ' and ' int2str(hazard2.orig_years) '\n']);
nd
f hazard1.event_count ~= hazard2.event_count   
   fprintf(['Warning: event counts are not equal: ' int2str(hazard1.event_count) ' and ' int2str(hazard2.event_count) '\n']);
nd
f size(hazard1.lon,2) ~= size(hazard2.lon,2)
   fprintf('Merge two hazards with different centroids\n');
   
   hazard     = hazard2;
   hazard.lon = [hazard1.lon hazard2.lon];
   hazard.lat = [hazard1.lat hazard2.lat];
   no_cen     = size(hazard.lon,2);
   hazard.centroid_ID = 1:no_cen;
   hazard.intensity = [hazard1.intensity hazard2.intensity];
nd
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_merge.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_loss_hist">
<H2>climada_plot_loss_hist</H2></A>
<font color="blue">function climada_plot_loss_hist(event_loss) </font>
 EDS loss damage histogram
 NAME:
   climada_plot_loss_hist
 PURPOSE:
 	plot a histogram of event losses
 CALLING SEQUENCE:
   [contr t_handle] = climada_plot_windfield(hazard, tc_track, track_no)
 EXAMPLE:
   climada_plot_windfield
 INPUTS:
   hazard: hazard.intensity with wind intensities per centroid
   tc_track: a structure with the track information:
   track_no: number of track to show footprint
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   figure with footprint
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, david.bresch@gmail.com, 20121205
 Lea Mueller, david.bresch@gmail.com, 20141121, fixed (was a mess)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_plot_loss_hist.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_lossfootprint">
<H2>climada_plot_lossfootprint</H2></A>
<font color="blue">function climada_plot_lossfootprint(event_loss, centroids, tc_track, nametag) </font>
 TC footprint figure
 NAME:
   climada_plot_windfield
 PURPOSE:
 create footprint figure
 CALLING SEQUENCE:
   [contr t_handle] = climada_plot_windfield(hazard, tc_track, track_no)
 EXAMPLE:
   climada_plot_windfield
 INPUTS:
   hazard: hazard.intensity with wind intensities per centroid
   tc_track: a structure with the track information:
   track_no: number of track to show footprint
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   figure with footprint
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, david.bresch@gmail.com, 20121205
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_plot_lossfootprint.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_probabilistic_wind_speed_decay">
<H2>climada_plot_probabilistic_wind_speed_decay</H2></A>
<font color="blue">function track_req = climada_plot_probabilistic_wind_speed_decay(tc_track, track_req, single) </font>
 plot historical tc track (Longitude, Latitude) in world map according to
 saffir-simpson hurrican scale. Add plot of probabilistic generated sister
 storms. Historical tracks has black lines around markers to identify as
 original track.
 NAME:
   climada_plot_probabilistic_wind_speed_map
 PURPOSE:
   analyse visuallly historical tc track and its generated probabilistic
   sister storms. Check Longitude, Latitude and wind speed category
   (saffir-simpson hurricane scale) 
 CALLING SEQUENCE:
   climada_plot_probabilistic_wind_speed_decay(tc_track)
 EXAMPLE:
   climada_plot_probabilistic_wind_speed_decay
 INPUTS:
   tc_track: probabilistic tc track set (random walk of wind speed, 
   longitude and latitude), wind speed in knots, nodes every six hours, if
   not given, prompted for
 OPTIONAL INPUT PARAMETERS:
   track_req:  number of specific historical track to be displayed with
   its probabilistic sister storms, prompts for input 
   p:          to print figure
   x:          to exit
   41:         or any other track number. will be rounded to the nearest 
               historical track.
   enter:      to continue.
 OUTPUTS:
   figure, printout of figure if requested
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110628
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_plot_probabilistic_wind_speed_decay.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_probabilistic_wind_speed_map_gui">
<H2>climada_plot_probabilistic_wind_speed_map_gui</H2></A>
<font color="blue">function [track_req h g] = climada_plot_probabilistic_wind_speed_map_gui(tc_track, track_req) </font>
 plot historical tc track (Longitude, Latitude) in world map according to
 saffir-simpson hurrican scale. Add plot of probabilistic generated sister
 storms. Historical tracks has black lines around markers to identify as
 original track.
 NAME:
   climada_plot_probabilistic_wind_speed_map
 PURPOSE:
   analyse visuallly historical tc track and its generated probabilistic
   sister storms. Check Longitude, Latitude and wind speed category
   (saffir-simpson hurricane scale) 
 CALLING SEQUENCE:
   climada_plot_probabilistic_wind_speed_map(tc_track)
 EXAMPLE:
   climada_plot_probabilistic_wind_speed_map
 INPUTS:
   tc_track: probabilistic tc track set (random walk of wind speed, 
   longitude and latitude), wind speed in knots, nodes every six hours, if
   not given, prompted for
 OPTIONAL INPUT PARAMETERS:
   track_req:  number of specific historical track to be displayed with
   its probabilistic sister storms, prompts for input 
   p:          to print figure
   x:          to exit
   41:         or any other track number. will be rounded to the nearest 
               historical track.
   enter:      to continue.
 OUTPUTS:
   figure, printout of figure if requested
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110628
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_plot_probabilistic_wind_speed_map_gui.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_scale_to_MSP_to_market">
<H2>climada_scale_to_MSP_to_market</H2></A>
<font color="blue">function [entity ELS] = climada_scale_to_MSP_to_market(entity, ELS, MSP_AEL, market_TIV) </font>
 UNDOCUMENTED
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_scale_to_MSP_to_market.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hazard_set_slow">
<H2>climada_tc_hazard_set_slow</H2></A>
<font color="blue">function hazard = climada_tc_hazard_set_slow(tc_track,hazard_set_file,centroids) </font>
 climada TC hazard event set generate
 NAME:
   climada_tc_hazard_set
 PURPOSE:
   SLOW, only kept for backward compatibility, see climada_tc_hazard_set

   generate a tc (tropical cyclone) hazard event set

   If centroids.distance2coast_km exists, the hazard intensity is only
   calculated in the coastal_range_km (usually 200km, see PARAMETERS in
   climada_tc_windfield) - this speeds up calculation for large countries
   considerably.

   Special: the hazard event set is stored every 100 tracks in order to
   allow for interruption of the hazard set generation. Just re-start the
   calculation by calling climada_tc_hazard_set with exactly the same
   input parameters (the last track calculated is stored in hazard.track_i
   and the field track_i is removed in the final complete hazard event set).  
   Therefore, if you get errors such as 
       Subscripted assignment dimension mismatch.
       Error in climada_tc_hazard_set (line 270) % ... or nearby
       hazard.intensity(track_i,:)     = res.gust;
   It is VERY likely that you changed something between subsequent calls
   (i.e. different centroids). Just delete the hazard set .mat file and run
   climada_tc_hazard_set again.

   previous: likely climada_random_walk
   next: diverse
 CALLING SEQUENCE:
   res=climada_tc_hazard_set_slow(tc_track,hazard_set_file,centroids)
 EXAMPLE:
   res=climada_tc_hazard_set_slow(tc_track)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   tc_track: a TC track structure, or a filename of a saved one
       details: see e.g. climada_tc_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name (and path, optional) of the hazard set file
       If no path provided, default path ../data/hazards is used (and name
       can be without extension .mat). If ='NOSAVE', the hazard set is not
       saved (but returned as output)
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           lon(1,:): the longitudes
           lat(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a .mat-file which contains a centroids struct (saved by
       climada_centroids_read) or the filename of an Excel file (the original
       input to climada_centroids_read) which holds the centroids, in
       which case climada_centroids_read is called.
       OR: an entity, in which case the entity.assets.lat and
       entity.assets.lon are used as centroids.
       &ampgt promted for .mat or .xls filename if not given
       NOTE: if you then select Cancel, a regular default grid is used, see hard-wired definition in code
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090729
 David N. Bresch, david.bresch@gmail.com, 20130506, centroids filename handling improved
 David N. Bresch, david.bresch@gmail.com, 20140421, waitbar with secs
 David N. Bresch, david.bresch@gmail.com, 20141226, optional fields in centroids added
 David N. Bresch, david.bresch@gmail.com, 20150103, equal_timestep (much) improved
 Lea Mueller, muelleleh@gmail.com, 20150420, include tc category into hazard structure
 David N. Bresch, david.bresch@gmail.com, 20150804, allow for filename without path for hazard set name on input
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
 David N. Bresch, david.bresch@gmail.com, 20150824, removed 'TCNA' from hazard.comment
 David N. Bresch, david.bresch@gmail.com, 20150906, note on a frequent issue added to header
 David N. Bresch, david.bresch@gmail.com, 20151008, NOSAVE option added
 Lea Mueller, muelleleh@gmail.com, 20151127, add hazard.scenario, default is 'no climate change'
 David N. Bresch, david.bresch@gmail.com, 20160514, -v7.3 in save added
 David N. Bresch, david.bresch@gmail.com, 20160529, renamed to climada_tc_hazard_set_slow
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_hazard_set_slow.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_on_land">
<H2>climada_tc_on_land</H2></A>
<font color="blue">function tc_track = climada_tc_on_land(tc_track, border_mask) </font>
 Add on land variable to tc track structure for every tc track (former
 climada_tc_track_on_land)
 NAME:
   climada_tc_on_land
 PURPOSE:
   add on land variable (1 on land, 0 over sea) for every tc track in tc 
   track strucuture based on world map (raster file)
   within:  climada_tc_track_wind_decay
 CALLING SEQUENCE:
   tc_track = climada_tc_on_land(tc_track, border_mask);
 EXAMPLE:
   tc_track = climada_tc_on_land;
 INPUTS:
   none, if tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   tc_track: a structure with the track information including
   tc_track.onLand (1 for on land, 0 for over sea)
 OUTPUTS:
   same structure now including tc track variable for every tc track
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20140716, minor edit to catch date-line issue
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_on_land.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_track_google_earth">
<H2>climada_tc_track_google_earth</H2></A>
<font color="blue">function climada_tc_track_google_earth(tc_track, google_earth_save) </font>
 climada_tc_track_google_earth
 MODULE:
   tc_hazard_advanced
 NAME:
   climada_tc_track_google_earth
 PURPOSE:
   visualisation of historical tracks with time stamp in google
   create kml-file of all historical tc tracks 
   lines with colors according to saffir-simpson scale
 CALLING SEQUENCE:
   climada_tc_track_google_earth(tc_track, google_earth_save)
 EXAMPLE:
   climada_tc_track_google_earth
 INPUTS:
   tc_track: track set, historical or probabilistic, but only historical
   tracks are visualized. prompted for, if not given.
 OPTIONAL INPUT PARAMETERS:
   google_earth_save:  file to be saved in
                       \climada\data\tc_tracks\tc_track....kml
 OUTPUTS:
   kmz-file, visualisation of historical tracks with time stamp in google
   earth
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20110724
 Lea Mueller, muellele@gmail.com, 20150123, changed nodetime_mat to datenum
 Lea Mueller, muellele@gmail.com, 20150130, new kml toolbox
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_track_google_earth.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_track_wind_decay">
<H2>climada_tc_track_wind_decay</H2></A>
<font color="blue">function tc_track = climada_tc_track_wind_decay(tc_track, p_rel, check_plot) </font>
 Incorporate wind decay after landfall for probabilistic tracks, based on
 historical tc tracks
 NAME:
   climada_tc_track_wind_decay
 PURPOSE:
   incorporate wind decay after landfall of probabilistic tracks. The
   decay can be calculated based on historical tracks or can be loaded
   from a mat file (p_rel)
   within:  climada_tc_random_walk_position_windspeed
 CALLING SEQUENCE:
   tc_track = climada_tc_track_wind_decay(tc_track, p_rel, check_plot)
 EXAMPLE:
   tc_track = climada_tc_track_wind_decay(tc_track)
 INPUTS:
   none, if tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   p_rel: parameters for exponential decay, y = exp(B) * exp(x*A), where 
          A = p_rel(1,1), B = p_rel(1,2), can be newly calculated or can
          be loaded from data within globalGDP modul
   check_plot: to create plot
 OUTPUTS:
   same structure now MaxSustainedWind in tc track decays after landfall
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150106, climada_tc_equal_timestep
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_track_wind_decay.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_track_wind_decay_calculate">
<H2>climada_tc_track_wind_decay_calculate</H2></A>
<font color="blue">function [tc_track p_rel] = climada_tc_track_wind_decay_calculate(tc_track, check_plot) </font>
 Calculate wind decay after landfall based on historical tc tracks
 NAME:
   climada_tc_track_wind_decay_calculate
 PURPOSE:
   Calculate wind decay after landfall based on historical tc tracks
   within:  climada_tc_random_walk_position_windspeed
 CALLING SEQUENCE:
   [tc_track p_rel] = climada_tc_track_wind_decay_calculate(tc_track, check_plot)
 EXAMPLE:
   [tc_track p_rel] = climada_tc_track_wind_decay_calculate(tc_track)
 INPUTS:
   none, if tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   check_plot: to create plot
 OUTPUTS:
   p_rel contains the parameters for exponential decay for tropical
   depression, tropical storm and hurricanes category 1 to 5
   wind decay = exp(B) * exp(x*A), where A = p_rel(1,1), B = p_rel(1,2)
   wind decay = 1      * exp(x*A), where A = p_rel(1,1), B = p_rel(1,2)
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150106, climada_tc_equal_timestep
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_track_wind_decay_calculate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_track_windfield_google_earth">
<H2>climada_tc_track_windfield_google_earth</H2></A>
<font color="blue">function climada_tc_track_windfield_google_earth(tc_track,centroids,aggregation,google_earth_save) </font>
 climada_tc_track_windfield_google_earth
 MODULE:
   tc_hazard_advanced
 NAME:
   climada_tc_track_windfield_google_earth
 PURPOSE:
   create kmz-file of wind field animation in google earth
 CALLING SEQUENCE:
   climada_tc_track_windfield_google_earth(tc_track, centroids, aggregation, google_earth_save)
 EXAMPLE:
   climada_tc_track_windfield_google_earth
 INPUTS:
   tc_track: track set, historical or probabilistic, but only historical
   tracks are visualized. prompted for, if not given.
   centroids
 OPTIONAL INPUT PARAMETERS:
   aggregation:        aggregation time, default is 6h
   google_earth_save:  filename, to be saved in
                       \climada\data\tc_tracks\tc_track....kml
 OUTPUTS:
   kmz-file, visualisation of historical track and winfield with time stamp in google
   earth
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20110724
 Lea Mueller, muellele@gmail.com, 20150123, changed nodetime_mat to datenum
 Lea Mueller, muellele@gmail.com, 20150130, new kml toolbox
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_track_windfield_google_earth.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_wind_decay">
<H2>climada_tc_wind_decay</H2></A>
<font color="blue">function tc_track = climada_tc_wind_decay(tc_track) </font>
 UNDOCUMENTED
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_wind_decay.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_windfield_slow">
<H2>climada_tc_windfield_slow</H2></A>
<font color="blue">function res=climada_tc_windfield_slow(tc_track,centroids,equal_timestep,silent_mode,check_plot) </font>
 TC windfield calculation
 NAME:
   climada_tc_windfield_slow
 PURPOSE:
   SLOW version, see climada_tc_windfield

   given a TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the wind field at locations (=centroids)

   If centroids.distance2coast_km exists, the hazard intensity is only
   calculated in the coastal_range_km (usually 300km, see PARAMETERS) -
   this speeds up calculation for large countries considerably. To switch
   this feature off, just centroids=rmfield(centroids,'distance2coast_km')
   prior to passing centroids to climada_tc_windfield_slow

   mainly called from: see climada_tc_hazard_set
 CALLING SEQUENCE:
   climada_tc_windfield_slow(tc_track,centroids,equal_timestep,silent_mode)
 EXAMPLE:
   climada_tc_windfield_slow
   plot windfield:
   climada_tc_windfield_slow(tc_track(1411), centroids,1,1,1)
 INPUTS:
   tc_track: a structure with the track information:
       tc_track.lat
       tc_track.lon
       tc_track.MaxSustainedWind: maximum sustained wind speed (one-minute)
       tc_track.MaxSustainedWindUnit as 'kn', 'mph', 'm/s' or 'km/h'
       tc_track.CentralPressure: optional
       tc_track.Celerity: translational (forward speed) of the hurricane.
           optional, calculated from lat/lon if missing
       tc_track.TimeStep: optional, only needed if Celerity needs to be
           calculated, 6h assumed as default
       tc_track.Azimuth: the forward moving angle, calculated if not given
           to ensure consistency, it is even suggested not to pass Azimuth
       tc_track.yyyy: 4-digit year, optional
       tc_track.mm: month, optional
       tc_track.dd: day, optional
       tc_track.ID_no: unique ID, optional
       tc_track.name: name, optional
       tc_track.SaffSimp: Saffir-Simpson intensity, optional
   centroids: a structure with the centroids information
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
       If centroids.distance2coast_km exists, the hazard intensity is only
       calculated in the coastal_range_km (usually 300km, see PARAMETERS) -
       this speeds up calculation for large countries considerably. To switch
       this feature off, just centroids=rmfield(centroids,'distance2coast_km')
       prior to passing centroids to climada_tc_windfield_slow.
       Some other fields of centroids are also appended to res struct
 OPTIONAL INPUT PARAMETERS:
   equal_timestep: if set=1 (default), first interpolate the track to a common
       timestep, if set=0, no equalization of TC track data (not recommended)
       BUT: for speedup, run climada_tc_equal_timestep for ALL tracks
       prior to calling climada_tc_windfield_slow (see e.g. climada_tc_hazard_set)
       and then set equal_timestep=0 in calling climada_tc_windfield_slow
   silent_mode: if =1, do not write to stdout unless severe warning
       If silent_mode=-1, use step-by-step detailed windfield, i.e. reduce
       wind to zero at center of the eye (not recommended for
       probabilistic, since hit/miss issue with closest node, see variable
       max_wind_at_bullseye in code).
   check_plot: disabled, see code, commented out for speedup
 OUTPUTS:
   res: the output strcuture, with fields
       gust(i): the windfield [m/s] at all centroids i
       lat(i): the latitude of the centroids i
       lon(i): the longitude of the centroids i
       Some other fields of centroids are also appended to res struct
 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090728
 David N. Bresch, david.bresch@gmail.com, 20141227, centroids.distance2coast_km treatment added
 David N. Bresch, david.bresch@gmail.com, 20150124, wind_threshold=15 (was 0), coastal_range_km=375 (was 300)
 David N. Bresch, david.bresch@gmail.com, 20150315, back to real Holland for single timestep
 David N. Bresch, david.bresch@gmail.com, 20150319, eye 'filled' for probabilistic windfields
 David N. Bresch, david.bresch@gmail.com, 20150515, optional plot debugged (usually commented out, starting line 333)
 David N. Bresch, david.bresch@gmail.com, 20150807, climada_global.tc.extratropical_transition
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_windfield_slow.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tr_hazard_set">
<H2>climada_tr_hazard_set</H2></A>
<font color="blue">function hazard  = climada_tr_hazard_set(tc_track,hazard_set_file,centroids) </font>
 generate hazard rain set from tc_tracks
 NAME:
   climada_tr_hazard_set
 PURPOSE:
   generate tropical cyclone hazard rain set
   previous: likely climada_random_walk

   See climada_tr_hazard_set_slow for backward compatibility.

   next: diverse, e.g. climada_EDS_calc
 CALLING SEQUENCE:
   hazard = climada_tr_hazard_set(tc_track,hazard_set_file)
 EXAMPLE:
   tc_track=climada_tc_track_load('TEST_tracks.atl_hist');
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   hazard=climada_tr_hazard_set(tc_track,'_TR_TEST_PARFOR',centroids);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   tc_track: a TC track structure, or a filename of a saved one
       details: see e.g. climada_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           lon(1,:): the longitudes
           lat(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a file which contains the struct (saved after climada_centroids_read)
       or an entity with entity.assets, centroids are then inferred from
       if you select Cancel, a regular default grid is used, see hard-wired definition in code
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 Lea Mueller, 20110722
 david.bresch@gmail.com, 20140804, GIT update
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, parfor, much faster (factor 3-10)
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tr_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tr_hazard_set_slow">
<H2>climada_tr_hazard_set_slow</H2></A>
<font color="blue">function hazard  = climada_tr_hazard_set_slow(tc_track, hazard_set_file, centroids) </font>
 generate hazard rain set from tc_tracks
 NAME:
   climada_tr_hazard_set_slow
 PURPOSE:
   see climada_tr_hazard_set, this is the SLOW version, kep for backward
   compatibility only

   generate tropical cyclone hazard rain set
   previous: likely climada_random_walk
   next: diverse
 CALLING SEQUENCE:
   hazard = climada_tr_hazard_set_slow(tc_track,hazard_set_file)
 EXAMPLE:
   hazard = climada_tr_hazard_set_slow(tc_track)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   tc_track: a TC track structure, or a filename of a saved one
       details: see e.g. climada_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes
           Latitude(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a file which contains the struct (saved after climada_centroids_read)
       if you select Cancel, a regular default grid is used, see hard-wired definition in code
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 Lea Mueller, 20110722
 david.bresch@gmail.com, 20140804, GIT update
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, renamed to climada_tr_hazard_set_slow
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tr_hazard_set_slow.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tr_rainfield">
<H2>climada_tr_rainfield</H2></A>
<font color="blue">function rainsum=climada_tr_rainfield(tc_track,centroids,~,~,~,~) </font>
 TC rainfield calculation (rainsum)
 NAME:
   climada_tr_rainfield
 PURPOSE:
   given a single TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the rain sum field at locations (=centroids)

   Note: this code is optimized for speed, hence assumes that tc_track is
   free of missing data, climada_tc_equal_timestep applied and
   MaxSustainedWind calculated.

   there is still the old SLOW version climada_tr_rainfield_slow, not
   recommended, just kep for backward compatibility

   mainly called from: see climada_tr_hazard_set
 CALLING SEQUENCE:
   rainsum=climada_tr_rainfield(tc_track,centroids,~,~,~,~)
 EXAMPLE:
   tc_track=climada_tc_track_load('TEST_tracks.atl_hist');
   tc_track=climada_tc_equal_timestep(tc_track);
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   rainsum=climada_tr_rainfield(tc_track(68),centroids);
   climada_color_plot(rainsum,centroids.lon,centroids.lat);
 INPUTS:
   tc_track: a structure with the single track information (length(tc_track)!=1)
       see e.g. climada_tc_read_unisys_tc_track
       tc_track.Azimuth and/or tc_track.Celerity calculated, if not existing
       but climada_tc_equal_timestep mist have been run and
       tc_track.MaxSustainedWind must exist on input
   centroids: a structure with the centroids information (see e.g.
       climada_centroids_read):
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   rainsum(i): the rain fall sum [mm over full lieftime of the event] 
       at all centroids(i)

   One could also return res (switched off for speedup, 
   search for res. in code to swithc this on):
   (res.rainsum: the rain fall sum [mm per storm] at all centroids
       the single-character variables refer to the Pioneer offering circular
       that's why we kept these short names (so one can copy the OC for
       documentation)
   (res.lat: the latitude of the centroids (=centroids.lat)
   (res.lon: the longitude of the centroids (=centroids.lon)
   (res.rainrate: COULD be returned, but most cases not needed, see code)
   (res.time: time in sec, coiuld be returned, see TIMING in code)
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110606
 Martin Heyenn 20120503
 david.bresch@gmail.com, 20140804, GIT update
 david.bresch@gmail.com, 20141020, cleanup, inreach speedup
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, major speedup, five times faster
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tr_rainfield.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tr_rainfield_slow">
<H2>climada_tr_rainfield_slow</H2></A>
<font color="blue">function rainsum=climada_tr_rainfield_slow(tc_track,centroids,equal_timestep,silent_mode,check_plot,unit_) </font>
 TC rainfield calculation (rainsum)
 NAME:
   climada_tr_rainfield_slow
 PURPOSE:
   see climada_tr_rainfield for a much FASTER version (same result), 
   kept for backward compatipibility only

   given a single TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the rain sum field at locations (=centroids)
   mainly called from: see climada_tr_hazard_set

 CALLING SEQUENCE:
   [res,tc_track_ori,centroids]=climada_tr_rainfield_slow(tc_track,centroids,equal_timestep,silent_mode,check_plot,unit_)
 EXAMPLE:
   tc_track=climada_tc_track_load('TEST_tracks.atl_hist');
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   rainsum=climada_tr_rainfield_slow(tc_track(68),centroids);
   climada_color_plot(rainsum,centroids.lon,centroids.lat);
 INPUTS:
   tc_track: a structure with the information for a single (1) tc track:
       tc_track.lat
       tc_track.lon
       tc_track.MaxSustainedWind: maximum sustained wind speed (one-minute)
       tc_track.MaxSustainedWindUnit as 'kn', 'mph', 'm/s' or 'km/h'
       tc_track.CentralPressure: optional
       tc_track.Celerity: translational (forward speed) of the hurricane.
           optional, calculated from lat/lon if missing
       tc_track.TimeStep: optional, only needed if Celerity needs to be
           calculated, 6h assumed as default
       tc_track.Azimuth: the forward moving angle, calculated if not given
           to ensure consistency, it is even suggested not to pass Azimuth
       tc_track.yyyy: 4-digit year, optional
       tc_track.mm: month, optional
       tc_track.dd: day, optional
       tc_track.ID_no: unique ID, optional
       tc_track.name: name, optional
       tc_track.SaffSimp: Saffir-Simpson intensity, optional
       NOTE: if empty, the user can also select a file with tc_track and will then
       get promted for a single track number to use (mainly useful for TESTs)
   centroids: a structure with the centroids information
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
 OPTIONAL INPUT PARAMETERS:
   unit_: rainfall unit, either unit_='mm' (millimeters, default) or for inches unit_='in'
   equal_timestep: if set=1 (default), first interpolate the track to a common
       timestep, if set=0, no equalization of TC track data (not recommended)
   silent_mode: if =1, do not write to stdout unless severe warning
   check_plot: whether some plots are created =1 (default=0, silent_mode=1
       sets check_plot also =0)
 OUTPUTS:
   rainsum(i): the rain fall sum [mm over full lieftime of the event] 
       at all centroids(i)

   One could also return res (switched off for speedup, 
   search for res. in code to swithc this on):
   (res.rainsum: the rain fall sum [mm per storm] at all centroids
       the single-character variables refer to the Pioneer offering circular
       that's why we kept these short names (so one can copy the OC for
       documentation)
   (res.lat: the latitude of the centroids (=centroids.lat)
   (res.lon: the longitude of the centroids (=centroids.lon)
   (res.rainrate: COULD be returned, but most cases not needed, see code)
   (res.time: time in sec, coiuld be returned, see TIMING in code)
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110606
 Martin Heyenn 20120503
 david.bresch@gmail.com, 20140804, GIT update
 david.bresch@gmail.com, 20141020, cleanup, inreach speedup
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, renamed to climada_tr_rainfield_slow
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tr_rainfield_slow.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tr_rainrate_field_animation">
<H2>climada_tr_rainrate_field_animation</H2></A>
<font color="blue">function climada_tr_rainrate_field_animation(tc_track, centroids,... </font>
                                            aggregation,check_avi)                        
 plot animation of rainrate field for a specific historical or
 probabilistic storm
 NAME:
   climada_tc_rainrate_field_animation
 PURPOSE:
   plot animation of rainrate field for a specific historical or
   probabilistic storm, plot is produced every aggregation time step
   (minimum 1 hour or more)
 CALLING SEQUENCE:
   climada_tr_rainrate_field_animation(tc_track       ,...
                                  centroids      ,...
                                  aggregation    ,...
                                  check_printplot)
 EXAMPLE:
   climada_tc_rainrate_field_animation(tc_track_prob(1226), centroids, 1, 6)
 INPUTS:
	tc_track:           just one tc_track, tc_track_prob(1)
   centroids:          centroid mat file
 OPTIONAL INPUT PARAMETERS:
   aggregation:        desired timestep for plots (minimum one plot per
   hour, can be one plot for 6 hours or more)
   check_avi:         if set to 1 will save animation as avi-file
 OUTPUTS:
   plot of rainrate field (footprint) for every aggreagation step
   (minimum 1 hour) for one specific storm track
 MODIFICATION HISTORY:
 Lea Mueller, 20110603
 david.bresch@gmail.com, 20140804, GIT update
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tr_rainrate_field_animation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tr_rainsum_field_animation">
<H2>climada_tr_rainsum_field_animation</H2></A>
<font color="blue">function climada_tr_rainsum_field_animation(tc_track, centroids,... </font>
                                           aggregation,check_avi)                                        
 plot animation of rainrate field for a specific historical or
 probabilistic storm
 NAME:
   climada_tc_rainrate_field_animation
 PURPOSE:
   plot animation of rainrate field for a specific historical or
   probabilistic storm, plot is produced every aggregation time step
   (minimum 1 hour or more)
 CALLING SEQUENCE:
   climada_tr_rainrate_field_animation(tc_track       ,...
                                  centroids      ,...
                                  aggregation    ,...
                                  check_printplot)
 EXAMPLE:
   climada_tr_rainrate_field_animation(tc_track_prob(1226), centroids, 1, 6)
 INPUTS:
	tc_track:           just one tc_track, tc_track_prob(1)
   centroids:          centroid mat file
 OPTIONAL INPUT PARAMETERS:
   aggregation:        desired timestep for plots (minimum one plot per
   hour, can be one plot for 6 hours or more)
   check_avi:         if set to 1 will save animation as avi-file
 OUTPUTS:
   plot of rainrate field (footprint) for every aggreagation step
   (minimum 1 hour) for one specific storm track
 MODIFICATION HISTORY:
 Lea Mueller, 20110603
 david.bresch@gmail.com, 20140804, GIT update
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_tr_rainsum_field_animation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_track_map">
<H2>climada_track_map</H2></A>
<font color="blue">function varargout = climada_track_map(varargin) </font>
 CLIMADA_TRACK_MAP M-file for climada_track_map.fig
      CLIMADA_TRACK_MAP, by itself, creates a new CLIMADA_TRACK_MAP or raises the existing
      singleton*.

      H = CLIMADA_TRACK_MAP returns the handle to a new CLIMADA_TRACK_MAP or the handle to
      the existing singleton*.

      CLIMADA_TRACK_MAP('CALLBACK',hObject,eventData,handles,...) calls the local
      function named CALLBACK in CLIMADA_TRACK_MAP.M with the given input arguments.

      CLIMADA_TRACK_MAP('Property','Value',...) creates a new CLIMADA_TRACK_MAP or raises the
      existing singleton*.  Starting from the left, property value pairs are
      applied to the GUI before climada_track_map_OpeningFcn gets called.  An
      unrecognized property name or invalid value makes property application
      stop.  All inputs are passed to climada_track_map_OpeningFcn via varargin.

      *See GUI Options on GUIDE's Tools menu.  Choose &quotGUI allows only one
      instance to run (singleton)&quot.

 See also: GUIDE, GUIDATA, GUIHANDLES

 Edit the above text to modify the response to help climada_track_map

 Last Modified by GUIDE v2.5 08-Feb-2013 18:15:03
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_track_map.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ts_hazard_set">
<H2>climada_ts_hazard_set</H2></A>
<font color="blue">function hazard=climada_ts_hazard_set(hazard,hazard_set_file,elevation_data,check_plots) </font>
 climada storm surge TS hazard event set
 NAME:
   climada_ts_hazard_set
 PURPOSE:
   create a storm surge (TS) hazard event, based on an existing
   tropical cyclone (TC) hazard event set

   two steps:
   1) check wether we need to obtain bathymetry (high res, calls etopo_get
   from module etopo) or elevation is provided (see elevation_data)
   2) convert all TC footprints into TS footprints
   see CORE_CONVERSION in code below for the conversion formula

   Note on bathymetry data: see https://github.com/davidnbresch/climada_module_elevation_models 

   see tc_surge_TEST for a testbed for this code

 CALLING SEQUENCE:
   hazard=climada_ts_hazard_set(hazard,hazard_set_file,elevation_data,check_plot)
 EXAMPLE:
   hazard_TC=climada_hazard_load('TCNA_today_small')
   hazard_TS=climada_ts_hazard_set(hazard_TC,'TCNA_today_small_TS')
 INPUTS:
   hazard: an already existing tropical cyclone (TC) hazard event set (a
       TC hazard structure)
       &ampgt prompted for if not given (for .mat file containing a TC hazard event set)
       Note: if hazard.elevation_m exists on input, this elevation
       information is used, hence elevation_data is ignored
       The variable hazard is modified on output (saves a lot of memory).
   hazard_set_file: the name of the newly created storm surge (TS) hazard
       event set (if ='NO_SAVE', the hazard is just returned, not saved)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   elevation_data: if a scalar, take elevation (or bathymetry) from etopo
       (needs module etopo). If =1, save bathymetry in a .mat file (speeds up
       subsequent calls), if =0 do not save bathymetry (default)
       If elevation_data is a structure with the fields lon(i), lat(i),
       elevation_m(i) and centroid_ID(i), check for centroid IDs being the
       same as in hazard.centroid_ID and then just 'attach' the elevation
       to hazard (i.e. hazard.elevation_m=elevation_data.elevation_m)
       Note: if hazard.elevation_m exists on input, this elevation
       information is used.
   check_plots: =1, do show check plots (only if BATI used), =0: no plots (default)
 OUTPUTS:
   hazard: a hazard event set, see core climada doc
       also written to a .mat file (see hazard_set_file)
       NOTE: for memory allocation reasons, the input hazard is used and
       modified to create the output hazard
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20140421
 david.bresch@gmail.com, 20141017, module path relative
 david.bresch@gmail.com, 20141026, save_bathymetry_flag
 david.bresch@gmail.com, 20150106, elevation_data
 david.bresch@gmail.com, 20160516, elevation_data single precision allowed (as eg from SRTM)
 david.bresch@gmail.com, 20160525, better error messaging for ETOPO issues
 david.bresch@gmail.com, 20160529, renamed to climada_ts_hazard_set and tc_surge_hazard_create deleted
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/climada_ts_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="figures_for_hazard_advanced_manual">
<H2>figures_for_hazard_advanced_manual</H2></A>
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/figures_for_hazard_advanced_manual.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="haversine">
<H2>haversine</H2></A>
<font color="blue">function [km nmi mi] = haversine(loc1, loc2) </font>
 HAVERSINE     Compute distance between locations using Haversine formula
   KM = HAVERSINE(LOC1, LOC2) returns the distance KM in km between
   locations LOC1 and LOC2 using the Haversine formula.  LOC1 and LOC2 are
   latitude and longitude coordinates that can be expressed as either
   strings representing degrees, minutes, and seconds (suffixed with
   N/S/E/W), or numeric arrays representing decimal degrees (where
   negative indicates West/South).

   [KM, NMI, MI] = HAVERSINE(LOC1, LOC2) returns the computed distance in
   kilometers (KM), nautical miles (NMI), and miles (MI).

   Examples
       haversine('53 08 50N, 001 50 58W', '52 12 16N, 000 08 26E') returns
           170.2547
       haversine([53.1472 -1.8494], '52 12.16N, 000 08.26E') returns
           170.2508
       haversine([53.1472 -1.8494], [52.2044 0.1406]) returns 170.2563

   Inputs
       LOC must be either a string specifying the location in degrees,
       minutes and seconds, or a 2-valued numeric array specifying the
       location in decimal degrees.  If providing a string, the latitude
       and longitude must be separated by a comma.

   Notes
       The Haversine formula is used to calculate the great-circle
       distance between two points, which is the shortest distance over
       the earth's surface.

       This program was created using equations found on the website
       http://www.movable-type.co.uk/scripts/latlong.html
 Created by Josiah Renfree
 May 27, 2010
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/haversine.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="tc_surge_TEST">
<H2>tc_surge_TEST</H2></A>
<font color="blue">function hazard=tc_surge_TEST </font>
 climada
 NAME:
   tc_surge_TEST
 PURPOSE:
   TEST the tropical cyclone (TC) storm surge (TS) hazard creation
   1) get centroids for the test country (eg Bangladesh, see PARAMETERS)
      if they do not exist, try to run GDP_entity in order to create them
   2) create TC wind hazard event set
   call climada_ts_hazard_set in order to
      3) create bathymetry file for region
      4) create TC surge hazard event set
   show the result

   In essence, you define the country and the code checks the generation
   of centroids, TC and TS hazard event sets

   in essence a caller for code climada_ts_hazard_set

   see tc_surge_plot_3d for 3D plots of surge fields
 CALLING SEQUENCE:
   hazard=tc_surge_TEST
 EXAMPLE:
   tc_surge_TEST
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   writes a couple files, such as entity, assets, bathymetry and a
       hazard event set
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140420
 David N. Bresch, david.bresch@gmail.com, 20141017 module independent of location
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/tc_surge_TEST.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="tc_surge_TEST_Netherlands">
<H2>tc_surge_TEST_Netherlands</H2></A>
<font color="blue">function hazard=tc_surge_TEST_Netherlands </font>
 climada
 NAME:
   tc_surge_TEST
 PURPOSE:
   See tc_surge_TEST for the real TEST environment

   A kind of silly test, just to see whether it all works with just one or
   just ten tracks...

   TEST the tropical cyclone (TC) storm surge (TS) raw hazard creation
   1) get centroids for the test country (eg Bangladesh, see PARAMETERS)
      if they do not exist, try to run GDP_entity in order to create them
   2) create TC wind hazard event set
   call climada_ts_hazard_set in order to
      3) create bathymetry file for region
      4) create TC surge hazard event set
   show the result

   In essence, you define the country and the code checks the generation
   of centroids, TC and TS hazard event sets

   in essence a caller for code climada_ts_hazard_set
 CALLING SEQUENCE:
   tc_surge_TEST(force_recalc_ts)
 EXAMPLE:
   tc_surge_TEST
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   writes a couple files, such as entity, assets, bathymetry and a
       hazard event set
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140421
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/tc_surge_TEST_Netherlands.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="tc_surge_plot_3d">
<H2>tc_surge_plot_3d</H2></A>
<font color="blue">function tc_surge_plot_3d(hazard,event_i) </font>
 climada
 NAME:
   tc_surge_plot3d
 PURPOSE:
   plot surge hazard as 3D surface, 'overshadowing' terrain
 CALLING SEQUENCE:
   tc_surge_plot3d(hazard,event_i);
 EXAMPLE:
   climada_hazard_plot(climada_hazard_load);
 INPUTS:
   hazard: hazard structure
       consider to use climada_hazard_load, as in the example
   event_i: the i-th event in the hazard event set to be displayed
       if event_i=0, the maximum intensity at each centroid is shown
       if event_i=-i, the i-th 'largest' event (sum of intensities) is shown
           e.g. for event_i=-2, the second largest event is shown
       default=-1 (just to get something on the screen ;-)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   figure
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140503
View <A HREF=file://CHRB1028.CORP.GWPNET.COM/homes/N/SRZDNB/Documents/Projects_local/_climada_GIT/climada_modules/tropical_cyclone/code/tc_surge_plot_3d.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
